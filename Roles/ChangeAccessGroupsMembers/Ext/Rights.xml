<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns="http://v8.1c.ru/8.2/roles" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Rights">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Password</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.AccessRights</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForSending</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthentication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.LeaveMessageCopiesOnServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.DeleteResponsibleForEmailProcessing</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonForm.AccessRights</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForReceiving</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Timeout</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.DeleteIncludeUserNameInPresentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.ServerEmailStoragePeriod</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UserName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroups
WHERE
	AccessGroups.IsFolder
	Или истина In
		(SELECT TOP 1
			истина
		FROM
			InformationRegister.UsersGroupsContents AS UsersGroupsContents
				WHERE
					 UsersGroupsContents.UsersGroup = AccessGroups.Responsible
				#If &amp;CurrentExternalUser = Значение(Catalog.ExternalUsers.EmptyRef) #Then
					И UsersGroupsContents.User = &amp;CurrentUser
				#Else
					И UsersGroupsContents.User = &amp;CurrentExternalUser
				#EndIf
		 )
	И Choice
		When AccessGroups.Ref = Значение(Catalog.AccessGroups.Administrators)
		Then AccessGroups.Profile = Значение(Catalog.AccessGroupsProfiles.Administrator)
		Else AccessGroups.Profile &lt;&gt; Значение(Catalog.AccessGroupsProfiles.Administrator)
	End
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroups
WHERE
	AccessGroups.IsFolder
	Или истина In
		(SELECT TOP 1
			истина
		FROM
			InformationRegister.UsersGroupsContents AS UsersGroupsContents
				WHERE
					 UsersGroupsContents.UsersGroup = AccessGroups.Responsible
				#If &amp;CurrentExternalUser = Значение(Catalog.ExternalUsers.EmptyRef) #Then
					И UsersGroupsContents.User = &amp;CurrentUser
				#Else
					И UsersGroupsContents.User = &amp;CurrentExternalUser
				#EndIf
		 )
	И Choice
		When AccessGroups.Ref = Значение(Catalog.AccessGroups.Administrators)
		Then AccessGroups.Profile = Значение(Catalog.AccessGroupsProfiles.Administrator)
		Else AccessGroups.Profile &lt;&gt; Значение(Catalog.AccessGroupsProfiles.Administrator)
	End
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroupsProfiles
WHERE
 AccessGroupsProfiles.IsFolder
 Или истина In
 (SELECT TOP 1
 истина
 FROM
 InformationRegister.UsersGroupsContents AS UsersGroupsContents
 INNER JOIN Catalog.AccessGroups AS AccessGroups
 ON
 AccessGroups.Profile = AccessGroupsProfiles.Ref
 И UsersGroupsContents.UsersGroup = AccessGroups.Responsible
 #If &amp;CurrentExternalUser = Значение(Catalog.ExternalUsers.EmptyRef) #Then
 И UsersGroupsContents.User = &amp;CurrentUser
 #Else
 И UsersGroupsContents.User = &amp;CurrentExternalUser
 #EndIf
 И Choice
 When AccessGroups.Ref = Значение(Catalog.AccessGroups.Administrators)
 Then AccessGroups.Profile = Значение(Catalog.AccessGroupsProfiles.Administrator)
 Else AccessGroups.Profile &lt;&gt; Значение(Catalog.AccessGroupsProfiles.Administrator)
 End
 )
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.POP3AuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValues</name>
		<condition>// ByValues(Table, -, Modifier, B1,P1, B2,P2, ..., IN(n), P(n)).
// No. parameter: 1, 2, 3, 4, 5, 6, 7, ..., 2+n*2,3+n*2.
// Read so: "access restriction by values".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log. 
// Other modifiers in this version of the template are Не expected.
// K(n) - Access kind - access kind name, for example, Companies. It's a good idea to specify
// several names for fields of a composite
// type for productivity increase, for example, Companies,PrivateIndividualsGroups, by specifying several parameters blocks with the same field name.
// You can use special kinds of
// access Condition, RightsSettings,ReadRight, ChangeRight only separately.
// When K(n) = Condition (Или ""), then P(n) contains a condition row on
// language of query,
// for example, T.Author = &amp;AuthorizedUser, VALUETYPE (T.Owner) = TYPE (Catalog.Organization), where T - current table alias.
// When K(n) = ReadRight
// Или ChangeRight checking if you have rights for value table T.P(n) is performed.
// F(n) - Field of verified value, except of K(n) case = Condition (Или "").
// Note: you can increase the maximum quantity of simultaneously checked fields
// values by changing the template; but you should also specify all parameters of the pattern, namely specify empty rows, when the quantity of fields is less than maximum.
// The pattern has the following structure:
// &lt;Conditions common part&gt; &lt;Condition by parameters group 1&gt; И &lt;Condition by parameters group 2&gt; И ... &lt;Condition by
// parameters group(n)&gt; Example:
// ByValues("Document.GoodsAndServicesReceipt", "", "",
// "Companies","Company",
// "Vendors","Counterparty", "","", ...)

// Verification of the Right parameter.
#If Не ("#Parameter(2)" = "Read" Или "#Parameter(2)" = "Insert" Или
 "#Parameter(2)" = "Update" Или "#Parameter(2)" = "Delete" Или "#Parameter(2)" = "")
 Или #CurrentAccessRightName &lt;&gt; "Read" И "#Parameter(2)" = "Read"
 Или #CurrentAccessRightName = "Read" И "#Parameter(2)" &lt;&gt; "Read" И "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If Не ("#Parameter(3)" = "DontLimitAccessToGroups" Или "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction on record level
// И checking of usage at least of one restriction from listed access kinds.
#If &amp;LimitAccessOnRecordsLevel
 И Не (истина
 И ("#Parameter(4)" = "" И "#Parameter(5)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(4),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(4),"))
 И ("#Parameter(6)" = "" И "#Parameter(7)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(6),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),"))
 И ("#Parameter(8)" = "" И "#Parameter(9)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(8),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(8),"))
 И ("#Parameter(10)" = "" И "#Parameter(11)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(10),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(10),"))
 И ("#Parameter(12)" = "" И "#Parameter(13)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(12),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),"))
 И ("#Parameter(14)" = "" И "#Parameter(15)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(14),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(14),"))
 И ("#Parameter(16)" = "" И "#Parameter(17)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(16),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(16),"))
 И ("#Parameter(18)" = "" И "#Parameter(19)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(18),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),"))
 И ("#Parameter(20)" = "" И "#Parameter(21)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(20),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(20),"))
 И ("#Parameter(22)" = "" И "#Parameter(23)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(22),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(22),"))
 И ("#Parameter(24)" = "" И "#Parameter(25)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(24),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),"))
 И ("#Parameter(26)" = "" И "#Parameter(27)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(26),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(26),"))
 И ("#Parameter(28)" = "" И "#Parameter(29)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(28),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(28),"))
 И ("#Parameter(30)" = "" И "#Parameter(31)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(30),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),"))
 И ("#Parameter(32)" = "" И "#Parameter(33)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(32),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(32),"))
 И ("#Parameter(34)" = "" И "#Parameter(35)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(34),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(34),"))
 ) #Then

T WHERE // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups" #Then
	T.IsFolder Или
#EndIf

истина In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 истина
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.DescriptionFull = "#Parameter(1)"
			И истина In
			 (
				SELECT TOP 1 истина
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						И AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If Не #CurrentAccessRightName = "Read" #Then
						И AccessGroupsTables.Update
					#EndIf
			 )
			И AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						И UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Search values of specified fields in the allowed access groups values (of users).

//// Value verification of parameters group field 1.
#If "#Parameter(4)" = "Condition" Или "#Parameter(4)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	( #Parameter(5) )
#ElseIf "#Parameter(4)" = "ReadRight" Или "#Parameter(4)" = "EditRight" #Then
	 T.#Parameter(5) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(5))
		#If Не "#Parameter(4)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(4)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(4),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(4)", ",") #Then
		InvalidAccessKind: "#Parameter(4)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(4)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(4),") #Then
	
	 (
			ISNULL(T.#Parameter(5), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(4),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(4),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(5)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(5)
		#ElseIf "T.#Parameter(5)" = "T.Ref" #Then
			#If StrContains("#Parameter(4)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(4)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(5)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(5)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(5))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

//// Value verification of parameters group field 2.
#If "#Parameter(6)" = "" И "#Parameter(7)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(6)" = "Condition" Или "#Parameter(6)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Или "#Parameter(6)" = "EditRight" #Then
	И T.#Parameter(7) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(7))
		#If Не "#Parameter(6)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(6)", ",") #Then
		InvalidAccessKind: "#Parameter(6)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(6)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),") #Then
	И
	 (
			ISNULL(T.#Parameter(7), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(6),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(7)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(7)
		#ElseIf "T.#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(6)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(7)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(7))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 3.
#If "#Parameter(8)" = "" И "#Parameter(9)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(8)" = "Condition" Или "#Parameter(8)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(9) )
#ElseIf "#Parameter(8)" = "ReadRight" Или "#Parameter(8)" = "EditRight" #Then
	И T.#Parameter(9) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(9))
		#If Не "#Parameter(8)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(8)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(8),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(8)", ",") #Then
		InvalidAccessKind: "#Parameter(8)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(8)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(8),") #Then
	И
	 (
			ISNULL(T.#Parameter(9), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(8),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(8),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(9)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(9)
		#ElseIf "T.#Parameter(9)" = "T.Ref" #Then
			#If StrContains("#Parameter(8)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(8)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(9)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(9)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(9))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 4.
#If "#Parameter(10)" = "" И "#Parameter(11)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(10)" = "Condition" Или "#Parameter(10)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(11) )
#ElseIf "#Parameter(10)" = "ReadRight" Или "#Parameter(10)" = "EditRight" #Then
	И T.#Parameter(11) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(11))
		#If Не "#Parameter(10)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(10)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(10),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(10)", ",") #Then
		InvalidAccessKind: "#Parameter(10)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(10)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(10),") #Then
	И
	 (
			ISNULL(T.#Parameter(11), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(10),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(10),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(11)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(11)
		#ElseIf "T.#Parameter(11)" = "T.Ref" #Then
			#If StrContains("#Parameter(10)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(10)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(11)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(11)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(11))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 5.
#If "#Parameter(12)" = "" И "#Parameter(13)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(12)" = "Condition" Или "#Parameter(12)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Или "#Parameter(12)" = "EditRight" #Then
	И T.#Parameter(13) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(13))
		#If Не "#Parameter(12)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(12)", ",") #Then
		InvalidAccessKind: "#Parameter(12)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(12)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),") #Then
	И
	 (
			ISNULL(T.#Parameter(13), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(12),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(13)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(13)
		#ElseIf "T.#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(12)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(13)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(13))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 6.
#If "#Parameter(14)" = "" И "#Parameter(15)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(14)" = "Condition" Или "#Parameter(14)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(15) )
#ElseIf "#Parameter(14)" = "ReadRight" Или "#Parameter(14)" = "EditRight" #Then
	И T.#Parameter(15) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(15))
		#If Не "#Parameter(14)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(14)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(14),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(14)", ",") #Then
		InvalidAccessKind: "#Parameter(14)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(14)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(14),") #Then
	И
	 (
			ISNULL(T.#Parameter(15), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(14),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(14),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(15)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(15)
		#ElseIf "T.#Parameter(15)" = "T.Ref" #Then
			#If StrContains("#Parameter(14)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(14)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(15)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(15)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(15))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 7.
#If "#Parameter(16)" = "" И "#Parameter(17)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(16)" = "Condition" Или "#Parameter(16)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(17) )
#ElseIf "#Parameter(16)" = "ReadRight" Или "#Parameter(16)" = "EditRight" #Then
	И T.#Parameter(17) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(17))
		#If Не "#Parameter(16)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(16)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(16),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(16)", ",") #Then
		InvalidAccessKind: "#Parameter(16)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(16)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(16),") #Then
	И
	 (
			ISNULL(T.#Parameter(17), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(16),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(16),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(17)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(17)
		#ElseIf "T.#Parameter(17)" = "T.Ref" #Then
			#If StrContains("#Parameter(16)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(16)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(17)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(17)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(17))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 8.
#If "#Parameter(18)" = "" И "#Parameter(19)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(18)" = "Condition" Или "#Parameter(18)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Или "#Parameter(18)" = "EditRight" #Then
	И T.#Parameter(19) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(19))
		#If Не "#Parameter(18)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(18)", ",") #Then
		InvalidAccessKind: "#Parameter(18)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(18)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),") #Then
	И
	 (
			ISNULL(T.#Parameter(19), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(18),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(19)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(19)
		#ElseIf "T.#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(18)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(19)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(19))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 9.
#If "#Parameter(20)" = "" И "#Parameter(21)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(20)" = "Condition" Или "#Parameter(20)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(21) )
#ElseIf "#Parameter(20)" = "ReadRight" Или "#Parameter(20)" = "EditRight" #Then
	И T.#Parameter(21) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(21))
		#If Не "#Parameter(20)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(20)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(20),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(20)", ",") #Then
		InvalidAccessKind: "#Parameter(20)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(20)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(20),") #Then
	И
	 (
			ISNULL(T.#Parameter(21), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(20),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(20),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(21)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(21)
		#ElseIf "T.#Parameter(21)" = "T.Ref" #Then
			#If StrContains("#Parameter(20)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(20)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(21)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(21)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(21))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 10.
#If "#Parameter(22)" = "" И "#Parameter(23)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(22)" = "Condition" Или "#Parameter(22)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(23) )
#ElseIf "#Parameter(22)" = "ReadRight" Или "#Parameter(22)" = "EditRight" #Then
	И T.#Parameter(23) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(23))
		#If Не "#Parameter(22)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(22)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(22),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(22)", ",") #Then
		InvalidAccessKind: "#Parameter(22)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(22)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(22),") #Then
	И
	 (
			ISNULL(T.#Parameter(23), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(22),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(22),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(23)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(23)
		#ElseIf "T.#Parameter(23)" = "T.Ref" #Then
			#If StrContains("#Parameter(22)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(22)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(23)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(23)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(23))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 11.
#If "#Parameter(24)" = "" И "#Parameter(25)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(24)" = "Condition" Или "#Parameter(24)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Или "#Parameter(24)" = "EditRight" #Then
	И T.#Parameter(25) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(25))
		#If Не "#Parameter(24)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(24)", ",") #Then
		InvalidAccessKind: "#Parameter(24)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(24)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),") #Then
	И
	 (
			ISNULL(T.#Parameter(25), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(24),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(25)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(25)
		#ElseIf "T.#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(24)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(25)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(25))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 12.
#If "#Parameter(26)" = "" И "#Parameter(27)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(26)" = "Condition" Или "#Parameter(26)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(27) )
#ElseIf "#Parameter(26)" = "ReadRight" Или "#Parameter(26)" = "EditRight" #Then
	И T.#Parameter(27) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(27))
		#If Не "#Parameter(26)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(26)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(26),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(26)", ",") #Then
		InvalidAccessKind: "#Parameter(26)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(26)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(26),") #Then
	И
	 (
			ISNULL(T.#Parameter(27), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(26),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(26),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(27)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(27)
		#ElseIf "T.#Parameter(27)" = "T.Ref" #Then
			#If StrContains("#Parameter(26)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(26)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(27)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(27)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(27))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 13.
#If "#Parameter(28)" = "" И "#Parameter(29)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(28)" = "Condition" Или "#Parameter(28)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(29) )
#ElseIf "#Parameter(28)" = "ReadRight" Или "#Parameter(28)" = "EditRight" #Then
	И T.#Parameter(29) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(29))
		#If Не "#Parameter(28)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(28)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(28),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(28)", ",") #Then
		InvalidAccessKind: "#Parameter(28)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(28)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(28),") #Then
	И
	 (
			ISNULL(T.#Parameter(29), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(28),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(28),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(29)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(29)
		#ElseIf "T.#Parameter(29)" = "T.Ref" #Then
			#If StrContains("#Parameter(28)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(28)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(29)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(29)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(29))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 14.
#If "#Parameter(30)" = "" И "#Parameter(31)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(30)" = "Condition" Или "#Parameter(30)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Или "#Parameter(30)" = "EditRight" #Then
	И T.#Parameter(31) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(31))
		#If Не "#Parameter(30)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(30)", ",") #Then
		InvalidAccessKind: "#Parameter(30)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(30)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),") #Then
	И
	 (
			ISNULL(T.#Parameter(31), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(30),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(31)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(31)
		#ElseIf "T.#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(30)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(31)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(31))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 15.
#If "#Parameter(32)" = "" И "#Parameter(33)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(32)" = "Condition" Или "#Parameter(32)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(33) )
#ElseIf "#Parameter(32)" = "ReadRight" Или "#Parameter(32)" = "EditRight" #Then
	И T.#Parameter(33) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(33))
		#If Не "#Parameter(32)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(32)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(32),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(32)", ",") #Then
		InvalidAccessKind: "#Parameter(32)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(32)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(32),") #Then
	И
	 (
			ISNULL(T.#Parameter(33), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(32),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(32),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(33)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(33)
		#ElseIf "T.#Parameter(33)" = "T.Ref" #Then
			#If StrContains("#Parameter(32)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(32)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(33)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(33)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(33))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 16.
#If "#Parameter(34)" = "" И "#Parameter(35)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(34)" = "Condition" Или "#Parameter(34)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	И ( #Parameter(35) )
#ElseIf "#Parameter(34)" = "ReadRight" Или "#Parameter(34)" = "EditRight" #Then
	И T.#Parameter(35) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(35))
		#If Не "#Parameter(34)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(34)" = "RightSettings" #Then
	И
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(34),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(34)", ",") #Then
		InvalidAccessKind: "#Parameter(34)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(34)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(34),") #Then
	И
	 (
			ISNULL(T.#Parameter(35), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(34),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(34),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(35)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.#Parameter(35)
		#ElseIf "T.#Parameter(35)" = "T.Ref" #Then
			#If StrContains("#Parameter(34)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(34)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = T.#Parameter(35)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = T.#Parameter(35)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(35))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#EndIf

 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesAndSetsAdvanced</name>
		<condition>// ByValuesAndSetsAdvanced(Table, -, Modifier, JoinedTables, O, B1,P1,O1, B2,P2,O2,..., IN(n), P(n), O(n)).
// No. parameter: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Reads as: "restriction of access to values И sets of advanced".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log.
// 2-nd modifier - the string "ExtendedOR" indicates
// for restrictions, for example, "ByCompanies Или
// ByAccounts", to make extended validation for which the option settings
// kind of access in the "All allowed, no prohibited" access groups is considered to be as "Access kind is Не used".
// If this modifier is Не available, then the result
// is истина, which leads to the final result истина;
// if "All allowed, no prohibited" at least one of the access kinds (either ByCompanies either ByAccounts).
// Modifier has meaning only when the verifying sets values of access.
// You can use combinations
// of modifiers: "DontLimitAccessToGroups" "ExtendedOR" "DontLimitAccessToGroups, ExtendedOR".
// Other modifiers in this version of the template are Не expected.
// JoinedTables - the text of joining additional tables in
// the query language such as
// "INNER JOIN Document.ExpenseReport.PaymentToVendor AS T1 On T.Ref = T1.Ref".
// Joining allows to specify the fields of PaymentToVendor table,
// as the fields of the main table for verifying their values, as the main table values.
// You should remember that in case of multiplication of the
// lines in the result of connection, it is enough that the only one line pass the verification conditions, in other words the lines verification results unite on "Или".
// O - Initial brackets "(".
// K(n) - Access kind - access kind name, for example, Companies. It's a good idea to specify
// several names for fields of a composite
// type for productivity increase, for example, Companies,PrivateIndividualsGroups, by specifying several parameters blocks with the same field name.
// Special kinds of access object "Condition"
// "RightsSettings" "ReadingRights" "ChangingRights" can use only separately.
// When K(n) = Condition (Или ""), then P(n) contains a condition row on
// language of query,
// for example, T.Author = &amp;AuthorizedUser, VALUETYPE (T.Owner) = TYPE (Catalog.Organization), where T - current table alias.
// When K(n) = "ReadRight"
// Или "ChangeRight" checking if you have rights for value table T.F(n) is run.
// When K n = "object" Или ""
// When there are Dependencies rights record in the register information
// AccessRightsCorrelation Then executing Checking Rights reading etc n И sets the
// values of access to register information Access NaboryValuesOf readable on link etc n for Rights reading;
// otherwise use the default rule:
// When Right = "reading", then checking reading rights is run T.F(n) И
// the access value sets in the AccessValuesSets information register, which are read on ref T.F(n) for reading rights;
// When Right = "Changing", then checking changing rights is
// run T.F(n) И the access value sets access in information register AccessValuesSets, which are read on link T.F(n) for changing rights
// F(n) - Field of verified value with an
// alias such as "T.Organization except the case of K(n) = "Condition" (Или "").
// O(n) - Logical operations "И", "Или" in combination with brackets "(", ")".
// Note: you can increase the maximum quantity of simultaneously checked fields
// values by changing the template; but you should also specify all parameters of the pattern, namely specify empty rows, when the quantity of fields is less than maximum.
// The pattern has the following structure:
// &lt;Join on table1&gt; &lt;Join on table2&gt; ... &lt;Join
// by table(m)&gt; &lt;Common conditions part&gt; &lt;Condition on parameters group 1&gt; И/Или &lt;Condition on parameters group 1&gt; И/Или ... &lt;Condition by
// parameters group(n)&gt; Example:
// ByValuesAndSetsAdvanced("DocumentJournal.WarehouseDocuments", "", "",
// "",
// "",
// "Object","T.Ref","И",
// "Object","T.MainDocument","", "","","", ...)

// Verification of the Right parameter.
#If Не ("#Parameter(2)" = "Read" Или "#Parameter(2)" = "Insert" Или
 "#Parameter(2)" = "Update" Или "#Parameter(2)" = "Delete" Или "#Parameter(2)" = "")
 Или #CurrentAccessRightName &lt;&gt; "Read" И "#Parameter(2)" = "Read"
 Или #CurrentAccessRightName = "Read" И "#Parameter(2)" &lt;&gt; "Read" И "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If Не ( "#Parameter(3)" = "DontLimitAccessToGroups"
 Или "#Parameter(3)" = "ExtendedOR"
 Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR"
 Или "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction on record level
// И checking of usage at least of one restriction from listed access kinds.
#If &amp;LimitAccessOnRecordsLevel
 И Не (истина
 И ("#Parameter(6)" = "" И "#Parameter(7)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(6),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),"))
 И ("#Parameter(9)" = "" И "#Parameter(10)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(9),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),"))
 И ("#Parameter(12)" = "" И "#Parameter(13)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(12),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),"))
 И ("#Parameter(15)" = "" И "#Parameter(16)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(15),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),"))
 И ("#Parameter(18)" = "" И "#Parameter(19)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(18),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),"))
 И ("#Parameter(21)" = "" И "#Parameter(22)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(21),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),"))
 И ("#Parameter(24)" = "" И "#Parameter(25)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(24),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),"))
 И ("#Parameter(27)" = "" И "#Parameter(28)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(27),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),"))
 И ("#Parameter(30)" = "" И "#Parameter(31)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(30),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),"))
 И ("#Parameter(33)" = "" И "#Parameter(34)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(33),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),"))
 И ("#Parameter(36)" = "" И "#Parameter(37)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(36),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),"))
 И ("#Parameter(39)" = "" И "#Parameter(40)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(39),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),"))
 И ("#Parameter(42)" = "" И "#Parameter(43)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(42),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),"))
 И ("#Parameter(45)" = "" И "#Parameter(46)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(45),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),"))
 И ("#Parameter(48)" = "" И "#Parameter(49)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(48),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),"))
 И ("#Parameter(51)" = "" И "#Parameter(52)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(51),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),"))
 ) #Then

T FROM T // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Attachable tables to the verifing line of the current table "T".
#Parameter(4)

WHERE

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
	T.IsFolder Или
#EndIf

истина In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 истина
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.DescriptionFull = "#Parameter(1)"
			И истина In
			 (
				SELECT TOP 1 истина
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						И AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If Не #CurrentAccessRightName = "Read" #Then
						И AccessGroupsTables.Update
					#EndIf
			 )
			И AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						И UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Search values of specified fields in the allowed access groups values (of users).

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Value verification of parameters group field 1.
#If "#Parameter(6)" = "Condition" Или "#Parameter(6)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Или "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Не "#Parameter(6)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "Object" Или "#Parameter(6)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(7))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(7))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(7)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(7)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(7)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(6)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(6)", ",") #Then
		InvalidAccessKind: "#Parameter(6)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(6)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(6),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(7)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(7)
		#ElseIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(6)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(7))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(8) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 2.
#If "#Parameter(9)" = "" И "#Parameter(10)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(9)" = "Condition" Или "#Parameter(9)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(10) )
#ElseIf "#Parameter(9)" = "ReadRight" Или "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Не "#Parameter(9)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "Object" Или "#Parameter(9)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(10))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(10))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(10)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(10)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(10)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(9)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(9)", ",") #Then
		InvalidAccessKind: "#Parameter(9)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(9)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(9),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(10)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(10)
		#ElseIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(9)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(10))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(11) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 3.
#If "#Parameter(12)" = "" И "#Parameter(13)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(12)" = "Condition" Или "#Parameter(12)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Или "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Не "#Parameter(12)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "Object" Или "#Parameter(12)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(13))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(13))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(13)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(13)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(13)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(12)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(12)", ",") #Then
		InvalidAccessKind: "#Parameter(12)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(12)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(12),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(13)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(13)
		#ElseIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(12)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(13))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(14) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 4.
#If "#Parameter(15)" = "" И "#Parameter(16)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(15)" = "Condition" Или "#Parameter(15)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(16) )
#ElseIf "#Parameter(15)" = "ReadRight" Или "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Не "#Parameter(15)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "Object" Или "#Parameter(15)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(16))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(16))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(16)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(16)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(16)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(15)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(15)", ",") #Then
		InvalidAccessKind: "#Parameter(15)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(15)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(15),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(16)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(16)
		#ElseIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(15)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(16))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(17) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 5.
#If "#Parameter(18)" = "" И "#Parameter(19)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(18)" = "Condition" Или "#Parameter(18)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Или "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Не "#Parameter(18)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "Object" Или "#Parameter(18)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(19))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(19))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(19)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(19)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(19)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(18)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(18)", ",") #Then
		InvalidAccessKind: "#Parameter(18)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(18)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(18),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(19)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(19)
		#ElseIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(18)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(19))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(20) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 6.
#If "#Parameter(21)" = "" И "#Parameter(22)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(21)" = "Condition" Или "#Parameter(21)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(22) )
#ElseIf "#Parameter(21)" = "ReadRight" Или "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Не "#Parameter(21)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "Object" Или "#Parameter(21)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(22))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(22))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(22)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(22)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(22)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(21)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(21)", ",") #Then
		InvalidAccessKind: "#Parameter(21)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(21)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(21),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(22)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(22)
		#ElseIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(21)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(22))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(23) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 7.
#If "#Parameter(24)" = "" И "#Parameter(25)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(24)" = "Condition" Или "#Parameter(24)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Или "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Не "#Parameter(24)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "Object" Или "#Parameter(24)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(25))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(25))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(25)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(25)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(25)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(24)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(24)", ",") #Then
		InvalidAccessKind: "#Parameter(24)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(24)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(24),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(25)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(25)
		#ElseIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(24)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(25))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(26) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 8.
#If "#Parameter(27)" = "" И "#Parameter(28)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(27)" = "Condition" Или "#Parameter(27)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(28) )
#ElseIf "#Parameter(27)" = "ReadRight" Или "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Не "#Parameter(27)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "Object" Или "#Parameter(27)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(28))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(28))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(28)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(28)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(28)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(27)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(27)", ",") #Then
		InvalidAccessKind: "#Parameter(27)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(27)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(27),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(28)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(28)
		#ElseIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(27)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(28))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(29) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 9.
#If "#Parameter(30)" = "" И "#Parameter(31)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(30)" = "Condition" Или "#Parameter(30)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Или "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Не "#Parameter(30)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "Object" Или "#Parameter(30)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(31))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(31))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(31)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(31)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(31)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(30)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(30)", ",") #Then
		InvalidAccessKind: "#Parameter(30)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(30)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(30),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(31)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(31)
		#ElseIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(30)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(31))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(32) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 10.
#If "#Parameter(33)" = "" И "#Parameter(34)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(33)" = "Condition" Или "#Parameter(33)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(34) )
#ElseIf "#Parameter(33)" = "ReadRight" Или "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Не "#Parameter(33)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "Object" Или "#Parameter(33)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(34))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(34))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(34)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(34)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(34)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(33)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(33)", ",") #Then
		InvalidAccessKind: "#Parameter(33)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(33)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(33),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(34)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(34)
		#ElseIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(33)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(34))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(35) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 11.
#If "#Parameter(36)" = "" И "#Parameter(37)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(36)" = "Condition" Или "#Parameter(36)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(37) )
#ElseIf "#Parameter(36)" = "ReadRight" Или "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Не "#Parameter(36)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "Object" Или "#Parameter(36)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(37))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(37))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(37)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(37)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(37)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(36)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(36)", ",") #Then
		InvalidAccessKind: "#Parameter(36)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(36)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(36),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(37)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(37)
		#ElseIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(36)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(37))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(38) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 12.
#If "#Parameter(39)" = "" И "#Parameter(40)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(39)" = "Condition" Или "#Parameter(39)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(40) )
#ElseIf "#Parameter(39)" = "ReadRight" Или "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Не "#Parameter(39)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "Object" Или "#Parameter(39)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(40))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(40))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(40)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(40)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(40)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(39)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(39)", ",") #Then
		InvalidAccessKind: "#Parameter(39)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(39)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(39),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(40)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(40)
		#ElseIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(39)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(40))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(41) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 13.
#If "#Parameter(42)" = "" И "#Parameter(43)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(42)" = "Condition" Или "#Parameter(42)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(43) )
#ElseIf "#Parameter(42)" = "ReadRight" Или "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Не "#Parameter(42)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "Object" Или "#Parameter(42)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(43))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(43))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(43)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(43)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(43)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(42)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(42)", ",") #Then
		InvalidAccessKind: "#Parameter(42)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(42)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(42),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(43)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(43)
		#ElseIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(42)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(43))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(44) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 14.
#If "#Parameter(45)" = "" И "#Parameter(46)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(45)" = "Condition" Или "#Parameter(45)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(46) )
#ElseIf "#Parameter(45)" = "ReadRight" Или "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Не "#Parameter(45)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "Object" Или "#Parameter(45)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(46))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(46))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(46)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(46)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(46)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(45)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(45)", ",") #Then
		InvalidAccessKind: "#Parameter(45)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(45)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(45),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(46)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(46)
		#ElseIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(45)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(46))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(47) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 15.
#If "#Parameter(48)" = "" И "#Parameter(49)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(48)" = "Condition" Или "#Parameter(48)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(49) )
#ElseIf "#Parameter(48)" = "ReadRight" Или "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Не "#Parameter(48)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "Object" Или "#Parameter(48)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(49))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(49))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(49)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(49)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(49)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(48)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(48)", ",") #Then
		InvalidAccessKind: "#Parameter(48)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(48)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(48),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(49)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(49)
		#ElseIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(48)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(49))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(50) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 16.
#If "#Parameter(51)" = "" И "#Parameter(52)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(51)" = "Condition" Или "#Parameter(51)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(52) )
#ElseIf "#Parameter(51)" = "ReadRight" Или "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Не "#Parameter(51)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "Object" Или "#Parameter(51)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			истина In
			(
			SELECT TOP 1 истина
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				И VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(52))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				И Не
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					И Не истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		И 
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN истина In
				(
					SELECT TOP 1 истина
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(52))
						И IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							И RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		Не
		 (
		 истина IN // Не all the checks are disabled.
		 (
				SELECT TOP 1 истина // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(52)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					И SetNumbers.Read = истина
				#Else
					// Changing right can depend on leading rights Reading, Changing
					И CASE
						WHEN истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					И
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
		 ) И Не
	#Else
		 (
	#EndIf
		 истина In
		 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(52)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				И SetNumbers.Read = истина
			#Else
				// Changing right can depend on leading rights Reading, Changing
				И CASE
					WHEN истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							И VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				И
			 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				истина IN // Не all the checks of the current set are disabled.
				(
					SELECT TOP 1 истина // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						И Не истина In
							(
								SELECT TOP 1 истина // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									И DefaultValues.WithoutSetup = истина
							)
				)
				И
			 #EndIf
				 Не false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first Не permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(52)
					И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					И Не
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					истина In
					(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					истина
			#Else
				THEN
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Не #CurrentAccessRightName = "Read" #Then
					WHEN
						Не истина In
							(
							SELECT TOP 1 истина
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						истина
				#EndIf
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						истина In
							(
							SELECT TOP 1 истина
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									И DefaultValues.AccessGroup = AccessGroups.Ref
									И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									И Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If Не #CurrentAccessRightName = "Read"
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false Или истина single line values set.
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
				THEN истина
				WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN истина In
					(	SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
									И AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If Не &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					истина IN // Verifying that right is allowed for user Или a user group.
						(
						SELECT TOP 1 истина
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					И Не false IN // Checking if the right is forfeited for user Или any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								И RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								И RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								И UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) // Не false IN
		 )
		 )
	#If Не &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(51)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(51)", ",") #Then
		InvalidAccessKind: "#Parameter(51)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(51)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(51),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(52)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(52)
		#ElseIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(51)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(52))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )

#Else
	истина
#EndIf

	#Parameter(53) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

 )
)
#EndIf
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValueSets</name>
		<condition>// ByValueSets(Table, -, Modifier, SetsOwner).
// Parameter No: 1, 2, 3, 4.
// Reads as: "restriction of access by sets of values".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log.
// 2-nd modifier - the string "ExtendedOR" indicates
// for restrictions, for example, "ByCompanies Или
// ByAccounts", to make extended validation for which the option settings
// kind of access in the "All allowed, no prohibited" access groups is considered to be as "Access kind is Не used".
// If this modifier is Не available, then the result
// is истина, which leads to the final result истина;
// if "All allowed, no prohibited" at least one of the access kinds (either ByCompanies either ByAccounts).
// Modifier has meaning only when the verifying sets values of access.
// You can use combinations
// of modifiers: "DontLimitAccessToGroups" "ExtendedOR" "DontLimitAccessToGroups, ExtendedOR".
// Other modifiers in this version of the template are Не expected.
// SetsOwner - name of the field that
// contains a reference to an objectowner sets values of access to register information AccessValuesSets.
// If name fields is Не specified it shall
// be deemed that the object-owner of sets the checked values of access that has the tabular section &lt;Table&gt;.AccessValueSets.
// This tabular section is applied when Right = "Changing".
// Tabular section is exactly the same as InformationRegister.AccessValuesSets
// without measuring Object И details.
// For documents need specify log "link".
//
// Example1: ByValueSets("Document.FundsAdjustment", "", "",
// "") Example2: ByValueSets("Document.GoodsAndServicesReceipt", "", "",
// "") Example3: ByValueSets("DocumentJournal.WarehouseDocuments", "",
// "", "Refs") Example4: ByValueSets("Catalog.EmailAttachments", "", "", "Owner")

// Verification of the Right parameter.
#If Не ("#Parameter(2)" = "Read" Или "#Parameter(2)" = "Insert" Или
 "#Parameter(2)" = "Update" Или "#Parameter(2)" = "Delete" Или "#Parameter(2)" = "")
 Или #CurrentAccessRightName &lt;&gt; "Read" И "#Parameter(2)" = "Read"
 Или #CurrentAccessRightName = "Read" И "#Parameter(2)" &lt;&gt; "Read" И "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If Не ( "#Parameter(3)" = "DontLimitAccessToGroups"
 Или "#Parameter(3)" = "ExtendedOR"
 Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR"
 Или "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// The overall use checking access restriction on record level.
#If &amp;LimitAccessOnRecordsLevel #Then

T WHERE // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
	T.IsFolder Или
#EndIf

истина In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 истина
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.DescriptionFull = "#Parameter(1)"
			И истина In
			 (
				SELECT TOP 1 истина
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						И AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If Не #CurrentAccessRightName = "Read" #Then
						И AccessGroupsTables.Update
					#EndIf
			 )
			И AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						И UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
#If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
 Не
 (
 истина IN // Не all the checks are disabled.
 (
			SELECT TOP 1 истина // Select the first set with enabled checking.
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				 SetNumbers.Object = T.Ref
			#Else
				 SetNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				И SetNumbers.Read
			#Else
				И SetNumbers.Update
			#EndIf
				И 
	истина IN // Не all the checks of the current set are disabled.
	(
		SELECT TOP 1 истина // Select the first enabled check of current set.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
			И Не истина In
				(
					SELECT TOP 1 истина // Search access restrictions settings
					FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						И DefaultValues.WithoutSetup = истина
				)
	)
 ) И Не
#Else
 (
#EndIf
 истина In
 (
			SELECT TOP 1 истина // Select the first set for which access is allowed.
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				 SetNumbers.Object = T.Ref
			#Else
				 SetNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				И SetNumbers.Read
			#Else
				И SetNumbers.Update
			#EndIf
				И
 #If "#Parameter(3)" = "ExtendedOR" Или "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
	истина IN // Не all the checks of the current set are disabled.
	(
		SELECT TOP 1 истина // Select the first enabled check of current set.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
			И Не истина In
				(
					SELECT TOP 1 истина // Search access restrictions settings
					FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						И DefaultValues.WithoutSetup = истина
				)
	) И
 #EndIf
	Не false IN // All the checks are successful.
	(
		SELECT TOP 1 false // Select the first Не permitted access value.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			И ValueSets.NumberOfSet = SetNumbers.NumberOfSet
			И Не
			CASE
		#If #CurrentAccessRightName = "Read" #Then
		 #If Не &amp;AccessKindsWithDisabledUse = "All" #Then
			WHEN ValueSets.ValueWithoutGroups
			THEN
				истина In
					(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						LEFT JOIN InformationRegister.AccessGroupsValues AS Values
						ON
							 Values.AccessGroup = AccessGroups.Ref
							И Values.AccessValue = ValueSets.AccessValue
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
					)
		 #EndIf
			WHEN ValueSets.StandardValue
		#Else
			WHEN
				истина In
				(
					SELECT TOP 1 истина
					FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
					WHERE
						VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
				)
		#EndIf
		#If &amp;AccessKindsWithDisabledUse = "All" #Then
			THEN
				истина
		#Else
			THEN
			#If Не #CurrentAccessRightName = "Read"
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
				CASE
			#EndIf
			#If Не #CurrentAccessRightName = "Read" #Then
				WHEN
					Не истина In
						(
						SELECT TOP 1 истина
						FROM Catalog.MetadataObjectIDs AS TypesOfReferences
						WHERE
							 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
							И TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
						)
				THEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							И ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			#EndIf
			#If Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
				WHEN
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
						WHERE
							 AccessValuesGroups.AccessValue = ValueSets.AccessValue
							И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
						)
				THEN
					истина
			#EndIf
			#If Не #CurrentAccessRightName = "Read"
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
				ELSE
			#EndIf
					истина In
						(
						SELECT TOP 1 истина
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								 ValueGroups.AccessValue = ValueSets.AccessValue
								И DefaultValues.AccessGroup = AccessGroups.Ref
								И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								И Values.AccessValue = ValueGroups.AccessValuesGroup
						WHERE
							ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			#If Не #CurrentAccessRightName = "Read"
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
			 Или Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
				END
			#EndIf
		#EndIf
			// Checking prior false Или истина single line values set.
			WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessPermitted)
			THEN истина
			WHEN ValueSets.AccessValue = ЗНАЧЕНИЕ(Enum.AdditionalAccessValues.AccessDenied)
			THEN false
			// Checking if user has the access to AccessValue table.
			WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
		#If #CurrentAccessRightName = "Read" #Then
			// Reading right can depend only on reading right
			THEN истина In
				(	SELECT TOP 1 истина
					FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
					WHERE
						 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
				)
		#Else
			THEN истина In
				(	SELECT TOP 1 истина
					FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
					WHERE
						 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						И AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
						И Не(ValueSets.Adjustment &lt;&gt; ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
								И AccessGroupTablesObjectRightCheck.Update = false)
				)
		#EndIf
		#If Не &amp;RightSettingsOwnerTypes = "" #Then
			ELSE
				(
				истина IN // Verifying that right is allowed for user Или a user group.
					(
					SELECT TOP 1 истина
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = ValueSets.AccessValue
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
							И RightSettings.Table = CASE
								WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
								THEN ValueSets.Adjustment
								ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				И Не false IN // Checking if the right is forfeited for user Или any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = ValueSets.AccessValue
							И RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
							И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
							И RightSettings.Table = CASE
								WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
								THEN ValueSets.Adjustment
								ELSE ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							И UsersGroupsContents.UsersGroup = RightSettings.User
					)
				)
		#Else
			ELSE
				false
		#EndIf
			END
	) // Не false IN
 )
 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesEx</name>
		<condition>// ByValuesExtension(Table, -, Modifier, AttachableTables, O, K1,P1,O1, K2,P2,O2,..., K(n), P(n), O(n)).
// No. parameter: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read: "access restriction on the values advanced".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log. 
// Other modifiers in this version of the template are Не expected.
// JoinedTables - the text of joining additional tables in
// the query language such as
// "INNER JOIN Document.ExpenseReport.PaymentToVendor AS T1 On T.Ref = T1.Ref".
// Joining allows to specify the fields of PaymentToVendor table,
// as the fields of the main table for verifying their values, as the main table values.
// You should remember that in case of multiplication of the
// lines in the result of connection, it is enough that the only one line pass the verification conditions, in other words the lines verification results unite on "Или".
// O - Initial brackets "(".
// K(n) - Access kind - access kind name, for example, Companies. It's a good idea to specify
// several names for fields of a composite
// type for productivity increase, for example, Companies,PrivateIndividualsGroups, by specifying several parameters blocks with the same field name.
// You can use special kinds of
// access Condition, RightsSettings,ReadRight, ChangeRight only separately.
// When K(n) = Condition (Или ""), then P(n) contains a condition row on
// language of query,
// for example, T.Author = &amp;AuthorizedUser, VALUETYPE (T.Owner) = TYPE (Catalog.Organization), where T - current table alias.
// When K(n) = ReadRight
// Или ChangeRight checking if you have rights for value table T.P(n) is performed.
// F(n) - Field of verified value with an
// alias such as "T.Organization except the case of K(n) = "Condition" (Или "").
// O(n) - Logical operations "И", "Или" in combination with brackets "(", ")".
// Note: you can increase the maximum quantity of simultaneously checked fields
// values by changing the template; but you should also specify all parameters of the pattern, namely specify empty rows, when the quantity of fields is less than maximum.
// The pattern has the following structure:
// &lt;Conditions common part&gt; &lt;Condition by parameters group 1&gt; И/Или &lt;Condition by parameters group 2&gt; И/Или ... &lt;Condition by
// parameters group(n)&gt; Example:
// ByValuesEx("Document.ProductTransfer", "", "",
// "",
// "",
// "Companies","T.Company","И(",
// "Warehouses","T.SourceWarehouse","Или",
// "Warehouses","T.WarehouseRecipient",")", "","","", ...)

// Verification of the Right parameter.
#If Не ("#Parameter(2)" = "Read" Или "#Parameter(2)" = "Insert" Или
 "#Parameter(2)" = "Update" Или "#Parameter(2)" = "Delete" Или "#Parameter(2)" = "")
 Или #CurrentAccessRightName &lt;&gt; "Read" И "#Parameter(2)" = "Read"
 Или #CurrentAccessRightName = "Read" И "#Parameter(2)" &lt;&gt; "Read" И "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If Не ("#Parameter(3)" = "DontLimitAccessToGroups" Или "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction on record level
// И checking of usage at least of one restriction from listed access kinds.
#If &amp;LimitAccessOnRecordsLevel
 И Не (истина
 И ("#Parameter(6)" = "" И "#Parameter(7)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(6),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),"))
 И ("#Parameter(9)" = "" И "#Parameter(10)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(9),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),"))
 И ("#Parameter(12)" = "" И "#Parameter(13)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(12),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),"))
 И ("#Parameter(15)" = "" И "#Parameter(16)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(15),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),"))
 И ("#Parameter(18)" = "" И "#Parameter(19)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(18),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),"))
 И ("#Parameter(21)" = "" И "#Parameter(22)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(21),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),"))
 И ("#Parameter(24)" = "" И "#Parameter(25)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(24),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),"))
 И ("#Parameter(27)" = "" И "#Parameter(28)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(27),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),"))
 И ("#Parameter(30)" = "" И "#Parameter(31)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(30),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),"))
 И ("#Parameter(33)" = "" И "#Parameter(34)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(33),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),"))
 И ("#Parameter(36)" = "" И "#Parameter(37)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(36),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),"))
 И ("#Parameter(39)" = "" И "#Parameter(40)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(39),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),"))
 И ("#Parameter(42)" = "" И "#Parameter(43)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(42),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),"))
 И ("#Parameter(45)" = "" И "#Parameter(46)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(45),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),"))
 И ("#Parameter(48)" = "" И "#Parameter(49)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(48),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),"))
 И ("#Parameter(51)" = "" И "#Parameter(52)" = ""
 Или &amp;AccessKindsWithDisabledUse = "All"
 И Не StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(51),")
 Или StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),"))
 ) #Then

T FROM T // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Attachable tables to the verifing line of the current table "T".
#Parameter(4)

WHERE

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups" #Then
	T.IsFolder Или
#EndIf

истина In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 истина
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.DescriptionFull = "#Parameter(1)"
			И истина In
			 (
				SELECT TOP 1 истина
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						И AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If Не #CurrentAccessRightName = "Read" #Then
						И AccessGroupsTables.Update
					#EndIf
			 )
			И AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						И UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Search values of specified fields in the allowed access groups values (of users).

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Value verification of parameters group field 1.
#If "#Parameter(6)" = "Condition" Или "#Parameter(6)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Или "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Не "#Parameter(6)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(6)", ",") #Then
		InvalidAccessKind: "#Parameter(6)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(6)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(6),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(7)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(7)
		#ElseIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(6)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(7))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(8) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 2.
#If "#Parameter(9)" = "" И "#Parameter(10)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(9)" = "Condition" Или "#Parameter(9)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(10) )
#ElseIf "#Parameter(9)" = "ReadRight" Или "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Не "#Parameter(9)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(9)", ",") #Then
		InvalidAccessKind: "#Parameter(9)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(9)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(9),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(10)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(10)
		#ElseIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(9)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(10))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(11) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 3.
#If "#Parameter(12)" = "" И "#Parameter(13)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(12)" = "Condition" Или "#Parameter(12)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Или "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Не "#Parameter(12)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(12)", ",") #Then
		InvalidAccessKind: "#Parameter(12)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(12)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(12),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(13)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(13)
		#ElseIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(12)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(13))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(14) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 4.
#If "#Parameter(15)" = "" И "#Parameter(16)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(15)" = "Condition" Или "#Parameter(15)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(16) )
#ElseIf "#Parameter(15)" = "ReadRight" Или "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Не "#Parameter(15)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(15)", ",") #Then
		InvalidAccessKind: "#Parameter(15)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(15)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(15),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(16)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(16)
		#ElseIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(15)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(16))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(17) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 5.
#If "#Parameter(18)" = "" И "#Parameter(19)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(18)" = "Condition" Или "#Parameter(18)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Или "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Не "#Parameter(18)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(18)", ",") #Then
		InvalidAccessKind: "#Parameter(18)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(18)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(18),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(19)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(19)
		#ElseIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(18)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(19))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(20) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 6.
#If "#Parameter(21)" = "" И "#Parameter(22)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(21)" = "Condition" Или "#Parameter(21)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(22) )
#ElseIf "#Parameter(21)" = "ReadRight" Или "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Не "#Parameter(21)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(21)", ",") #Then
		InvalidAccessKind: "#Parameter(21)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(21)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(21),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(22)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(22)
		#ElseIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(21)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(22))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(23) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 7.
#If "#Parameter(24)" = "" И "#Parameter(25)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(24)" = "Condition" Или "#Parameter(24)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Или "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Не "#Parameter(24)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(24)", ",") #Then
		InvalidAccessKind: "#Parameter(24)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(24)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(24),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(25)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(25)
		#ElseIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(24)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(25))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(26) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 8.
#If "#Parameter(27)" = "" И "#Parameter(28)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(27)" = "Condition" Или "#Parameter(27)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(28) )
#ElseIf "#Parameter(27)" = "ReadRight" Или "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Не "#Parameter(27)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(27)", ",") #Then
		InvalidAccessKind: "#Parameter(27)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(27)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(27),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(28)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(28)
		#ElseIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(27)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(28))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(29) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 9.
#If "#Parameter(30)" = "" И "#Parameter(31)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(30)" = "Condition" Или "#Parameter(30)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Или "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Не "#Parameter(30)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(30)", ",") #Then
		InvalidAccessKind: "#Parameter(30)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(30)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(30),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(31)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(31)
		#ElseIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(30)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(31))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(32) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 10.
#If "#Parameter(33)" = "" И "#Parameter(34)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(33)" = "Condition" Или "#Parameter(33)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(34) )
#ElseIf "#Parameter(33)" = "ReadRight" Или "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Не "#Parameter(33)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(33)", ",") #Then
		InvalidAccessKind: "#Parameter(33)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(33)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(33),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(34)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(34)
		#ElseIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(33)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(34))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(35) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 11.
#If "#Parameter(36)" = "" И "#Parameter(37)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(36)" = "Condition" Или "#Parameter(36)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(37) )
#ElseIf "#Parameter(36)" = "ReadRight" Или "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Не "#Parameter(36)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(36)", ",") #Then
		InvalidAccessKind: "#Parameter(36)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(36)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(36),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(37)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(37)
		#ElseIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(36)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(37))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(38) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 12.
#If "#Parameter(39)" = "" И "#Parameter(40)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(39)" = "Condition" Или "#Parameter(39)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(40) )
#ElseIf "#Parameter(39)" = "ReadRight" Или "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Не "#Parameter(39)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(39)", ",") #Then
		InvalidAccessKind: "#Parameter(39)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(39)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(39),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(40)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(40)
		#ElseIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(39)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(40))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(41) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 13.
#If "#Parameter(42)" = "" И "#Parameter(43)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(42)" = "Condition" Или "#Parameter(42)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(43) )
#ElseIf "#Parameter(42)" = "ReadRight" Или "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Не "#Parameter(42)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(42)", ",") #Then
		InvalidAccessKind: "#Parameter(42)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(42)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(42),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(43)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(43)
		#ElseIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(42)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(43))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(44) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 14.
#If "#Parameter(45)" = "" И "#Parameter(46)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(45)" = "Condition" Или "#Parameter(45)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(46) )
#ElseIf "#Parameter(45)" = "ReadRight" Или "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Не "#Parameter(45)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(45)", ",") #Then
		InvalidAccessKind: "#Parameter(45)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(45)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(45),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(46)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(46)
		#ElseIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(45)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(46))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(47) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 15.
#If "#Parameter(48)" = "" И "#Parameter(49)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(48)" = "Condition" Или "#Parameter(48)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(49) )
#ElseIf "#Parameter(48)" = "ReadRight" Или "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Не "#Parameter(48)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(48)", ",") #Then
		InvalidAccessKind: "#Parameter(48)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(48)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(48),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(49)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(49)
		#ElseIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(48)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(49))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(50) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

//// Value verification of parameters group field 16.
#If "#Parameter(51)" = "" И "#Parameter(52)" = "" #Then
	// Parameters group is Не used.
#ElseIf "#Parameter(51)" = "Condition" Или "#Parameter(51)" = "" #Then
	// When the Condition access kind name (Или ""), then instead of field name condition is specified.
	 ( #Parameter(52) )
#ElseIf "#Parameter(51)" = "ReadRight" Или "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; НЕОПРЕДЕЛЕНО
	И истина In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 истина
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			И VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Не "#Parameter(51)" = "ReadRight" #Then
			И AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "RightSettings" #Then
	
	 (
		истина IN // Verifying that right is allowed for user Или a user group.
			(
			SELECT TOP 1 истина
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
		 И Не false IN // Verifying that right is Не allowed for user Или a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					И RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					И SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					И RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					И RightSettings.Table = ЗНАЧЕНИЕ(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					И SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					И UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf Не StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(51)", ",") #Then
		InvalidAccessKind: "#Parameter(51)" - "The list of access type names is Не found"
	#Else
		InvalidAccessKind: "#Parameter(51)" - "Access type name is Не found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
 И Не StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), НЕОПРЕДЕЛЕНО) &lt;&gt; НЕОПРЕДЕЛЕНО
			И
		#If (Не StrContains(&amp;AccessKindsWithDisabledUse, ",Users,") И StrContains(",#Parameter(51),", ",Users,"))
		 Или (Не StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") И StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			Не
			(
			Не истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(52)
					И AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			И Не
		#Else
			(
		#EndIf
			CASE
			WHEN истина In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = #Parameter(52)
		#ElseIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(51)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessGroup
					И ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					И Values.AccessValue = ValueGroups.AccessValuesGroup
					И ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN истина
			ELSE false
			END
			=
			CASE
			WHEN истина In
				(
				SELECT TOP 1 истина
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 И VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(52))
				 И DefaultValues.AllAllowed = false
				)
			THEN истина
			ELSE false
			END
			)
	 )
#Else
	истина
#EndIf

	#Parameter(53) // [)[)][)]...] [Или|И] [([(][(]...] operator И/Или with/without brackets.

 )
)
#EndIf

</condition>
	</restrictionTemplate>
</Rights>