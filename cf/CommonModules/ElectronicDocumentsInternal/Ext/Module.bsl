////////////////////////////////////////////////////////////////////////////////
// ElectonicDocumentsInternal: mechanism of electronic documents exchange.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROGRAMMING INTERFACE

////////////////////////////////////////////////////////////////////////////////
// Generation of ED from DB documents

// Generates the electronic document of expenditure invoice by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateInvoiceByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.TORG12);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber", ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = InvoiceParametersStructure();
	ElectronicDocumentsOverridable.PrepareDataByConsignment(ObjectReference, EDStructure, ParametersStructure);
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName", DirectoryAddress
			+ DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If GenerateCMLInvoice(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.SumWithVAT);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
		
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of expenditure invoice by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function FormTORG12SellerFTS(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.TORG12Seller);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
						ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("PrefixFileId", "DP_OTORG12");
	EDStructure.Insert("CTD", "1175004");
	
	DataTree = CommonUseED.DocumentTree("TORG12_Seller");
	ElectronicDocumentsOverridable.FillDataOnTrad21SellerFTS(ObjectReference, EDStructure, DataTree);
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddFTSServiceFields(DataTree, EDStructure);
		
		RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
		// Send parameter "OperationKind" of the document through the mechanism of additional parameters.
		If ValueIsFilled(TreeAttributeValue(DataTree, "OperationKind")) Then
			OperationKind = TreeAttributeValue(DataTree, "OperationKind");
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.OperationKind", XMLString(OperationKind));
		EndIf;
		If ValueIsFilled(TreeAttributeValue(DataTree, "CurrencyCode")) Then
			CurrencyCode = TreeAttributeValue(DataTree, "CurrencyCode");
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CurrencyCode", XMLString(CurrencyCode));
		EndIf;
		
		AdditDataStructure = New Structure;
		RowDocumentsBases = DataTree.Rows.Find("BasisDocuments", "FullPath");
		// Parse supporting documents.
		If ValueIsFilled(RowDocumentsBases.Value) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(RowDocumentsBases.Value);
			
			For Each String IN BasisDocumentsParametersTable Do
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.BasisDocumentKind", String.EDKind);
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.BasisDocumentNumber",
					String.SenderDocumentNumber);
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.BasisDocumentDate",
					Format(String.SenderDocumentDate, "DLF=D"));
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.IDEDDocumentFoundation", String.Description);
			EndDo;
		EndIf;
		
		// Add information about transaction document to AddData
		Attribute = TreeAttributeValue(DataTree, "TransactionDocumentDescription", False);
		If ValueIsFilled(Attribute) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentDescription", Attribute);
			Attribute = TreeAttributeValue(DataTree, "TransactionDocumentNumber", False);
			If ValueIsFilled(Attribute) Then
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentNumber", Attribute);
			EndIf;
			Attribute = TreeAttributeValue(DataTree, "TransactionDocumentDate", False);
			If ValueIsFilled(Attribute) Then
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentDate", Attribute);
			EndIf;
		EndIf;
		
		// Add correction document information to AddData
		CorrectionNumber = TreeAttributeValue(DataTree, "CorrectionNumber", False);
		If ValueIsFilled(CorrectionNumber) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CorrectionNumber", CorrectionNumber);
			NumberTemplate = NStr("en='%1 (correct. %2)';ru='%1 (испр. %2)'");
			ConsignmentNoteNumber = TreeAttributeValue(DataTree, "ConsignmentNoteNumber");
			SenderDocumentNumber = StringFunctionsClientServer.SubstituteParametersInString(
											NumberTemplate, ConsignmentNoteNumber, CorrectionNumber);
			EDStructure.Insert("SenderDocumentNumber", SenderDocumentNumber);
		EndIf;
		
		DateOfCorrection = TreeAttributeValue(DataTree, "DateOfCorrection", False);
		If ValueIsFilled(DateOfCorrection) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.DateOfCorrection", DateOfCorrection);
		EndIf;
		
		// Fill in table of products
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");

		For Each Product IN StringProductsTable.Rows Do
			RowOptionalData = Product.Rows.Find("ProductsTable.LineNumber.AdditionalInformationDigitallySigned", "FullPath", True);
			BasisDocument = TreeAttributeValue(Product, "ProductsTable.LineNumber.BasisDocument");
			If ValueIsFilled(BasisDocument) Then
				BasisDocumentsParametersTable = GetBasisDocumentsParameters(BasisDocument);
				For Each String IN BasisDocumentsParametersTable Do
					AddValueToTree(RowOptionalData, "AdditionalDataSigned.BasisDocumentKind", String.EDKind);
					AddValueToTree(RowOptionalData,
											"AdditDataSigned.BasisDocumentNumber",
											String.SenderDocumentNumber);
					AddValueToTree(RowOptionalData,
											"AdditDataSigned.BasisDocumentDate",
											Format(String.SenderDocumentDate, "DLF=D"));
					AddValueToTree(RowOptionalData, "AdditDataSigned.BasisDocumentIDED", String.Description);
				EndDo;
			EndIf;
			ID = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductIdOfCounterparty");
			If Not ValueIsFilled(ID) Then
				ProductsAndServices = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServices");
				ProductID = ProductsAndServices.UUID();
				Characteristic = TreeAttributeValue(Product, "ProductsTable.LineNumber.Characteristic");
				CharacteristicID = ?(ValueIsFilled(Characteristic), Characteristic.UUID(), "");
				Package = TreeAttributeValue(Product, "ProductsTable.LineNumber.Package");
				IDPackage = ?(ValueIsFilled(Package), Package.UUID(), "");
		
				ID = String(ProductID) + "#" + String(CharacteristicID) + "#" + String(IDPackage);
			EndIf;
			AddValueToTree(RowOptionalData, "AdditDataSigned.ID", ID);
		EndDo;
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		InsertValueIntoTree(DataTree, "FullFileName", DirectoryAddress + TreeAttributeValue(DataTree, "IdFile") + ".xml");
		IdEDF = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
		If Mid(IdEDF, 2, 2) = "BE" Then
			InsertValueIntoTree(DataTree, "EDFOperatorAttributes.EDFId", Left(IdEDF, 1) + "EB");
		EndIf;
		
		If GenerateTORG12SellerFTSCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			EDStructure.Insert("DocumentAmount", TreeAttributeValue(DataTree, "TotalInInvoice.AmountWithVAT"));
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure", EDStructure);
			ParametersStructure.Insert("EDKind", EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", TreeAttributeValue(DataTree, "FullFileName"));
			ParametersStructure.Insert("UUID", TreeAttributeValue(DataTree, "UUID"));
			If CommonUseED.AttributeExistsInTree(DataTree, "AdditFileFullName") Then
				ParametersStructure.Insert("AdditFileFullName", TreeAttributeValue(DataTree, "AdditFileFullName"));
				ParametersStructure.Insert("AdditFileIdentifier", TreeAttributeValue(DataTree, "AdditFileIdentifier"));
			EndIf;
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of expenditure invoice by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateTrad12FTSByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.TORG12Seller);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber", ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("PrefixFileId", "DP_OTORG12");
	EDStructure.Insert("CTD", "1175004");
	
	SenderIsIndividual = ElectronicDocumentsOverridable.ThisIsInd(ObjectReference.Company);
	ParametersStructure = Torg12StructureOfParameters(SenderIsIndividual);
	
	ErrorText = "";
	ElectronicDocumentsOverridable.PrepareDataByTorg12(ObjectReference, EDStructure, ParametersStructure);
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		FTSServiceFieldsStructure(ParametersStructure);
		FillFTSServiceFieldsStructure(EDStructure, ParametersStructure);
		
		// Transfer the parameter "OperationKind" cor. document through the mechanism of additional parameters.
		AdditDataStructure = New Structure;
		AdditDataStructure.Insert("OperationKind",             XMLString(ParametersStructure.OperationKind));
		ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Header", True);
		
		// Parse supporting documents.
		If ValueIsFilled(ParametersStructure.BasisDocuments) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(
				ParametersStructure.BasisDocuments);
			For Each String IN BasisDocumentsParametersTable Do
				AdditDataStructure = New Structure;
				AdditDataStructure.Insert("BasisDocumentKind",    String.EDKind);
				AdditDataStructure.Insert("BasisDocumentNumber",  String.SenderDocumentNumber);
				AdditDataStructure.Insert("SenderDocumentDate", Format(String.SenderDocumentDate, "DLF=D"));
				AdditDataStructure.Insert("IDEDDocumentFoundation",   String.Description);
				ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Header", True);
			EndDo;
		EndIf;
		
		For Each TableRow IN ParametersStructure.ProductsTable Do
			If ValueIsFilled(TableRow.BasisDocument) Then
				BasisDocumentsParametersTable = GetBasisDocumentsParameters(
					TableRow.BasisDocument);
				For Each String IN BasisDocumentsParametersTable Do
					AdditDataStructure = New Structure;
					AdditDataStructure.Insert("BasisDocumentKind",    String.EDKind);
					AdditDataStructure.Insert("BasisDocumentNumber",  String.SenderDocumentNumber);
					AdditDataStructure.Insert("SenderDocumentDate", Format(String.SenderDocumentDate, "DLF=D"));
					AdditDataStructure.Insert("IDEDDocumentFoundation",   String.Description);
					ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Products", True,
						TableRow.LineNumber);
				EndDo;
				
			EndIf;
		EndDo;
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName", DirectoryAddress + ParametersStructure.IdFile + ".xml");
		If Mid(ParametersStructure.IdEDF, 2, 2) = "BE" Then
			ParametersStructure.IdEDF = Left(ParametersStructure.IdEDF, 1) + "EB";
		EndIf;
		
		If DeleteFornTorg12CML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.TotalByBill.SumWithVAT);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

//Generates catalog item EDAttachedFiles for TORG-12 buyer
//
//Parameters:
//LinkToED - CatalogRef - reference to new item
//
// Returns:
//  EDAttachedFiles - completed electronic document
//
Function GenerateEDTorg12Buyer(LinkToED) Export
	
	AddedFile = Undefined;
	AddressInTemporaryStorage = "";
	
	EDAttributes = CommonUse.ObjectAttributesValues(
							LinkToED,
							"FileOwner, UniqueId, EDFScheduleVersion, DocumentAmount");
	
	EDStructure = GenerateFileTrad12CustomerFTS(LinkToED);
	If TypeOf(EDStructure) = Type("Structure") AND EDStructure.Property("AddressInTemporaryStorage", AddressInTemporaryStorage) Then
		FileCreationDate = CurrentSessionDate();
		AddedFile = AttachedFiles.AddFile(
													EDAttributes.FileOwner,
													EDStructure.FileID,
													"xml",
													FileCreationDate,
													CurrentSessionDate(),
													AddressInTemporaryStorage,
													Undefined,
													,
													Catalogs.EDAttachedFiles.GetRef());
		
		EDStructure.Insert("EDStatus",                       Enums.EDStatuses.Approved);
		EDStructure.Insert("UniqueId",                   EDAttributes.UniqueId);
		EDStructure.Insert("ElectronicDocumentOwner",    LinkToED);
		EDStructure.Insert("EDFScheduleVersion",            EDAttributes.EDFScheduleVersion);
		EDStructure.Insert("VersionPointTypeED",            Enums.EDVersionElementTypes.PrimaryED);
		EDStructure.Insert("EDFormingDateBySender", FileCreationDate);
		EDStructure.Insert("DocumentAmount",                 EDAttributes.DocumentAmount);
		EDStructure.Insert("FileDescription",              EDStructure.FileID);
		
		ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(AddedFile, EDStructure);
	EndIf;
	
	Return AddedFile;
	
EndFunction

// Generates the electronic document for expenditure invoice (buyer title) by reference to IB document.
//
// Parameters:
//  LinkToED    - Reference to ED by which the
//  electronic document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateFileTrad12CustomerFTS(LinkToED) Export
	
	ReturnValue = Undefined;
	EDAttributes = CommonUse.ObjectAttributesValues(LinkToED, "EDFProfileSettings, EDAggreement,
		|Counterparty, Name, FileOwner, SenderDocumentNumber,
		|SenderDocumentDate, Company, DocumentAmount, EDSender, EDRecipient, EDFormingDateBySender");
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind",                            Enums.EDKinds.TORG12Customer);
	EDStructure.Insert("EDDirection",                    Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber",                          New UUID);
	EDStructure.Insert("UUID",          New UUID);
	EDStructure.Insert("Recipient",                       EDAttributes.EDFrom);
	EDStructure.Insert("EDDate",                           CurrentSessionDate());
	EDStructure.Insert("Sender",                      EDAttributes.EDRecipient);
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	EDStructure.Insert("EDOwner",                       EDAttributes.FileOwner);
	EDStructure.Insert("SenderDocumentNumber",        EDAttributes.SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate",         EDAttributes.SenderDocumentDate);
	EDStructure.Insert("Company",                      EDAttributes.Company);
	EDStructure.Insert("Counterparty",                       EDAttributes.Counterparty);
	EDStructure.Insert("EDFProfileSettings",               EDAttributes.EDFProfileSettings);
	EDStructure.Insert("EDAgreement",                     EDAttributes.EDAgreement);
	EDStructure.Insert("PrefixFileId",                   "DP_PTORG12");
	EDStructure.Insert("CTD",                              "1175005");
	EDStructure.Insert("DocumentAmount",                   EDAttributes.DocumentAmount);
	
	DocumentTree = CommonUseED.DocumentTree("TORG12_Customer");
	ElectronicDocumentsOverridable.FillDataByTRAD12CustomerFTS(LinkToED, EDStructure, DocumentTree);

	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DocumentTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
			
		AddFTSServiceFields(DocumentTree, EDStructure);
		
		InsertValueIntoTree(DocumentTree,
								"TempDocT",
								Format(EDAttributes.EDFormingDateBySender, "DF=HH.mm.ss"));
		InsertValueIntoTree(DocumentTree,
								"DocDateTN",
								Format(EDAttributes.EDFormingDateBySender, "DF=dd.MM.yyyy"));
		InsertValueIntoTree(DocumentTree, "ConsignmentNoteNumber", EDAttributes.SenderDocumentNumber);
		InsertValueIntoTree(DocumentTree, "DateOfInvoice",  EDAttributes.SenderDocumentDate);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, LinkToED.UUID());
		IdFile = TreeAttributeValue(DocumentTree, "IdFile");
		ParametersStructure = New Structure();
		ParametersStructure.Insert("FullFileName", DirectoryAddress + IdFile + ".xml");
		InsertValueIntoTree(DocumentTree, "FullFileName", DirectoryAddress + IdFile + ".xml");
		
		ParametersStructure.Insert("RecievedDS", ReceivedFileES(LinkToED));
		
		InsertValueIntoTree(DocumentTree, "TNFileId", EDAttributes.Description);
		TINLP = TreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP");
		If Mid(TINLP, 6, 2) = (Char(49) + Char(54)) Then
			TINLP = Left(TINLP, 5) + Char(54) + Char(49) + Mid(TINLP, 8);
		EndIf;
		
		CommonUseED.FillTreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP", TINLP);
		
		If GenerateTrad12BuyerFTSCML(DocumentTree) Then
			AddressInTemporaryStorage = PutToTempStorage(New BinaryData(ParametersStructure.FullFileName));
			EDStructure.Insert("FileID", IdFile);
			EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
			ReturnValue = EDStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document for expenditure invoice (buyer title) by reference to IB document.
//
// Parameters:
//  LinkToED    - Reference to ED by which the
//  electronic document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateFileTrad12Customer(LinkToED) Export
	
	ReturnValue = Undefined;
	EDAttributes = CommonUse.ObjectAttributesValues(LinkToED, "EDNumber, Counterparty,
		|Name, FileOwner, SenderDocumentNumber, SenderDocumentDate, Company, EDFProfileSettings,
		|EDAgreement, DocumentAmount, FileOwner, EDFormingDateBySender, EDSender, EDRecipient");
	
	EDExchangeSettings = EDAttributes.EDAgreement;
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind", Enums.EDKinds.TORG12Customer);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber", EDAttributes.EDNumber);
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("Recipient", EDAttributes.EDFrom);
	
	EDStructure.Insert("EDDate",                           CurrentSessionDate());
	EDStructure.Insert("Sender",                      EDAttributes.EDRecipient);
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	EDStructure.Insert("EDOwner",                       EDAttributes.FileOwner);
	EDStructure.Insert("SenderDocumentNumber",        EDAttributes.SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate",         EDAttributes.SenderDocumentDate);
	EDStructure.Insert("Company",                      EDAttributes.Company);
	EDStructure.Insert("Counterparty",                       EDAttributes.Counterparty);
	EDStructure.Insert("EDFProfileSettings",               EDAttributes.EDFProfileSettings);
	EDStructure.Insert("EDAgreement",                     EDAttributes.EDAgreement);
	EDStructure.Insert("PrefixFileId",                   "DP_PTORG12");
	EDStructure.Insert("CTD",                              "1175005");
	EDStructure.Insert("DocumentAmount",                   EDAttributes.DocumentAmount);
	
	SenderIsIndividual = ElectronicDocumentsOverridable.ThisIsInd(EDAttributes.Company);
	ParametersStructure = Torg12BuyerParametersStructure(SenderIsIndividual);
	
	ErrorText = "";
	ElectronicDocumentsOverridable.PrepareDataByTorg12Buyer(
												LinkToED,
												EDStructure,
												ParametersStructure);
	If CheckRequiredFieldsFilling(EDAttributes.FileOwner, ParametersStructure, ErrorText) Then
		
		FTSServiceFieldsStructure(ParametersStructure);
		FillFTSServiceFieldsStructure(EDStructure, ParametersStructure);
		
		ParametersStructure.Insert("TempDocT", Format(EDAttributes.EDFormingDateBySender, "DF=HH.mm.ss"));
		ParametersStructure.Insert("DocDateTN", Format(EDAttributes.EDFormingDateBySender, "DF=dd.MM.yyyy"));
		ParametersStructure.Insert("ConsignmentNoteNumber", EDAttributes.SenderDocumentNumber);
		ParametersStructure.Insert("DateOfInvoice", EDAttributes.SenderDocumentDate);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, LinkToED.UUID());
		ParametersStructure.Insert("FullFileName", DirectoryAddress + ParametersStructure.IdFile + ".xml");
		
		ParametersStructure.Insert("RecievedDS", ReceivedFileES(LinkToED));
		
		TNFileId = EDAttributes.Description;
		ParametersStructure.Insert("TNFileId", TNFileId);
		If Mid(ParametersStructure.TINLP, 6, 2) = (Char(49) + Char(54)) Then
			ParametersStructure.TINLP = Left(ParametersStructure.TINLP, 5) + Char(54) + Char(49) + Mid(ParametersStructure.TINLP, 8);
		EndIf;

		If DeleteGenerateTrad12CustomerCML(ParametersStructure) Then
			AddressInTemporaryStorage = PutToTempStorage(New BinaryData(ParametersStructure.FullFileName));
			EDStructure.Insert("FileID", ParametersStructure.IdFile);
			EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
			ReturnValue = EDStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of expenditure invoice by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateCorDocumentByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.AgreementAboutCostChangeSender);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	SenderDocumentNumber = ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference);
	EDStructure.Insert("SenderDocumentNumber", SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("PrefixFileId", "OKORDOC");
	EDStructure.Insert("CTD", "");
	
	DataTree = CommonUseED.DocumentTree("AgreementAboutCostChangeSender");
	ElectronicDocumentsOverridable.FillDataByCorrectingDocument(
													ObjectReference,
													EDStructure,
													DataTree);
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddFTSServiceFields(DataTree, EDStructure);
		
		// Transfer the parameter "OperationKind" cor. document through the mechanism of additional parameters.
		OperationKind = TreeAttributeValue(DataTree, "AddData.DigitallySigned.OperationKind");
		InsertValueIntoTree(DataTree,
								"AddData.DigitallySigned.OperationKind",
								XMLString(OperationKind));
		
		AdditDataStructure = New Structure;
		RowDocumentsBases = DataTree.Rows.Find("BasisDocuments", "FullPath");
		// Parse supporting documents.
		If ValueIsFilled(RowDocumentsBases.Value) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(RowDocumentsBases.Value);
			
			RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
			For Each String IN BasisDocumentsParametersTable Do
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.BasisDocumentKind", String.EDKind);
				AddValueToTree(RowOptionalData,
										"AddData.DigitallySigned.BasisDocumentNumber",
										String.SenderDocumentNumber);
				AddValueToTree(RowOptionalData,
										"AddData.DigitallySigned.BasisDocumentDate",
										Format(String.SenderDocumentDate, "DLF=D"));
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.IDEDDocumentFoundation", String.Description);
			EndDo;
		EndIf;
		
		// Add the information about numbers and dates of corrections to the additional data.
		RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
		
		CorrectionNumber = TreeAttributeValue(DataTree, "CorrectionNumber", False);
		If ValueIsFilled(CorrectionNumber) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CorrectionNumber", CorrectionNumber);
		EndIf;
		
		DateOfCorrection = TreeAttributeValue(DataTree, "DateOfCorrection", False);
		If ValueIsFilled(DateOfCorrection) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.DateOfCorrection", DateOfCorrection);
		EndIf;
			
		InitialDocumentNumber = TreeAttributeValue(DataTree, "InitialDocumentNumber", False);
		If ValueIsFilled(InitialDocumentNumber) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.InitialDocumentNumber", InitialDocumentNumber);
		EndIf;
		
		InitialDocumentDate = TreeAttributeValue(DataTree, "InitialDocumentDate", False);
		If ValueIsFilled(InitialDocumentDate) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.InitialDocumentDate", InitialDocumentDate);
		EndIf;
		
		SourceDocumentCorrectionNumber = TreeAttributeValue(DataTree, "SourceDocumentCorrectionNumber", False);
		If ValueIsFilled(SourceDocumentCorrectionNumber) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.SourceDocumentCorrectionNumber", SourceDocumentCorrectionNumber);
		EndIf;
		
		SourceDocumentCorrectionDate = TreeAttributeValue(DataTree, "SourceDocumentCorrectionDate", False);
		If ValueIsFilled(SourceDocumentCorrectionDate) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.SourceDocumentCorrectionDate", SourceDocumentCorrectionDate);
		EndIf;

		OriginalDocumentPresentation = TreeAttributeValue(DataTree, "OriginalDocumentPresentation", False);
		If ValueIsFilled(OriginalDocumentPresentation) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.OriginalDocumentPresentation", OriginalDocumentPresentation);
		EndIf;
		
		//Fill in table of products
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");

		For Each Product IN StringProductsTable.Rows Do
			RowOptionalData = Product.Rows.Find("ProductsTable.LineNumber.AdditionalInformationDigitallySigned", "FullPath", True);
			BasisDocument = TreeAttributeValue(Product, "ProductsTable.LineNumber.BasisDocument");
			If ValueIsFilled(BasisDocument) Then
				BasisDocumentsParametersTable = GetBasisDocumentsParameters(BasisDocument);
				For Each String IN BasisDocumentsParametersTable Do
					AddValueToTree(RowOptionalData, "AdditionalDataSigned.BasisDocumentKind", String.EDKind);
					AddValueToTree(RowOptionalData,
											"AdditDataSigned.BasisDocumentNumber",
											String.SenderDocumentNumber);
					AddValueToTree(RowOptionalData,
											"AdditDataSigned.BasisDocumentDate",
											Format(String.SenderDocumentDate, "DLF=D"));
					AddValueToTree(RowOptionalData, "AdditDataSigned.BasisDocumentIDED", String.Description);
				EndDo;
			EndIf;
			ID = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductIdOfCounterparty");
			If Not ValueIsFilled(ID) Then
				ProductsAndServices = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServices");
				ProductID = ProductsAndServices.UUID();
				Characteristic = TreeAttributeValue(Product, "ProductsTable.LineNumber.Characteristic");
				CharacteristicID = ?(ValueIsFilled(Characteristic), Characteristic.UUID(), "");
				Package = TreeAttributeValue(Product, "ProductsTable.LineNumber.Package");
				IDPackage = ?(ValueIsFilled(Package), Package.UUID(), "");
		
				ID = String(ProductID) + "#" + String(CharacteristicID) + "#" + String(IDPackage);
			EndIf;
			AddValueToTree(RowOptionalData, "ProductsTable.LineNumber.AdditionalInformationDigitallySigned.ID", ID);
		EndDo;
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		InsertValueIntoTree(DataTree,
								"FullFileName",
								DirectoryAddress + TreeAttributeValue(DataTree, "IdFile") + ".xml");
		IdEDF = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
		If Mid(IdEDF, 2, 2) = "BE" Then
			InsertValueIntoTree(DataTree, "EDFOperatorAttributes.EDFId", Left(IdEDF, 1) + "EB");
		EndIf;
		
		If GenerateCorrectingDocumentCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			EDStructure.Insert(
					"DocumentAmount",
					TreeAttributeValue(DataTree, "TotalInInvoice.AmountWithVAT"));
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure", EDStructure);
			ParametersStructure.Insert("EDKind", EDStructure.EDKind);
			ParametersStructure.Insert(
									"FullFileName",
									TreeAttributeValue(DataTree, "FullFileName"));
			ParametersStructure.Insert(
									"UUID",
									TreeAttributeValue(DataTree, "UUID"));
			If CommonUseED.AttributeExistsInTree(DataTree, "AdditFileFullName") Then
				ParametersStructure.Insert(
										"AdditFileFullName",
										TreeAttributeValue(DataTree, "AdditFileFullName"));
			
				ParametersStructure.Insert(
										"AdditFileIdentifier",
										TreeAttributeValue(DataTree, "AdditFileIdentifier"));
			EndIf;
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

//Generates catalog item EDAttachedFiles for agreement on the change in recipient cost
//
//Parameters:
//LinkToED - CatalogRef - reference to new item
//
// Returns:
//  EDAttachedFiles - completed electronic document
//
Function GenerateCorDocumentEDRecipient(LinkToED) Export
	
	AddedFile = Undefined;
	AddressInTemporaryStorage = "";
	EDAttributes = CommonUse.ObjectAttributesValues(
						LinkToED,
						"FileOwner, UniqueId, EDFScheduleVersion, DocumentAmount");
	EDStructure = GenerateRecipientCorDocumentFile(LinkToED);
	If TypeOf(EDStructure) = Type("Structure")
			AND EDStructure.Property("AddressInTemporaryStorage", AddressInTemporaryStorage) Then
		FileCreationDate = CurrentSessionDate();
		AddedFile = AttachedFiles.AddFile(
								EDAttributes.FileOwner,
								EDStructure.FileID,
								"xml",
								FileCreationDate,
								CurrentSessionDate(),
								AddressInTemporaryStorage,
								Undefined,
								,
								Catalogs.EDAttachedFiles.GetRef());
		
		EDStructure.Insert("EDStatus",                       Enums.EDStatuses.Approved);
		EDStructure.Insert("UniqueId",                   EDAttributes.UniqueId);
		EDStructure.Insert("ElectronicDocumentOwner",    LinkToED);
		EDStructure.Insert("EDFScheduleVersion",            EDAttributes.EDFScheduleVersion);
		EDStructure.Insert("VersionPointTypeED",            Enums.EDVersionElementTypes.PrimaryED);
		EDStructure.Insert("EDFormingDateBySender", FileCreationDate);
		EDStructure.Insert("DocumentAmount",                 EDAttributes.DocumentAmount);
		EDStructure.Insert("FileDescription",              EDStructure.FileID);
		
		ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(AddedFile, EDStructure);
	EndIf;
	
	Return AddedFile;
	
EndFunction

// Generates the electronic document of correction expenditure invoice (sender title) by reference to IB document.
//
// Parameters:
//  LinkToED    - Reference to ED by which the
//  electronic document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateRecipientCorDocumentFile(LinkToED) Export
	
	ReturnValue = Undefined;
	EDAttributes = CommonUse.ObjectAttributesValues(LinkToED, "EDFProfileSettings, EDAggreement,
		|Counterparty, Name, FileOwner, SenderDocumentNumber,
		|SenderDocumentDate, Company, DocumentAmount, EDFormingDateBySender, EDSender, EDRecipient");

	EDExchangeSettings = EDAttributes.EDAgreement;
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind",                   Enums.EDKinds.AgreementAboutCostChangeRecipient);
	EDStructure.Insert("EDDirection",           Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber",                 New UUID);
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("Recipient", EDAttributes.EDFrom);
	
	EDStructure.Insert("EDDate",                           CurrentSessionDate());
	EDStructure.Insert("Sender",                      EDAttributes.EDRecipient);
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	EDStructure.Insert("EDOwner",                       EDAttributes.FileOwner);
	EDStructure.Insert("SenderDocumentNumber",        EDAttributes.SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate",         EDAttributes.SenderDocumentDate);
	EDStructure.Insert("Company",                      EDAttributes.Company);
	EDStructure.Insert("Counterparty",                       EDAttributes.Counterparty);
	EDStructure.Insert("EDFProfileSettings",               EDAttributes.EDFProfileSettings);
	EDStructure.Insert("EDAgreement",                     EDAttributes.EDAgreement);
	EDStructure.Insert("PrefixFileId",                   "PKORDOC");
	EDStructure.Insert("CTD",                              "");
	EDStructure.Insert("DocumentAmount",                   EDAttributes.DocumentAmount);
	
	DocumentTree = CommonUseED.DocumentTree("AgreementAboutCostChangeRecipient");
	ElectronicDocumentsOverridable.FillDataByCorrectingDocumentRecipient(
																				LinkToED,
																				EDStructure,
																				DocumentTree);

	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DocumentTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
			
		AddFTSServiceFields(DocumentTree, EDStructure);
		
		InsertValueIntoTree(DocumentTree,
								"TempDocT",
								Format(EDAttributes.EDFormingDateBySender, "DF=HH.mm.ss"));
		InsertValueIntoTree(DocumentTree,
								"DocDateTN",
								Format(EDAttributes.EDFormingDateBySender, "DF=dd.MM.yyyy"));
		InsertValueIntoTree(DocumentTree, "ConsignmentNoteNumber", EDAttributes.SenderDocumentNumber);
		InsertValueIntoTree(DocumentTree, "DateOfInvoice",  EDAttributes.SenderDocumentDate);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, LinkToED.UUID());
		IdFile = TreeAttributeValue(DocumentTree, "IdFile");
		ParametersStructure = New Structure();
		ParametersStructure.Insert("FullFileName", DirectoryAddress + IdFile + ".xml");
		InsertValueIntoTree(DocumentTree, "FullFileName", DirectoryAddress + IdFile + ".xml");
		
		ParametersStructure.Insert("RecievedDS", ReceivedFileES(LinkToED));
		
		InsertValueIntoTree(DocumentTree, "TNFileId", EDAttributes.Description);
		TINLP = TreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP");
		If Mid(TINLP, 6, 2) = (Char(49) + Char(54)) Then
			TINLP = Left(TINLP, 5) + Char(54) + Char(49) + Mid(TINLP, 8);
		EndIf;
		
		CommonUseED.FillTreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP", TINLP);
		
		If GenerateCorrectingDocumentBuyerCML(DocumentTree) Then
			AddressInTemporaryStorage = PutToTempStorage(New BinaryData(ParametersStructure.FullFileName));
			EDStructure.Insert("FileID", IdFile);
			EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
			ReturnValue = EDStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates electronic document of invoice for payment by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateInvoiceForPaymentByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.InvoiceForPayment);
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	DataTree = CommonUseED.DocumentTree("InvoiceForPayment");
	
	ElectronicDocumentsOverridable.FillInAccountData(ObjectReference, EDStructure, DataTree);

	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
			
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Invoice for payment");
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "ID", EDStructure.EDNumber);
		
		PlaceHeaderAttributeToAdditData(DataTree, "VATTaxation");
		PlaceHeaderAttributeToAdditData(DataTree, "PaymentDestination");
		
		PlaceHeaderAttributeToAdditData(DataTree, "TotalInDocument.Sum");
		PlaceHeaderAttributeToAdditData(DataTree, "TotalByDocument.DiscountAmount");
		PlaceHeaderAttributeToAdditData(DataTree, "TotalByDocument.AmountWithoutDiscount");
		PlaceHeaderAttributeToAdditData(DataTree, "TotalsInWords");
		
		PutSupportingDocumentsToAdditData(DataTree);
		
		PutTreeTableToAdditData(DataTree, "PaymentSchedule");
		
		If GenerateInvoiceForPaymentCML(DataTree) AND ASignOfED Then
			
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
			
		EndIf;
		
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
	
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates electronic document of invoice for payment by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateInvoiceForPaymentByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.InvoiceForPayment);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = InvoiceForPaymentParametersStructure();
	ElectronicDocumentsOverridable.PrepareDataByBill(ObjectReference, EDStructure, ParametersStructure);

	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGenerateInvoiceForPaymentCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of purchase order by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateOrderToSupplierByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ProductOrder);
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	DataTree = CommonUseED.DocumentTree("ProductOrder");

	ElectronicDocumentsOverridable.FillInProductsOrderData(ObjectReference, EDStructure, DataTree);
		
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
								
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Product order");
		InsertValueIntoTree(DataTree, "Role", "Customer");
		
		PlaceHeaderAttributeToAdditData(DataTree, "BasisDocumentNumber");
		PlaceHeaderAttributeToAdditData(DataTree, "BasisDocumentDate");
		PlaceHeaderAttributeToAdditData(DataTree, "ContractNumber");
		PlaceHeaderAttributeToAdditData(DataTree, "ContractDate");
		PlaceHeaderAttributeToAdditData(DataTree, "TotalsInWords");
		
		PutTreeGroupToAdditData(DataTree, "TotalByDocument");
		
		PutSupportingDocumentsToAdditData(DataTree);
		
		If GenerateOrderCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
			
		EndIf;
		
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
		EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of purchase order by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateOrderToSupplierByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ProductOrder);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = OrderParametersResellerStructure();
	ElectronicDocumentsOverridable.PrepareDataByProductsOrder(ObjectReference, EDStructure, ParametersStructure);
		
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGenerateOrderCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of customer order by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateClientOrderByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ResponseToOrder);
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert(
						"SenderDocumentNumber",
						ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	DataTree = CommonUseED.DocumentTree("ResponseToOrder");
	
	ElectronicDocumentsOverridable.FillInDataInResponseToOrder(
												ObjectReference,
												EDStructure,
												DataTree);
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Product order");
		InsertValueIntoTree(DataTree, "Role", "Seller");
		
		PlaceHeaderAttributeToAdditData(DataTree, "BasisDocumentNumber");
		PlaceHeaderAttributeToAdditData(DataTree, "BasisDocumentDate");
		PlaceHeaderAttributeToAdditData(DataTree, "ContractNumber");
		PlaceHeaderAttributeToAdditData(DataTree, "ContractDate");
		
		PutTreeGroupToAdditData(DataTree, "TotalByDocument");
		
		PutSupportingDocumentsToAdditData(DataTree);
		
		If GenerateOrderCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
			
		EndIf;
		
	EndIf;

	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of customer order by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateCustomerOrderByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ResponseToOrder);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert(
						"SenderDocumentNumber",
						ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = OrderClientParametersStructure();
	
	ElectronicDocumentsOverridable.PrepareDataByOnOrderResponce(
												ObjectReference,
												EDStructure,
												ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
			
		If DeleteGenerateOrderCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates electonic document of products directory by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object by which the electronic document
// shall be generated or reference to the company if ED is exported through single transaction;
//  ProductsDirectory - values table that contains
//  the list of products and services, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateProductsAndServicesCatalog(EDExchangeSettings, AdditionalParameters, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("SchemaVersion",   ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDKind",         Enums.EDKinds.ProductsDirectory);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber",       ReturnEDId(EDExchangeSettings.Company));
	EDStructure.Insert("EDDate",        CurrentSessionDate());
	
	EDStructure.Insert("Sender",   EDExchangeSettings.CompanyID);
	EDStructure.Insert("Company",   EDExchangeSettings.Company);
	
	If EDExchangeSettings.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		
		MessagePattern = NStr("en='Directory %1 from %2';ru='Каталог %1 от %2'");
		CatalogName = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDExchangeSettings.Company, Format(EDStructure.EDDate, "DLF=D"));
	Else
		EDStructure.Insert("Counterparty",    EDExchangeSettings.Counterparty);
		EDStructure.Insert("Recipient",    EDExchangeSettings.CounterpartyID);
		EDStructure.Insert("EDOwner",    EDExchangeSettings.EDAgreement);
		EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
		EDStructure.Insert("EDAgreement",  EDExchangeSettings.EDAgreement);
		EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(
			EDExchangeSettings.EDAgreement));
		EDStructure.Insert("SenderDocumentDate", CurrentSessionDate());
		
		MessagePattern = NStr("en='The directory %1 for %2 from %3';ru='Каталог %1 для %2 от %3'");
		CatalogName = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDExchangeSettings.Company, EDExchangeSettings.Counterparty, Format(EDStructure.EDDate, "DLF=D"));
	EndIf;
	
	// Receipt of products table from the temporary storage.
	ProductsDirectory = "";
	AdditionalParameters.Property("ProductsDirectory", ProductsDirectory);
	ProductsDirectory = GetFromTempStorage(ProductsDirectory);
	
	// Creation and filling of the tree according to the template.
	DataTree = CommonUseED.DocumentTree("ProductsDirectory");
	ElectronicDocumentsOverridable.FillDataByProductCatalogCML(
																EDExchangeSettings.Company,
																ProductsDirectory,
																DataTree);
		
	// Check completion of the fields marked as mandatory in the template.
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
		CatalogName = CommonUseClientServer.ReplaceProhibitedCharsInFileName(CatalogName);
		InsertValueIntoTree(DataTree, "Description", CatalogName);
		
		FullFileName = CommonUseClientServer.GetFullFileName(
			ElectronicDocumentsService.WorkingDirectory(, EDExchangeSettings.Company.UUID()),
			CatalogName);
		
		FileNamePattern = NStr("en='%1.xml';ru='%1.xml'");
		FullFileName = StringFunctionsClientServer.SubstituteParametersInString(FileNamePattern, FullFileName);
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		
		FilesArray = New Array;
		If GenerateCMLCatalog(DataTree, FilesArray) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   CatalogName);
			ParametersStructure.Insert("FilesArray",   FilesArray);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
		EndIf;
		
	Else
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates electronic document in the CML2 format of the price list by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GeneratePriceListByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	EDStructure = New Structure;
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDKind", Enums.EDKinds.PriceList);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("SenderDocumentNumber", ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", EDExchangeSettings.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);

	DataTree = CommonUseED.DocumentTree("PriceList");

	ElectronicDocumentsOverridable.FillInDataByPriceList(ObjectReference, EDStructure, DataTree);
	
	ReturnValue = Undefined;
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		// add utility fields in a
		// separate branch for a while, they can be placed to the root
		AddCMLServiceFields(DataTree, EDStructure);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "DirectoryId", New UUID);
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		
		If GeneratePriceListCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
			
		EndIf;
		
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;

	
EndFunction

// Generates electronic document of the price list by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
// Outdated procedure
Function DeleteGeneratePriceListFromDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.PriceList);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("SenderDocumentNumber", ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", EDExchangeSettings.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = PriceListParameterStructure();
	ElectronicDocumentsOverridable.PrepareDataByPriceList(ObjectReference, EDStructure, ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGeneratePriceListCML(ParametersStructure) AND ASignOfED Then
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of works execution by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateAcceptanceCertificateByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ErrorText = "";
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.AcceptanceCertificate);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = ReportsOfComplitionParametersStructure();
	ElectronicDocumentsOverridable.PrepareDataByAcceptanceCertificate(
												ObjectReference,
												EDStructure,
												ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If GenerateCMLCertificate(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.DocumentAmount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;

	Return ReturnValue;
	
EndFunction

// Generates electronic document Acceptance certificate of the format 5.01 by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateAct501PerformerFTS(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ActPerformer);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
						ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("PrefixFileId", "DP_IAKTPRM");
	EDStructure.Insert("CTD", "1175006");
	
	DataTree = CommonUseED.DocumentTree("Act501_Performer");
	ElectronicDocumentsOverridable.FillDataByAct501PerformerFTS(ObjectReference, EDStructure, DataTree);
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddFTSServiceFields(DataTree, EDStructure);
		
		RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
		// Send parameter "OperationKind" of the document through the mechanism of additional parameters.
		If ValueIsFilled(TreeAttributeValue(DataTree, "OperationKind")) Then
			OperationKind = TreeAttributeValue(DataTree, "OperationKind");
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.OperationKind", XMLString(OperationKind));
		EndIf;
		If ValueIsFilled(TreeAttributeValue(DataTree, "CurrencyCode")) Then
			CurrencyCode = TreeAttributeValue(DataTree, "CurrencyCode");
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CurrencyCode", XMLString(CurrencyCode));
		EndIf;
		
		AdditDataStructure = New Structure;
		RowDocumentsBases = DataTree.Rows.Find("BasisDocuments", "FullPath");
		// Parse supporting documents.
		If ValueIsFilled(RowDocumentsBases.Value) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(RowDocumentsBases.Value);
			
			For Each String IN BasisDocumentsParametersTable Do
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.BasisDocumentKind", String.EDKind);
				AddValueToTree(RowOptionalData,
										"AddData.DigitallySigned.BasisDocumentNumber",
										String.SenderDocumentNumber);
				AddValueToTree(RowOptionalData,
										"AddData.DigitallySigned.BasisDocumentDate",
										Format(String.SenderDocumentDate, "DLF=D"));
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.IDEDDocumentFoundation", String.Description);
			EndDo;
		EndIf;
		
		// Add information about transaction document to AddData
		Attribute = TreeAttributeValue(DataTree, "TransactionDocumentDescription", False);
		If ValueIsFilled(Attribute) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentDescription", Attribute);
			Attribute = TreeAttributeValue(DataTree, "TransactionDocumentNumber", False);
			If ValueIsFilled(Attribute) Then
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentNumber", Attribute);
			EndIf;
			Attribute = TreeAttributeValue(DataTree, "TransactionDocumentDate", False);
			If ValueIsFilled(Attribute) Then
				AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TransactionDocumentDate", Attribute);
			EndIf;
		EndIf;
		
		// Add number and date of correction to additional data.
		CorrectionNumber = TreeAttributeValue(DataTree, "CorrectionNumber", False);
		If ValueIsFilled(CorrectionNumber) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CorrectionNumber", CorrectionNumber);
		EndIf;
		
		DateOfCorrection = TreeAttributeValue(DataTree, "DateOfCorrection", False);
		If ValueIsFilled(DateOfCorrection) Then
			AddValueToTree(RowOptionalData, "AddData.DigitallySigned.DateOfCorrection", DateOfCorrection);
		EndIf;
		
		// Fill in products table.

		StringProductsTable = DataTree.Rows.Find("ServicesTable", "FullPath");

		For Each Service IN StringProductsTable.Rows Do
			RowOptionalData = Service.Rows.Find("ServicesTable.LineNumber.AdditionalInformationDigitallySigned", "FullPath", True);
			BasisDocument = TreeAttributeValue(Service, "ServicesTable.LineNumber.BasisDocument");
			If ValueIsFilled(BasisDocument) Then
				BasisDocumentsParametersTable = GetBasisDocumentsParameters(BasisDocument);
				For Each String IN BasisDocumentsParametersTable Do
					AddValueToTree(RowOptionalData, "AdditionalDataSigned.BasisDocumentKind", String.EDKind);
					AddValueToTree(RowOptionalData,
											"AdditDataSigned.BasisDocumentNumber",
											String.SenderDocumentNumber);
					AddValueToTree(RowOptionalData,
										"AdditDataSigned.BasisDocumentDate",
											Format(String.SenderDocumentDate, "DLF=D"));
					AddValueToTree(RowOptionalData, "AdditDataSigned.BasisDocumentIDED", String.Description);
				EndDo;
			EndIf;
			If ValueIsFilled(TreeAttributeValue(Service, "ServicesTable.LineNumber.VATRate")) Then
				Rate = TreeAttributeValue(Service, "ServicesTable.LineNumber.VATRate");
				VATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence( , Rate);
				AddValueToTree(RowOptionalData, "AdditDataSigned.VATRate", VATRate);
			EndIf;
			ID = TreeAttributeValue(Service, "ServicesTable.LineNumber.ProductIdOfCounterparty");
			If Not ValueIsFilled(ID) Then
				ProductsAndServices = TreeAttributeValue(Service, "ServicesTable.LineNumber.ProductsAndServices");
				ID = String(ProductsAndServices.UUID()) + "##";
			EndIf;
			AddValueToTree(RowOptionalData, "AdditDataSigned.ID", ID);
		EndDo;
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		InsertValueIntoTree(DataTree, "FullFileName", DirectoryAddress + TreeAttributeValue(DataTree, "IdFile") + ".xml");
		InsertValueIntoTree(DataTree, "EDFScheduleVersion", EDExchangeSettings.EDFScheduleVersion);
		IdEDF = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
		If Mid(IdEDF, 2, 2) = "BE" Then
			InsertValueIntoTree(DataTree, "EDFOperatorAttributes.EDFId", Left(IdEDF, 1) + "EB");
		EndIf;
		
		If GenerateAct501PerformerFTSCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			EDStructure.Insert("DocumentAmount", TreeAttributeValue(DataTree, "ServiceDescription.AmountWithVATTotal"));
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure", EDStructure);
			ParametersStructure.Insert("EDKind", EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", TreeAttributeValue(DataTree, "FullFileName"));
			ParametersStructure.Insert("UUID", TreeAttributeValue(DataTree, "UUID"));
			If CommonUseED.AttributeExistsInTree(DataTree, "AdditFileFullName") Then
				ParametersStructure.Insert("AdditFileFullName", TreeAttributeValue(DataTree, "AdditFileFullName"));
			
				ParametersStructure.Insert("AdditFileIdentifier", TreeAttributeValue(DataTree, "AdditFileIdentifier"));
			EndIf;
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates electronic document Acceptance certificate of the format 5.01 by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateAct501FTSByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ActPerformer);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber", ElectronicDocumentsOverridable.GetDocumentPrintNumber(
		ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("PrefixFileId", "DP_IAKTPRM");
	EDStructure.Insert("CTD", "1175006");
	
	SenderIsIndividual = ElectronicDocumentsOverridable.ThisIsInd(ObjectReference.Company);
	ParametersStructure = Act501ParametersStructure(SenderIsIndividual);
	
	ErrorText = "";
	ElectronicDocumentsOverridable.PrepareDataByAct501(ObjectReference, EDStructure, ParametersStructure);
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		FTSServiceFieldsStructure(ParametersStructure);
		FillFTSServiceFieldsStructure(EDStructure, ParametersStructure);
		
		// Transfer the parameter "OperationKind" cor. document through the mechanism of additional parameters.
		AdditDataStructure = New Structure;
		AdditDataStructure.Insert("OperationKind",             XMLString(ParametersStructure.OperationKind));
		ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Header", True);
		
		// Parse supporting documents.
		If ValueIsFilled(ParametersStructure.BasisDocuments) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(
				ParametersStructure.BasisDocuments);
			For Each String IN BasisDocumentsParametersTable Do
				AdditDataStructure = New Structure;
				AdditDataStructure.Insert("BasisDocumentKind",   String.EDKind);
				AdditDataStructure.Insert("BasisDocumentNumber", String.SenderDocumentNumber);
				AdditDataStructure.Insert("BasisDocumentDate",  Format(String.SenderDocumentDate, "DLF=D"));
				AdditDataStructure.Insert("IDEDDocumentFoundation",  String.Description);
				ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Header", True);
			EndDo;
		EndIf;
		
		For Each ServicesDescriptionRow IN ParametersStructure.ServicesDescriptionTable Do
			For Each TableRow IN ServicesDescriptionRow.Services Do
				If ValueIsFilled(TableRow.BasisDocument) Then
					BasisDocumentsParametersTable = GetBasisDocumentsParameters(
						TableRow.BasisDocument);
					For Each String IN BasisDocumentsParametersTable Do
						AdditDataStructure = New Structure;
						AdditDataStructure.Insert("BasisDocumentKind",    String.EDKind);
						AdditDataStructure.Insert("BasisDocumentNumber",  String.SenderDocumentNumber);
						AdditDataStructure.Insert("SenderDocumentDate", Format(String.SenderDocumentDate, "DLF=D"));
						AdditDataStructure.Insert("IDEDDocumentFoundation",   String.Description);
						ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Services", True,
							String(ServicesDescriptionRow.LineNumber) + "." + TableRow.LineNumber);
					EndDo;
					
				EndIf;
			EndDo;
		EndDo;
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",          DirectoryAddress + ParametersStructure.IdFile + ".xml");
		ParametersStructure.Insert("EDFScheduleVersion",     EDExchangeSettings.EDFScheduleVersion);
		If Mid(ParametersStructure.TINLP, 6, 2) = "16" Then
			ParametersStructure.TINLP = Left(ParametersStructure.TINLP, 5) + "61" + Mid(ParametersStructure.TINLP, 8);
		EndIf;
		If DeteteFormAct501CML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.ServicesTable.Total("SumWithVAT"));
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

//Generates catalog item EDAttachedFiles for customer act
//
//Parameters:
//LinkToED - CatalogRef - reference to new item
//
// Returns:
//  EDAttachedFiles - completed electronic document
//
Function GenerateEDAct501Customer(LinkToED) Export
	
	AddedFile = Undefined;
	AddressInTemporaryStorage = "";
	EDAttributes = CommonUse.ObjectAttributesValues(
						LinkToED,
						"FileOwner, UniqueId, EDFScheduleVersion, DocumentAmount");
	EDStructure = GenerateFileAct501CustomerFTS(LinkToED);
	If TypeOf(EDStructure) = Type("Structure")
		AND EDStructure.Property("AddressInTemporaryStorage", AddressInTemporaryStorage) Then
		
		FileCreationDate = CurrentSessionDate();
		AddedFile = AttachedFiles.AddFile(
									EDAttributes.FileOwner,
									EDStructure.FileID,
									"xml", FileCreationDate,
									CurrentSessionDate(),
									AddressInTemporaryStorage,
									Undefined,
									,
									Catalogs.EDAttachedFiles.GetRef());
		
		EDStructure.Insert("EDStatus",                       Enums.EDStatuses.Approved);
		EDStructure.Insert("UniqueId",                   EDAttributes.UniqueId);
		EDStructure.Insert("ElectronicDocumentOwner",    LinkToED);
		EDStructure.Insert("EDFScheduleVersion",            EDAttributes.EDFScheduleVersion);
		EDStructure.Insert("VersionPointTypeED",            Enums.EDVersionElementTypes.PrimaryED);
		EDStructure.Insert("EDFormingDateBySender", FileCreationDate);
		EDStructure.Insert("DocumentAmount",                 EDAttributes.DocumentAmount);
		EDStructure.Insert("FileDescription",              EDStructure.FileID);
		
		ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(AddedFile, EDStructure);
	EndIf;
	
	Return AddedFile;
	
EndFunction

// Generates the electronic document for expenditure invoice (buyer title) by reference to IB document.
//
// Parameters:
//  LinkToED    - Reference to ED by which the
//  electronic document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateFileAct501CustomerFTS(LinkToED) Export
	
	ReturnValue = Undefined;
	EDAttributes = CommonUse.ObjectAttributesValues(LinkToED, "EDFProfileSettings,
		|EDAggreement, Counterparty, Name, FileOwner, SenderDocumentNumber,
		|SenderDocumentDate, Company, DocumentAmount, EDFormingDateBySender, EDFScheduleVersion, EDSender, EDRecipient");

	EDExchangeSettings = EDAttributes.EDAgreement;
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind",                   Enums.EDKinds.ActCustomer);
	EDStructure.Insert("EDDirection",           Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber",                 New UUID);
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("Recipient", EDAttributes.EDFrom);
	
	EDStructure.Insert("EDDate",                           CurrentSessionDate());
	EDStructure.Insert("Sender",                      EDAttributes.EDRecipient);
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	EDStructure.Insert("EDOwner",                       EDAttributes.FileOwner);
	EDStructure.Insert("SenderDocumentNumber",        EDAttributes.SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate",         EDAttributes.SenderDocumentDate);
	EDStructure.Insert("Company",                      EDAttributes.Company);
	EDStructure.Insert("Counterparty",                       EDAttributes.Counterparty);
	EDStructure.Insert("EDFProfileSettings",               EDAttributes.EDFProfileSettings);
	EDStructure.Insert("EDAgreement",                     EDAttributes.EDAgreement);
	EDStructure.Insert("PrefixFileId",                   "DP_ZAKTPRM");
	EDStructure.Insert("CTD",                              "1175007");
	EDStructure.Insert("DocumentAmount",                   EDAttributes.DocumentAmount);
	
	DocumentTree = CommonUseED.DocumentTree("Act501_Customer");
	ElectronicDocumentsOverridable.FillDataOnTheAct150CustomerFTS(LinkToED, EDStructure, DocumentTree);

	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DocumentTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
			
		AddFTSServiceFields(DocumentTree, EDStructure);
		
		Attribute = Format(EDAttributes.EDFormingDateBySender, "DF=HH.mm.ss");
		InsertValueIntoTree(DocumentTree, "TimDocActE", Attribute);
		Attribute = Format(EDAttributes.EDFormingDateBySender, "DF=dd.MM.yyyy");
		InsertValueIntoTree(DocumentTree, "DateDocActE", Attribute);
		InsertValueIntoTree(DocumentTree, "NumberAct", EDAttributes.SenderDocumentNumber);
		InsertValueIntoTree(DocumentTree, "DateCertificate",  EDAttributes.SenderDocumentDate);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, LinkToED.UUID());
		IdFile = TreeAttributeValue(DocumentTree, "IdFile");
		ParametersStructure = New Structure();
		ParametersStructure.Insert("FullFileName", DirectoryAddress + IdFile + ".xml");
		InsertValueIntoTree(DocumentTree, "FullFileName", DirectoryAddress + IdFile + ".xml");
		
		ParametersStructure.Insert("RecievedDS", ReceivedFileES(LinkToED));
		
		InsertValueIntoTree(DocumentTree, "IdFileActE", EDAttributes.Description);
		TINLP = TreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP");
		If Mid(TINLP, 6, 2) = (Char(49) + Char(54)) Then
			TINLP = Left(TINLP, 5) + Char(54) + Char(49) + Mid(TINLP, 8);
		EndIf;
		
		CommonUseED.FillTreeAttributeValue(DocumentTree, "EDFOperatorAttributes.TINLP", TINLP);
		
		If GenerateAct501CustomerFTSCML(DocumentTree, EDAttributes.EDFScheduleVersion) Then
			AddressInTemporaryStorage = PutToTempStorage(New BinaryData(ParametersStructure.FullFileName));
			EDStructure.Insert("FileID", IdFile);
			EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
			ReturnValue = EDStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document for expenditure invoice (buyer title) by reference to IB document.
//
// Parameters:
//  LinkToED    - Reference to ED by which the
//  electronic document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateFileAct501Customer(LinkToED) Export
	
	ReturnValue = Undefined;
	EDAttributes = CommonUse.ObjectAttributesValues(LinkToED, "EDFProfileSettings,
		|EDAggreement, Counterparty, Name, FileOwner, SenderDocumentNumber,
		|SenderDocumentDate, Company, DocumentAmount, EDFormingDateBySender, EDFScheduleVersion, EDSender, EDRecipient");
	EDExchangeSettings = EDAttributes.EDAgreement;
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind", Enums.EDKinds.ActCustomer);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber", New UUID());
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("Recipient", EDAttributes.EDFrom);
	
	EDStructure.Insert("EDDate",                           CurrentSessionDate());
	EDStructure.Insert("Sender",                      EDAttributes.EDRecipient);
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	EDStructure.Insert("EDOwner",                       EDAttributes.FileOwner);
	EDStructure.Insert("SenderDocumentNumber",        EDAttributes.SenderDocumentNumber);
	EDStructure.Insert("SenderDocumentDate",         EDAttributes.SenderDocumentDate);
	EDStructure.Insert("Company",                      EDAttributes.Company);
	EDStructure.Insert("Counterparty",                       EDAttributes.Counterparty);
	EDStructure.Insert("EDFProfileSettings",               EDAttributes.EDFProfileSettings);
	EDStructure.Insert("EDAgreement",                     EDAttributes.EDAgreement);
	EDStructure.Insert("PrefixFileId",                   "DP_ZAKTPRM");
	EDStructure.Insert("CTD",                              "1175007");
	EDStructure.Insert("DocumentAmount",                   EDAttributes.DocumentAmount);
	
	SenderIsIndividual = ElectronicDocumentsOverridable.ThisIsInd(EDAttributes.Company);
	ParametersStructure = Act501CustomerParametersStructure(SenderIsIndividual);
	
	ErrorText = "";
	ElectronicDocumentsOverridable.PrepareDataByAct501Customer(LinkToED, EDStructure, ParametersStructure);
	If CheckRequiredFieldsFilling(EDAttributes.FileOwner, ParametersStructure, ErrorText) Then
		
		FTSServiceFieldsStructure(ParametersStructure);
		FillFTSServiceFieldsStructure(EDStructure, ParametersStructure);
		
		ParametersStructure.Insert("TempDocAcp", Format(EDAttributes.EDFormingDateBySender, "DF=HH.mm.ss"));
		ParametersStructure.Insert("DateOfAcpDock", Format(EDAttributes.EDFormingDateBySender, "DF=dd.MM.yyyy"));
		ParametersStructure.Insert("ActNumber", EDAttributes.SenderDocumentNumber);
		ParametersStructure.Insert("DateOfAct", EDAttributes.SenderDocumentDate);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, LinkToED.UUID());
		ParametersStructure.Insert("FullFileName", DirectoryAddress + ParametersStructure.IdFile + ".xml");
		
		ParametersStructure.Insert("RecievedDS", ReceivedFileES(LinkToED));
		
		EidFileAct = EDAttributes.Description;
		ParametersStructure.Insert("EidFileAct", EidFileAct);
		If Mid(ParametersStructure.IdEDF, 2, 2) = "BE" Then
			ParametersStructure.IdEDF = Left(ParametersStructure.IdEDF, 1) + "EB";
		EndIf;
		
		If DeleteGenerateAct501CustomerCML(ParametersStructure, EDAttributes.EDFScheduleVersion) Then
			AddressInTemporaryStorage = PutToTempStorage(New BinaryData(ParametersStructure.FullFileName));
			EDStructure.Insert("FileID", ParametersStructure.IdFile);
			EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
			ReturnValue = EDStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of principal report by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateReportAboutCommissionGoodsSalesByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ComissionGoodsSalesReport);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	
	// Generate parameters structure for ReportOnCommissionGoodsSales and fill it in.
	DataTree = CommonUseED.DocumentTree("AgentSalesReport");
	
	// fill in values tree with document data
	ElectronicDocumentsOverridable.FillInDataOnCommissionGoodsSalesReport(
																				ObjectReference,
																				EDStructure,
																				DataTree);
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Report on the commission goods sales");
		InsertValueIntoTree(DataTree, "Role", "Consignor");
		
		
		PlaceHeaderAttributeToAdditData(DataTree, "TotalsInWords");
		PutTreeGroupToAdditData(DataTree, "TotalByDocument");
		PutTreeTableToAdditData(DataTree, "PaymentSchedule");
		PutTreeGroupToAdditData(DataTree, "Service");
		
		If GenerateReportAboutComissionGoodsSalesCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
		EndIf;
		
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);

	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of principal report by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateReportOnCommissionGoodsSalesByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ComissionGoodsSalesReport);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("SchemaVersion", "4.02");
	
	// Generate parameters structure for ReportOnCommissionGoodsSales and fill it in.
	ParametersStructure = StructureParametersOnReportOfCommissionGoodsSales();
	
	ElectronicDocumentsOverridable.PrepareDataByReportAboutComissionGoodsSales(
																ObjectReference, EDStructure, ParametersStructure);
	
	ServiceFieldsStructure(ParametersStructure);
	FillServiceFieldStructure(EDStructure, ParametersStructure);
	
	ErrorText = "";
	CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText);
	If ErrorText = "" Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGenerateReportOnComissionGoodsSalesCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
		
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of principal report on writeoff by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateComissionGoodsWriteOffReportByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ComissionGoodsWriteOffReport);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	
	// Generate parameters structure for ReportOnCommissionGoodsSales and fill it in.
	DataTree = CommonUseED.DocumentTree("AgentReportOnWriteOff");
	
	ElectronicDocumentsOverridable.FillInDataFromComissionGoodsWriteOffReport(
												ObjectReference,
												EDStructure,
												DataTree);
		
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DataTree, "FullFileName", FullFileName);
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Report on the commission goods depreciation");
		InsertValueIntoTree(DataTree, "Role", "Consignor");
		
		If GenerateComissionGoodsWriteOffReportCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
		EndIf;
		
	EndIf;

	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
		
	EndIf;
	
	Return ReturnValue;

	
EndFunction

// Generates the electronic document of principal report on writeoff by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
// OUTDATED
Function DeleteGenerateComissionGoodsWriteOffReportByDocument(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ComissionGoodsWriteOffReport);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	// Generate parameters structure for ReportOnCommissionGoodsSales and fill it in.
	ParametersStructure = ComissionGoodsWriteOffReportStructureParameters();
	ElectronicDocumentsOverridable.PrepareDataByComissionGoodsWriteOffReport(
												ObjectReference,
												EDStructure,
												ParametersStructure);
		
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGenerateComissionGoodsWriteOffReportCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
		
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document for goods transfer between companies by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateGoodsTransferBetweenCompanies(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.GoodsTransferBetweenCompanies);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Intercompany);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.CompanyRecipient);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = TransferOfGoodsBetweenCompaniesStructureParameters();
	ElectronicDocumentsOverridable.PrepareDataByGoodsTransferBetweenCompanies(
												ObjectReference,
												EDStructure,
												ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If GenerateGoodsTransferReturnBetweenCompaniesCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document for returns of products between companies by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object based on which it
//  is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GenerateGoodsReturnBetweenCompanies(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ProductsReturnBetweenCompanies);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Intercompany);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
		ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.CompanyRecipient);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = ReturnOfGoodsBetweenCompaniesOfStructureParameters();
	ElectronicDocumentsOverridable.PrepareDataByGoodsReturnBetweenCompanies(
												ObjectReference,
												EDStructure,
												ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
	
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If GenerateGoodsTransferReturnBetweenCompaniesCML(ParametersStructure) AND ASignOfED Then
			EDStructure.Insert("DocumentAmount", ParametersStructure.Amount);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document transfer order by reference to IB document.
//
// Parameters:
// ObjectReference - Reference to IB object based on which it
// is required to generate an electronic document, EDSign - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function GeneratePaymentOrder(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind",         Enums.EDKinds.PaymentOrder);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber",       ReturnEDId(ObjectReference, "", EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate",        CurrentSessionDate());
	EDStructure.Insert("EDOwner",    ObjectReference);
	EDStructure.Insert(
			"SenderDocumentNumber",
			ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company",              ObjectReference.Company);
	EDStructure.Insert("Counterparty",               ObjectReference.Counterparty);
	EDStructure.Insert("Author",                    SessionParameters.CurrentUser);
	EDStructure.Insert("EDAgreement",             EDExchangeSettings.EDAgreement);
	EDStructure.Insert("BankApplication",           EDExchangeSettings.BankApplication);
	
	DocumentTree = CommonUseED.DocumentTree("PaymentOrder");
	
	ElectronicDocumentsOverridable.FillInDataInTransferOrder(
									ObjectReference, EDStructure, DocumentTree);
	
	UUID = New UUID;
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("UUID", UUID);
	ParametersStructure.Insert("Counterparty",  EDStructure.Counterparty);
	ParametersStructure.Insert("Company", EDStructure.Company);
	ParametersStructure.Insert("EDKind",       EDStructure.EDKind);
	ParametersStructure.Insert("Number",       EDStructure.SenderDocumentNumber);

	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DocumentTree, ErrorText);
	If Not ValueIsFilled(ErrorText) Then

		AddValueToTree(DocumentTree, "DocumentId", String(UUID));
		CompanyID = CommonUse.ObjectAttributeValue(
			EDExchangeSettings.EDAgreement, "CompanyID");
		AddValueToTree(DocumentTree, "ClientId", CompanyID);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		AddValueToTree(DocumentTree, "FullFileName", FullFileName);
		ParametersStructure.Insert("FullFileName", FullFileName);
		
		AddValueToTree(DocumentTree, "Number", EDStructure.SenderDocumentNumber);
		
		BankApplication = CommonUse.ObjectAttributeValue(EDStructure.EDAgreement, "BankApplication");
		
		If BankApplication = Enums.BankApplications.SberbankOnline Then
			EDComposed = GeneratePaymentOrderSberbankCML(DocumentTree);
		ElsIf BankApplication = Enums.BankApplications.AsynchronousExchange Then
			EDComposed = GenerateTransferOrderAsync(DocumentTree);
		Else
			EDComposed = GeneratePaymentOrderCML(DocumentTree);
		EndIf;
		
		If EDComposed AND ASignOfED Then
			EDStructure.Insert("DocumentAmount",           TreeAttributeValue(DocumentTree, "Amount"));
			PaymentDestination = TreeAttributeValue(DocumentTree, "PaymentDetails.PaymentDestination");
			EDStructure.Insert("AdditionalInformation", PaymentDestination);
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
								NStr("en='ED formation';ru='Формирование ЭД'"), MessageText, , 1);
	EndIf;

	Return ReturnValue;
	
EndFunction

//Forms catalog item EDAttachedFiles for notice
// of clarification.
//
//Parameters:
//  LinkToED - CatalogRef - reference
//  to new item CorrectionText - String - Correction content
//
// Returns:
//  Structure - structure with document data
//
Function GenerateServiceDocumentFileByED(LinkToED, EDKind, CorrectionText = "") Export
	
	ReturnValue = Undefined;
	
	EDAttributes = CommonUse.ObjectAttributesValues( LinkToED, "Counterparty,
		|Company, EDVersionPointType, Name, CreationDate, DocumentAmount, EDSender, EDRecipient");
	
	EDStructure = New Structure; // to create EDAttachedFiles
	EDStructure.Insert("EDKind",         EDKind);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("EDNumber",       New UUID());
	EDStructure.Insert("Recipient",    EDAttributes.Counterparty);
	EDExchangeSettings = ElectronicDocumentsService.DetermineEDExchangeSettingsBySource(LinkToED.FileOwner, , , LinkToED);

	EDStructure.Insert("RecipientID", EDExchangeSettings.CounterpartyID);
	
	If EDExchangeSettings.EDExchangeMethod = Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom Then
		
		If EDAttributes.VersionPointTypeED = Enums.EDVersionElementTypes.EIRDC
			OR EDAttributes.VersionPointTypeED = Enums.EDVersionElementTypes.EISDC
			OR EDAttributes.VersionPointTypeED = Enums.EDVersionElementTypes.SDANAREIC Then
			
			EDStructure.Insert("OperatorEDO", EDFOperatorSettingsStructure());
		EndIf;
	EndIf;
	
	EDStructure.Insert("SenderId", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Sender",   EDAttributes.Company);
	EDStructure.Insert("FileID",       DetermineEDFileId(EDStructure));
	EDStructure.Insert("ReceivedFileDescriptionWithoutExtension", EDAttributes.Description);
	// Date and time of file receipt.
	EDStructure.Insert("DateReceivedTime", EDAttributes.CreationDate);
	If EDKind <> Enums.EDKinds.NotificationAboutReception Then
		EDStructure.Insert("CorrectionText", CorrectionText);
		If EDKind = Enums.EDKinds.NotificationAboutClarification Then
			TemplateName = "NotificationAboutClarification";
		Else
			TemplateName = "CancellationOffer";
		EndIf;
	Else
		TemplateName = "NotificationAboutReception";
	EndIf;
	
	Tree = CommonUseED.DocumentTree(TemplateName);
	If PrepareDataByServiceDocument(LinkToED, EDStructure, Tree)
		AND FillInServiceDocumentFile(Tree, EDKind) Then
		DataFile = TreeAttributeValue(Tree, "FullFileName");
		AddressInTemporaryStorage = PutToTempStorage(New BinaryData(DataFile));
		DeleteFiles(DataFile);
		EDStructure.Insert("AddressInTemporaryStorage", AddressInTemporaryStorage);
		EDStructure.Insert("DocumentAmount",            EDAttributes.DocumentAmount);
		ReturnValue = EDStructure;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

// Generates the electronic document of expenditure invoice by reference to IB document.
//
// Parameters:
//  ObjectReference    - Reference to IB object by which the electronic
//  document shall be generated, EDExchangeSettings - structure containing the exchange
// settings EDSign -       Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function FormTransferOfAuthorityAct(ObjectReference, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	
	EDStructure = New Structure;
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDKind", Enums.EDKinds.RightsDelegationAct);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("UUID", New UUID);
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber",
						ElectronicDocumentsOverridable.GetDocumentPrintNumber(ObjectReference));
	EDStructure.Insert("SenderDocumentDate", ObjectReference.Date);
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	DataTree = CommonUseED.DocumentTree("RightsDelegationAct");
	ElectronicDocumentsOverridable.FillDataByAssignmentDeed(ObjectReference, EDStructure, DataTree);
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DataTree, ErrorText);
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DataTree, EDStructure);
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		InsertValueIntoTree(DataTree,
								"FullFileName",
								DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		InsertValueIntoTree(DataTree, "Number", EDStructure.SenderDocumentNumber);
		InsertValueIntoTree(DataTree, "Date", EDStructure.SenderDocumentDate);
		InsertValueIntoTree(DataTree, "BusinessTransaction", "Transfer of rights");
		InsertValueIntoTree(DataTree, "Role", "Licensor");
		EDStructure.Insert("DocumentAmount", TreeAttributeValue(DataTree, "Amount"));
		
		PlaceHeaderAttributeToAdditData(DataTree, "OperationKind");
		PlaceHeaderAttributeToAdditData(DataTree, "DateOfCorrection");
		PlaceHeaderAttributeToAdditData(DataTree, "CorrectionNumber");
		PlaceHeaderAttributeToAdditData(DataTree, "CodePartner");
		PlaceHeaderAttributeToAdditData(DataTree, "TransferConditions");
		
		PutTreeTableToAdditData(DataTree, "TransactionDocuments");
		
		PutSupportingDocumentsToAdditData(DataTree);
		
		PlaceTableRowAttributeToAdditData(DataTree, "Products", "SerialNumber");
		PlaceTableRowAttributeToAdditData(DataTree, "Products", "SerialNumbers");
		
		If FormTransferOfAuthorityActCML(DataTree) AND ASignOfED Then
			ParametersStructure = New Structure;
			If ValueIsFilled(TreeAttributeValue(DataTree, "CoveringNote")) Then
				EDStructure.Insert("AdditionalInformation", TreeAttributeValue(DataTree, "CoveringNote"));
			EndIf;
			ParametersStructure.Insert("EDStructure", EDStructure);
			ParametersStructure.Insert("EDKind", EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", TreeAttributeValue(DataTree, "FullFileName"));
			
			AddWithFieldsForAdditData(ParametersStructure, DataTree);
			
			ReturnValue = ParametersStructure;
			
		EndIf;
		
	EndIf;
		
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function GenerateCompanyInvoice(ObjectReference, EDExchangeSettings) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", "CompanyAttributes");
	EDStructure.Insert("SchemaVersion", ElectronicDocumentsReUse.CML2SchemeVersion());
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CompanyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentNumber","");
	EDStructure.Insert("SenderDocumentDate", CurrentSessionDate());
	EDStructure.Insert("Company", ObjectReference);
	EDStructure.Insert("Counterparty", ObjectReference);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	// Generate parameters structure for ReportOnCommissionGoodsSales and fill it in.
	DocumentTree = CommonUseED.DocumentTree("CompanyAttributes");
	
	ElectronicDocumentsOverridable.FillInDataCompanyDetails(
												ObjectReference,
												EDStructure,
												DocumentTree);
		
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(DocumentTree, ErrorText);
	
	ReturnValue = Undefined;
	
	If Not ValueIsFilled(ErrorText) Then
		
		AddCMLServiceFields(DocumentTree, EDStructure);
		
			
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		FullFileName = DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate);
		
		InsertValueIntoTree(DocumentTree, "FullFileName", FullFileName);
		
		If GenerateCompanyDetailsCML(DocumentTree) Then
			
			ParametersStructure = New Structure;
			ParametersStructure.Insert("EDStructure",    EDStructure);
			ParametersStructure.Insert("EDKind",          EDStructure.EDKind);
			ParametersStructure.Insert("FullFileName", FullFileName);
			ParametersStructure.Insert("Description",   DirectoryAddress);
			ReturnValue = ParametersStructure;

		EndIf;
		
	EndIf;

	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			NStr("en='electronic document';ru='электронный документ'"), ErrorText);
			
		CommonUseClientServer.MessageToUser(MessageText);
		
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					MessageText);
	
	EndIf;
	
	Return ReturnValue;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Filling of files

// Fills in property of XDTO object.
//
// Parameters
//  XDTOObject   -
//  fill object, PropertyName  - Property
//  of object, Value     - set
//  value, Mandatory - Boolean - sign of necessity
//  to fill in the property, ErrorText  - String - text of error if filling was unsuccessful
//
Procedure FillXDTOProperty(XDTODataObject, PropertyName, Value, Required = False, ErrorText = "", SetBlankValues = False) Export
	
	If TypeOf(Value) = Type("XDTODataValue") OR TypeOf(Value) = Type("XDTODataObject") Then
		SetXDTOValue(XDTODataObject, PropertyName, Value, ErrorText);
	Else
		If Required OR ValueIsFilled(Value) OR SetBlankValues Then
			SetXDTOValue(XDTODataObject, PropertyName, Value, ErrorText);
		EndIf;
	EndIf;
	
EndProcedure

// For internal use only
Procedure ExportEDtoFile(ED, FileName, TypeIndication = True, EncodingType = "windows-1251") Export
	
	NewXMLWriter = New XMLWriter;
	NewXMLWriter.OpenFile(FileName, EncodingType);
	NewXMLWriter.WriteXMLDeclaration();
	XDTOFactory.WriteXML(NewXMLWriter, ED, , , , ?(TypeIndication, XMLTypeAssignment.Explicit, XMLTypeAssignment.Implicit));
	NewXMLWriter.Close();
	
EndProcedure

// Returns identification number of the electronic document.
//
// Parameters:
//  ObjectReference - reference to the electronic document which identification
//  number shall be received, SenderID - String, identification number of electronic document
// sender, VersionNumber - number, number of electronic document version.
//
// Returns:
//  row of the format "SenderId#IBObjectReferenceId##VersionNumber"
//
Function ReturnEDId(ObjectReference, SenderId = Undefined, VersionNumber = Undefined) Export
	
	IDED = String(ObjectReference.UUID());
	
	Return IDED;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// CML

// Function receives CML value type
//
// Parameters
//  Type - Type   - initial
//  type SchemeVersion - CML scheme version
//
// Returns:
//  ValueType - Value type
//
Function GetCMLValueType(Type, SchemaVersion = "4.02") Export
	
	Try
		If SchemaVersion <> "4.02" Then
			ValueType = XDTOFactory.Type(SchemaVersion, Type);
		Else
			ValueType = XDTOFactory.Type("http://v8.1c.ru/edi/edi_stnd", Type);
		EndIf
	Except
		
		ValueType = Undefined;
	EndTry;
	
	Return ValueType;
	
EndFunction

// For internal use only
Function GetCMLObjectType(Type, SchemaVersion = "4.01") Export
	
	If TypeOf(Type) = Type("String") Then
		ObjectType = GetObjectTypeCML(Type, SchemaVersion);
	Else
		ObjectType = Type;
	EndIf;
	
	If ObjectType = Undefined Then
		Return Undefined;
	EndIf;
	
	NewObject = XDTOFactory.Create(ObjectType);
	
	Return NewObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Files parsing

// Parses the file with counterparty details
//
// Parameters:
//  FileReference - address of file storage with counterparty details
//
Procedure ParseCounterpartyAttributesFile(FileReference, ReturnStructure, ParseError) Export
	
	ParseError = False;
	ReturnStructure.Insert("PartnerPhone");
	ReturnStructure.Insert("CLPhone");
	ReturnStructure.Insert("PartnerEMAddress");
	ReturnStructure.Insert("SpecifyLegalAttributes");
	ReturnStructure.Insert("AccountNo");
	ReturnStructure.Insert("BankBIC");
	ReturnStructure.Insert("BankCorrAccount");
	ReturnStructure.Insert("BankPresentation");
	ReturnStructure.Insert("SpecifyCounterpartyBankAcc");
	ReturnStructure.Insert("SettlementBankUsed");
	ReturnStructure.Insert("BankBICForSettlements");
	ReturnStructure.Insert("BankCorrAccountForSettlements");
	ReturnStructure.Insert("BankForSettlementsPresentation");
	ReturnStructure.Insert("CounterpartyKind");
	ReturnStructure.Insert("TIN");
	ReturnStructure.Insert("CounterpartyDescription");
	ReturnStructure.Insert("LegalAddress");
	ReturnStructure.Insert("LegalAddressFieldsValues");
	ReturnStructure.Insert("SpecifyContactPersonData");
	ReturnStructure.Insert("CPSurname");
	ReturnStructure.Insert("CPName");
	ReturnStructure.Insert("CPSecondName");
	ReturnStructure.Insert("CounterpartySurname");
	ReturnStructure.Insert("CounterpartyName");
	ReturnStructure.Insert("CounterpartyPatronymic");
	ReturnStructure.Insert("Description");
	ReturnStructure.Insert("ActualAddress");
	ReturnStructure.Insert("ActualAddressFieldsValues");

	ParcingResult = False;
	ElectronicDocumentsOverridable.ParseCounterpartyAttributesFile(FileReference, ReturnStructure, ParcingResult, ParseError);
	
	If TypeOf(ParcingResult) <> Type("Boolean") OR ParcingResult = False Then
		XMLObject = New XMLReader;
		BinaryData = GetFromTempStorage(FileReference);
		TempFile = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		BinaryData.Write(TempFile);
		
		Try
			XMLObject.OpenFile(TempFile);
			ED = XDTOFactory.ReadXML(XMLObject);
		Except
			XMLObject.Close();
			ParseError = True;
			DeleteFiles(TempFile);
			Return;
		EndTry;
		
		If Not ED.Type() = GetCMLValueType("Counterparty", "4.02") Then
			XMLObject.Close();
			ParseError = True;
			DeleteFiles(TempFile);
			Return;
		EndIf;
		
		Try
			EDProperty = ED.Properties().Get("Contacts");
			If Not EDProperty = Undefined AND Not ED.Contacts = Undefined Then
				For Each CurContact IN ED.Contacts.Contact Do
					If CurContact.Type = "Work phone" Then
						ReturnStructure.PartnerPhone = CurContact.Value;
						ReturnStructure.CLPhone = CurContact.Value;
					ElsIf CurContact.Type = "Mail" Then
						ReturnStructure.PartnerEMAddress = CurContact.Value;
					EndIf;
				EndDo;
			EndIf;
			
			EDProperty = ED.Properties().Get("BankAccounts");
			If EDProperty <> Undefined Then
				
				DataVal = ED.Get(EDProperty);
				If DataVal <> Undefined Then
					For Each CurProp IN DataVal.BankAccount Do
						
						ReturnStructure.AccountNo = CurProp.AccountNo;
						ReturnStructure.BankBIC = CurProp.Bank.BIN;
						ReturnStructure.BankCorrAccount = CurProp.Bank.AccountCorrespondent;
						ReturnStructure.BankPresentation = CurProp.Bank.Description;
						ReturnStructure.SpecifyCounterpartyBankAcc = True;
						
						If Not CurProp.CorrespondentBank = Undefined Then
							ReturnStructure.SettlementBankUsed = True;
							ReturnStructure.BankBICForSettlements = CurProp.CorrespondentBank.BIN;
							ReturnStructure.BankCorrAccountForSettlements = CurProp.CorrespondentBank.AccountCorrespondent;
							ReturnStructure.BankForSettlementsPresentation = CurProp.CorrespondentBank.Description;
						EndIf;
						Break;
					EndDo
				EndIf;
			EndIf;
			
			ReturnStructure.SpecifyLegalAttributes = True;
			ValidTypes = "Country, State, Region, City, Street, House, Block, Apartment";
			
			EDProperty = ED.Properties().Get("LegalEntity");
			If EDProperty <> Undefined Then
				DataVal = ED.Get(EDProperty);
				If DataVal <> Undefined Then
					ReturnStructure.CounterpartyKind = 0;
					TINProperty = DataVal.Properties().Get("TIN");
					If TINProperty <> Undefined Then
						ReturnStructure.TIN = DataVal.Get(TINProperty);
					EndIf;
					PropertyOfName = DataVal.Properties().Get("OfficialName");
					If PropertyOfName <> Undefined Then
						ReturnStructure.CounterpartyDescription = DataVal.Get(PropertyOfName);
					EndIf;
					
					PropertyLegAddress = DataVal.Properties().Get("LegalAddress");
					If PropertyLegAddress <> Undefined Then
						ValLegAddress = DataVal.Get(PropertyLegAddress);
						If ValLegAddress <> Undefined Then
							
							ReturnStructure.LegalAddress = ValLegAddress.Presentation;
							LegalAddressFieldsValues = New ValueList;
							For Each CurProp IN ValLegAddress.AddressField Do
								If CurProp.Type = "Postal index" Then
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation =  "IndexOf";
									ValueLegAddress.Value = CurProp.Value;
								ElsIf CurProp.Type = "Settlement" Then
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation = "Settlement";
									ValueLegAddress.Value = CurProp.Value;
								ElsIf Find(ValidTypes, CurProp.Type) > 0 THEN
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation = CurProp.Type;
									ValueLegAddress.Value = CurProp.Value;
								EndIf;
							EndDo;
							
							ReturnStructure.LegalAddressFieldsValues = LegalAddressFieldsValues;
						EndIf
					EndIf;
					
					PropertyHead = DataVal.Properties().Get("Head");
					If PropertyHead <> Undefined Then
						ValHead = DataVal.Get(PropertyHead);
						If ValHead <> Undefined Then
							PropertyIndividual = ValHead.Properties().Get("Ind");
							If PropertyIndividual<> Undefined Then
								Ind = ValHead.Get(PropertyIndividual);
								If Ind <> Undefined Then
									ReturnStructure.SpecifyContactPersonData = True;
									CPSurname = ""; CPName = ""; CPSecondName = "";
									ElectronicDocuments.SurnameInitialsOfIndividual(Ind.FullDescr, CPSurname, CPName, CPSecondName);
									ReturnStructure.CPSurname =  CPSurname;
									ReturnStructure.CPName =      CPName;
									ReturnStructure.CPSecondName = CPSecondName;
								EndIf;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
			EDProperty = ED.Properties().Get("Ind");
			If EDProperty <> Undefined Then
				DataVal = ED.Get(EDProperty);
				If DataVal <> Undefined Then
					
					ReturnStructure.CounterpartyKind = 2;
					TINProperty = DataVal.Properties().Get("TIN");
					If TINProperty <> Undefined Then
						ReturnStructure.TIN = DataVal.Get(TINProperty);
					EndIf;
					
					PropertyOfName = DataVal.Properties().Get("FullDescr");
					If PropertyOfName <> Undefined Then
						ReturnStructure.CounterpartyDescription = DataVal.Get(PropertyOfName);
						CounterpartySurname = ""; CounterpartyName = ""; CounterpartyPatronymic = "";
						
						ElectronicDocuments.SurnameInitialsOfIndividual(ReturnStructure.CounterpartyDescription,
																	CounterpartySurname,
																	CounterpartyName,
																	CounterpartyPatronymic);
						ReturnStructure.CounterpartySurname =  CounterpartySurname;
						ReturnStructure.CounterpartyName =      CounterpartyName;
						ReturnStructure.CounterpartyPatronymic = CounterpartyPatronymic;
					EndIf;
					
					PropertyLegAddress = DataVal.Properties().Get("LegalAddress");
					If PropertyLegAddress <> Undefined Then
						
						ValLegAddress = DataVal.Get(PropertyLegAddress);
						If ValLegAddress <> Undefined Then
							
							ReturnStructure.LegalAddress = ValLegAddress.Presentation;
							LegalAddressFieldsValues = New ValueList;
							For Each CurProp IN ValLegAddress.AddressField Do
								If CurProp.Type = "Postal index" Then
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation = "IndexOf";
									ValueLegAddress.Value = CurProp.Value;
								ElsIf CurProp.Type = "Settlement" Then
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation = "Settlement";
									ValueLegAddress.Value = CurProp.Value;
								ElsIf Find(ValidTypes, CurProp.Type)>0 THEN
									ValueLegAddress = LegalAddressFieldsValues.Add();
									ValueLegAddress.Presentation = CurProp.Type;
									ValueLegAddress.Value = CurProp.Value;
								EndIf;
							EndDo;
							
							ReturnStructure.LegalAddressFieldsValues = LegalAddressFieldsValues;
						EndIf
					EndIf;
				EndIf
			EndIf;
			
			EDProperty = ED.Properties().Get("Description");
			If EDProperty <> Undefined Then
				ReturnStructure.Description = ED.Get(EDProperty);
			EndIf;
			
			EDProperty = ED.Properties().Get("Address");
			If EDProperty <> Undefined Then
				DataVal = ED.Get(EDProperty);
				If DataVal <> Undefined Then
					
					ReturnStructure.ActualAddress = DataVal.Presentation;
					ActualAddressFieldsValues = New ValueList;
					For Each CurProp IN DataVal.AddressField Do
						If CurProp.Type = "Postal index" Then
							ActuValueAddress = ActualAddressFieldsValues.Add();
							ActuValueAddress.Presentation = "IndexOf";
							ActuValueAddress.Value = CurProp.Value;
						ElsIf CurProp.Type = "Settlement" Then
							ActuValueAddress = ActualAddressFieldsValues.Add();
							ActuValueAddress.Presentation = "Settlement";
							ActuValueAddress.Value = CurProp.Value;
						ElsIf Find(ValidTypes, CurProp.Type)>0 THEN
							ActuValueAddress = ActualAddressFieldsValues.Add();
							ActuValueAddress.Value = CurProp.Value;
							ActuValueAddress.Presentation = CurProp.Type;
						EndIf;
					EndDo;
					
					ReturnStructure.ActualAddressFieldsValues = ActualAddressFieldsValues;
				EndIf;
			EndIf;
		Except
			ParseError = True;
		EndTry;
		XMLObject.Close();
		DeleteFiles(TempFile);
	EndIf;
	
EndProcedure

// Parses the file of electronic document data, creates/modifies IB objects based on ED data.
//
// Parameters:
//  ParametersStructure - parameters structure for parsing of
// the electronic document, ParsingTree - values tree, data structure of previously parsed ED.
//
// Returns:
//  Structure of parameters with attributes of created/changed IB objects
//
Function ParseDataFile(ParametersStructure, ParseTree = Undefined) Export
	
	If ParseTree = Undefined Then
		ParseTree = InitializeParseTree();
	EndIf;
	
	Return GetDataFromFile(ParametersStructure, ParseTree);
	
EndFunction

// Receives key file data from the electronic document header using XDTO package.
//
// Parameters:
//  FileName - String, path to the file which data is required to get.
//
// Returns:
//  Parameter structure with attributes of the electronic document
//
Function ReadCMLFileHeaderByXDTO(FileName) Export
	
	XMLObject = New XMLReader;
	ParametersStructure = New Structure;
	ParticipantsStructure = New Structure;
	
	EDKind = Undefined;
	Sender = Undefined;
	
	EDFormingDateBySender = Undefined;
	OwnerEDId = Undefined;
	UnknownED = False;
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();

	Try
		XMLObject.OpenFile(FileName);
		ED = XDTOFactory.ReadXML(XMLObject);
		
		If Not ED.Properties().Get("ID") = Undefined Then
			IDED = ED.ID;
		EndIf;
		
		IsPropertyIdFile = ED.Properties().Get("IdFile") <> Undefined;
		
		If ED.Type() = GetCMLValueType("ActAboutAcceptance", "4.02") Then
			
			EDKind = Enums.EDKinds.AcceptanceCertificate;
			Sender = "Seller";
			SellerSign = True;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("TORG12", "4.02") Then
			
			EDKind = Enums.EDKinds.TORG12;
			Sender = "Seller";
			SellerSign = True;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("InvoiceForPayment", "4.02") Then
			
			EDKind = Enums.EDKinds.InvoiceForPayment;
			Sender = "Seller";
			SellerSign = True;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("ComissionGoodsWriteOffReport", "4.02") Then
			
			EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport;
			Sender = "Customer";
			SellerSign = False;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("ComissionGoodsSalesReport", "4.02") Then
			
			EDKind = Enums.EDKinds.ComissionGoodsSalesReport;
			Sender = "Customer";
			SellerSign = False;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("CustomerOrder", "4.02") Then
			If ED.Role = "Seller" Then
				EDKind = Enums.EDKinds.ResponseToOrder;
				Sender = "Seller";
				SellerSign = True;
			ElsIf ED.Role = "Customer" Then	
				EDKind = Enums.EDKinds.ProductOrder;
				Sender = "Customer";
				SellerSign = False;
			EndIf;
			EDFormingDateBySender = ED.GeneratingDate;
		ElsIf ED.Type() = GetCMLValueType("Directory", "4.02") Then
			EDKind = Enums.EDKinds.ProductsDirectory;
			SenderDocumentDate  = ED.GeneratingDate;
			SellerSign = True;
			EDFormingDateBySender = ED.GeneratingDate;
			
		ElsIf ED.Type() = GetCMLValueType("BusinessInformation", TargetNamespaceSchema) Then
			If Not ED.Directory = Undefined Then
				IDED = ED.Directory.ID;
				EDKind = Enums.EDKinds.ProductsDirectory;
				SellerSign = True;
				EDFormingDateBySender = ED.GeneratingDate;
			ElsIf Not ED.Document = Undefined AND ED.Document.Count() > 0 Then
				EDocument = ED.Document[0];
				If Upper(EDocument.BusinessTransaction) = Upper("Report on the commission goods sales") Then
					EDKind = Enums.EDKinds.ComissionGoodsSalesReport;
					Sender = "Customer";
					SellerSign = False;
					EDFormingDateBySender = ED.GeneratingDate;
					
				ElsIf Upper(EDocument.BusinessTransaction) = Upper("Report on the commission goods depreciation") Then
					
					EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport;
					Sender = "Customer";
					SellerSign = False;
					EDFormingDateBySender = ED.GeneratingDate;
					
				ElsIf Upper(EDocument.BusinessTransaction) = Upper("Invoice for payment") Then
					
					EDKind = Enums.EDKinds.InvoiceForPayment;
					Sender = "Seller";
					SellerSign = True;
					EDFormingDateBySender = ED.GeneratingDate;
					
				ElsIf Upper(EDocument.BusinessTransaction) = Upper("Product order") Then
					
					If EDocument.Role = "Seller" Then
						EDKind = Enums.EDKinds.ResponseToOrder;
						Sender = "Seller";
						SellerSign = True;
					ElsIf EDocument.Role = "Customer" Then	
						EDKind = Enums.EDKinds.ProductOrder;
						Sender = "Customer";
						SellerSign = False;
					EndIf;
					EDFormingDateBySender = ED.GeneratingDate;
					
				ElsIf Upper(EDocument.BusinessTransaction) = Upper("Transfer of rights") Then
					
					EDKind = Enums.EDKinds.RightsDelegationAct;
					EDFormingDateBySender = ED.GeneratingDate;
					
				EndIf;
				
			ElsIf Not ED.OffersPackage = Undefined Then
				
				EDKind = Enums.EDKinds.PriceList;
				SellerSign = True;
				SenderDocumentDate  = ED.OffersPackage.ValidFrom;
				
				SenderDocumentDate  = ED.GeneratingDate;
				SellerSign = True;
				
			EndIf;
			
		ElsIf ED.Type() = GetCMLValueType("PriceList", "4.02") Then
			EDKind = Enums.EDKinds.PriceList;
			SellerSign = True;
		ElsIf IsPropertyIdFile Then
			IDED = ED.IdFile;
			// Process the case when a third-party XML file has come.
			If Not ValueIsFilled(XMLObject.NamespaceURI) Then
				
				// Insert 1C namespace into ED temporary file.
				Add1CNameSpaceToExternalEDFile(XMLObject, ED, FileName);
			EndIf;
			
			If Find(ED.IdFile, "OKORDOC") > 0 Then // correction torg-12 vendor title
				ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OKORDOC"));
				EDKind = Enums.EDKinds.AgreementAboutCostChangeSender;
				SellerSign = True;
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ StrReplace(ED.Document.TempDoc, ".", ""));
			ElsIf Find(ED.IdFile, "OTORG12") > 0 Then // torg-12 vendor title
				ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OTORG12"));
				EDKind = Enums.EDKinds.TORG12Seller;
				SellerSign = True;
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ StrReplace(ED.Document.TempDoc, ".", ""));
			ElsIf Find(ED.IdFile, "PTORG12") > 0 Then // torg-12 buyer title
				ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "PTORG12"));
				EDKind = Enums.EDKinds.TORG12Customer;
				SellerSign = False;
				OwnerEDId = Right(TrimR(ED.Document.IdTNO.TNFileId), 36);
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ StrReplace(ED.Document.TempDoc, ".", ""));
			ElsIf Find(ED.IdFile, "PKORDOC") > 0 Then // correction torg-12 buyer title
				ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "PKORDOC"));
				EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient;
				SellerSign = False;
				OwnerEDId = Right(TrimR(ED.Document.IdTNO.TNFileId), 36);
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ StrReplace(ED.Document.TempDoc, ".", ""));
			ElsIf Find(ED.IdFile, "IAKTPRM") > 0 Then // Act title of executive
				CertificateInNewFormat = CertificateInNewFormat(FileName);
				If CertificateInNewFormat Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM2"));
				Else
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM"));
				EndIf;
				EDKind = Enums.EDKinds.ActPerformer;
				SellerSign = True;
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ ?(CertificateInNewFormat, "", StrReplace(ED.Document.TempDoc, ".", "")));
			ElsIf Find(ED.IdFile, "ZAKTPRM") > 0 Then // Act title of customer
				CertificateInNewFormat = CertificateInNewFormat(FileName);
				If CertificateInNewFormat Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "ZAKTPRM2"));
				Else
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "ZAKTPRM"));
				EndIf;
				EDKind = Enums.EDKinds.ActCustomer;
				SellerSign = False;
				OwnerEDId = Right(TrimR(ED.Document.PrActI.IdActE.IdFileActE), 36);
				DocDate = ED.Document.DocDate;
				EDFormingDateBySender = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)
					+ ?(CertificateInNewFormat, "", StrReplace(ED.Document.TempDoc, ".", "")));
			Else
				UnknownED = True;
			EndIf
		Else
			UnknownED = True;
		EndIf;
		If UnknownED Then
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(
				NStr("en='Unknown ED type when reading the data out of the file %1!';ru='Неизвестный тип ЭД при чтении данных из файла %1!'"), FileName);
			CommonUseClientServer.MessageToUser(MessageText);
		EndIf;
		
		ParametersStructure.Insert("EDNumber", IDED);
		ParametersStructure.Insert("EDKind",   EDKind);
		ParametersStructure.Insert("SellerSign", SellerSign);
		ParametersStructure.Insert("EDFormingDateBySender", EDFormingDateBySender);
		ParametersStructure.Insert("OwnerEDId", OwnerEDId);
		ParametersStructure.Insert("EDDirection", Enums.EDDirections.Incoming);
	Except
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			FileName, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	XMLObject.Close();
	
	Return ParametersStructure;
	
EndFunction

// For internal use only
Procedure Add1CNameSpaceToExternalEDFile(XMLObject, ElectronicDocument, FileName)
	
	XMLObject.Close();
	XMLObject.OpenFile(FileName);
	
	// Read content of XML file
	DOMBuilder = New DOMBuilder();
	DOMDocument = DOMBuilder.Read(XMLObject);
	
	// Clear temporary file for recording
	XMLObject.Close();
	
	// Define our namespace
	NamespaceURI = "";
	If Find(ElectronicDocument.IdFile, "ON_SFAKT") > 0 Then
		NamespaceURI = "SFAKT";
	ElsIf Find(ElectronicDocument.IdFile, "ON_KORSFAKT") > 0 Then // adjusting invoice
		NamespaceURI = "KORSFAKT";
	ElsIf Find(ElectronicDocument.IdFile, "OTORG12") > 0 Then // torg-12 vendor title
		NamespaceURI = "OTORG12";
	ElsIf Find(ElectronicDocument.IdFile, "OKORDOC") > 0 Then // correction torg-12 vendor title
		NamespaceURI = "OKORDOC";
	ElsIf Find(ElectronicDocument.IdFile, "PKORDOC") > 0 Then // correction torg-12 vendor title
		NamespaceURI = "PKORDOC";
	ElsIf Find(ElectronicDocument.IdFile, "PTORG12") > 0 Then // torg-12 buyer title
		NamespaceURI = "PTORG12";
	ElsIf Find(ElectronicDocument.IdFile, "IAKTPRM") > 0 Then // Act title of executive
		If CertificateInNewFormat(FileName) Then
			NamespaceURI = "IAKTPRM2";
		Else
			NamespaceURI = "IAKTPRM";
		EndIf;
	ElsIf Find(ElectronicDocument.IdFile, "ZAKTPRM") > 0 Then // Act title of customer
		If CertificateInNewFormat(FileName) Then
			NamespaceURI = "ZAKTPRM2";
		Else
			NamespaceURI = "ZAKTPRM";
		EndIf;
	ElsIf Find(ElectronicDocument.IdFile, "DP_IZVPOL") > 0 Then
		NamespaceURI = "DP_IZVPOL";
	ElsIf Find(ElectronicDocument.IdFile, "DP_UVUTOCH") > 0 Then
		NamespaceURI = "DP_UVUTOCH";
	ElsIf Find(ElectronicDocument.IdFile, "POD_DPIZVPOL") > 0 Then
		NamespaceURI = "DP_IZVPOL";
	ElsIf Find(ElectronicDocument.IdFile, "DP_PDOTPR") > 0 Then
		NamespaceURI = "DP_PDOTPR";
	ElsIf Find(ElectronicDocument.IdFile, "DP_PDPOL") > 0 Then
		NamespaceURI = "DP_PDPOL";
	ElsIf Find(ElectronicDocument.IdFile, "POD") > 0 Then
		NamespaceURI = "PDO";
	EndIf;
	
	// Set 1C namespace
	If Not ValueIsFilled(DOMDocument.DocumentElement.NamespaceURI) Then
		DOMDocument.DocumentElement.SetNamespaceMapping("", NamespaceURI);
	EndIf;
	
	XMLWriter = New XMLWriter;
	XMLWriter.OpenFile(FileName);
	DOMWriter = New DOMWriter;
	DOMWriter.Write(DOMDocument, XMLWriter);
	XMLWriter.Close();
	
	XMLObject.OpenFile(FileName);
	
EndProcedure

// For internal use only
Procedure DeleteNameSpace(FileName, TargetNamespace)
	
	Text = New TextDocument;
	Text.Read(FileName,"windows-1251");
	StringFile = Text.GetLine(2);
	StringFile = StrReplace(StringFile, "xmlns=""" + TargetNamespace + """", "");
	Text.ReplaceLine(2, StringFile);
	Text.Write(FileName, "windows-1251");
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Filling of parsing objects tree and tree of object matches

// Receives information about the product in ED array
//
// Parameters:
//  EDKindsArray - array of references to catalog items EDAttachedFiles
//
// Returns:
//  Values table containing the information about the product.
//
Function GetInformationAboutProduct(EDKindsArray) Export
	
	ReturnTable = Undefined;
	AdditColumnsNames = "";
	
	For Each CurED IN EDKindsArray Do
		If CurED.EDKind = Enums.EDKinds.TORG12Customer
			OR CurED.EDKind = Enums.EDKinds.ActCustomer
			OR CurED.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
			
			ED = CurED.ElectronicDocumentOwner;
		Else
			ED = CurED;
		EndIf;
		AdditInformationAboutED = ElectronicDocumentsService.GetFileData(ED, , True);
		If AdditInformationAboutED.Property("FileBinaryDataRef")
			AND ValueIsFilled(AdditInformationAboutED.FileBinaryDataRef) Then
			
			EDData = GetFromTempStorage(AdditInformationAboutED.FileBinaryDataRef);
			
			If ValueIsFilled(AdditInformationAboutED.Extension) Then
				FileName = ElectronicDocumentsService.TemporaryFileCurrentName(AdditInformationAboutED.Extension);
			Else
				FileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
			EndIf;
			
			If FileName = Undefined Then
				ErrorTemplate = NStr("en='Reading electronic document: %1.
		|Failed to read electronic document. Verify the work directory setup.';ru='Чтение электронного документа: %1.
		|Не удалось прочитать электронный документ. Проверьте настройку рабочего каталога.'");
				ErrorText = StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, ED);
				CommonUseClientServer.MessageToUser(ErrorText);
				Continue;
			EndIf;
			
			AdditDataTree = Undefined;
			If Not CommonUse.ObjectAttributeValue(ED, "EDKind") = Enums.EDKinds.ProductsDirectory Then
				SelectionEDAddData = ElectronicDocumentsService.SelectionAdditDataED(ED);
				If SelectionEDAddData.Next() Then
					AdditDataED = ElectronicDocumentsService.GetFileData(
					                                                           SelectionEDAddData.Ref,
					                                                           SelectionEDAddData.Ref.UUID(),
					                                                           True);
					RefToDDAdditDataED = "";
					If AdditDataED.Property("FileBinaryDataRef", RefToDDAdditDataED)
						AND ValueIsFilled(RefToDDAdditDataED) Then
						TempFile = GetTempFileName("xml");
						FileBinaryData = GetFromTempStorage(RefToDDAdditDataED);
						FileBinaryData.Write(TempFile);
						AdditDataTree = ParseUniversalAdditFile(TempFile);
						DeleteFiles(TempFile);
					EndIf;
				EndIf;
			EndIf;
			
			EDData.Write(FileName);
			
			If Find(AdditInformationAboutED.Extension, "zip") > 0 OR Find(AdditInformationAboutED.Extension, "xml") > 0 Then
				
				FolderForUnpacking = ElectronicDocumentsService.WorkingDirectory(, ED.UUID());
				If FolderForUnpacking = Undefined Then
					ErrorTemplate = NStr("en='Reading electronic document: %1.
		|Failed to read electronic document. Verify the work directory setup.';ru='Чтение электронного документа: %1.
		|Не удалось прочитать электронный документ. Проверьте настройку рабочего каталога.'");
					ErrorText = StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, ED);
					DeleteFiles(FileName);
					Continue;
				EndIf;
				DeleteFiles(FolderForUnpacking, "*.*");
				If Find(AdditInformationAboutED.Extension, "zip") > 0 Then
					ZIPReading = New ZipFileReader(FileName);
					Try
						ZipReading.ExtractAll(FolderForUnpacking);
					Except
						ErrorText = BriefErrorDescription(ErrorInfo());
						If Not ElectronicDocumentsService.PossibleToExtractFiles(ZipReading, FolderForUnpacking) Then
							MessageText = ElectronicDocumentsReUse.GetMessageAboutError("006");
						EndIf;
						ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
							ErrorText, MessageText);
						ZipReading.Close();
						DeleteFiles(FolderForUnpacking);
						DeleteFiles(FileName);
						Continue;
					EndTry;
				Else
					FileRecipient = FolderForUnpacking + "\" + New UUID + ".xml";
					ElectronicDocumentsService.DeleteUnnecessarySlashInPath(FileRecipient);
					FileCopy(FileName, FileRecipient);
				EndIf;
				XMLArchiveFiles = FindFiles(FolderForUnpacking, "*.xml");
				For Each UnpackedFile IN XMLArchiveFiles Do
					DataFileName = UnpackedFile.FullName;
					If Find(UnpackedFile.Name, "packageDescription") Then
						Continue;
					EndIf;
					InformationAboutProductFromXMLFile(DataFileName, ReturnTable, ED, AdditDataTree, AdditColumnsNames);
				EndDo;
				DeleteFiles(FolderForUnpacking);
			EndIf;
			DeleteFiles(FileName);
		EndIf;
	EndDo;
	
	If TypeOf(ReturnTable) = Type("ValueTable") Then
		ReturnTable.GroupBy("ID, SKU, Description, BasicUnitCode,
			|BasicUnitName, BasicUnitDescriptionFull, BasicUnitInternationalAbbreviation, Definition, ED, CharacteristicName"
			+ AdditColumnsNames);
	EndIf;

	Return ReturnTable;
	
EndFunction

// For internal use only
Procedure InformationAboutProductFromXMLFile(FullFileName,
									  ReturnTable,
									  ED,
									  AdditDataTree = Undefined,
									  AdditColumnsNames = "") Export
	
	XMLObject = New XMLReader;
	UnknownED = False;
	Try
		XMLObject.OpenFile(FullFileName);
		ED_XML = XDTOFactory.ReadXML(XMLObject);
		DataSet = Undefined;
		IsPropertyIdFile = ED_XML.Properties().Get("IdFile") <> Undefined;
		
		If ED_XML.Type() = GetCMLValueType("PriceList", "4.02") Then
			DataSet = ED_XML["Offers"].Offer;
			GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject,,,,, AdditColumnsNames);
		ElsIf ED_XML.Type() = GetCMLValueType("BusinessInformation", "urn:1C.ru:commerceml_2") Then
			If TypeOf(ED_XML.Directory) = Type("XDTODataObject") Then
				DataSet = ED_XML.Directory["Products"].Product;
			ElsIf TypeOf(ED_XML.Document) = Type("XDTOList") AND (ED_XML.Document.Count() > 0) Then
				DataSet = ED_XML.Document[0]["Products"].Product;
			ElsIf TypeOf(ED_XML.OffersPackage) = Type("XDTODataObject") 
				AND TypeOf(ED_XML.OffersPackage.Offers) = Type("XDTODataObject")
				AND TypeOf(ED_XML.OffersPackage.Offers.Offer) = Type("XDTOList")
				AND ED_XML.OffersPackage.Offers.Offer.Count() > 0 Then
				
				DataSet = ED_XML.OffersPackage.Offers.Offer;
				
			EndIf;
			GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject,,,,, AdditColumnsNames);
		ElsIf ED_XML.Type() = GetCMLValueType("Directory", "4.02")
				OR ED_XML.Type() = GetCMLValueType("ActAboutAcceptance", "4.02")
				OR ED_XML.Type() = GetCMLValueType("TORG12", "4.02")
				OR ED_XML.Type() = GetCMLValueType("InvoiceForPayment", "4.02")
				OR ED_XML.Type() = GetCMLValueType("ComissionGoodsWriteOffReport", "4.02")
				OR ED_XML.Type() = GetCMLValueType("ComissionGoodsSalesReport", "4.02")
				OR ED_XML.Type() = GetCMLValueType("CustomerOrder", "4.02") Then
			If ED_XML["Products"] <> Undefined Then
				DataSet = ED_XML["Products"].Product;
				GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, , , , , AdditColumnsNames);
			EndIf;
		ElsIf IsPropertyIdFile Then
			// Process the case when a third-party XML file has come.
			If Not ValueIsFilled(XMLObject.NamespaceURI) Then
		
				// Insert 1C namespace into ED temporary file.
				Add1CNameSpaceToExternalEDFile(XMLObject, ED_XML, FullFileName);
			EndIf;
			
			If Find(ED_XML.IdFile, "OTORG12") > 0 Then
				ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OTORG12"));
				DataSet = ED_XML.Document.PrInD.CN.Table.PrGd;
				GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, AdditDataTree,
					True, "Products", , AdditColumnsNames);
			ElsIf Find(ED_XML.IdFile, "OKORDOC") > 0 Then
				ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OKORDOC"));
				DataSet = ED_XML.Document.PrInD.CN.Table.PrGd;
				GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, AdditDataTree,
					True, "Products", , AdditColumnsNames);
			ElsIf Find(ED_XML.IdFile, "IAKTPRM") > 0 Then
				If CertificateInNewFormat(FullFileName) Then
					ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM2"));
				Else
					ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM"));
				EndIf;
				WorksDescriptionDataSet = ED_XML.Document.PrActI.WorksDescr;
				DataSet = Undefined;
				// Search products and services in all tabular sections of the act.
				For Ct = 0 To WorksDescriptionDataSet.Count() - 1 Do
					DescriptionItem = WorksDescriptionDataSet.GetXDTO(Ct);
					DataSet = DescriptionItem.GetList("Work");
					GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, AdditDataTree,
						True, "Services", Ct + 1, AdditColumnsNames);
				EndDo;
			ElsIf Find(ED_XML.IdFile, "KORSFAKT") > 0 Then
				ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "KORSFAKT"));
				DataSet = ED_XML.Document.TablCInv.InfoInv;
				GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, AdditDataTree,
					True, "Products");
			ElsIf Find(ED_XML.IdFile, "SFAKT") > 0 Then
				ED_XML = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "SFAKT"));
				DataSet = ED_XML.Document.TablInv.InfoInv;
				GenerateVTByXDTODataSet(ReturnTable, DataSet, ED, XMLObject, AdditDataTree,
					True, "Products");
			Else
				UnknownED = True;
			EndIf;
		Else
			UnknownED = True;
		EndIf;
		
		If UnknownED Then
			If Users.InfobaseUserWithFullAccess(, , False) Then
				MessageText = StringFunctionsClientServer.SubstituteParametersInString(
					NStr("en='Unknown type when reading data from the ED %1.';ru='Неизвестный тип при чтении данных из ЭД %1.'"), ED);
				CommonUseClientServer.MessageToUser(MessageText);
			EndIf;
			XMLObject.Close();
			Return;
		EndIf;
		
	Except
		If Users.InfobaseUserWithFullAccess(, , False) Then
			MessagePattern = NStr("en='An error occurred when reading data from ED %1: %2';ru='Возникла ошибка при чтении данных из ЭД %1: %2'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(
				MessagePattern, ED, ErrorDescription());
			CommonUseClientServer.MessageToUser(MessageText);
		EndIf;
	EndTry;
	
	XMLObject.Close();
	
EndProcedure

// For internal use only
Function DetermineEDTypeByOwnerEDType(LinkToED) Export
	
	VersionPointTypeED = LinkToED.VersionPointTypeED;
	If ValueIsFilled(VersionPointTypeED) Then
		If VersionPointTypeED = Enums.EDVersionElementTypes.EISDC Then
			ReturnedType = Enums.EDVersionElementTypes.NRCDDEI;
		ElsIf VersionPointTypeED = Enums.EDVersionElementTypes.EIRDC Then
			ReturnedType = Enums.EDVersionElementTypes.NRCDREI;
		ElsIf VersionPointTypeED = Enums.EDVersionElementTypes.ESF Then
			ReturnedType = Enums.EDVersionElementTypes.NAREI;
		ElsIf VersionPointTypeED = Enums.EDVersionElementTypes.SDANAREIC Then
			ReturnedType = Enums.EDVersionElementTypes.NRCDDNREI;
		ElsIf VersionPointTypeED = Enums.EDVersionElementTypes.NAEIC Then
			ReturnedType = Enums.EDVersionElementTypes.NRNCEI;
		ElsIf VersionPointTypeED = Enums.EDVersionElementTypes.PrimaryED Then
			ReturnedType = Enums.EDVersionElementTypes.RN;
		Else
			ReturnedType = Undefined;
		EndIf;
	Else
		If LinkToED.EDKind = Enums.EDKinds.NotificationAboutClarification Then
			
			ReturnedType = Enums.EDVersionElementTypes.NRNCEI;
		ElsIf LinkToED.EDKind = Enums.EDKinds.NotificationAboutReception
			OR LinkToED.EDKind = Enums.EDKinds.Confirmation Then
			
			ReturnedType = Undefined;
		Else
			ReturnedType = Enums.EDVersionElementTypes.RN;
		EndIf;
	EndIf;
	
	Return ReturnedType;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// View of electronic documents

// Creates the print form of the electronic document according to the data file.
//
// Parameters:
//  FullFileName - String, path to the file by which the printed form shall be generated.
//  EDDirection - enumeration
//  EDDirection ID - unique identifier of
//  ED object AdditDataFileName - String, path to additional data file.
//  EDKind - enumeration reference EDKinds, returns the kind of processed ED to the calling procedure.
//  DocumentID - returns the identifier if it exists
// in the electronic document Return value:
//  Tabular document with data of the electronic document.
//
Function GenerateEDPrintForm(FullFileName,
									EDDirection,
									ID = Undefined,
									SubordinatedEDFileName = Undefined,
									Val EDDescription = Undefined,
									AdditDataFileName = Undefined,
									EDKind = Undefined,
									DocumentID = Undefined) Export
	
	Result = GenerateParseTree(FullFileName, EDDirection, AdditDataFileName);
	
	If Result = Undefined Then
		Return Undefined;
	EndIf;
	
	Return EDPrintForm(Result, EDDirection, ID, SubordinatedEDFileName, EDKind, DocumentID);
	
EndFunction

// Creates the print form of the electronic document according to the data file.
//
// Parameters:
//  StructureFileParser - structure contains ED parsing tree.
//  EDDirection - enumeration
//  EDDirection ID - unique identifier of ED object
//  
//  AdditDataFileName - String, path to additional data file.
//  EDKind - enumeration reference EDKinds, returns the kind of processed ED to the calling procedure.
//
// Returns:
//  Tabular document with data of the electronic document.
//
Function EDPrintForm(StructureFileParser, EDDirection, ID = Undefined, SubordinatedEDFileName = Undefined, EDKind = Undefined, DocumentID = Undefined) Export
	
	ParseTree = StructureFileParser.ParseTree;
	ObjectString = StructureFileParser.ObjectString;
	
	EDKind = ObjectString.EDKind;
	
	CommonTabDoc = New SpreadsheetDocument;
	CommonTabDoc.PageOrientation = PageOrientation.Portrait;
	
	DocumentID = GetParsedTreeStringAttributeValue(
					ParseTree, ObjectString, "DocumentID");
	
	If ValueIsFilled(DocumentID) Then
		DocumentIdentifierTemplate = Catalogs.EDAttachedFiles.GetTemplate("ED_DocumentID");
		AreaDocumentID = DocumentIdentifierTemplate.GetArea("DocumentID");
		AreaDocumentID.Parameters.DocumentID = DocumentID;
		CellsArea = AreaDocumentID.Area();
		CellsArea.CreateFormatOfRows();
		CommonTabDoc.Put(AreaDocumentID);
	EndIf;
	
	SpreadsheetDocument = New SpreadsheetDocument;
	
	Try
		
		If ObjectString.EDKind = Enums.EDKinds.InvoiceForPayment Then
			
			EDDataToPrint = GetOrderBillDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentAccountOrder_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.TORG12
			OR ObjectString.EDKind = Enums.EDKinds.TORG12Seller Then
			
			BuyerData = New Structure;
			If ValueIsFilled(SubordinatedEDFileName) Then
				BuyerEDDirection = ?(EDDirection = Enums.EDDirections.Incoming, Enums.EDDirections.Outgoing,
					Enums.EDDirections.Incoming);
				FillBuyerData(SubordinatedEDFileName, BuyerEDDirection, BuyerData);
			EndIf;
			
			EDDataToPrint = GetConsignmentDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentTORG12_ED(SpreadsheetDocument, EDDataToPrint, BuyerData);
			SpreadsheetDocument.PageOrientation = PageOrientation.Landscape;
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.AgreementAboutCostChangeSender
			OR ObjectString.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
			
			BuyerData = New Structure;
			If ValueIsFilled(SubordinatedEDFileName) Then
				BuyerEDDirection = ?(EDDirection = Enums.EDDirections.Incoming, Enums.EDDirections.Outgoing,
					Enums.EDDirections.Incoming);
				FillBuyerData(SubordinatedEDFileName, BuyerEDDirection, BuyerData);
			EndIf;
			
			EDDataToPrint = GetCorrectingDocumentDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentCorrectionDocument_ED(SpreadsheetDocument, EDDataToPrint, BuyerData);
			SpreadsheetDocument.PageOrientation = PageOrientation.Landscape;
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ActPerformer
			OR ObjectString.EDKind = Enums.EDKinds.ActCustomer THEN
			
			ConsumerData = New Structure;
			If ValueIsFilled(SubordinatedEDFileName) Then
				BuyerEDDirection = ?(EDDirection = Enums.EDDirections.Incoming, Enums.EDDirections.Outgoing,
					Enums.EDDirections.Incoming);
				CustomerDatgaFill(SubordinatedEDFileName, BuyerEDDirection, ConsumerData);
			EndIf;
			
			EDDataToPrint = GetAct501DataToPrint(ObjectString, ParseTree);
			FillTableDocumentAct501(SpreadsheetDocument, EDDataToPrint, ConsumerData);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ResponseToOrder Then
			
			EDDataToPrint = GetOrderBillDataToPrint(ObjectString, ParseTree, "Order");
			FillInTabularDocumentAccountOrder_ED(SpreadsheetDocument, EDDataToPrint, "Order");
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ProductOrder Then
			
			EDDataToPrint = GetSupplierOrderDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentOrderToSupplier_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.PriceList Then
			
			EDDataToPrint = GetPriceListDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentPriceList_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ProductsDirectory Then
			
			EDDataToPrint = GetGoodsListDataToPrint(ObjectString, ParseTree);
			FillInProductsCatalogTabularDocument_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.RightsDelegationAct Then
			
			EDDataToPrint = GetDataAssignmentDeedForPrint(ObjectString, ParseTree);
			FillSpreadsheetDocumentDeedOfAssignment(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.AcceptanceCertificate THEN
			
			EDDataToPrint = GetAcceptanceCertificatesDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentAcceptanceCertificate_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ComissionGoodsSalesReport Then
			
			EDDataToPrint = GetReportDataAboutComissionGoodsSalesToPrint(ObjectString, ParseTree);
			FillInTabularDocumentCommissionGoodsSalesReport_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport Then
			
			EDDataToPrint = GetReportDataAboutComissionGoodsWriteOffToPrint(ObjectString, ParseTree);
			FillInTabularDocumentComissionGoodsWriteOffReport_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.Confirmation Then
			
			EDDataToPrint = GetConfirmationDataToPrint(ObjectString, ParseTree);
			FillTableDocumentConfirmation(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.NotificationAboutReception Then
			
			EDDataToPrint = GetNotificationDataToPrint(ObjectString, ParseTree);
			FillTableDocumentNumbertification(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.NotificationAboutClarification Then
			
			EDDataToPrint = GetCorrectionDataToPrint(ObjectString, ParseTree, ID);
			FillTableDocumentCorrection(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.CancellationOffer Then
			
			EDDataToPrint = GetCancellationOfferDataForPrinting(ObjectString, ParseTree, ID);
			FillInTabularDocumentCancellationOffer(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.PaymentOrder Then
			
			EDDataToPrint = DataForPrint(ObjectString);
			FillInTabularDocumentPaymentOrderOutgoing_ED(SpreadsheetDocument, EDDataToPrint, ID);
		
		ElsIf ObjectString.EDKind = Enums.EDKinds.QueryStatement Then
			
			EDDataToPrint = GetStatementInquiryDataToPrint(ObjectString, ParseTree);
			FillInTabularDocumentQueryOnStatement_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.BankStatement Then
			
			EDDataToPrint = GetStatementDataToPrint(ObjectString, ParseTree);
			FillInStatementTabularDocument_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.STATEMENT Then
			
			EDDataToPrint = GetReceiptDataForPrinting(ObjectString, ParseTree);
			FillInTabularDocumentReciept_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf Upper(ObjectString.EDKind) = Upper("CompanyAttributes") Then 
			
			EDDataToPrint = GetCompanyDetailsForPrinting(ObjectString, ParseTree);
			FillInTabularDocumentCompanyDetails_ED(SpreadsheetDocument, EDDataToPrint);
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.EDStateQuery Then
			
			EDDataToPrint = DataForPrint(ObjectString);
			FillInTabularDocument_ED(SpreadsheetDocument, EDDataToPrint, "ED_EDStateQuery");
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.QueryProbe Then
			
			EDDataToPrint = DataForPrint(ObjectString);
			FillInTabularDocument_ED(SpreadsheetDocument, EDDataToPrint, "ED_QueryProbe");
			
		ElsIf ObjectString.EDKind = Enums.EDKinds.NotificationOnStatusOfED Then
			
			EDDataToPrint = DataForPrint(ObjectString);
			FillInTabularDocumentNumbertificationOnState_ED(SpreadsheetDocument, EDDataToPrint);
			
		EndIf;
		
		CellsArea = SpreadsheetDocument.Area(1, 1, 1);
		CellsArea.CreateFormatOfRows();
		CommonTabDoc.Put(SpreadsheetDocument);
		
		CommonTabDoc.PageOrientation = SpreadsheetDocument.PageOrientation;
		CommonTabDoc.FitToPage = True;
		CommonTabDoc.ShowHeaders = False;
		CommonTabDoc.ShowGrid = False;
		CommonTabDoc.ReadOnly = True;
		
		Return CommonTabDoc;
	Except
		MessagePattern = NStr("en='Generation of tabular
		|document failed: %1 (see details in Event log monitor).';ru='Ошибка
		|формирования табличного документа: %1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
													NStr("en='tabular document generation';ru='формирования табличного документа'"),
													DetailErrorDescription(ErrorInfo()),
													MessageText);
		
		Return Undefined;
		
	EndTry;
	
EndFunction

// Receives the value of electronic document header attribute by its name from the string of parsed data.
//
// Parameters:
//  TreeRow - String of values tree, parameters of
//  electronic document parsing, AttributeName - String, attribute name which value
//  shall be received, ParsingTree - values tree - complete structure with electronic document parsing data.
//
// Returns:
//  Value of the attribute of electronic document header.
//
Function GetEDHeaderAttribute(TreeRow, AttributeName, ParseTree = Undefined) Export
	
	Result = Undefined;
	
	If TreeRow.Rows.Count() > 0 Then
		FoundString = TreeRow.Rows.Find(AttributeName, "Attribute");
	Else
		FoundString = TreeRow;
	EndIf;
	
	If FoundString <> Undefined Then
		If ValueIsFilled(FoundString.ObjectReference) Then // return reference
			Result = FoundString.ObjectReference;
		Else
			Result = FoundString.AttributeValue;
			// If the attribute is of reference
			// type (passed attribute ParsingTree), then just a string index was found.
			If ValueIsFilled(ParseTree) Then
				FoundString = ParseTree.Rows.Find(Result, "RowIndex", True);
				If FoundString <> Undefined Then
					Result = FoundString.ObjectReference;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
	Return Result;
	
EndFunction

// Checks if the pass table
// documents fit in the printing page.
//
// Parameters
//  TabDocument        - Tabular
//  document DisplayedAreas - Array of checked tables or
//  tabular document ResultOnError - Which result to return if an error occurs
//
// Returns:
//  Boolean - whether the sent documents fit in or not
//
Function SpreadsheetDocumentFitsPage(Spreadsheet, AreasToPut, ResultOnError = True)

	Try
		Return Spreadsheet.CheckPut(AreasToPut);
	Except
		Return ResultOnError;
	EndTry;

EndFunction

////////////////////////////////////////////////////////////////////////////////
// Value mapping

//Collects from the items of address structure the address record string in the format of 8 commas
Function PrepareAdress(Val AddresStructure)
	
	Return "" + AddresStructure.IndexOf + ","+ AddresStructure.CodeState + ","
	+ AddresStructure.District  + "," + AddresStructure.City  + ","+ AddresStructure.Settlement + ","
	+ AddresStructure.Street  + "," + AddresStructure.Building    + ","+ AddresStructure.Section + "," + AddresStructure.Qart
	
EndFunction

//Function parses the string with data about the address (in the format of 8 commas) to structure elements
Function SplitAddres(Val AddresString) Export
	
	IndexOf = "";
	CodeState = "";
	District = "";
	City = "";
	Settlement = "";
	Street = "";
	Building = "";
	Section = "";
	Qart = "";

	AddressArray = StringFunctionsClientServer.DecomposeStringIntoSubstringsArray(AddresString);
	NumberOfItemsInArray = AddressArray.Count();

	If NumberOfItemsInArray > 0 Then
		IndexOf = TrimAll(AddressArray[0]);
	EndIf;
	If NumberOfItemsInArray > 1 Then
		CodeState = TrimAll(AddressArray[1]);
	EndIf;
	If NumberOfItemsInArray > 2 Then
		District = TrimAll(AddressArray[2]);
	EndIf;
	If NumberOfItemsInArray > 3 Then
		City = TrimAll(AddressArray[3]);
	EndIf;
	If NumberOfItemsInArray > 4 Then
		Settlement = TrimAll(AddressArray[4]);
	EndIf;
	If NumberOfItemsInArray > 5 Then
		Street = TrimAll(AddressArray[5]);
	EndIf;
	If NumberOfItemsInArray > 6 Then
		Building = TrimAll(AddressArray[6]);
	EndIf;
	If NumberOfItemsInArray > 7 Then
		Section = TrimAll(AddressArray[7]);
	EndIf;
	If NumberOfItemsInArray > 8 Then
		Qart = TrimAll(AddressArray[8]);
	EndIf;

	ReturnStructure = New Structure;
	ReturnStructure.Insert("IndexOf", IndexOf);
	ReturnStructure.Insert("CodeState", CodeState);
	ReturnStructure.Insert("District", District);
	ReturnStructure.Insert("City", City);
	ReturnStructure.Insert("Settlement", Settlement);
	ReturnStructure.Insert("Street", Street);
	ReturnStructure.Insert("Building", Building);
	ReturnStructure.Insert("Section", Section);
	ReturnStructure.Insert("Qart", Qart);
	
	Return ReturnStructure;
	
EndFunction

//Function parses a string to the array items
Function SubstringArray(Val String, Delimiter) Export
	
	Result = New Array;
	If IsBlankString(String) Then
		Return Result;
	EndIf;
	
	FirstItemBegPosition = Find(String, "{");
	FirstItemEndPosition = Find(String, "}");
	If FirstItemBegPosition > 0 AND FirstItemEndPosition > 0 Then
		FirstItem = Mid(String, FirstItemBegPosition, FirstItemEndPosition);
		Result.Add(TrimAll(FirstItem));
		String = TrimAll(Mid(String,FirstItemEndPosition + 2));
	EndIf;
	
	While True Do
		Position = Find(String,Delimiter);
		If Position = 0 Then
			Break;
		EndIf;
		
		Result.Add(TrimAll(Left(String,Position - 1)));
		String = TrimAll(Mid(String,Position + 1));
	EndDo;
	
	Result.Add(TrimAll(String));
	
	Return Result;
	
EndFunction 

////////////////////////////////////////////////////////////////////////////////
// Sberbank

// Searches and returns first ED that has a specific EDKind
// and subordinate to ED If not found - empty reference is returned
//
// ED
//  Parameters - CatalogRef.EDAttachedFiles - owner of required
//  electronic document EDKind - Enums.EDKinds - kind of required electronic document
//
// Returns:
// CatalogRef.EDAttachedFiles
//
Function SubordinateDocument(ED, EDKind) Export
	
	Query = New Query;
	Query.Text = "SELECT TOP 1
	               |	EDAttachedFiles.Ref
	               |FROM
	               |	Catalog.EDAttachedFiles AS EDAttachedFiles
	               |WHERE
	               |	EDAttachedFiles.ElectronicDocumentOwner = &Ref
	               |	AND EDAttachedFiles.EDKind = &EDKind";
	Query.SetParameter("Ref", ED);
	Query.SetParameter("EDKind",  EDKind);
	Selection = Query.Execute().Select();
	If Selection.Next() Then
		Return Selection.Ref;
	EndIf;
	Return Catalogs.EDAttachedFiles.EmptyRef();
	
EndFunction

// Prepares a query string for receipt of bank statement
//
// Parameters
//  <EDAgreement>  - <CatalogRef.AgreementAboutEDUsage> - according to which agreement the exchange
//  with bank is executed <BeginningDate>  - <Date> - date of period start
//  for statement query <BeginningDate>  - <Date> - Period end date of
//  statement query <QueryIdentifier> - <UUID> - query
//  identifier <QueryFile> - <String> - file for saving
//  of generated query <ErrorOccurred> - <Boolean> - Generating query failed
//
Procedure SetSubscriptionQuery(EDAgreement,
									StartDate,
									EndDate,
									IDRequest,
									QueryFile,
									IsError) Export

	TargetNamespace = "http://www.bssys.com/en/";
	
	ErrorText = "";
	IsError  = False;
	
	IDRequest = String(New UUID);
	
	Try
		Company = CommonUse.GetAttributeValue(EDAgreement, "Company");
		Bank        = CommonUse.GetAttributeValue(EDAgreement, "Counterparty");
		AccountsArray = New Array;
		ElectronicDocumentsOverridable.GetBankAccountNumbers(Company, Bank, AccountsArray);
		
		If AccountsArray.Count()=0 Then
			ErrorText = NStr("en='To generate the extract request it is necessary to add a company banking account';ru='Для формирования запроса выписки необходимо добавить банковский счет организации'");
			CommonUseClientServer.MessageToUser(ErrorText);
			IsError = True;
			Return;
		EndIf;
		
		StmtReqType = GetCMLObjectType("StmtReqType", TargetNamespace);
		FillXDTOProperty(StmtReqType, "docExtId",   String(IDRequest), True, ErrorText);
		FillXDTOProperty(StmtReqType, "createTime", CurrentSessionDate(),          True, ErrorText);
		FillXDTOProperty(StmtReqType, "beginDate",  StartDate,                   True, ErrorText);
		FillXDTOProperty(StmtReqType, "endDate",    EndOfDay(EndDate),      True, ErrorText);
		FillXDTOProperty(StmtReqType, "stmtType",   101,                          True, ErrorText);
		
		AttributeCutCompaniesName = ElectronicDocumentsReUse.NameAttributeObjectExistanceInAppliedSolution(
																					"ShortDescriptionOfTheCompany");
		If Not ValueIsFilled(AttributeCutCompaniesName) Then
			AttributeCutCompaniesName = "Description";
		EndIf;
		Description = CommonUse.GetAttributeValue(Company, AttributeCutCompaniesName);
		FillXDTOProperty(StmtReqType, "orgName", Description, , ErrorText);
		
		Accounts = GetCMLObjectType("StmtReqType.Accounts", TargetNamespace);
		
		BIN = CommonUse.GetAttributeValue(Bank, "Code");
		For Each Account in AccountsArray Do
			Acc = GetCMLObjectType("Acc",TargetNamespace);
			FillXDTOProperty(Acc, "__content", Account, True, ErrorText);
			FillXDTOProperty(Acc, "bic",       BIN,  True, ErrorText);
			Accounts.Account.Add(Acc);
		EndDo;
		
		FillXDTOProperty(StmtReqType, "Accounts", Accounts, True, ErrorText);
		
		StmtReqType.Validate();
		
		If ValueIsFilled(ErrorText) Then
			Raise NStr("en='Statement request generation error';ru='Ошибка формирования запроса выписки'");
		EndIf;
		
		ExportEDtoFile(StmtReqType, QueryFile, , "UTF-8");

	Except
		
		MessagePattern = NStr("en='%1. (see details in Event log monitor).';ru='%1. (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(
															MessagePattern,
															BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()), MessageText, 1);
		IsError = True;
		
	EndTry;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROCEDURES AND FUNCTIONS

////////////////////////////////////////////////////////////////////////////////
// Generation of ED FTS from DB documents

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateCorrectionInvoiceFTSCML(DataTree)
	
	ErrorText = "";
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	TargetNamespaceSchema = "KORSFAKT";
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree,"FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree, "IdFile"),  True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"), , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree, "VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		IdSen = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", IdSen, True, ErrorText);
		IdCust = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", IdCust, True, ErrorText);
		
		PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
		DescEnt = TreeAttributeValue(DataTree, "EDFOperatorAttributes.CompName");
		FillXDTOProperty(PrSEDSend, "DescEnt", DescEnt, True, ErrorText);
		TINLP = TreeAttributeValue(DataTree, "EDFOperatorAttributes.TINLP");
		FillXDTOProperty(PrSEDSend, "TINLP", TINLP, True, ErrorText);
		IdEDF = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
		FillXDTOProperty(PrSEDSend, "IdEDF", IdEDF, True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree, "CTD"), True, ErrorText);
		
		PrInvoice = GetCMLObjectType("File.Document.PrCInv", TargetNamespaceSchema);
		DocNo = TreeAttributeValue(DataTree, "BalancedAccountInvoiceNoteNumber");
		DocDate = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "BalancedAccountInvoiceNoteDate"));
		FillXDTOProperty(PrInvoice, "NumberCInv", DocNo, True, ErrorText);
		FillXDTOProperty(PrInvoice, "DateCInv", DocDate, True, ErrorText);
		DocNo = TreeAttributeValue(DataTree, "InvoiceNumber");
		DocDate = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "InvoiceDate"));
		FillXDTOProperty(PrInvoice, "InvNumber", DocNo, True, ErrorText);
		FillXDTOProperty(PrInvoice, "DateInv", DocDate, True, ErrorText);
		FillXDTOProperty(PrInvoice, "CodeRCC", TreeAttributeValue(DataTree, "CurrencyCode"), True, ErrorText);
		
		DocNo = TreeAttributeValue(DataTree, "BalancedAccountInvoiceNoteCorrectionNumber");
		DocDate = TreeAttributeValue(DataTree, "BalancedAccountInvoiceNoteCorrectionDate");
		If ValueIsFilled(DocNo) AND ValueIsFilled(DocDate) Then
			DocDate = DateDD_MM_YYYY(DocDate);
			CorInv = GetCMLObjectType("File.Document.PrCInv.CorCInv", TargetNamespaceSchema);
			FillXDTOProperty(CorInv, "NumCorToInv", DocNo, True, ErrorText);
			FillXDTOProperty(CorInv, "DateCorCInv", DocDate, True, ErrorText);
			FillXDTOProperty(PrInvoice,"CorCInv", CorInv,,ErrorText);
		EndIf;
		
		DocNo = TreeAttributeValue(DataTree, "CorrectionNumber");
		DocDate = TreeAttributeValue(DataTree, "DateOfCorrection");
		If ValueIsFilled(DocNo) AND ValueIsFilled(DocDate) Then
			DocDate = DateDD_MM_YYYY(DocDate);
			CorInv = GetCMLObjectType("File.Document.PrCInv.CorInv", TargetNamespaceSchema);
			FillXDTOProperty(CorInv, "NumCorInv", DocNo, True, ErrorText);
			FillXDTOProperty(CorInv, "DateCorInv", DocDate, True, ErrorText);
			FillXDTOProperty(PrInvoice,"CorInv", CorInv,,ErrorText);
		EndIf;
		
		PrSale = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillInBuyerSellerDataFTSForIR(PrSale, DataTree, ErrorText, TargetNamespaceSchema, "Seller") Then
			FillXDTOProperty(PrInvoice, "PrSale", PrSale, True, ErrorText);
		EndIf;
		
		PrCustomer = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillInBuyerSellerDataFTSForIR(PrCustomer, DataTree, ErrorText, TargetNamespaceSchema, "Customer") Then
			FillXDTOProperty(PrInvoice, "PrCustomer", PrCustomer, True, ErrorText);
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "Agent.ParticipantType")) Then
			PutComissionAgentDataToAdditionalData(DataTree, TargetNamespaceSchema, ErrorText);
		EndIf;
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrInvoice, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrCInv.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrCInv", PrInvoice, True, ErrorText);
		TablInv = GetCMLObjectType("File.Document.TablCInv", TargetNamespaceSchema);
		
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");
		AmountWithoutVATDifference = 0;
		VATAmountDifference = 0;
		AmountWithVATDifference = 0;
		AllRowsWithoutVAT = True;
		For Each Product IN StringProductsTable.Rows Do
			InfoInv = GetCMLObjectType("File.Document.TablCInv.InfoInv", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "NumRow", Product.Value, True, ErrorText);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServicesDescription");
			FillXDTOProperty(InfoInv, "DescProd", Attribute, True, ErrorText);
			
			MeasurementUnitCodeBefore = TreeAttributeValue(Product, "ProductsTable.LineNumber.MeasurementUnitCodeBefore");
			If StrLen(MeasurementUnitCodeBefore) = 3 Then
				FillXDTOProperty(InfoInv, "OKEI_GoodsBefore", MeasurementUnitCodeBefore, , ErrorText);
			Else
				PlaceInAddData("CodeOKEIBefore", MeasurementUnitCodeBefore, Product, "ProductsTable.LineNumber");
			EndIf;
			
			MeasurementUnitCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.MeasurementUnitCode");
			If StrLen(MeasurementUnitCode) = 3 Then
				FillXDTOProperty(InfoInv, "OKEI_ProdAfter", MeasurementUnitCode, , ErrorText);
			Else
				PlaceInAddData("CodeOKEIAfter", MeasurementUnitCode, Product, "ProductsTable.LineNumber");
			EndIf;
			
			QuantityBefore = TreeAttributeValue(Product, "ProductsTable.LineNumber.QuantityBefore");
			FillXDTOProperty(InfoInv, "QuantItBefore", QuantityBefore, , ErrorText);
			
			Quantity = TreeAttributeValue(Product, "ProductsTable.LineNumber.Quantity");
			FillXDTOProperty(InfoInv, "NumItAfter", Quantity, , ErrorText);
			
			PriceBefore = TreeAttributeValue(Product, "ProductsTable.LineNumber.PriceBefore");
			FillXDTOProperty(InfoInv, "PriceTovBef", PriceBefore, , ErrorText);
			
			Price = TreeAttributeValue(Product, "ProductsTable.LineNumber.Price");
			FillXDTOProperty(InfoInv, "PriceTovAfter", Price, , ErrorText);
			
			// Cost without VAT
			AmountBefore = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountNoVATBefore");
			AmountAfter = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountWithoutVAT");
			If ValueIsFilled(AmountBefore) AND ValueIsFilled(AmountAfter) Then
				StGoodsWithoutVAT = GetCMLObjectType("PricType", TargetNamespaceSchema);
				FillXDTOProperty(StGoodsWithoutVAT, "PricBeforeChan", AmountBefore, True, ErrorText);
				FillXDTOProperty(StGoodsWithoutVAT, "PricAfterChan", AmountAfter, True, ErrorText);
				AmountWithoutVATDifference = AmountWithoutVATDifference + AmountBefore - AmountAfter;
				If AmountBefore < AmountAfter Then
					FillXDTOProperty(StGoodsWithoutVAT, "PricIncr", AmountAfter - AmountBefore, , ErrorText);
				ElsIf AmountBefore > AmountAfter Then
					FillXDTOProperty(StGoodsWithoutVAT, "PricDecr", AmountBefore - AmountAfter, , ErrorText);
				EndIf;
				FillXDTOProperty(InfoInv, "StGoodsWithoutVAT", StGoodsWithoutVAT, , ErrorText);
			EndIf;
			
			// excise
			Excise = GetCMLObjectType("AmountExciseType", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.ExciseUntil");
			If Not ValueIsFilled(Attribute) OR Find(Attribute, "no excise") > 0 Then
				ExciseTaxValue = "no excise";
				AmountBefore = 0;
			Else
				If TypeOf(Attribute) = Type("Number") Then
					ExciseTaxValue = Format(Attribute, "NFD=2; NDS=.; NG=");
					AmountBefore = Attribute;
				Else
					ExciseTaxValue = TrimAll(Attribute);
					AmountBefore = Number(Attribute);
				EndIf;
			EndIf;
			FillXDTOProperty(Excise, "AmountExcise", ExciseTaxValue, True, ErrorText);
			FillXDTOProperty(InfoInv, "ExciseTo", Excise, True, ErrorText);
			
			Excise = GetCMLObjectType("AmountExciseType", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.Excise");
			If Not ValueIsFilled(Attribute) OR Find(Attribute, "no excise") > 0 Then
				ExciseTaxValue = "no excise";
				AmountAfter = 0;
			Else
				If TypeOf(Attribute) = Type("Number") Then
					ExciseTaxValue = Format(Attribute, "NFD=2; NDS=.; NG=");
					AmountAfter = Attribute;
				Else
					ExciseTaxValue = TrimAll(Attribute);
					AmountAfter = Number(Attribute);
				EndIf;
			EndIf;
			FillXDTOProperty(Excise, "AmountExcise", ExciseTaxValue, True, ErrorText);
			FillXDTOProperty(InfoInv, "ExciseAfter", Excise, True, ErrorText);
			
			ExciseDiff = GetCMLObjectType("File.Document.TablCInv.InfoInv.ExciseDiff", TargetNamespaceSchema);
			If AmountBefore <= AmountAfter Then
				FillXDTOProperty(ExciseDiff, "AmountIncr", AmountAfter - AmountBefore, True, ErrorText);
			ElsIf AmountBefore > AmountAfter Then
				FillXDTOProperty(ExciseDiff, "AmountMult", AmountBefore - AmountAfter, True, ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "ExciseDiff", ExciseDiff, True, ErrorText);
			
			// VAT rate
			TaxVal = GetCMLObjectType("File.Document.TablCInv.InfoInv.TaxValBefore", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATRateBefore");
			VATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence( , Attribute);
			FillXDTOProperty(TaxVal, "TaxValMag", VATRate, True, ErrorText);
			FillXDTOProperty(TaxVal, "TaxValType", VATRateType(VATRate), True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxValBefore", TaxVal, True, ErrorText);
			
			TaxVal = GetCMLObjectType("File.Document.TablCInv.InfoInv.TaxValAfter", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATRate");
			VATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence( , Attribute);
			FillXDTOProperty(TaxVal, "TaxValMag", VATRate, True, ErrorText);
			FillXDTOProperty(TaxVal, "TaxValType", VATRateType(VATRate), True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxValAfter", TaxVal, True, ErrorText);
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmountBefore");
			StrVATAmountbefore = TrimAll(Attribute);
			If Upper(StrVATAmountbefore) = Upper("Without VAT") OR StrVATAmountbefore = "-" Then
				VATAmount = StrVATAmountbefore;
				AmountBefore = 0;
			Else
				If Attribute = 0 Then
					VATAmount = "-";
					AmountBefore = 0;
				Else
					VATAmount = Format(Attribute, "NFD=2; NDS=.; NG=");
					AmountBefore = Number(Attribute);
				EndIf;
			EndIf;
			FillXDTOProperty(AmountVATType, "AmountVAT", VATAmount, True, ErrorText);
			FillXDTOProperty(InfoInv, "AmountCasBefore", AmountVATType, True, ErrorText);
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmount");
			StrVATAmount = TrimAll(Attribute);
			If Upper(StrVATAmount) = Upper("Without VAT") OR StrVATAmount = "-" Then
				VATAmount = StrVATAmount;
				AmountAfter = 0;
			Else
				If Attribute = 0 Then
					VATAmount = "-";
					AmountAfter = 0;
				Else
					VATAmount = Format(Attribute, "NFD=2; NDS=.; NG=");
					AmountAfter = Number(Attribute);
				EndIf;
			EndIf;
			FillXDTOProperty(AmountVATType, "AmountVAT", VATAmount, True, ErrorText);
			FillXDTOProperty(InfoInv, "AmountCasAfter", AmountVATType, True, ErrorText);
			If AllRowsWithoutVAT AND (Upper(StrVATAmountbefore) <> Upper("Without VAT") OR Upper(StrVATAmount) <> Upper("Without VAT")) Then
				AllRowsWithoutVAT = False;
			EndIf;
			
			AmountCasDiff = GetCMLObjectType("File.Document.TablCInv.InfoInv.AmountCasDiff", TargetNamespaceSchema);
			VATAmountDifference = VATAmountDifference + AmountBefore - AmountAfter;
			If AmountBefore <= AmountAfter Then
				FillXDTOProperty(AmountCasDiff, "AmountIncr", AmountAfter - AmountBefore, True, ErrorText);
			ElsIf AmountBefore > AmountAfter Then
				FillXDTOProperty(AmountCasDiff, "AmountMult", AmountBefore - AmountAfter, True, ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "AmountCasDiff", AmountCasDiff, True, ErrorText);
			
			// Cost with VAT
			StGoodAcTax = GetCMLObjectType("PricType", TargetNamespaceSchema);
			AmountBefore = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmountBefore");
			FillXDTOProperty(StGoodAcTax, "PricBeforeChan", AmountBefore, True, ErrorText);
			AmountAfter = TreeAttributeValue(Product, "ProductsTable.LineNumber.SumWithVAT");
			FillXDTOProperty(StGoodAcTax, "PricAfterChan", AmountAfter, True, ErrorText);
			AmountWithVATDifference = AmountWithVATDifference + AmountBefore - AmountAfter;
			If AmountBefore <= AmountAfter Then
				FillXDTOProperty(StGoodAcTax, "PricIncr", AmountAfter - AmountBefore, True, ErrorText);
			ElsIf AmountBefore > AmountAfter Then
				FillXDTOProperty(StGoodAcTax, "PricDecr", AmountBefore - AmountAfter, True, ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "StGoodAcTax", StGoodAcTax, True, ErrorText);
			
			FillAdditionalInformationFromTreeData(
									InfoInv,
									Product,
									"ProductsTable.LineNumber",
									ParametersStructure,
									TargetNamespaceSchema,
									"File.Document.TablCInv.InfoInv",
									"InfFullStr",
									"Products",
									String(Product.Value),
									ErrorText);
						
			TablInv.InfoInv.Add(InfoInv);
		EndDo;
		
		// Total increase
		TotalIncrease = GetCMLObjectType("File.Document.TablCInv.TotalIncr", TargetNamespaceSchema);
		TotalReduction = GetCMLObjectType("File.Document.TablCInv.TotalDecr", TargetNamespaceSchema);
		IncreaseIsFilled = False;
		DecreaseIsFilledIn = False;
		If AmountWithoutVATDifference < 0 Then
			FillXDTOProperty(TotalIncrease, "StGoodsWithoutVATTotal", -AmountWithoutVATDifference, , ErrorText);
		Else
			FillXDTOProperty(TotalReduction, "StGoodsWithoutVATTotal", AmountWithoutVATDifference, , ErrorText);
		EndIf;
		If AmountWithVATDifference < 0 Then
			FillXDTOProperty(TotalIncrease, "StGoodsAcTaxTotal", -AmountWithVATDifference, True, ErrorText);
			IncreaseIsFilled = True;
		Else
			FillXDTOProperty(TotalReduction, "StGoodsAcTaxTotal", AmountWithVATDifference, True, ErrorText);
			DecreaseIsFilledIn = True;
		EndIf;
		AmountCasTotal = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
		AbsVATAmount = ?(VATAmountDifference < 0, -VATAmountDifference, VATAmountDifference);
		AbsVATAmount = ?(AllRowsWithoutVAT, "Without VAT",
			?(AbsVATAmount = 0, "-", Format(AbsVATAmount, "NFD=2; NDS=.; NG=")));
		If IncreaseIsFilled Then
			FillXDTOProperty(AmountCasTotal, "AmountVAT", AbsVATAmount, True, ErrorText);
			FillXDTOProperty(TotalIncrease, "AmountCas", AmountCasTotal, True, ErrorText);
		Else
			IncreaseIsFilled = False;
			FillXDTOProperty(AmountCasTotal, "AmountVAT", AbsVATAmount, True, ErrorText);
			FillXDTOProperty(TotalReduction, "AmountCas", AmountCasTotal, True, ErrorText);
		EndIf;
		If IncreaseIsFilled Then
			FillXDTOProperty(TablInv, "TotalIncr", TotalIncrease, , ErrorText);
		ElsIf DecreaseIsFilledIn Then
			FillXDTOProperty(TablInv, "TotalDecr", TotalReduction, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "TablCInv", TablInv, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		File.Validate();
		
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
		DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1. (see details in Event log monitor).';ru='%1. (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateInvoiceFTSCML(DataTree)
	
	ErrorText = "";
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	TargetNamespaceSchema = "SFAKT";
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree,"FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree, "IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"),       , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree, "VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		IdSen = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", IdSen, True, ErrorText);
		IdCust = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", IdCust, True, ErrorText);
		
		PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
		DescEnt = TreeAttributeValue(DataTree, "EDFOperatorAttributes.CompName");
		FillXDTOProperty(PrSEDSend, "DescEnt", DescEnt, True, ErrorText);
		TINLP = TreeAttributeValue(DataTree, "EDFOperatorAttributes.TINLP");
		FillXDTOProperty(PrSEDSend, "TINLP", TINLP, True, ErrorText);
		IdEDF = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
		FillXDTOProperty(PrSEDSend, "IdEDF", IdEDF, True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree, "CTD"), True, ErrorText);
		
		PrInvoice = GetCMLObjectType("File.Document.PrInvoice", TargetNamespaceSchema);
		DocNo = TreeAttributeValue(DataTree, "InvoiceNumber");
		DocDate = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "InvoiceDate"));
		FillXDTOProperty(PrInvoice, "InvNumber", DocNo, True, ErrorText);
		FillXDTOProperty(PrInvoice, "DateInv", DocDate, True, ErrorText);
		FillXDTOProperty(PrInvoice, "CodeRCC", TreeAttributeValue(DataTree, "CurrencyCode"), True, ErrorText);
		
		DocNo = TreeAttributeValue(DataTree, "CorrectionNumber");
		DocDate = TreeAttributeValue(DataTree, "DateOfCorrection");
		If ValueIsFilled(DocNo) AND ValueIsFilled(DocDate) Then
			DocDate = DateDD_MM_YYYY(DocDate);
			CorInv = GetCMLObjectType("File.Document.PrInvoice.CorInv", TargetNamespaceSchema);
			FillXDTOProperty(CorInv, "NumCorInv", DocNo, True, ErrorText);
			FillXDTOProperty(CorInv, "DateCorInv", DocDate, True, ErrorText);
			FillXDTOProperty(PrInvoice,"CorInv", CorInv,,ErrorText);
		EndIf;
		
		PrSale = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillInBuyerSellerDataFTSForIR(PrSale, DataTree, ErrorText, TargetNamespaceSchema, "Seller") Then
			FillXDTOProperty(PrInvoice, "PrSale", PrSale, True, ErrorText);
		EndIf;
		
		SenderInf = TreeAttributeValue(DataTree, "InfoAboutShipper");
		If TreeAttributeValue(DataTree, "JustServices") <> True AND ValueIsFilled(SenderInf) Then
			CargoFrom = GetCMLObjectType("File.Document.PrInvoice.CargoFrom", TargetNamespaceSchema);
			If SenderInf = "Same" Then
				FillXDTOProperty(CargoFrom, "Same", "the same", True, ErrorText);
				FillXDTOProperty(PrInvoice, "CargoFrom", CargoFrom, True, ErrorText);
			Else
				Consignor = TreeAttributeValue(DataTree, "InformationAboutConsignor.Consignor");
				PrCargoRec = GetCMLObjectType("PrCargoSendRecType", TargetNamespaceSchema);
				If Consignor = True
					AND FillInConsignorConsigneeDataFTSForIR(PrCargoRec,
						DataTree, ErrorText, TargetNamespaceSchema, "InformationAboutConsignor.Consignor") Then
					FillXDTOProperty(CargoFrom, "CargoShpd", PrCargoRec, True, ErrorText);
					FillXDTOProperty(PrInvoice, "CargoFrom", CargoFrom, True, ErrorText);
				EndIf;
			EndIf;
		EndIf;
		
		Consignee = TreeAttributeValue(DataTree, "Consignee");
		PrCargoRec = GetCMLObjectType("PrCargoSendRecType", TargetNamespaceSchema);
		If TreeAttributeValue(DataTree, "JustServices") <> True AND Consignee = True
			AND FillInConsignorConsigneeDataFTSForIR(PrCargoRec,
				DataTree, ErrorText, TargetNamespaceSchema, "Consignee") Then
			FillXDTOProperty(PrInvoice, "CargoRece", PrCargoRec, True, ErrorText);
		EndIf;
		
		TableRow = DataTree.Rows.Find("PaymentAndSettlementDocuments", "FullPath");
		If TypeOf(TableRow.Value) = Type("Number") AND TableRow.Value > 0 Then
			For Each PRD IN TableRow.Rows Do
				PrIND = GetCMLObjectType("File.Document.PrInvoice.PrIND", TargetNamespaceSchema);
				
				Attribute = TreeAttributeValue(PRD, "PaymentAndSettlementDocuments.LineNumber.NumberPRD");
				FillXDTOProperty(PrIND, "NumberPRD", Attribute, True, ErrorText);
				Attribute = DateDD_MM_YYYY(TreeAttributeValue(PRD, "PaymentAndSettlementDocuments.LineNumber.DatePRD"));
				FillXDTOProperty(PrIND, "DatePRD", Attribute, True, ErrorText);
				PrInvoice.PrIND.Add(PrIND);
			EndDo;
		EndIf;
		
		PrCustomer = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillInBuyerSellerDataFTSForIR(PrCustomer, DataTree, ErrorText, TargetNamespaceSchema, "Customer") Then
			FillXDTOProperty(PrInvoice, "PrCustomer", PrCustomer, True, ErrorText);
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "Agent.ParticipantType")) Then
			PutComissionAgentDataToAdditionalData(DataTree, TargetNamespaceSchema, ErrorText);
		EndIf;
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrInvoice, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrInvoice.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrInvoice", PrInvoice, True, ErrorText);
		TablInv = GetCMLObjectType("File.Document.TablInv", TargetNamespaceSchema);
		
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");

		For Each Product IN StringProductsTable.Rows Do
			InfoInv = GetCMLObjectType("File.Document.TablInv.InfoInv", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "NumRow", Product.Value, True, ErrorText);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServicesDescription");
			FillXDTOProperty(InfoInv, "DescProd", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.SumWithVAT");
			FillXDTOProperty(InfoInv, "StGoodAcTax", Attribute, True, ErrorText);
			
			Excise = GetCMLObjectType("File.Document.TablInv.InfoInv.Excise", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.Excise");
			If Not ValueIsFilled(Attribute) Then
				ExciseTaxValue = "no excise";
			Else
				If TypeOf(Attribute) = Type("Number") Then
					ExciseTaxValue = Format(Attribute, "NFD=2; NDS=.; NG=");
				Else
					ExciseTaxValue = TrimAll(Attribute);
				EndIf;
			EndIf;
			FillXDTOProperty(Excise, "AmountExcise", ExciseTaxValue, True, ErrorText);
			FillXDTOProperty(InfoInv, "Excise", Excise, True, ErrorText);
			
			TaxVal = GetCMLObjectType("File.Document.TablInv.InfoInv.TaxVal", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATRate");
			VATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence( , Attribute);
			FillXDTOProperty(TaxVal, "TaxValMag", VATRate, True, ErrorText);
			FillXDTOProperty(TaxVal, "TaxValType", VATRateType(VATRate), True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxVal", TaxVal, True, ErrorText);
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmount");
			StrAttribute = TrimAll(Attribute);
			If Upper(StrAttribute) = Upper("Without VAT") OR StrAttribute = "-" Then
				VATAmount = StrAttribute;
			Else
				If Attribute = 0 Then
					VATAmount = "-";
				Else
					VATAmount = Format(Attribute, "NFD=2; NDS=.; NG=");
				EndIf;
			EndIf;
			FillXDTOProperty(AmountVATType, "AmountVAT", VATAmount, True, ErrorText);
			FillXDTOProperty(InfoInv, "AmountCas", AmountVATType, True, ErrorText);
			
			// optional details:
			MeasurementUnitCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.MeasurementUnitCode");
			If StrLen(MeasurementUnitCode) = 3 Then
				FillXDTOProperty(InfoInv, "OKEI_Tov", MeasurementUnitCode, , ErrorText);
			Else
				PlaceInAddData("CodeOKEI", MeasurementUnitCode, Product, "ProductsTable.LineNumber");
			EndIf;
			
			Quantity = TreeAttributeValue(Product, "ProductsTable.LineNumber.Quantity");
			FillXDTOProperty(InfoInv, "QuantIt", Quantity, , ErrorText);
			
			Price = TreeAttributeValue(Product, "ProductsTable.LineNumber.Price");
			FillXDTOProperty(InfoInv, "PriceTov", Price, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountWithoutVAT");
			FillXDTOProperty(InfoInv, "StGoodsWithoutVAT", AmountWithoutVAT, , ErrorText);
			
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.CountryOfOriginCode");
			If TypeOf(Attribute) = Type("Array") Then
				For Each CountryCode IN Attribute Do
					InfoInv.CodeOrig.Add(CountryCode);
				EndDo;
			ElsIf TypeOf(Attribute) = Type("String") AND ValueIsFilled(Attribute) Then
				InfoInv.CodeOrig.Add(Attribute);
			EndIf;
			
			Attribute = TreeAttributeValue(Product, "ProductsTable.LineNumber.CustomsDeclarationNumber");
			If TypeOf(Attribute) = Type("Array") Then
				For Each TD IN Attribute Do
					InfoInv.TDNumber.Add(TD);
				EndDo;
			ElsIf TypeOf(Attribute) = Type("String") AND ValueIsFilled(Attribute) Then
				InfoInv.TDNumber.Add(Attribute);
			EndIf;
			
			FillAdditionalInformationFromTreeData(
									InfoInv,
									Product,
									"ProductsTable.LineNumber",
									ParametersStructure,
									TargetNamespaceSchema,
									"File.Document.TablInv.InfoInv",
									"InfFullStr",
									"Products",
									String(Product.Value),
									ErrorText);
			
			TablInv.InfoInv.Add(InfoInv);
		EndDo;
		
		TotalPai = GetCMLObjectType("File.Document.TablInv.TotalPai", TargetNamespaceSchema);
		Attribute = TreeAttributeValue(DataTree, "TotalDue.AmountWithVATTotal");
		FillXDTOProperty(TotalPai, "StGoodsAcTaxTotal", Attribute, True, ErrorText);
		SumWithoutVATTotal = TreeAttributeValue(DataTree, "TotalDue.AmountWithoutVATTotal");
		FillXDTOProperty(TotalPai, "StGoodsWithoutVATTotal", SumWithoutVATTotal, , ErrorText);
		
		AmountCasTotal = GetCMLObjectType("File.Document.TablInv.TotalPai.AmountCasTotal", TargetNamespaceSchema);
		Attribute = TreeAttributeValue(DataTree, "TotalDue.AmountVATTotal");
		StrAttribute = TrimAll(Attribute);
		If Upper(StrAttribute) = Upper("Without VAT") OR StrAttribute = "-" Then
			VATAmount = StrAttribute;
		Else
			If Attribute = 0 Then
				VATAmount = "-";
			Else
				VATAmount = Format(Attribute, "NFD=2; NDS=.; NG=");
			EndIf;
		EndIf;
		FillXDTOProperty(AmountCasTotal, "AmountVAT", VATAmount, True, ErrorText);
		FillXDTOProperty(TotalPai, "AmountCasTotal", AmountCasTotal, True, ErrorText);
		
		FillXDTOProperty(TablInv, "TotalPai", TotalPai, True, ErrorText);
		FillXDTOProperty(Document, "TablInv", TablInv, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		File.Validate();
		
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
		DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1. (see details in Event log monitor).';ru='%1. (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateTORG12SellerFTSCML(DataTree)
	
	ErrorText = "";
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	TargetNamespaceSchema = "OTORG12";
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree,"FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree,"IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"), , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree,"VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		IdSen = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", IdSen, True, ErrorText);
		IdCust = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", IdCust, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			DescEnt = TreeAttributeValue(DataTree,"EDFOperatorAttributes.CompName");
			FillXDTOProperty(PrSEDSend, "DescEnt", DescEnt, True, ErrorText);
			TINLP = TreeAttributeValue(DataTree,"EDFOperatorAttributes.TINLP");
			FillXDTOProperty(PrSEDSend, "TINLP", TINLP, True, ErrorText);
			IdEDF = TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId");
			FillXDTOProperty(PrSEDSend, "IdEDF", IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree,"CTD"), True, ErrorText);
		DocDate = DateDD_MM_YYYY(TreeAttributeValue(DataTree,"DocDate"));
		FillXDTOProperty(Document, "DocDate", DocDate, True, ErrorText);
		FillXDTOProperty(Document, "TempDoc", TreeAttributeValue(DataTree,"TempDoc"), True, ErrorText);
		
		PrInD = GetCMLObjectType("File.Document.PrInD", TargetNamespaceSchema);
		
		FillXDTOProperty(PrInD, "DescFirstDock", TreeAttributeValue(DataTree,"DescFirstDock"), True, ErrorText);
		FillXDTOProperty(PrInD, "RCMDFirstDoc", TreeAttributeValue(DataTree,"RCMDFirstDoc"), True, ErrorText);
		FillXDTOProperty(PrInD, "NumForm", TreeAttributeValue(DataTree,"NumForm"), True, ErrorText);
		
		Vendor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTS(Vendor, DataTree, ErrorText, TargetNamespaceSchema, "Vendor") Then
			FillXDTOProperty(PrInD, "Vendor", Vendor, , ErrorText);
		EndIf;
		
		Payer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTS(Payer, DataTree, ErrorText, TargetNamespaceSchema, "Payer") Then
			FillXDTOProperty(PrInD, "Payer", Payer, , ErrorText);
		EndIf;
		
		Consignor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		
		SenderFilled = FillParticipantDataFTS(Consignor, DataTree, ErrorText,
			TargetNamespaceSchema, "Consignor");
		
		If SenderFilled Then
			CargoFrom = GetCMLObjectType("File.Document.PrInD.CargoFrom", TargetNamespaceSchema);
			FillXDTOProperty(CargoFrom, "CargoShpd", Consignor, , ErrorText);
			CodeRCEAP = TreeAttributeValue(DataTree, "Consignor.OKPDCode");
			FillXDTOProperty(CargoFrom, "RCEAP", CodeRCEAP, , ErrorText);
			OrganizationDepartment = TreeAttributeValue(DataTree, "Consignor.StructuralDepartment");
			FillXDTOProperty(CargoFrom, "StructDep", OrganizationDepartment, , ErrorText);
			FillXDTOProperty(PrInD, "CargoFrom", CargoFrom, , ErrorText);
		EndIf;
		
		Consignee = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		RecipientFilled = FillParticipantDataFTS(Consignee, DataTree, ErrorText,
			TargetNamespaceSchema, "Consignee");
		
		If RecipientFilled Then
			FillXDTOProperty(PrInD, "CargoRece", Consignee, , ErrorText);
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "DocBasisDescription"))
			OR ValueIsFilled(TreeAttributeValue(DataTree, "DocBasisNumber"))
			OR ValueIsFilled(TreeAttributeValue(DataTree, "DocBasisDate"))
			OR ValueIsFilled(TreeAttributeValue(DataTree, "DocBasisAdditInformation")) Then
		
			Basis = GetCMLObjectType("File.Document.PrInD.Basis", TargetNamespaceSchema);
			DocBasisDescription = TreeAttributeValue(DataTree,"DocBasisDescription");
			FillXDTOProperty(Basis, "DescBas", DocBasisDescription, , ErrorText);
			FillXDTOProperty(Basis, "BasisNum", TreeAttributeValue(DataTree, "DocBasisNumber"), , ErrorText);
			DocBasisDate = TreeAttributeValue(DataTree, "DocBasisDate");
			If ValueIsFilled(DocBasisDate) Then
				Attribute = DateDD_MM_YYYY(DocBasisDate);
				FillXDTOProperty(Basis, "DateBas", Attribute, , ErrorText);
			EndIf;
			DocBasisAdditInformation = TreeAttributeValue(DataTree,"DocBasisAdditInformation");
			FillXDTOProperty(Basis, "AdditPrBas", DocBasisAdditInformation, , ErrorText);
			FillXDTOProperty(PrInD, "Basis", Basis, , ErrorText);
			
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"WayBillNumber"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"WaybillDate")) Then
			
			TransInv = GetCMLObjectType("File.Document.PrInD.TransInv", TargetNamespaceSchema);
			
			WayBillNumber = TreeAttributeValue(DataTree,"WayBillNumber");
			FillXDTOProperty(TransInv, "NumTranWayb", WayBillNumber, , ErrorText);
			
			WaybillDate = TreeAttributeValue(DataTree,"WaybillDate");
			If ValueIsFilled(WaybillDate) Then
				Attribute = DateDD_MM_YYYY(WaybillDate);
				FillXDTOProperty(TransInv, "DateWayBill", Attribute, , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "TransInv", TransInv, , ErrorText);
		EndIf;
		
		FillXDTOProperty(PrInD, "OperationKind", TreeAttributeValue(DataTree,"OperationKindCode"), , ErrorText);
		
		CN = GetCMLObjectType("File.Document.PrInD.CN", TargetNamespaceSchema);
		FillXDTOProperty(CN, "NumCW", TreeAttributeValue(DataTree,"ConsignmentNoteNumber"), True, ErrorText);
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree,"DateOfInvoice"));
		FillXDTOProperty(CN, "WBDate", Attribute, True, ErrorText);
		
		Table = GetCMLObjectType("File.Document.PrInD.CN.Table", TargetNamespaceSchema);
		
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");

		For Each Product IN StringProductsTable.Rows Do
			InfoInv = GetCMLObjectType("File.Document.PrInD.CN.Table.PrGd", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "ItemNum", Product.Value, True, ErrorText);
			Attribute = String(TreeAttributeValue(Product, "ProductsTable.LineNumber.MeasurementUnit"));
			FillXDTOProperty(InfoInv, "DescUnOfMeas", Attribute, True, ErrorText);
			NetWeight = ?(ValueIsFilled(TreeAttributeValue(Product, "ProductsTable.LineNumber.NetWeight")),
							TreeAttributeValue(Product, "ProductsTable.LineNumber.NetWeight"),
							0);
			FillXDTOProperty(InfoInv, "Net", NetWeight, True, ErrorText);
			
			ProductsAndServicesDescription = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServicesDescription");
			FillXDTOProperty(InfoInv, "DescProd", ProductsAndServicesDescription, , ErrorText);
			
			BaseUnitCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.BaseUnitCode");
			If StrLen(BaseUnitCode) = 3 Then
				FillXDTOProperty(InfoInv, "OKEI_Tov", BaseUnitCode, , ErrorText);
			Else
				PlaceInAddData("CodeOKEI", BaseUnitCode, Product, "ProductsTable.LineNumber");
			EndIf;
			
			CharacteristicDescription = TreeAttributeValue(Product,
			                                                      "ProductsTable.LineNumber.CharacteristicDescription");
			FillXDTOProperty(InfoInv, "CharacterTov", CharacteristicDescription, , ErrorText);
			
			Kind = TreeAttributeValue(Product, "ProductsTable.LineNumber.Kind");
			FillXDTOProperty(InfoInv, "GradeItems", Kind, , ErrorText);
			
			SKU = TreeAttributeValue(Product, "ProductsTable.LineNumber.SKU");
			FillXDTOProperty(InfoInv, "GoodsSKU", SKU, , ErrorText);
			
			ProductCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductCode");
			FillXDTOProperty(InfoInv, "CodeProd", ProductCode, , ErrorText);
			
			PackagingKind = TreeAttributeValue(Product, "ProductsTable.LineNumber.PackagingKind");
			FillXDTOProperty(InfoInv, "KindPack", PackagingKind, , ErrorText);
			
			QuantityInOnePlace = TreeAttributeValue(Product, "ProductsTable.LineNumber.QuantityInOnePlace");
			FillXDTOProperty(InfoInv, "place", QuantityInOnePlace, , ErrorText);
			
			PlacesQuantity = TreeAttributeValue(Product, "ProductsTable.LineNumber.PlacesQuantity");
			FillXDTOProperty(InfoInv, "NumberOfSeats", PlacesQuantity, , ErrorText);
			
			GrossWeight = TreeAttributeValue(Product, "ProductsTable.LineNumber.GrossWeight");
			FillXDTOProperty(InfoInv, "Gross", GrossWeight, , ErrorText);
			
			Price = TreeAttributeValue(Product, "ProductsTable.LineNumber.Price");
			FillXDTOProperty(InfoInv, "Price", Price, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountWithoutVAT");
			FillXDTOProperty(InfoInv, "AmountNoVAT", AmountWithoutVAT, , ErrorText);
			
			VATRate = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATRate");
			RowVATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence(, VATRate);
			If ValueIsFilled(RowVATRate) AND Upper(RowVATRate) <> "WITHOUT VAT" Then
				RateAsNumber = ElectronicDocumentsReUse.TaxRateVATAsNumber(RowVATRate);
				FillXDTOProperty(InfoInv, "VATRate", RateAsNumber, , ErrorText);
			EndIf;
			
			VATAmount = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmount");
			FillXDTOProperty(InfoInv, "AmountVAT", VATAmount, , ErrorText);
			
			SumWithVAT = TreeAttributeValue(Product, "ProductsTable.LineNumber.SumWithVAT");
			FillXDTOProperty(InfoInv, "AmountCtVAT", SumWithVAT, True, ErrorText);
			
			FillAdditionalInformationFromTreeData(InfoInv,
			                                 Product,
			                                 "ProductsTable.LineNumber",
			                                 ParametersStructure,
			                                 TargetNamespaceSchema,
			                                 "File.Document.PrInD.CN.Table.PrGd",
			                                 "InfFullStr",
			                                 "Products",
			                                 String(Product.Value),
			                                 ErrorText);
			
			Table.PrGd.Add(InfoInv);
		EndDo;
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.CargoItem"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.GrossWeight"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.NetWeight"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalInInvoice.AmountWithVAT"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalInInvoice.VATAmount"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithoutVAT")) Then
			
			TotalInv = GetCMLObjectType("File.Document.PrInD.CN.Table.TotalInv", TargetNamespaceSchema);
			PlacesQuantity = TreeAttributeValue(DataTree,"TotalByInvoice.CargoItem");
			FillXDTOProperty(TotalInv, "NumSeatsTot", PlacesQuantity, , ErrorText);
			
			GrossWeight = TreeAttributeValue(DataTree,"TotalByInvoice.GrossWeight");
			FillXDTOProperty(TotalInv, "GrossWt", GrossWeight, , ErrorText);
			
			NetWeight = TreeAttributeValue(DataTree,"TotalByInvoice.NetWeight");
			FillXDTOProperty(TotalInv, "NetWieg", NetWeight, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithoutVAT");
			FillXDTOProperty(TotalInv, "AmountNoVATVs", AmountWithoutVAT, , ErrorText);
			
			VATAmount = TreeAttributeValue(DataTree,"TotalInInvoice.VATAmount");
			FillXDTOProperty(TotalInv, "AmountVATTotal", VATAmount, , ErrorText);
			
			SumWithVAT = TreeAttributeValue(DataTree,"TotalInInvoice.AmountWithVAT");
			FillXDTOProperty(TotalInv, "AmountCtVATSun", SumWithVAT, , ErrorText);
			
			FillXDTOProperty(Table, "TotalInv", TotalInv, , ErrorText);
		EndIf;
		
		SequentialRecordsNumbersQuantity = TreeAttributeValue(DataTree,
			"CommonInformationAboutConsignmentNote.SequentialRecordsNumbersQuantity");
		PlacesTotal = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.TotalPlaces");
		RecordsSequenceNumbersQuantityInWords = TreeAttributeValue(DataTree,
			"CommonInformationAboutConsignmentNote.RecordsSequenceNumbersQuantityInWords");
		TotalPlacesInWords = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.TotalPlacesInWords");
		CargoNetWeightInWords = TreeAttributeValue(DataTree,"CommonInformationAboutConsignmentNote.CargoNetWeightInWords");
		CargoGrossWeightInWords = TreeAttributeValue(DataTree,
			"CommonInformationAboutConsignmentNote.CargoGrossWeightInWords");
		CargoGrossWeight = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.CargoGrossWeight");
		CargoNetWeight  = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.CargoNetWeight");
		
		If ValueIsFilled(SequentialRecordsNumbersQuantity) OR ValueIsFilled(PlacesTotal)
			OR ValueIsFilled(RecordsSequenceNumbersQuantityInWords) OR ValueIsFilled(TotalPlacesInWords)
			OR ValueIsFilled(CargoNetWeightInWords) OR ValueIsFilled(CargoGrossWeightInWords)
			OR ValueIsFilled(CargoGrossWeight) OR ValueIsFilled(CargoNetWeight) Then
			
			WBCom = GetCMLObjectType("File.Document.PrInD.CN.WBCom", TargetNamespaceSchema);
			FillXDTOProperty(WBCom, "NumRecNum", SequentialRecordsNumbersQuantity, , ErrorText);
			FillXDTOProperty(WBCom, "NumRecNumWor", RecordsSequenceNumbersQuantityInWords, , ErrorText);
			FillXDTOProperty(WBCom, "TotSpots", PlacesTotal, , ErrorText);
			FillXDTOProperty(WBCom, "TotSpotsEtc", TotalPlacesInWords, , ErrorText);
			FillXDTOProperty(WBCom, "Net", CargoNetWeight, , ErrorText);
			FillXDTOProperty(WBCom, "NetPr", CargoNetWeightInWords, , ErrorText);
			FillXDTOProperty(WBCom, "Gross", CargoGrossWeight, , ErrorText);
			FillXDTOProperty(WBCom, "GrossInFull", CargoGrossWeightInWords, , ErrorText);
			FillXDTOProperty(CN, "WBCom", WBCom, , ErrorText);
		EndIf;
		
		FillXDTOProperty(CN, "Table", Table, True, ErrorText);
		FillXDTOProperty(PrInD, "CN", CN, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "InformationByCargoRelease")) Then
			ReleaseCargo = GetCMLObjectType("File.Document.PrInD.ReleaseCargo", TargetNamespaceSchema);
			
			AmountReleased = TreeAttributeValue(DataTree, "InformationOnCargoRelease.ReleasedForAmount");
			FillXDTOProperty(ReleaseCargo, "AmountRelease", AmountReleased, True, ErrorText);
			
			AmountReleasedInWords = TreeAttributeValue(DataTree, "InformationOnCargoRelease.AmountReleasedInWords");
			FillXDTOProperty(ReleaseCargo, "AmountReleasePr", AmountReleasedInWords, , ErrorText);
			
			AttachmentsSheetsCount = TreeAttributeValue(DataTree, "InformationOnCargoRelease.AttachmentsSheetsNumber");
			FillXDTOProperty(ReleaseCargo, "NumApp", AttachmentsSheetsCount, , ErrorText);
			
			AttachmentsSheetsCountInWords = TreeAttributeValue(DataTree,
				"InformationOnCargoRelease.AttachmentSheetsNumberInWords");
			FillXDTOProperty(ReleaseCargo, "NumAppWo", AttachmentsSheetsCountInWords, , ErrorText);
			
			If ValueIsFilled(TreeAttributeValue(DataTree, "InformationOnCargoRelease.DateReleased")) Then
				Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "InformationOnCargoRelease.DateReleased"));
				FillXDTOProperty(ReleaseCargo, "DateRelease", Attribute, , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "ReleaseCargo", ReleaseCargo, , ErrorText);
		EndIf;
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrInD, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrInD.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrInD", PrInD, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
		DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateTrad12BuyerFTSCML(DataTree)
	
	ErrorText = "";
	
	TargetNamespaceSchema = "PTORG12";
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree, "FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree, "IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"),       , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree, "VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		ParticipantID = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", ParticipantID, True, ErrorText);
		ParticipantID = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", ParticipantID, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(
					PrSEDSend,
					"DescEnt",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.CompName"),
					True,
					ErrorText);
			FillXDTOProperty(
					PrSEDSend,
					"TINLP",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.TINLP"),
					True,
					ErrorText);
			FillXDTOProperty(
					PrSEDSend,
					"IdEDF",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId"),
					True,
					ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree, "CTD"), True, ErrorText);
		DocDate = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DocDate"));
		FillXDTOProperty(Document, "DocDate", DocDate, True, ErrorText);
		FillXDTOProperty(Document, "TempDoc", TreeAttributeValue(DataTree, "TempDoc"), True, ErrorText);
		
		IdTNO = GetCMLObjectType("File.Document.IdTNO", TargetNamespaceSchema);
		FillXDTOProperty(IdTNO, "TNFileId", TreeAttributeValue(DataTree, "TNFileId"), True, ErrorText);
		DocDateTN = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DocDateTN"));
		FillXDTOProperty(IdTNO, "DocDateTN", DocDateTN, True, ErrorText);
		FillXDTOProperty(IdTNO, "TempDocT", TreeAttributeValue(DataTree, "TempDocT"), True, ErrorText);
		FillXDTOProperty(Document, "IdTNO", IdTNO, True, ErrorText);
		
		PrRnIn = GetCMLObjectType("File.Document.PrRnIn", TargetNamespaceSchema);
		FillXDTOProperty(PrRnIn, "DescFirstDock", TreeAttributeValue(DataTree, "DescFirstDock"), True, ErrorText);
		FillXDTOProperty(PrRnIn, "RCMDFirstDoc", TreeAttributeValue(DataTree, "RCMDFirstDoc"), True, ErrorText);
		FillXDTOProperty(PrRnIn, "NumForm", TreeAttributeValue(DataTree, "NumForm"), True, ErrorText);
		FillXDTOProperty(PrRnIn, "NumCW", TreeAttributeValue(DataTree, "ConsignmentNoteNumber"), , ErrorText);
		DateOfInvoice = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DateOfInvoice"));
		FillXDTOProperty(PrRnIn, "WBDate", DateOfInvoice, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "CargoDateReceived")) Then
			ReceiveCargo = GetCMLObjectType("File.Document.PrRnIn.ReceiveCargo", TargetNamespaceSchema);
			DateReceived = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "CargoDateReceived"));
			FillXDTOProperty(ReceiveCargo, "ReceivDate", DateReceived, True, ErrorText);
			
			PowerOfAttorney = GetCMLObjectType("PowerOfAttorneyType", TargetNamespaceSchema);
			If FillCMLPowerOfAttorneyData(PowerOfAttorney, DataTree, ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(ReceiveCargo, "PowerOfAttorney", PowerOfAttorney, , ErrorText);
			EndIf;
			FillXDTOProperty(PrRnIn, "ReceiveCargo", ReceiveCargo, , ErrorText);
		EndIf;
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrRnIn, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrRnIn.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrRnIn", PrRnIn, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
			DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Act of works completed.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateAct501PerformerFTSCML(DataTree)
	
	ErrorText = "";
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	EDFScheduleVersion = TreeAttributeValue(DataTree,"EDFScheduleVersion");
	If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
		TargetNamespaceSchema = "IAKTPRM2";
	Else
		TargetNamespaceSchema = "IAKTPRM";
	EndIf;
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree,"FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile", TreeAttributeValue(DataTree,"IdFile"), True, ErrorText);
		If ValueIsFilled(TreeAttributeValue(DataTree, "VersProg")) Then
			FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"), , ErrorText);
		EndIf;
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree,"VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		Attribute = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", Attribute, True, ErrorText);
		Attribute = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", Attribute, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(DataTree,"EDFOperatorAttributes.CompName");
			FillXDTOProperty(PrSEDSend, "DescEnt", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree,"EDFOperatorAttributes.TINLP");
			FillXDTOProperty(PrSEDSend, "TINLP", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId");
			FillXDTOProperty(PrSEDSend, "IdEDF", Attribute, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree,"CTD"), True, ErrorText);
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree,"DocDate"));
		FillXDTOProperty(Document, "DocDate", Attribute, True, ErrorText);
		If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			FillXDTOProperty(Document, "TempDoc", Attribute, True, ErrorText);
		Else
			FillXDTOProperty(Document, "TempDoc", TreeAttributeValue(DataTree, "TempDoc"), True, ErrorText);
		EndIf;
		
		PrActI = GetCMLObjectType("File.Document.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(PrActI, "DescFirstDock", TreeAttributeValue(DataTree,"DescFirstDock"), True, ErrorText);
		FillXDTOProperty(PrActI, "NumCertificate", TreeAttributeValue(DataTree, "ActNumber"), True, ErrorText);
		
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DateOfAct"));
		FillXDTOProperty(PrActI, "DateCertificate", Attribute, True, ErrorText);
		
		FillXDTOProperty(PrActI, "Title", TreeAttributeValue(DataTree, "Title"), True, ErrorText);
		
		Performer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTS(Performer, DataTree, ErrorText, TargetNamespaceSchema, "Performer") Then
			FillXDTOProperty(PrActI, "Performer", Performer, True, ErrorText);
		EndIf;
		
		If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			If ValueIsFilled(TreeAttributeValue(DataTree, "Customer.ParticipantType")) Then
				RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
				If TreeAttributeValue(DataTree, "Customer.ParticipantType") = "Individual" Then
					TIN = TreeAttributeValue(DataTree, "Customer.ParticipantType.Individual.TIN");
					Surname = TreeAttributeValue(DataTree, "Customer.ParticipantType.Individual.Surname");
					Name = TreeAttributeValue(DataTree, "Customer.ParticipantType.Individual.Name");
					Patronymic = TreeAttributeValue(DataTree, "Customer.ParticipantType.Individual.Patronymic");
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CustomerSurname", Surname);
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CustomerName", Name);
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CustomerPatronimic", Patronymic);
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CustomerTIN", TIN);
				Else
					Description = TreeAttributeValue(DataTree, "Customer.ParticipantType.LegalEntity.CompanyDescription");
					TIN = TreeAttributeValue(DataTree, "Customer.ParticipantType.LegalEntity.TIN");
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.Customer", Description);
					AddValueToTree(RowOptionalData, "AddData.DigitallySigned.CustomerTIN", TIN);
				EndIf;
			EndIf;
		Else
			Customer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
			If FillParticipantDataFTS(Customer, DataTree, ErrorText, TargetNamespaceSchema, "Customer") Then
				FillXDTOProperty(PrActI, "Customer", Customer, True, ErrorText);
			EndIf;
		EndIf;
		
		WorksDescr = GetCMLObjectType("File.Document.PrActI.WorksDescr", TargetNamespaceSchema);
		If ValueIsFilled(TreeAttributeValue(DataTree, "ServiceDescription.JobStart")) Then
			Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "ServiceDescription.JobStart"));
			FillXDTOProperty(WorksDescr, "WorkBeg", Attribute, , ErrorText);
		EndIf;
		If ValueIsFilled(TreeAttributeValue(DataTree, "ServiceDescription.JobCompletion")) Then
			Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "ServiceDescription.JobCompletion"));
			FillXDTOProperty(WorksDescr, "WorkEnd", Attribute, , ErrorText);
		EndIf;
		
		AmountNoVATTotal = TreeAttributeValue(DataTree, "ServiceDescription.AmountWithoutVATTotal");
		FillXDTOProperty(WorksDescr, "AmountNoVATTot", AmountNoVATTotal, , ErrorText);
		
		VATAmountTotal = TreeAttributeValue(DataTree, "ServiceDescription.VATAmountTotal");
		FillXDTOProperty(WorksDescr, "AmountVATTot", VATAmountTotal, , ErrorText);
		
		Attribute = TreeAttributeValue(DataTree, "ServiceDescription.AmountWithVATTotal");
		FillXDTOProperty(WorksDescr, "AmountCtVATTot", Attribute, True, ErrorText);
		
		StringTableServices = DataTree.Rows.Find("ServicesTable", "FullPath");

		For Each Service IN StringTableServices.Rows Do
			Work = GetCMLObjectType("File.Document.PrActI.WorksDescr.Work", TargetNamespaceSchema);
			
			FillXDTOProperty(Work, "Number", Service.Value, True, ErrorText);
			Attribute = String(TreeAttributeValue(Service, "ServicesTable.LineNumber.MeasurementUnitDescription"));
			FillXDTOProperty(Work, "DescUnOfMeas", String(Attribute), True, ErrorText);
			
			ProductsAndServicesDescription = TreeAttributeValue(Service, "ServicesTable.LineNumber.ProductsAndServicesDescription");
			FillXDTOProperty(Work, "WorksDesc", ProductsAndServicesDescription, , ErrorText);
			
			Attribute = TreeAttributeValue(Service, "ServicesTable.LineNumber.MeasurementUnitCode");
			If ValueIsFilled(Attribute) AND TypeOf(Attribute) = Type("String")
				 AND IsNumber(Attribute) Then
				 If StrLen(Attribute) = 3 Then
					FillXDTOProperty(Work, "OKEI", Attribute, , ErrorText);
				Else
					PlaceInAddData("CodeOKEI", Attribute, Service, "ServicesTable.LineNumber");
				EndIf;
			EndIf;
			
			Quantity = TreeAttributeValue(Service, "ServicesTable.LineNumber.Quantity");
			FillXDTOProperty(Work, "Quantity", Quantity, , ErrorText);
		
			Price = TreeAttributeValue(Service, "ServicesTable.LineNumber.Price");
			FillXDTOProperty(Work, "Price", Price, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(Service, "ServicesTable.LineNumber.AmountWithoutVAT");
			FillXDTOProperty(Work, "AmountNoVAT", AmountWithoutVAT, , ErrorText);
			
			VATAmount = TreeAttributeValue(Service, "ServicesTable.LineNumber.VATAmount");
			FillXDTOProperty(Work, "AmountVAT", VATAmount, , ErrorText);
			
			SumWithVAT = TreeAttributeValue(Service, "ServicesTable.LineNumber.SumWithVAT");
			FillXDTOProperty(Work, "AmountCtVAT", SumWithVAT, , ErrorText);

			Definition = TreeAttributeValue(Service, "ServicesTable.LineNumber.Definition");
			FillXDTOProperty(Work, "Definition", Definition, , ErrorText);
						
			FillAdditionalInformationFromTreeData(
									Work,
									Service,
									"ServicesTable.LineNumber",
									ParametersStructure,
									TargetNamespaceSchema,
									"File.Document.PrActI.WorksDescr.Work",
									"InfFullStr",
									"Services",
									String(Service.Value),
									ErrorText);
			
			WorksDescr.Work.Add(Work);
		EndDo;
		
		PrActI.WorksDescr.Add(WorksDescr);
		
		Delivered = GetCMLObjectType("File.Document.PrActI.Delivered", TargetNamespaceSchema);
		If ValueIsFilled(TreeAttributeValue(DataTree, "InformationAboutServicesExecution.CompletionDate")) Then
			Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "InformationAboutServicesExecution.CompletionDate"));
			FillXDTOProperty(Delivered, "ComplDate", Attribute, , ErrorText);
		EndIf;
		FillXDTOProperty(PrActI, "Delivered", Delivered, , ErrorText);
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrActI, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrActI.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrActI", PrActI, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
			DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateAct501CustomerFTSCML(DataTree, EDFScheduleVersion)
	
	ErrorText = "";
	If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
		TargetNamespaceSchema = "ZAKTPRM2";
	Else
		TargetNamespaceSchema = "ZAKTPRM";
	EndIf;
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree, "FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree, "IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"),       , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree, "VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		Attribute = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdSen"));
		FillXDTOProperty(PrAcDocFlow, "IdSen", Attribute, True, ErrorText);
		Attribute = TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdCust"));
		FillXDTOProperty(PrAcDocFlow, "IdCust", Attribute, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			Attribute = TreeAttributeValue(DataTree, "EDFOperatorAttributes.CompName");
			FillXDTOProperty(PrSEDSend, "DescEnt", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, "EDFOperatorAttributes.TINLP");
			FillXDTOProperty(PrSEDSend, "TINLP", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId");
			FillXDTOProperty(PrSEDSend, "IdEDF", Attribute, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DocDate"));
		FillXDTOProperty(Document, "DocDate", Attribute, True, ErrorText);
		If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			FillXDTOProperty(Document, "TempDoc", Attribute, True, ErrorText);
		Else
			FillXDTOProperty(Document, "TempDoc", TreeAttributeValue(DataTree, "TempDoc"), True, ErrorText);
		EndIf;
		FillXDTOProperty(Document, "CTD", TreeAttributeValue(DataTree, "CTD"), True, ErrorText);
		
		IdActE = GetCMLObjectType("File.Document.PrActI.IdActE", TargetNamespaceSchema);
		Attribute = TreeAttributeValue(DataTree, "IdFileActE");
		FillXDTOProperty(IdActE, "IdFileActE", Attribute, True, ErrorText);
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DateDocActE"));
		FillXDTOProperty(IdActE, "DateDocActE", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(DataTree, "TimDocActE");
		FillXDTOProperty(IdActE, "TimDocActE", Attribute, True, ErrorText);
		
		InformationActI = GetCMLObjectType("File.Document.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(InformationActI, "IdActE", IdActE, True, ErrorText);
		Attribute = TreeAttributeValue(DataTree, "DescFirstDock");
		FillXDTOProperty(InformationActI, "DescFirstDock", Attribute, True, ErrorText);
		
		PrActI = GetCMLObjectType("File.Document.PrActI.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(PrActI, "NumCertificate", TreeAttributeValue(DataTree, "NumberAct"), , ErrorText);
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DateCertificate"));
		FillXDTOProperty(PrActI, "DateCertificate", Attribute, True, ErrorText);
		
		FillXDTOProperty(InformationActI, "PrActI", PrActI, True, ErrorText);
		
		ReceivedAct = GetCMLObjectType("File.Document.PrActI.Accepted", TargetNamespaceSchema);
		If ValueIsFilled(TreeAttributeValue(DataTree, "InformationOnServicesExecution.OrderDate")) Then
			Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, "InformationOnServicesExecution.OrderDate"));
			FillXDTOProperty(ReceivedAct, "DateOrder", Attribute, , ErrorText);
		EndIf;
		If ValueIsFilled(TreeAttributeValue(DataTree, "InformationOnServicesExecution.Claim")) Then
			Attribute = TreeAttributeValue(DataTree, "InformationOnServicesExecution.Claim");
			FillXDTOProperty(ReceivedAct, "Claim", Attribute, , ErrorText);
		EndIf;
		FillXDTOProperty(InformationActI, "Accepted", ReceivedAct, True, ErrorText);
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(InformationActI, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrActI.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrActI", InformationActI, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
			DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Agreement on.
//
// Parameters
//  DataTree - ValuesTree, contains data for ED generation
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateCorrectingDocumentCML(DataTree)
	
	ErrorText = "";
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
		
	TargetNamespaceSchema = "OKORDOC";
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree,"FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree,"IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree,"VersProg"),       , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree,"VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(
				PrAcDocFlow,
				"IdSen",
				TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdSen")),
				True,
				ErrorText);
		FillXDTOProperty(
				PrAcDocFlow,
				"IdCust",
				TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree,"IdCust")),
				True,
				ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			DescEnt = TreeAttributeValue(DataTree,"EDFOperatorAttributes.CompName");
			FillXDTOProperty(PrSEDSend, "DescEnt", DescEnt, True, ErrorText);
			TINLP = TreeAttributeValue(DataTree,"EDFOperatorAttributes.TINLP");
			FillXDTOProperty(PrSEDSend, "TINLP", TINLP, True, ErrorText);
			IdEDF = TreeAttributeValue(DataTree,"EDFOperatorAttributes.EDFId");
			FillXDTOProperty(PrSEDSend, "IdEDF", IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
			
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(
				Document,
				"DocDate",
				DateDD_MM_YYYY(TreeAttributeValue(DataTree,"DocDate")),
				True,
				ErrorText);
		FillXDTOProperty(Document, "TempDoc", TreeAttributeValue(DataTree,"TempDoc"), True, ErrorText);
		
		PrInD = GetCMLObjectType("File.Document.PrInD", TargetNamespaceSchema);
		
		Vendor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTS(Vendor, DataTree, ErrorText, TargetNamespaceSchema, "Vendor") Then
			FillXDTOProperty(PrInD, "Vendor", Vendor, , ErrorText);
		EndIf;
		
		Payer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTS(Payer, DataTree, ErrorText, TargetNamespaceSchema, "Payer") Then
			FillXDTOProperty(PrInD, "Payer", Payer, , ErrorText);
		EndIf;
		
		Consignor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		
		SenderFilled = FillParticipantDataFTS(
											Consignor,
											DataTree,
											ErrorText,
											TargetNamespaceSchema,
											"Consignor");
		
		If SenderFilled Then
			CargoFrom = GetCMLObjectType("File.Document.PrInD.CargoFrom", TargetNamespaceSchema);
			FillXDTOProperty(CargoFrom, "CargoShpd", Consignor, , ErrorText);
			CodeOKPD = TreeAttributeValue(DataTree, "Consignor.OKPDCode");
			FillXDTOProperty(CargoFrom, "RCEAP", CodeOKPD, , ErrorText);
			OrganizationDepartment = TreeAttributeValue(DataTree, "Consignor.StructuralDepartment");
			FillXDTOProperty(CargoFrom, "StructDep", OrganizationDepartment, , ErrorText);
			FillXDTOProperty(PrInD, "CargoFrom", CargoFrom, , ErrorText);
		EndIf;
		
		Consignee = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		RecipientFilled = FillParticipantDataFTS(
											Consignee,
											DataTree,
											ErrorText,
											TargetNamespaceSchema,
											"Consignee");
		
		If RecipientFilled Then
			FillXDTOProperty(PrInD, "CargoRece", Consignee, , ErrorText);
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"DocBasisDescription"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"DocBasisNumber"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"DocBasisDate"))
			OR ValueIsFilled(TreeAttributeValue(DataTree,"DocBasisAdditInformation")) Then
			
			Basis = GetCMLObjectType("File.Document.PrInD.Basis", TargetNamespaceSchema);
			DocBasisDescription = TreeAttributeValue(DataTree,"DocBasisDescription");
			FillXDTOProperty(Basis, "DescBas", DocBasisDescription, , ErrorText);
			
			DocBasisNumber = TreeAttributeValue(DataTree,"DocBasisNumber");
			FillXDTOProperty(Basis, "BasisNum", DocBasisNumber, , ErrorText);
			
			DocBasisDate = TreeAttributeValue(DataTree,"DocBasisDate");
			If ValueIsFilled(DocBasisDate) Then
				FillXDTOProperty(Basis, "DateBas", DateDD_MM_YYYY(DocBasisDate), , ErrorText);
			EndIf;
			DocBasisAdditInformation = TreeAttributeValue(DataTree,"DocBasisAdditInformation");
			FillXDTOProperty(Basis, "AdditPrBas", DocBasisAdditInformation, , ErrorText);
			
			FillXDTOProperty(PrInD, "Basis", Basis, , ErrorText);
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"WayBillNumber"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"WaybillDate")) Then
			TransInv = GetCMLObjectType("File.Document.PrInD.TransInv", TargetNamespaceSchema);
			WayBillNumber = TreeAttributeValue(DataTree,"WayBillNumber");
			FillXDTOProperty(TransInv, "NumTranWayb", WayBillNumber, , ErrorText);
			
			WaybillDate = TreeAttributeValue(DataTree,"WaybillDate");
			If WaybillDate Then
				FillXDTOProperty(TransInv, "DateWayBill", DateDD_MM_YYYY(WaybillDate), , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "TransInv", TransInv, , ErrorText);
		EndIf;
		
		OperationKindCode = TreeAttributeValue(DataTree,"OperationKindCode");
		FillXDTOProperty(PrInD, "OperationKind", OperationKindCode, , ErrorText);
		
		CN = GetCMLObjectType("File.Document.PrInD.CN", TargetNamespaceSchema);
		FillXDTOProperty(
				CN,
				"NumCW",
				TreeAttributeValue(DataTree,"ConsignmentNoteNumber"),
				True,
				ErrorText);
		FillXDTOProperty(
				CN,
				"WBDate",
				DateDD_MM_YYYY(TreeAttributeValue(DataTree,"DateOfInvoice")),
				True,
				ErrorText);
		
		Table = GetCMLObjectType("File.Document.PrInD.CN.Table", TargetNamespaceSchema);
		
		StringProductsTable = DataTree.Rows.Find("ProductsTable", "FullPath");

		For Each Product IN StringProductsTable.Rows Do
			InfoInv = GetCMLObjectType("File.Document.PrInD.CN.Table.PrGd", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "ItemNum", Product.Value, True, ErrorText);
			FillXDTOProperty(
					InfoInv,
					"DescUnOfMeas",
					String(TreeAttributeValue(Product, "ProductsTable.LineNumber.MeasurementUnit")),
					True,
					ErrorText);
			NetWeightBeforeCorrection = TreeAttributeValue(Product, "ProductsTable.LineNumber.NetWeightBeforeCorrection");
			NetWeightBeforeCorrection = ?(ValueIsFilled(NetWeightBeforeCorrection), NetWeightBeforeCorrection, 0);
			FillXDTOProperty(InfoInv, "NetBeforeCorrection", NetWeightBeforeCorrection, True, ErrorText);
			NetWeight = ?(ValueIsFilled(TreeAttributeValue(Product, "ProductsTable.LineNumber.NetWeight")),
							TreeAttributeValue(Product, "ProductsTable.LineNumber.NetWeight"),
							0);
			FillXDTOProperty(InfoInv, "Net", NetWeight, True, ErrorText);
			ProductsAndServicesDescription = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductsAndServicesDescription");
			FillXDTOProperty(InfoInv, "DescProd", ProductsAndServicesDescription, , ErrorText);
			
			BaseUnitCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.BaseUnitCode");
			FillXDTOProperty(InfoInv, "OKEI_Tov", BaseUnitCode, , ErrorText);
			
			CharacteristicDescription = TreeAttributeValue(Product, "ProductsTable.LineNumber.CharacteristicDescription");
			FillXDTOProperty(InfoInv, "CharacterTov", CharacteristicDescription, , ErrorText);
			
			Kind = TreeAttributeValue(Product, "ProductsTable.LineNumber.Kind");
			FillXDTOProperty(InfoInv, "GradeItems", Kind, , ErrorText);
			
			SKU = TreeAttributeValue(Product, "ProductsTable.LineNumber.SKU");
			FillXDTOProperty(InfoInv, "GoodsSKU", SKU, , ErrorText);
			
			ProductCode = TreeAttributeValue(Product, "ProductsTable.LineNumber.ProductCode");
			FillXDTOProperty(InfoInv, "CodeProd", ProductCode, , ErrorText);
			
			PackagingKind = TreeAttributeValue(Product, "ProductsTable.LineNumber.PackagingKind");
			FillXDTOProperty(InfoInv, "KindPack", PackagingKind, , ErrorText);
			
			QuantityInOnePlace = TreeAttributeValue(Product, "ProductsTable.LineNumber.QuantityInOnePlace");
			FillXDTOProperty(InfoInv, "place", QuantityInOnePlace, , ErrorText);
			
			PlacesQuantity = TreeAttributeValue(Product, "ProductsTable.LineNumber.PlacesQuantity");
			FillXDTOProperty(InfoInv, "NumberOfSeats", PlacesQuantity, , ErrorText);
			
			GrossWeight = TreeAttributeValue(Product, "ProductsTable.LineNumber.GrossWeight");
			FillXDTOProperty(InfoInv, "Gross", GrossWeight, , ErrorText);
			
			PriceBeforeCorrection = TreeAttributeValue(Product, "ProductsTable.LineNumber.PriceBeforeCorrection");
			FillXDTOProperty(InfoInv, "PriceBeforeCorrection", PriceBeforeCorrection, , ErrorText);
			
			Price = TreeAttributeValue(Product, "ProductsTable.LineNumber.Price");
			FillXDTOProperty(InfoInv, "Price", Price, , ErrorText);
			
			AmountNoVATBeforeCorrection = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountNoVATBeforeCorrection");
			FillXDTOProperty(InfoInv, "AmountNoVATBeforeCorrection", AmountNoVATBeforeCorrection, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(Product, "ProductsTable.LineNumber.AmountWithoutVAT");
			FillXDTOProperty(InfoInv, "AmountNoVAT", AmountWithoutVAT, , ErrorText);
			
			VATRate = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATRate");
			RowVATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence(, VATRate);
			If ValueIsFilled(RowVATRate) AND Upper(RowVATRate) <> "WITHOUT VAT" Then
				RateAsNumber = ElectronicDocumentsReUse.TaxRateVATAsNumber(RowVATRate);
				FillXDTOProperty(InfoInv, "VATRate", RateAsNumber, , ErrorText);
			EndIf;
			
			VATAmountBeforeCorrection = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmountBeforeCorrection");
			FillXDTOProperty(InfoInv, "AmountVATBeforeAdjustment", VATAmountBeforeCorrection, , ErrorText);
			
			VATAmount = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmount");
			FillXDTOProperty(InfoInv, "AmountVAT", VATAmount, , ErrorText);
			
			VATAmountBeforeAdjustments = TreeAttributeValue(Product, "ProductsTable.LineNumber.VATAmountBeforeAdjustments");
			FillXDTOProperty(InfoInv, "AmountCtVATBeforeCorrection", VATAmountBeforeAdjustments, , ErrorText);
			
			SumWithVAT = TreeAttributeValue(Product, "ProductsTable.LineNumber.SumWithVAT");
			FillXDTOProperty(InfoInv, "AmountCtVAT", SumWithVAT, , ErrorText);
			
			FillAdditionalInformationFromTreeData(
									InfoInv,
									Product,
									"ProductsTable.LineNumber",
									ParametersStructure,
									TargetNamespaceSchema,
									"File.Document.PrInD.CN.Table.PrGd",
									"InfFullStr",
									"Products",
									String(Product.Value),
									ErrorText);
						
			Table.PrGd.Add(InfoInv);
		EndDo;
		
		If ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.CargoItem"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.GrossWeight"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.NetWeight"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalInInvoice.AmountWithVAT"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalInInvoice.VATAmount"))
		 OR ValueIsFilled(TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithoutVAT")) Then
			
			TotalInv = GetCMLObjectType("File.Document.PrInD.CN.Table.TotalInv", TargetNamespaceSchema);
			PlacesQuantity = TreeAttributeValue(DataTree,"TotalByInvoice.CargoItem");
			FillXDTOProperty(TotalInv, "NumSeatsTot", PlacesQuantity, , ErrorText);
			
			GrossWeight = TreeAttributeValue(DataTree,"TotalByInvoice.GrossWeight");
			FillXDTOProperty(TotalInv, "GrossWt", GrossWeight, , ErrorText);
			
			NetWeight = TreeAttributeValue(DataTree,"TotalByInvoice.NetWeight");
			FillXDTOProperty(TotalInv, "NetWieg", NetWeight, , ErrorText);
			
			NetWeightBeforeCorrection = TreeAttributeValue(DataTree,"TotalByInvoice.NetWeightBeforeCorrection");
			FillXDTOProperty(TotalInv, "NetBeforeCorrectionWeig", NetWeightBeforeCorrection, , ErrorText);
			
			AmountNoVATBeforeCorrectionVs = TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithoutVATBeforeCorrection");
			FillXDTOProperty(TotalInv, "AmountNoVATBeforeCorrectionVs", AmountNoVATBeforeCorrectionVs, , ErrorText);
			
			AmountWithoutVAT = TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithoutVAT");
			FillXDTOProperty(TotalInv, "AmountNoVATVs", AmountWithoutVAT, , ErrorText);
			
			VATAmountBeforeCorrection = TreeAttributeValue(DataTree,"TotalByInvoice.VATAmountBeforeCorrection");
			FillXDTOProperty(TotalInv, "AmountVATBeforeCorrectionTotal", VATAmountBeforeCorrection, , ErrorText);
			
			VATAmount = TreeAttributeValue(DataTree,"TotalInInvoice.VATAmount");
			FillXDTOProperty(TotalInv, "AmountVATTotal", VATAmount, , ErrorText);
			
			VATAmountBeforeAdjustments = TreeAttributeValue(DataTree,"TotalByInvoice.AmountWithVATBeforeCorrection");
			FillXDTOProperty(TotalInv, "AmountCtVATBeforeCorrectionVs", VATAmountBeforeAdjustments, , ErrorText);
			
			SumWithVAT = TreeAttributeValue(DataTree,"TotalInInvoice.AmountWithVAT");
			FillXDTOProperty(TotalInv, "AmountCtVATSun", SumWithVAT, , ErrorText);
			
			FillXDTOProperty(Table, "TotalInv", TotalInv, , ErrorText);
		EndIf;
		
		SequentialRecordsNumbersQuantity = TreeAttributeValue(
												DataTree,
												"CommonInformationAboutConsignmentNote.SequentialRecordsNumbersQuantity", False);
		PlacesTotal = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.TotalPlaces");
		RecordsSequenceNumbersQuantityInWords = TreeAttributeValue(
													DataTree,
													"CommonInformationAboutConsignmentNote.RecordsSequenceNumbersQuantityInWords", False);
		TotalPlacesInWords = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.TotalPlacesInWords");
		CargoNetWeightInWords = TreeAttributeValue(
											DataTree,
											"CommonInformationAboutConsignmentNote.CargoNetWeightInWords");
		CargoGrossWeightInWords = TreeAttributeValue(DataTree,
															"CommonInformationAboutConsignmentNote.CargoGrossWeightInWords");
		CargoGrossWeight = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.CargoGrossWeight");
		CargoNetWeight  = TreeAttributeValue(DataTree, "CommonInformationAboutConsignmentNote.CargoNetWeight");
		
		If ValueIsFilled(SequentialRecordsNumbersQuantity) OR ValueIsFilled(PlacesTotal)
			OR ValueIsFilled(RecordsSequenceNumbersQuantityInWords) OR ValueIsFilled(TotalPlacesInWords)
			OR ValueIsFilled(CargoNetWeightInWords) OR ValueIsFilled(CargoGrossWeightInWords)
			OR ValueIsFilled(CargoGrossWeight) OR ValueIsFilled(CargoNetWeight) Then
		
			WBCom = GetCMLObjectType("File.Document.PrInD.CN.WBCom", TargetNamespaceSchema);
			
			FillXDTOProperty(WBCom, "NumRecNum", SequentialRecordsNumbersQuantity, , ErrorText);
			FillXDTOProperty(WBCom, "NumRecNumWor", RecordsSequenceNumbersQuantityInWords, , ErrorText);
			FillXDTOProperty(WBCom, "TotSpots", PlacesTotal, , ErrorText);
			FillXDTOProperty(WBCom, "TotSpotsEtc", TotalPlacesInWords, , ErrorText);
			FillXDTOProperty(WBCom, "Net", CargoNetWeight, , ErrorText);
			FillXDTOProperty(WBCom, "NetPr", CargoNetWeightInWords, , ErrorText);
			FillXDTOProperty(WBCom, "Gross", CargoGrossWeight, , ErrorText);
			FillXDTOProperty(WBCom, "GrossInFull", CargoGrossWeightInWords, , ErrorText);
			FillXDTOProperty(CN, "WBCom", WBCom, , ErrorText);
		EndIf;
		
		FillXDTOProperty(CN, "Table", Table, True, ErrorText);
		FillXDTOProperty(PrInD, "CN", CN, True, ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "InformationByCargoRelease")) Then
			ReleaseCargo = GetCMLObjectType("File.Document.PrInD.ReleaseCargo", TargetNamespaceSchema);
			AmountReleased = TreeAttributeValue(DataTree, "InformationOnCargoRelease.ReleasedForAmount");
			FillXDTOProperty(ReleaseCargo, "AmountRelease", AmountReleased, True, ErrorText);
			
			AmountReleasedInWords = TreeAttributeValue(DataTree, "InformationOnCargoRelease.AmountReleasedInWords");
			FillXDTOProperty(ReleaseCargo, "AmountReleasePr", AmountReleasedInWords, , ErrorText);
			AttachmentsSheetsCount = TreeAttributeValue(DataTree,
			                                                      "InformationOnCargoRelease.AttachmentsSheetsNumber",
			                                                      False);
			FillXDTOProperty(ReleaseCargo, "NumApp", AttachmentsSheetsCount, , ErrorText);
			AttachmentsSheetsCountInWords = TreeAttributeValue(
													DataTree,
													"InformationOnCargoRelease.AttachmentSheetsNumberInWords", False);
			FillXDTOProperty(ReleaseCargo, "NumAppWo", AttachmentsSheetsCountInWords, , ErrorText);
			
			DateReleased = TreeAttributeValue(DataTree, "InformationOnCargoRelease.DateReleased");
			If ValueIsFilled(DateReleased) Then
				FillXDTOProperty(ReleaseCargo, "DateRelease", DateDD_MM_YYYY(DateReleased), , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "ReleaseCargo", ReleaseCargo, , ErrorText);
		EndIf;
		
		FillAdditionalInformationFromTreeData(PrInD, DataTree, "", ParametersStructure, TargetNamespaceSchema,
			"File.Document.PrInD.InfFul", "TextInf", "Header", Undefined, ErrorText);
		
		FillXDTOProperty(Document, "PrInD", PrInD, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
		DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// DataTree
//  Parameters - values tree - contains data for formatting,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateCorrectingDocumentBuyerCML(DataTree)
	
	ErrorText = "";
	
	TargetNamespaceSchema = "PKORDOC";
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", TreeAttributeValue(DataTree,"IdFile"));
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(TreeAttributeValue(DataTree, "FullFileName"));
		
		// Business information
		FillXDTOProperty(File, "IdFile",   TreeAttributeValue(DataTree, "IdFile"),   True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(DataTree, "VersProg"),       , ErrorText);
		FillXDTOProperty(File, "VersForm", TreeAttributeValue(DataTree, "VersForm"), True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(
				PrAcDocFlow,
				"IdSen",
				TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdSen")),
				True,
				ErrorText);
		FillXDTOProperty(
				PrAcDocFlow,
				"IdCust",
				TypeDescriptionString46.AdjustValue(TreeAttributeValue(DataTree, "IdCust")),
				True,
				ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId")) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(
					PrSEDSend,
					"DescEnt",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.CompName"),
					True,
					ErrorText);
			FillXDTOProperty(
					PrSEDSend,
					"TINLP",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.TINLP"),
					True,
					ErrorText);
			FillXDTOProperty(
					PrSEDSend,
					"IdEDF",
					TreeAttributeValue(DataTree, "EDFOperatorAttributes.EDFId"),
					True,
					ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(
				Document,
				"DocDate",
				DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DocDate")),
				True,
				ErrorText);
		FillXDTOProperty(
				Document,
				"TempDoc",
				TreeAttributeValue(DataTree, "TempDoc"),
				True,
				ErrorText);
		
		IdTNO = GetCMLObjectType("File.Document.IdTNO", TargetNamespaceSchema);
		FillXDTOProperty(IdTNO, "TNFileId", TreeAttributeValue(DataTree, "TNFileId"), True, ErrorText);
		FillXDTOProperty(
				IdTNO,
				"DocDateTN",
				DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DocDateTN")),
				True,
				ErrorText);
		FillXDTOProperty(IdTNO, "TempDocT", TreeAttributeValue(DataTree, "TempDocT"), True, ErrorText);
		FillXDTOProperty(Document, "IdTNO", IdTNO, True, ErrorText);
		
		PrRnIn = GetCMLObjectType("File.Document.PrRnIn", TargetNamespaceSchema);
		FillXDTOProperty(PrRnIn, "NumForm", TreeAttributeValue(DataTree, "NumForm"), True, ErrorText);
		FillXDTOProperty(
				PrRnIn,
				"NumCW",
				TreeAttributeValue(DataTree, "ConsignmentNoteNumber"),
				,
				ErrorText);
		FillXDTOProperty(
				PrRnIn,
				"WBDate",
				DateDD_MM_YYYY(TreeAttributeValue(DataTree, "DateOfInvoice")),
				True,
				ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "CargoDateReceived")) Then
			ReceiveCargo = GetCMLObjectType("File.Document.PrRnIn.ReceiveCargo", TargetNamespaceSchema);
			FillXDTOProperty(
					ReceiveCargo,
					"ReceivDate",
					DateDD_MM_YYYY(TreeAttributeValue(DataTree, "CargoDateReceived")),
					True,
					ErrorText);
					
			FillXDTOProperty(PrRnIn, "ReceiveCargo", ReceiveCargo, , ErrorText);
		EndIf;
		
		RowOptionalData = DataTree.Rows.Find("AddData", "FullPath", True);
		If RowOptionalData <> Undefined Then
			FillAdditionalInformationFromTreeData(PrRnIn, RowOptionalData, "", ParametersStructure, TargetNamespaceSchema,
				"File.Document.PrRnIn.InfFul", "TextInf", "Header", Undefined, ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrRnIn", PrRnIn, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, TreeAttributeValue(DataTree, "FullFileName"), False, "windows-1251");
			DeleteNameSpace(TreeAttributeValue(DataTree, "FullFileName"), TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Outdated - Generation of ED FTS from DB documents

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateInvoiceCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	TargetNamespaceSchema = "SFAKT";
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information
		FillXDTOProperty(File, "IdFile",   ParametersStructure.IdFile,  True, ErrorText);
		FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, True, ErrorText);
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen", TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen), True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust",  TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust),  True, ErrorText);
		
		PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
		FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt, True, ErrorText);
		FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
		FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, True, ErrorText);
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		
		PrInvoice = GetCMLObjectType("File.Document.PrInvoice", TargetNamespaceSchema);
		FillXDTOProperty(PrInvoice, "InvNumber", ParametersStructure.InvNumber, True, ErrorText);
		FillXDTOProperty(PrInvoice, "DateInv", DateDD_MM_YYYY(ParametersStructure.DateInv),True,ErrorText);
		FillXDTOProperty(PrInvoice, "CodeRCC", ParametersStructure.CurrencyCode, True, ErrorText);
		
		If ValueIsFilled(ParametersStructure.CorrectionNumberSourceInv)
			AND ValueIsFilled(ParametersStructure.DateOfCorrectionSourceInvoice) Then
			CorInv = GetCMLObjectType("File.Document.PrInvoice.CorInv", TargetNamespaceSchema);
			
			FillXDTOProperty(CorInv, "NumCorInv", ParametersStructure.CorrectionNumberSourceInv, True, ErrorText);
			FillXDTOProperty(CorInv, "DateCorInv", DateDD_MM_YYYY(ParametersStructure.DateOfCorrectionSourceInvoice), True, ErrorText);
			FillXDTOProperty(PrInvoice,"CorInv", CorInv,,ErrorText);
		EndIf;
		
		PrSale = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillParticipantDataFTSForESFCML(PrSale, ParametersStructure.Company, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInvoice, "PrSale", PrSale, True, ErrorText);
		EndIf;
		
		PrCustomer = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillParticipantDataFTSForESFCML(PrCustomer, ParametersStructure.Counterparty, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInvoice, "PrCustomer", PrCustomer, True, ErrorText);
		EndIf;
		
		SenderInf = "";
		If Not ParametersStructure.JustServices AND ParametersStructure.Property("InfoAboutShipper", SenderInf)
			AND TypeOf(SenderInf) = Type("Structure") Then
			CargoFrom = GetCMLObjectType("File.Document.PrInvoice.CargoFrom", TargetNamespaceSchema);
			Same = "";
			If SenderInf.Property("Same", Same) AND Same = True Then // "=" - as type ItItself can be non-Boolean
				FillXDTOProperty(CargoFrom, "Same", "the same", True, ErrorText);
				FillXDTOProperty(PrInvoice, "CargoFrom", CargoFrom, True, ErrorText);
			Else
				Consignor = Undefined;
				PrCargoRec = GetCMLObjectType("PrCargoSendRecType", TargetNamespaceSchema);
				If SenderInf.Property("Consignor", Consignor)
					AND FillShipperDataRecipientESFCML(PrCargoRec, Consignor, ErrorText, TargetNamespaceSchema) Then
					FillXDTOProperty(CargoFrom, "CargoShpd", PrCargoRec, True, ErrorText);
					FillXDTOProperty(PrInvoice, "CargoFrom", CargoFrom, True, ErrorText);
				EndIf;
			EndIf;
		EndIf;
		
		Consignee = Undefined;
		PrCargoRec = GetCMLObjectType("PrCargoSendRecType", TargetNamespaceSchema);
		If Not ParametersStructure.JustServices AND ParametersStructure.Property("Consignee", Consignee)
			AND FillShipperDataRecipientESFCML(PrCargoRec, Consignee, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInvoice, "CargoRece", PrCargoRec, True, ErrorText);
		EndIf;
		
		PaymentDocuments = Undefined;
		If ParametersStructure.Property("PaymentDocuments", PaymentDocuments) AND TypeOf(PaymentDocuments) = Type("ValueTable") Then
			For Each RowOfPaymentOrder IN PaymentDocuments Do
				PrIND = GetCMLObjectType("File.Document.PrInvoice.PrIND", TargetNamespaceSchema);
				FillXDTOProperty(PrIND, "NumberPRD", RowOfPaymentOrder.NumberPRD, True, ErrorText);
				FillXDTOProperty(PrIND, "DatePRD", DateDD_MM_YYYY(RowOfPaymentOrder.DatePRD), True, ErrorText);
				PrInvoice.PrIND.Add(PrIND);
			EndDo
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrInvoice.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrInvoice, "InfFul", InfFul, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrInvoice", PrInvoice, True, ErrorText);
		TablInv = GetCMLObjectType("File.Document.TablInv", TargetNamespaceSchema);
		
		For Each Product in ParametersStructure.ProductsTable Do
			VTCells = ParametersStructure.ProductsTable.Columns;
			InfoInv = GetCMLObjectType("File.Document.TablInv.InfoInv", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "NumRow", Product.LineNumber, True, ErrorText);
			FillXDTOProperty(InfoInv, "DescProd", Product.ProductsAndServicesDescription, True, ErrorText);
			FillXDTOProperty(InfoInv, "StGoodAcTax", Product.Amount, True, ErrorText);
			
			Excise = GetCMLObjectType("File.Document.TablInv.InfoInv.Excise", TargetNamespaceSchema);
			If Not ValueIsFilled(Product.Excise) Then
				ExciseTaxValue = "no excise";
			Else
				If TypeOf(Product.Excise) = Type("Number") Then
					ExciseTaxValue = Format(Product.Excise, "NFD=2; NDS=.; NG=");
				Else
					ExciseTaxValue = TrimAll(Product.Excise);
				EndIf;
			EndIf;
			FillXDTOProperty(Excise, "AmountExcise", ExciseTaxValue, True, ErrorText);
			FillXDTOProperty(InfoInv, "Excise", Excise, True, ErrorText);
			
			TaxVal = GetCMLObjectType("File.Document.TablInv.InfoInv.TaxVal", TargetNamespaceSchema);
			FillXDTOProperty(TaxVal, "TaxValMag", Product.VATRate, True, ErrorText);
			FillXDTOProperty(TaxVal, "TaxValType", Product.VATRateType, True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxVal", TaxVal, True, ErrorText);
			
			If VTCells.Find("MeasurementUnitCode") <> Undefined AND ValueIsFilled(Product.MeasurementUnitCode) Then
				FillXDTOProperty(InfoInv, "OKEI_Tov", Product.MeasurementUnitCode, , ErrorText);
			EndIf;
			If VTCells.Find("Quantity") <> Undefined AND ValueIsFilled(Product.Quantity) Then
				FillXDTOProperty(InfoInv, "QuantIt", Product.Quantity, , ErrorText);
			EndIf;
			If VTCells.Find("Price") <> Undefined AND ValueIsFilled(Product.Price) Then
				FillXDTOProperty(InfoInv, "PriceTov", Product.Price, , ErrorText);
			EndIf;
			If VTCells.Find("AmountWithoutVAT") <> Undefined AND ValueIsFilled(Product.AmountWithoutVAT) Then
				FillXDTOProperty(InfoInv, "StGoodsWithoutVAT", Product.AmountWithoutVAT, , ErrorText);
			EndIf;
			
			If VTCells.Find("CountryOfOriginCode") <> Undefined Then
				If TypeOf(Product.CountryOfOriginCode) = Type("Array") Then
					For Each CountryCode IN Product.CountryOfOriginCode Do
						InfoInv.CodeOrig.Add(CountryCode);
					EndDo;
				ElsIf ValueIsFilled(Product.CountryOfOriginCode) Then
					InfoInv.CodeOrig.Add(Product.CountryOfOriginCode);
				EndIf;
			EndIf;
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			If Upper(TrimAll(Product.VATRate)) = Upper("Without VAT") Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "Without VAT", True, ErrorText);
			Else
				If Product.VATAmount = 0 Then
					FillXDTOProperty(AmountVATType, "AmountVAT", "-", True, ErrorText);
				Else
					FillXDTOProperty(AmountVATType, "AmountVAT", Format(Product.VATAmount, "NFD=2; NDS=.; NG="), True, ErrorText);
				EndIf;
			EndIf;
			FillXDTOProperty(InfoInv, "AmountCas", AmountVATType, True, ErrorText);
			
			If VTCells.Find("CustomsDeclarationNumber") <> Undefined Then
				If TypeOf(Product.CustomsDeclarationNumber) = Type("Array") Then
					For Each TD IN Product.CustomsDeclarationNumber Do
						InfoInv.TDNumber.Add(TD);
					EndDo;
				ElsIf TypeOf(Product.CustomsDeclarationNumber) = Type("String") AND ValueIsFilled(Product.CustomsDeclarationNumber) Then
					InfoInv.TDNumber.Add(Product.CustomsDeclarationNumber);
				EndIf;
			EndIf;
			
			If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree") Then
				If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Products", String(Product.LineNumber)) Then
					RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
					FillXDTOProperty(InfoInv, "InfFullStr", RowInfoPaul, , ErrorText);
				EndIf;
			EndIf;
			
			TablInv.InfoInv.Add(InfoInv);
		EndDo;
		
		TotalPai = GetCMLObjectType("File.Document.TablInv.TotalPai", TargetNamespaceSchema);
		SumWithoutVATTotal = Undefined;
		If ParametersStructure.Property("SumWithoutVATTotal", SumWithoutVATTotal) Then
			FillXDTOProperty(TotalPai, "StGoodsWithoutVATTotal", SumWithoutVATTotal, , ErrorText);
		EndIf;
		FillXDTOProperty(TotalPai, "StGoodsAcTaxTotal", ParametersStructure.AmountVATAll, True, ErrorText);
		
		AmountCasTotal = GetCMLObjectType("File.Document.TablInv.TotalPai.AmountCasTotal", TargetNamespaceSchema);
		
		If ParametersStructure.VATAmountTotal = 0 Then
			FillXDTOProperty(AmountCasTotal,"AmountVAT", "Without VAT", True, ErrorText);
		Else
			FillXDTOProperty(AmountCasTotal,"AmountVAT", Format(ParametersStructure.VATAmountTotal, "NFD=2; NDS=.; NG="), True,
				ErrorText);
		EndIf;
		
		FillXDTOProperty(TotalPai, "AmountCasTotal", AmountCasTotal, True, ErrorText);
		FillXDTOProperty(TablInv, "TotalPai", TotalPai, True, ErrorText);
		FillXDTOProperty(Document, "TablInv", TablInv, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		File.Validate();
		
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
		DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1. (see details in Event log monitor).';ru='%1. (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateCorrectionInvoiceCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	TargetNamespaceSchema = "KORSFAKT";
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information.
		FillXDTOProperty(File, "IdFile", ParametersStructure.IdFile, True, ErrorText);
		FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, True, ErrorText);
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ  = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen",TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen), True,
			ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust", TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust), True,
			ErrorText);
		
		PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
		FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt,True, ErrorText);
		FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
		FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "PrSEDSend", PrSEDSend, True, ErrorText);
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		
		PrCInv = GetCMLObjectType("File.Document.PrCInv", TargetNamespaceSchema);
		FillXDTOProperty(PrCInv, "NumberCInv", ParametersStructure.NumberCorrInv, True, ErrorText);
		FillXDTOProperty(PrCInv, "DateCInv", DateDD_MM_YYYY(ParametersStructure.DateOffsetInvoice), True, ErrorText);
		FillXDTOProperty(PrCInv, "InvNumber", ParametersStructure.InvNumber, True, ErrorText);
		FillXDTOProperty(PrCInv, "DateInv", DateDD_MM_YYYY(ParametersStructure.DateInv), True, ErrorText);
		FillXDTOProperty(PrCInv, "CodeRCC", ParametersStructure.CurrencyCode, True, ErrorText);
		
		CorrectionNumberCorrInv = Undefined;
		DateOfCorrectionOffsetInvoice = Undefined;
		If ParametersStructure.Property("CorrectionNumberCorrInv", CorrectionNumberCorrInv)
			AND ParametersStructure.Property("DateOfCorrectionOffsetInvoice", DateOfCorrectionOffsetInvoice)
			AND ValueIsFilled(CorrectionNumberCorrInv)
			AND ValueIsFilled(DateOfCorrectionOffsetInvoice) Then
			
			CorCInv = GetCMLObjectType("File.Document.PrCInv.CorCInv", TargetNamespaceSchema);
			FillXDTOProperty(CorCInv, "NumCorToInv", CorrectionNumberCorrInv, True, ErrorText);
			FillXDTOProperty(CorCInv, "DateCorCInv", DateDD_MM_YYYY(DateOfCorrectionOffsetInvoice), True, ErrorText);
			FillXDTOProperty(PrCInv, "CorCInv", CorCInv, , ErrorText);
		EndIf;
		
		InvoiceCorrectionNumber = Undefined;
		InvoiceModificationDate = Undefined;
		If ParametersStructure.Property("CorrectionNumberSourceInv", InvoiceCorrectionNumber)
			AND ParametersStructure.Property("DateOfCorrectionSourceInvoice", InvoiceModificationDate)
			AND ValueIsFilled(InvoiceCorrectionNumber)
			AND ValueIsFilled(InvoiceModificationDate) Then
			
			CorInv = GetCMLObjectType("File.Document.PrCInv.CorInv", TargetNamespaceSchema);
			FillXDTOProperty(CorInv, "NumCorInv", InvoiceCorrectionNumber, True, ErrorText);
			FillXDTOProperty(CorInv,"DateCorInv", DateDD_MM_YYYY(InvoiceModificationDate), True, ErrorText);
			FillXDTOProperty(PrCInv, "CorInv", CorInv, , ErrorText);
		EndIf;
		
		PrSale = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillParticipantDataFTSForESFCML(PrSale, ParametersStructure.Company, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrCInv, "PrSale", PrSale, True, ErrorText);
		EndIf;
		
		PrCustomer = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
		If FillParticipantDataFTSForESFCML(PrCustomer, ParametersStructure.Counterparty, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrCInv, "PrCustomer", PrCustomer, True, ErrorText);
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrCInv.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrCInv, "InfFul", InfFul, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrCInv", PrCInv, True, ErrorText);
		
		TablCInv = GetCMLObjectType("File.Document.TablCInv", TargetNamespaceSchema);
		
		For Each Product in ParametersStructure.ProductsTable Do
			InfoInv = GetCMLObjectType("File.Document.TablCInv.InfoInv", TargetNamespaceSchema);
			FillXDTOProperty(InfoInv, "NumRow", Product.LineNumber, True, ErrorText);
			FillXDTOProperty(InfoInv, "DescProd", Product.ProductsAndServicesDescription, True, ErrorText);
			FillXDTOProperty(InfoInv, "OKEI_GoodsBefore", Product.MeasurementUnitCodeBefore, , ErrorText);
			FillXDTOProperty(InfoInv, "OKEI_ProdAfter", Product.MeasurementUnitCode, , ErrorText);
			FillXDTOProperty(InfoInv, "QuantItBefore", Product.QuantityBefore, , ErrorText);
			FillXDTOProperty(InfoInv, "NumItAfter", Product.Quantity, , ErrorText);
			FillXDTOProperty(InfoInv, "PriceTovBef", Round(Product.PriceBefore, 2), , ErrorText);
			FillXDTOProperty(InfoInv, "PriceTovAfter", Round(Product.Price, 2), , ErrorText);
			
			If ValueIsFilled(Product.AmountNoVATBefore) AND ValueIsFilled(Product.AmountWithoutVAT) Then
				PricType = GetCMLObjectType("PricType", TargetNamespaceSchema);
				
				FillXDTOProperty(PricType, "PricBeforeChan", Product.AmountNoVATBefore, True, ErrorText);
				FillXDTOProperty(PricType, "PricAfterChan", Product.AmountWithoutVAT, True, ErrorText);
				FillXDTOProperty(PricType, "PricIncr", Product.AmountWithoutVATIncrease, , ErrorText);
				FillXDTOProperty(PricType, "PricDecr", Product.AmountWithoutVATReducing, , ErrorText);
				FillXDTOProperty(InfoInv, "StGoodsWithoutVAT", PricType, , ErrorText);
			EndIf;
			
			AmountExciseType = GetCMLObjectType("AmountExciseType", TargetNamespaceSchema);
			FillXDTOProperty(AmountExciseType, "AmountExcise", Product.ExciseUntil, True, ErrorText);
			FillXDTOProperty(InfoInv, "ExciseTo", AmountExciseType, True, ErrorText);
			
			AmountExciseType = GetCMLObjectType("AmountExciseType", TargetNamespaceSchema);
			FillXDTOProperty(AmountExciseType, "AmountExcise", Product.Excise, True, ErrorText);
			FillXDTOProperty(InfoInv, "ExciseAfter", AmountExciseType, True, ErrorText);
			
			DiffSumCasType = GetCMLObjectType("DiffSumCasType", TargetNamespaceSchema);
			ExciseUntil = ?(Product.ExciseUntil = "no excise", 0, Product.ExciseUntil);
			ExciseAfter = ?(Product.Excise = "no excise", 0, Product.Excise);
			If ExciseUntil < ExciseAfter Then
				FillXDTOProperty(DiffSumCasType, "AmountIncr", ExciseAfter - ExciseUntil, , ErrorText, True);
			Else
				FillXDTOProperty(DiffSumCasType, "AmountMult", ExciseUntil - ExciseAfter, , ErrorText, True);
			EndIf;
			FillXDTOProperty(InfoInv, "ExciseDiff", DiffSumCasType, True, ErrorText);
			
			TaxValBefore = GetCMLObjectType("File.Document.TablCInv.InfoInv.TaxValBefore", TargetNamespaceSchema);
			FillXDTOProperty(TaxValBefore, "TaxValMag", Product.VATRateBefore, True, ErrorText);
			FillXDTOProperty(TaxValBefore, "TaxValType", Product.VATRateTypeBefore, True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxValBefore", TaxValBefore, True, ErrorText);
			
			TaxValAfter = GetCMLObjectType("File.Document.TablCInv.InfoInv.TaxValAfter", TargetNamespaceSchema);
			FillXDTOProperty(TaxValAfter, "TaxValMag", Product.VATRate, True, ErrorText);
			FillXDTOProperty(TaxValAfter, "TaxValType", Product.VATRateType, True, ErrorText);
			FillXDTOProperty(InfoInv, "TaxValAfter", TaxValAfter, True, ErrorText);
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			If Product.VATRateBefore = "Without VAT" Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "Without VAT", True, ErrorText);
			ElsIf Product.VATAmountBefore = 0 Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "-", True, ErrorText);
			Else
				FillXDTOProperty(AmountVATType, "AmountVAT", Format(Product.VATAmountBefore, "NFD=2; NDS=.; NG="), True, ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "AmountCasBefore", AmountVATType, True, ErrorText);
			
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			If Product.VATRate = "Without VAT" Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "Without VAT", True, ErrorText);
			ElsIf Product.VATAmount = 0 Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "-", True, ErrorText);
			Else
				FillXDTOProperty(AmountVATType, "AmountVAT", Format(Product.VATAmount, "NFD=2; NDS=.; NG="), True, ErrorText);
			EndIf;
			
			FillXDTOProperty(InfoInv, "AmountCasAfter", AmountVATType, True, ErrorText);
			
			DiffSumCasType = GetCMLObjectType("DiffSumCasType", TargetNamespaceSchema);
			If ValueIsFilled(Product.VATAmountReduction) Then
				FillXDTOProperty(DiffSumCasType, "AmountMult", Product.VATAmountReduction, , ErrorText);
			Else
				FillXDTOProperty(DiffSumCasType, "AmountIncr", Product.VATAmountIncrease, , ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "AmountCasDiff", DiffSumCasType, True, ErrorText);
			
			PricType = GetCMLObjectType("PricType",TargetNamespaceSchema);
			FillXDTOProperty(PricType, "PricBeforeChan", Product.AmountBefore, True, ErrorText);
			FillXDTOProperty(PricType, "PricAfterChan",Product.Amount, True, ErrorText);
			
			If ValueIsFilled(Product.AmountOfIncrease) Then
				FillXDTOProperty(PricType,"PricIncr", Product.AmountOfIncrease, , ErrorText);
			Else
				FillXDTOProperty(PricType, "PricDecr", Product.AmountOfReduction, , ErrorText);
			EndIf;
			FillXDTOProperty(InfoInv, "StGoodAcTax", PricType, , ErrorText);
			
			If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree") Then
				If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Products", String(Product.LineNumber)) Then
					RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
					FillXDTOProperty(InfoInv, "InfFullStr", RowInfoPaul, , ErrorText);
				EndIf;
			EndIf;
			
			TablCInv.InfoInv.Add(InfoInv);
		EndDo;
		
		If ParametersStructure.VATAmountTotalIncrease > 0 AND ParametersStructure.AmountWithoutVATTotalIncrease > 0 Then
			TotalIncr = GetCMLObjectType("File.Document.TablCInv.TotalIncr", TargetNamespaceSchema);
			FillXDTOProperty(TotalIncr, "StGoodsWithoutVATTotal", ParametersStructure.AmountWithoutVATTotalIncrease, , ErrorText);
			FillXDTOProperty(TotalIncr, "StGoodsAcTaxTotal", ParametersStructure.VATAmountTotalIncrease, True, ErrorText);
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			If ParametersStructure.VATAmountIncrease = 0 Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "-", True, ErrorText);
			Else
				FillXDTOProperty(AmountVATType, "AmountVAT", Format(ParametersStructure.VATAmountIncrease, "NFD=2; NDS=.; NG="), True,
					ErrorText);
			EndIf;
			FillXDTOProperty(TotalIncr, "AmountCas", AmountVATType, True, ErrorText);
			FillXDTOProperty(TablCInv, "TotalIncr", TotalIncr, , ErrorText);
		EndIf;
		
		If ParametersStructure.VATAmountTotalReduction > 0 AND ParametersStructure.AmountWithoutVATTotalReduction > 0 Then
			TotalDecr = GetCMLObjectType("File.Document.TablCInv.TotalDecr", TargetNamespaceSchema);
			FillXDTOProperty(TotalDecr, "StGoodsWithoutVATTotal", ParametersStructure.AmountWithoutVATTotalReduction, , ErrorText);
			FillXDTOProperty(TotalDecr, "StGoodsAcTaxTotal", ParametersStructure.VATAmountTotalReduction, True, ErrorText);
			AmountVATType = GetCMLObjectType("AmountVATType", TargetNamespaceSchema);
			If ParametersStructure.VATAmountReduction = 0 Then
				FillXDTOProperty(AmountVATType, "AmountVAT", "-", True, ErrorText);
			Else	
				FillXDTOProperty(AmountVATType, "AmountVAT", Format(ParametersStructure.VATAmountReduction, "NFD=2; NDS=.; NG="), True,
					ErrorText);
			EndIf;
			FillXDTOProperty(TotalDecr, "AmountCas", AmountVATType, True, ErrorText);
			FillXDTOProperty(TablCInv, "TotalDecr", TotalDecr, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "TablCInv", TablCInv, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
			
		File.Validate();
		
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
		DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
		Return True;
	Except
		MessagePattern = NStr("en='%1. (see details in Event log monitor).';ru='%1. (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		
		Return False;
	EndTry;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteFornTorg12CML(ParametersStructure)
	
	ErrorText = "";
	ProductsTable = ParametersStructure.ProductsTable;
	
	TargetNamespaceSchema = "OTORG12";
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information
		FillXDTOProperty(File, "IdFile", ParametersStructure.IdFile, True, ErrorText);
		FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, , ErrorText);
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen", TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen), True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust",  TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust), True, ErrorText);
		
		If ValueIsFilled(ParametersStructure.IdEDF) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
			
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		FillXDTOProperty(Document, "DocDate", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		FillXDTOProperty(Document, "TempDoc", ParametersStructure.TempDoc, True, ErrorText);
		
		PrInD = GetCMLObjectType("File.Document.PrInD", TargetNamespaceSchema);
		FillXDTOProperty(PrInD, "DescFirstDock", ParametersStructure.DescFirstDock, True, ErrorText);
		FillXDTOProperty(PrInD, "RCMDFirstDoc", ParametersStructure.RCMDFirstDoc, True, ErrorText);
		FillXDTOProperty(PrInD, "NumForm", ParametersStructure.NumForm, True, ErrorText);
		
		Vendor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTSCML(Vendor, ParametersStructure.Vendor, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInD, "Vendor", Vendor, , ErrorText);
		EndIf;
		
		Payer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTSCML(Payer, ParametersStructure.Payer, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInD, "Payer", Payer, , ErrorText);
		EndIf;
		
		Consignor = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTSCML(Consignor, ParametersStructure.InfoAboutShipper.Consignor, 
				ErrorText, TargetNamespaceSchema) Then
			CargoFrom = GetCMLObjectType("File.Document.PrInD.CargoFrom", TargetNamespaceSchema);
			FillXDTOProperty(CargoFrom, "CargoShpd", Consignor, , ErrorText);
			If ValueIsFilled(ParametersStructure.InfoAboutShipper.CodeRCEAP) Then
				FillXDTOProperty(CargoFrom, "RCEAP", ParametersStructure.InfoAboutShipper.CodeRCEAP, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.InfoAboutShipper.OrganizationDepartment) Then
				FillXDTOProperty(CargoFrom, "StructDep", ParametersStructure.InfoAboutShipper.OrganizationDepartment,,
					ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "CargoFrom", CargoFrom, , ErrorText);
		EndIf;
		
		Consignee = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTSCML(Consignee, ParametersStructure.Consignee, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrInD, "CargoRece", Consignee, , ErrorText);
		EndIf;
		
		If ValueIsFilled(ParametersStructure.DocBasisDescription) OR ValueIsFilled(ParametersStructure.DocBasisNumber)
			OR ValueIsFilled(ParametersStructure.DocBasisDate) OR ValueIsFilled(ParametersStructure.DocBasisAdditInformation) Then
			Basis = GetCMLObjectType("File.Document.PrInD.Basis", TargetNamespaceSchema);
			If ValueIsFilled(ParametersStructure.DocBasisDescription) Then
				FillXDTOProperty(Basis, "DescBas", ParametersStructure.DocBasisDescription, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.DocBasisNumber) Then
				FillXDTOProperty(Basis, "BasisNum", ParametersStructure.DocBasisNumber, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.DocBasisDate) Then
				FillXDTOProperty(Basis, "DateBas", DateDD_MM_YYYY(ParametersStructure.DocBasisDate), , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.DocBasisAdditInformation) Then
				FillXDTOProperty(Basis, "AdditPrBas", ParametersStructure.DocBasisAdditInformation, , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "Basis", Basis, , ErrorText);
		EndIf;
		
		If ValueIsFilled(ParametersStructure.WayBillNumber)
			OR ValueIsFilled(ParametersStructure.WaybillDate) Then
			TransInv = GetCMLObjectType("File.Document.PrInD.TransInv", TargetNamespaceSchema);
			If ValueIsFilled(ParametersStructure.WayBillNumber) Then
				FillXDTOProperty(TransInv, "NumTranWayb", ParametersStructure.WayBillNumber, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.WaybillDate) Then
				FillXDTOProperty(TransInv, "DateWayBill", DateDD_MM_YYYY(ParametersStructure.WaybillDate), , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "TransInv", TransInv, , ErrorText);
		EndIf;
		
		If ValueIsFilled(ParametersStructure.OperationKindCode) Then
			FillXDTOProperty(PrInD, "OperationKind", ParametersStructure.OperationKindCode, , ErrorText);
		EndIf;
		
		CN = GetCMLObjectType("File.Document.PrInD.CN", TargetNamespaceSchema);
		FillXDTOProperty(CN, "NumCW", ParametersStructure.ConsignmentNoteNumber, True, ErrorText);
		FillXDTOProperty(CN, "WBDate", DateDD_MM_YYYY(ParametersStructure.DateOfInvoice), True, ErrorText);
		
		Table = GetCMLObjectType("File.Document.PrInD.CN.Table", TargetNamespaceSchema);
		
		VTProducts = ParametersStructure.ProductsTable;
		
		For Each Product IN VTProducts Do
			InfoInv = GetCMLObjectType("File.Document.PrInD.CN.Table.PrGd", TargetNamespaceSchema);
			
			FillXDTOProperty(InfoInv, "ItemNum", Product.LineNumber, True, ErrorText);
			FillXDTOProperty(InfoInv, "DescUnOfMeas", String(Product.MeasurementUnit), True, ErrorText);
			FillXDTOProperty(InfoInv, "Net", ?(ValueIsFilled(Product.NetWeight), Product.NetWeight, 0), True, ErrorText);
			
			If ValueIsFilled(Product.ProductsAndServicesDescription) Then
				FillXDTOProperty(InfoInv, "DescProd", Product.ProductsAndServicesDescription, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.BaseUnitCode) Then
				FillXDTOProperty(InfoInv, "OKEI_Tov", Product.BaseUnitCode, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.CharacteristicDescription) Then
				FillXDTOProperty(InfoInv, "CharacterTov", Product.CharacteristicDescription, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.Kind) Then
				FillXDTOProperty(InfoInv, "GradeItems", Product.Kind, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.SKU) Then
				FillXDTOProperty(InfoInv, "GoodsSKU", Product.SKU, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.ProductCode) Then
				FillXDTOProperty(InfoInv, "CodeProd", Product.ProductCode, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.PackagingKind) Then
				FillXDTOProperty(InfoInv, "KindPack", Product.PackagingKind, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.QuantityInOnePlace) Then
				FillXDTOProperty(InfoInv, "place", Product.QuantityInOnePlace, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.PlacesQuantity) Then
				FillXDTOProperty(InfoInv, "NumberOfSeats", Product.PlacesQuantity, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.GrossWeight) Then
				FillXDTOProperty(InfoInv, "Gross", Product.GrossWeight, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.Price) Then
				FillXDTOProperty(InfoInv, "Price", Product.Price, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.AmountWithoutVAT) Then
				FillXDTOProperty(InfoInv, "AmountNoVAT", Product.AmountWithoutVAT, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.VATRate) Then
				VATRate = Number(StrReplace(Product.VATRate, "%", ""));
				FillXDTOProperty(InfoInv, "VATRate", VATRate, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.VATAmount) Then
				FillXDTOProperty(InfoInv, "AmountVAT", Product.VATAmount, , ErrorText);
			EndIf;
			If ValueIsFilled(Product.SumWithVAT) Then
				FillXDTOProperty(InfoInv, "AmountCtVAT", Product.SumWithVAT, , ErrorText);
			EndIf;
			
			If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree") Then
				If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Products", String(Product.LineNumber)) Then
					RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
					FillXDTOProperty(InfoInv, "InfFullStr", RowInfoPaul, , ErrorText);
				EndIf;
			EndIf;
			
			Table.PrGd.Add(InfoInv);
		EndDo;
		
		If ValueIsFilled(ParametersStructure.TotalByBill.PlacesQuantity)
			OR ValueIsFilled(ParametersStructure.TotalByBill.GrossWeight)
			OR ValueIsFilled(ParametersStructure.TotalByBill.NetWeight)
			OR ValueIsFilled(ParametersStructure.TotalByBill.SumWithVAT)
			OR ValueIsFilled(ParametersStructure.TotalByBill.VATAmount)
			OR ValueIsFilled(ParametersStructure.TotalByBill.AmountWithoutVAT) Then
			
			TotalInv = GetCMLObjectType("File.Document.PrInD.CN.Table.TotalInv", TargetNamespaceSchema);
			If ValueIsFilled(ParametersStructure.TotalByBill.PlacesQuantity) Then
				FillXDTOProperty(TotalInv, "NumSeatsTot", ParametersStructure.TotalByBill.PlacesQuantity, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.TotalByBill.GrossWeight) Then
				FillXDTOProperty(TotalInv, "GrossWt", ParametersStructure.TotalByBill.GrossWeight, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.TotalByBill.NetWeight) Then
				FillXDTOProperty(TotalInv, "NetWieg", ParametersStructure.TotalByBill.NetWeight, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.TotalByBill.AmountWithoutVAT) Then
				FillXDTOProperty(TotalInv, "AmountNoVATVs", ParametersStructure.TotalByBill.AmountWithoutVAT, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.TotalByBill.VATAmount) Then
				FillXDTOProperty(TotalInv, "AmountVATTotal", ParametersStructure.TotalByBill.VATAmount, , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.TotalByBill.SumWithVAT) Then
				FillXDTOProperty(TotalInv, "AmountCtVATSun", ParametersStructure.TotalByBill.SumWithVAT, , ErrorText);
			EndIf;
			FillXDTOProperty(Table, "TotalInv", TotalInv, , ErrorText);
		EndIf;
		
		StComInfo = ParametersStructure.CommonInformationAboutInvoice;
		If ValueIsFilled(StComInfo.SequentialRecordsNumbersQuantity)
			OR ValueIsFilled(StComInfo.PlacesTotal)
			OR ValueIsFilled(StComInfo.RecordsSequenceNumbersQuantityInWords)
			OR ValueIsFilled(StComInfo.TotalPlacesInWords)
			OR ValueIsFilled(StComInfo.CargoNetWeightInWords)
			OR ValueIsFilled(StComInfo.CargoGrossWeightInWords)
			OR ValueIsFilled(StComInfo.CargoGrossWeight) Then
			WBCom = GetCMLObjectType("File.Document.PrInD.CN.WBCom", TargetNamespaceSchema);
			If ValueIsFilled(StComInfo.SequentialRecordsNumbersQuantity) Then
				FillXDTOProperty(WBCom, "NumRecNum", StComInfo.SequentialRecordsNumbersQuantity, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.RecordsSequenceNumbersQuantityInWords) Then
				FillXDTOProperty(WBCom, "NumRecNumWor", StComInfo.RecordsSequenceNumbersQuantityInWords, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.PlacesTotal) Then
				FillXDTOProperty(WBCom, "TotSpots", StComInfo.PlacesTotal, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.TotalPlacesInWords) Then
				FillXDTOProperty(WBCom, "TotSpotsEtc", StComInfo.TotalPlacesInWords, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.CargoNetWeight) Then
				FillXDTOProperty(WBCom, "Net", StComInfo.CargoNetWeight, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.CargoNetWeightInWords) Then
				FillXDTOProperty(WBCom, "NetPr", StComInfo.CargoNetWeightInWords, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.CargoGrossWeight) Then
				FillXDTOProperty(WBCom, "Gross", StComInfo.CargoGrossWeight, , ErrorText);
			EndIf;
			If ValueIsFilled(StComInfo.CargoGrossWeightInWords) Then
				FillXDTOProperty(WBCom, "GrossInFull", StComInfo.CargoGrossWeightInWords, , ErrorText);
			EndIf;
			FillXDTOProperty(CN, "WBCom", WBCom, , ErrorText);
		EndIf;
		
		FillXDTOProperty(CN, "Table", Table, True, ErrorText);
		FillXDTOProperty(PrInD, "CN", CN, True, ErrorText);
		
		StInfVacation = ParametersStructure.InformationByCargoRelease;
		If ValueIsFilled(StInfVacation.AmountReleased) Then
			ReleaseCargo = GetCMLObjectType("File.Document.PrInD.ReleaseCargo", TargetNamespaceSchema);
			FillXDTOProperty(ReleaseCargo, "AmountRelease", StInfVacation.AmountReleased, True, ErrorText);
			If ValueIsFilled(StInfVacation.AmountReleasedInWords) Then
				FillXDTOProperty(ReleaseCargo, "AmountReleasePr", StInfVacation.AmountReleasedInWords, , ErrorText);
			EndIf;
			If ValueIsFilled(StInfVacation.AttachmentsSheetsCount) Then
				FillXDTOProperty(ReleaseCargo, "NumApp", StInfVacation.AttachmentsSheetsCount, , ErrorText);
			EndIf;
			If ValueIsFilled(StInfVacation.AttachmentsSheetsCountInWords) Then
				FillXDTOProperty(ReleaseCargo, "NumAppWo", StInfVacation.AttachmentsSheetsCountInWords, , ErrorText);
			EndIf;
			If ValueIsFilled(StInfVacation.DateReleased) Then
				FillXDTOProperty(ReleaseCargo, "DateRelease", DateDD_MM_YYYY(StInfVacation.DateReleased), , ErrorText);
			EndIf;
			ReleasePermitted = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
			If FillResponsiblePersonFTSCML(ReleasePermitted, StInfVacation.ReleasePermitted,
					ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(ReleaseCargo, "ReleasePerm", ReleasePermitted, , ErrorText);
			EndIf;
			Accountant = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
			If FillResponsiblePersonFTSCML(Accountant, StInfVacation.Accountant, ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(ReleaseCargo, "Accountant", Accountant, , ErrorText);
			EndIf;
			ReleaseMade = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
			If FillResponsiblePersonFTSCML(ReleaseMade, StInfVacation.ReleaseMade,
					ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(ReleaseCargo, "ReleaseMad", ReleaseMade, , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "ReleaseCargo", ReleaseCargo, , ErrorText);
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrInD.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrInD, "InfFul", InfFul, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrInD", PrInD, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		
		StSigner = ParametersStructure.Signer;
		If FillCMLSignerData(Signer, StSigner, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
			DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateTrad12CustomerCML(ParametersStructure)
	
	ErrorText = "";
	
	TargetNamespaceSchema = "PTORG12";
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information
		FillXDTOProperty(File, "IdFile", ParametersStructure.IdFile, True, ErrorText);
		FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, , ErrorText);
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen", TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen),
			True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust",  TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust),
			True, ErrorText);
		
		If ValueIsFilled(ParametersStructure.IdEDF) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		FillXDTOProperty(Document, "DocDate", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		FillXDTOProperty(Document, "TempDoc", ParametersStructure.TempDoc, True, ErrorText);
		
		IdTNO = GetCMLObjectType("File.Document.IdTNO", TargetNamespaceSchema);
		FillXDTOProperty(IdTNO, "TNFileId", ParametersStructure.TNFileId, True, ErrorText);
		FillXDTOProperty(IdTNO, "DocDateTN", DateDD_MM_YYYY(ParametersStructure.DocDateTN), True, ErrorText);
		FillXDTOProperty(IdTNO, "TempDocT", ParametersStructure.TempDocT, True, ErrorText);
		FillXDTOProperty(Document, "IdTNO", IdTNO, True, ErrorText);
		
		PrRnIn = GetCMLObjectType("File.Document.PrRnIn", TargetNamespaceSchema);
		FillXDTOProperty(PrRnIn, "DescFirstDock", ParametersStructure.DescFirstDock, True, ErrorText);
		FillXDTOProperty(PrRnIn, "RCMDFirstDoc", ParametersStructure.RCMDFirstDoc, True, ErrorText);
		FillXDTOProperty(PrRnIn, "NumForm", ParametersStructure.NumForm, True, ErrorText);
		FillXDTOProperty(PrRnIn, "NumCW", ParametersStructure.ConsignmentNoteNumber, , ErrorText);
		FillXDTOProperty(PrRnIn, "WBDate", DateDD_MM_YYYY(ParametersStructure.DateOfInvoice), True,
			ErrorText);
		
		If ValueIsFilled(ParametersStructure.CargoDateReceived) Then
			ReceiveCargo = GetCMLObjectType("File.Document.PrRnIn.ReceiveCargo", TargetNamespaceSchema);
			FillXDTOProperty(ReceiveCargo, "ReceivDate", DateDD_MM_YYYY(ParametersStructure.CargoDateReceived), True,
				ErrorText);
			
			PowerOfAttorney = GetCMLObjectType("File.Document.PrRnIn.ReceiveCargo.PowerOfAttorney", TargetNamespaceSchema);
			If FillPowerOfAttorneyData(PowerOfAttorney, ParametersStructure.PowerOfAttorney, ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(ReceiveCargo, "PowerOfAttorney", PowerOfAttorney, , ErrorText);
			EndIf;
				
			If ValueIsFilled(ParametersStructure.CargoReceived.Position)
				OR ValueIsFilled(ParametersStructure.CargoReceived.Surname) Then
				CargoReceived = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
				If FillResponsiblePersonFTSCML(CargoReceived, ParametersStructure.CargoReceived, ErrorText, TargetNamespaceSchema) Then
					FillXDTOProperty(ReceiveCargo, "CargoReceived", CargoReceived, , ErrorText);
				EndIf;
			EndIf;
			
			If ValueIsFilled(ParametersStructure.CargoTaken.Position)
				OR ValueIsFilled(ParametersStructure.CargoTaken.Surname) Then
				CargoTaken = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
				If FillResponsiblePersonFTSCML(CargoTaken, ParametersStructure.CargoTaken, ErrorText, TargetNamespaceSchema) Then
					FillXDTOProperty(ReceiveCargo, "CargoTaken", CargoTaken, , ErrorText);
				EndIf;
			EndIf;
			
			FillXDTOProperty(PrRnIn, "ReceiveCargo", ReceiveCargo, , ErrorText);
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrRnIn.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrRnIn, "InfFul", InfFul, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrRnIn", PrRnIn, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		
		StSigner = ParametersStructure.Signer;
		If FillCMLSignerData(Signer, StSigner, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
			DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeteteFormAct501CML(ParametersStructure)
	
	ErrorText = "";
	
	If ParametersStructure.EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
		TargetNamespaceSchema = "IAKTPRM2";
	Else
		TargetNamespaceSchema = "IAKTPRM";
	EndIf;
	
	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information
		FillXDTOProperty(File, "IdFile", ParametersStructure.IdFile, True, ErrorText);
		If ValueIsFilled(ParametersStructure.VersProg) Then
			FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, , ErrorText);
		EndIf;
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen", TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen), True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust",  TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust), True, ErrorText);
		
		If ValueIsFilled(ParametersStructure.IdEDF) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		FillXDTOProperty(Document, "DocDate", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		If ParametersStructure.EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			FillXDTOProperty(Document, "TempDoc", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		Else
			FillXDTOProperty(Document, "TempDoc", ParametersStructure.TempDoc, True, ErrorText);
		EndIf;
		
		PrActI = GetCMLObjectType("File.Document.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(PrActI, "DescFirstDock", ParametersStructure.DescFirstDock, True, ErrorText);
		If ValueIsFilled(ParametersStructure.ActNumber) Then
			FillXDTOProperty(PrActI, "NumCertificate", ParametersStructure.ActNumber, , ErrorText);
		EndIf;
		FillXDTOProperty(PrActI, "DateCertificate", DateDD_MM_YYYY(ParametersStructure.DateOfAct), True, ErrorText);
		
		FillXDTOProperty(PrActI, "Title", ParametersStructure.Title, True, ErrorText);
		
		Performer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
		If FillParticipantDataFTSCML(Performer, ParametersStructure.Performer, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(PrActI, "Performer", Performer, True, ErrorText);
		EndIf;
		
		If ParametersStructure.EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			AdditDataStructure = New Structure;
			If ParametersStructure.Customer.ThisIsInd Then
				AdditDataStructure.Insert("CustomerSurname",  ParametersStructure.Customer.Surname);
				AdditDataStructure.Insert("CustomerName",      ParametersStructure.Customer.Name);
				AdditDataStructure.Insert("CustomerPatronimic", ParametersStructure.Customer.Patronymic);
				AdditDataStructure.Insert("CustomerTIN",      ParametersStructure.Customer.TIN);
			Else
				AdditDataStructure.Insert("Customer",    ParametersStructure.Customer.CompanyDescription);
				AdditDataStructure.Insert("CustomerTIN", ParametersStructure.Customer.TIN);
			EndIf;
			ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, "Header", True);
		Else
			Customer = GetCMLObjectType("ParticipantType", TargetNamespaceSchema);
			If FillParticipantDataFTSCML(Customer, ParametersStructure.Customer, ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(PrActI, "Customer", Customer, True, ErrorText);
			EndIf;
		EndIf;
		ServicesDescriptionVT = ParametersStructure.ServicesDescriptionTable;
		For Each ServiceDescription IN ServicesDescriptionVT Do
			
			WorksDescr = GetCMLObjectType("File.Document.PrActI.WorksDescr", TargetNamespaceSchema);
			If ValueIsFilled(ServiceDescription.WorksBegin) Then
				FillXDTOProperty(WorksDescr, "WorkBeg",    DateDD_MM_YYYY(ServiceDescription.WorksBegin), , ErrorText);
			EndIf;
			If ValueIsFilled(ServiceDescription.WorksEnd) Then
				FillXDTOProperty(WorksDescr, "WorkEnd",    DateDD_MM_YYYY(ServiceDescription.WorksEnd), , ErrorText);
			EndIf;
			If ValueIsFilled(ServiceDescription.AmountNoVATTotal) Then
				FillXDTOProperty(WorksDescr, "AmountNoVATTot", ServiceDescription.AmountNoVATTotal, , ErrorText);
			EndIf;
			If ValueIsFilled(ServiceDescription.VATAmountTotal) Then
				FillXDTOProperty(WorksDescr, "AmountVATTot",    ServiceDescription.VATAmountTotal, , ErrorText);
			EndIf;
			FillXDTOProperty(WorksDescr, "AmountCtVATTot",  ServiceDescription.VATAmountTotal, True, ErrorText);
			
			ServicesVT = ServiceDescription.Services;
			
			For Each Service IN ServicesVT Do
				Work = GetCMLObjectType("File.Document.PrActI.WorksDescr.Work", TargetNamespaceSchema);
				
				FillXDTOProperty(Work, "Number", Service.LineNumber, True, ErrorText);
				FillXDTOProperty(Work, "DescUnOfMeas", String(Service.MeasurementUnit), True, ErrorText);
				
				If ValueIsFilled(Service.ProductsAndServicesDescription) Then
					FillXDTOProperty(Work, "WorksDesc", Service.ProductsAndServicesDescription, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.BaseUnitCode) AND TypeOf(Service.BaseUnitCode) = Type("String")
						AND StrLen(Service.BaseUnitCode) = 3 AND IsNumber(Service.BaseUnitCode) Then
					FillXDTOProperty(Work, "OKEI", Service.BaseUnitCode, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.Quantity) Then
					FillXDTOProperty(Work, "Quantity", Service.Quantity, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.Price) Then
					FillXDTOProperty(Work, "Price", Service.Price, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.AmountWithoutVAT) Then
					FillXDTOProperty(Work, "AmountNoVAT", Service.AmountWithoutVAT, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.VATAmount) Then
					FillXDTOProperty(Work, "AmountVAT", Service.VATAmount, , ErrorText);
				EndIf;
				If ValueIsFilled(Service.SumWithVAT) Then
					FillXDTOProperty(Work, "AmountCtVAT", Service.SumWithVAT, , ErrorText);
				EndIf;
				
				If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree") Then
					If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Services",
						String(ServicesDescriptionVT.IndexOf(ServiceDescription) + 1) + "." + Service.LineNumber) Then
						
						RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
						FillXDTOProperty(Work, "InfFullStr", RowInfoPaul, , ErrorText);
					EndIf;
				EndIf;
				FillXDTOProperty(Work, "Definition", Service.Definition, , ErrorText);
				
				WorksDescr.Work.Add(Work);
			EndDo;
			
			PrActI.WorksDescr.Add(WorksDescr);
		EndDo;
		
		DeliveredFilled = False;
		PowerOfAttorneyFilled = False;
		InfoByServices = ParametersStructure.InformationAboutServicesExecution;
		Delivered = GetCMLObjectType("File.Document.PrActI.Delivered", TargetNamespaceSchema);
		If ValueIsFilled(InfoByServices.CompletionDate) Then
			FillXDTOProperty(Delivered, "ComplDate", DateDD_MM_YYYY(ParametersStructure.InformationAboutServicesExecution.CompletionDate), , ErrorText);
			DeliveredFilled = True;
		EndIf;
		ExecutSignature = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
		If FillResponsiblePersonFTSCML(ExecutSignature, ParametersStructure.InformationAboutServicesExecution.ExecutantSignature,
			ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Delivered, "ExecutSignature", ExecutSignature, , ErrorText);
			DeliveredFilled = True;
		EndIf;
		
		PowerOfAttorney = GetCMLObjectType("File.Document.PrActI.Delivered.ExecPowOfAtt", TargetNamespaceSchema);
		If FillPowerOfAttorneyData(PowerOfAttorney, ParametersStructure.InformationAboutServicesExecution.PowerOfAttorney, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Delivered, "ExecPowOfAtt", PowerOfAttorney, , ErrorText);
			DeliveredFilled = True;
		EndIf;
		
		If DeliveredFilled Then
			FillXDTOProperty(PrActI, "Delivered", Delivered, , ErrorText);
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrActI.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrActI, "InfFul", InfFul, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Document, "PrActI", PrActI, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		
		StSigner = ParametersStructure.Signer;
		If FillCMLSignerData(Signer, StSigner, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
			DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateAct501CustomerCML(ParametersStructure, EDFScheduleVersion)
	
	ErrorText = "";
	If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
		TargetNamespaceSchema = "ZAKTPRM2";
	Else
		TargetNamespaceSchema = "ZAKTPRM";
	EndIf;

	Try
		File = GetCMLObjectType("File", TargetNamespaceSchema);
		
		FileOnDrive = New File(ParametersStructure.FullFileName);
		
		// Business information
		FillXDTOProperty(File, "IdFile", ParametersStructure.IdFile, True, ErrorText);
		FillXDTOProperty(File, "VersProg", ParametersStructure.VersProg, , ErrorText);
		FillXDTOProperty(File, "VersForm", ParametersStructure.VersForm, True, ErrorText);
		
		PrAcDocFlow = GetCMLObjectType("File.PrAcDocFlow", TargetNamespaceSchema);
		
		SQ = New StringQualifiers(46, AllowedLength.Fixed);
		Array = New Array;
		Array.Add(Type("String"));
		TypeDescriptionString46 = New TypeDescription(Array, , SQ);
		
		FillXDTOProperty(PrAcDocFlow, "IdSen", TypeDescriptionString46.AdjustValue(ParametersStructure.IdSen),
			True, ErrorText);
		FillXDTOProperty(PrAcDocFlow, "IdCust",  TypeDescriptionString46.AdjustValue(ParametersStructure.IdCust),
			True, ErrorText);
		
		If ValueIsFilled(ParametersStructure.IdEDF) Then
			PrSEDSend = GetCMLObjectType("File.PrAcDocFlow.PrSEDSend", TargetNamespaceSchema);
			FillXDTOProperty(PrSEDSend, "DescEnt", ParametersStructure.DescEnt, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "TINLP", ParametersStructure.TINLP, True, ErrorText);
			FillXDTOProperty(PrSEDSend, "IdEDF", ParametersStructure.IdEDF, True, ErrorText);
			FillXDTOProperty(PrAcDocFlow, "PrSEDSend",PrSEDSend, , ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "PrAcDocFlow", PrAcDocFlow, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespaceSchema);
		FillXDTOProperty(Document, "CTD", ParametersStructure.CTD, True, ErrorText);
		FillXDTOProperty(Document, "DocDate", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		
		If EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
			FillXDTOProperty(Document, "TempDoc", DateDD_MM_YYYY(ParametersStructure.DocDate), True, ErrorText);
		Else
			FillXDTOProperty(Document, "TempDoc", ParametersStructure.TempDoc, True, ErrorText);
		EndIf;

		InformationActI = GetCMLObjectType("File.Document.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(InformationActI, "DescFirstDock", ParametersStructure.DescFirstDock, True, ErrorText);
		
		IdActE = GetCMLObjectType("File.Document.PrActI.IdActE", TargetNamespaceSchema);
		FillXDTOProperty(IdActE, "IdFileActE", ParametersStructure.EidFileAct, True, ErrorText);
		FillXDTOProperty(IdActE, "DateDocActE", DateDD_MM_YYYY(ParametersStructure.DateOfAcpDock), True, ErrorText);
		FillXDTOProperty(IdActE, "TimDocActE", ParametersStructure.TempDocAcp, True, ErrorText);
		FillXDTOProperty(InformationActI, "IdActE", IdActE, True, ErrorText);
		
		PrActI = GetCMLObjectType("File.Document.PrActI.PrActI", TargetNamespaceSchema);
		FillXDTOProperty(PrActI, "NumCertificate", ParametersStructure.ActNumber, , ErrorText);
		FillXDTOProperty(PrActI, "DateCertificate", DateDD_MM_YYYY(ParametersStructure.DateOfAct), True, ErrorText);
		FillXDTOProperty(InformationActI, "PrActI", PrActI, True, ErrorText);
		
		// Fill in properties of host side Accepted
		If ValueIsFilled(ParametersStructure.OrderDate) Then
			Accepted = GetCMLObjectType("File.Document.PrActI.Accepted", TargetNamespaceSchema);
			If ValueIsFilled(ParametersStructure.OrderDate) Then
				FillXDTOProperty(Accepted, "DateOrder", DateDD_MM_YYYY(ParametersStructure.OrderDate), , ErrorText);
			EndIf;
			If ValueIsFilled(ParametersStructure.Claim) Then
				FillXDTOProperty(Accepted, "Claim", ParametersStructure.Claim, , ErrorText);
			EndIf;
			
			PowerOfAttorney = GetCMLObjectType("File.Document.PrActI.Accepted.PowOfAttornOrder", TargetNamespaceSchema);
			If FillPowerOfAttorneyData(PowerOfAttorney, ParametersStructure.PowerOfAttorney, ErrorText, TargetNamespaceSchema) Then
				FillXDTOProperty(Accepted, "PowOfAttornOrder", PowerOfAttorney, , ErrorText);
			EndIf;
			
			If ValueIsFilled(ParametersStructure.SignatureOrder.Position)
				OR ValueIsFilled(ParametersStructure.SignatureOrder.Surname) Then
				SignatureOrder = GetCMLObjectType("RespPersonType", TargetNamespaceSchema);
				If FillResponsiblePersonFTSCML(SignatureOrder, ParametersStructure.SignatureOrder, ErrorText, TargetNamespaceSchema) Then
					FillXDTOProperty(Accepted, "SignatureOrder", SignatureOrder, , ErrorText);
				EndIf;
			EndIf;
			FillXDTOProperty(InformationActI, "Accepted", Accepted, , ErrorText);
		EndIf;
		
		// Fill in the additional text properties InfFul
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure, ErrorText, True, "Header") Then
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			EndIf;
			
			// Generate additional file:
			AdditFileGenerated = GenerateAdditFileCML(ParametersStructure, ErrorText, False);
		EndIf;
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			InfFul = GetCMLObjectType("File.Document.PrActI.InfFul", TargetNamespaceSchema);
			If ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(InfFul, "TextInf", RowInfoPaul, , ErrorText);
			EndIf;
			If AdditFileGenerated Then
				FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
			EndIf;
			FillXDTOProperty(PrActI, "InfFul", InfFul, , ErrorText);
		EndIf;
		FillXDTOProperty(Document, "PrActI", InformationActI, True, ErrorText);
		
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespaceSchema);
		
		StSigner = ParametersStructure.Signer;
		If FillCMLSignerData(Signer, StSigner, ErrorText, TargetNamespaceSchema) Then
			FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		EndIf;
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(File, ParametersStructure.FullFileName, False, "windows-1251");
			DeleteNameSpace(ParametersStructure.FullFileName, TargetNamespaceSchema);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
			
		// Remove the file with additional information in case of errors.
		If ParametersStructure.Property("AdditFileFullName") Then
			DeleteFiles(ParametersStructure.AdditFileFullName);
		EndIf;
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Generation of ED CML from DB documents

// Returns the result of successful generation of ED file with the directory of products
//
// Parameters
//  DataTree - values tree for generation of ED.
//  FilesArray - if there are attached files - then in this parameter the array of files is returned
//
// Returns:
//  Boolean - sign of successful ED generation.
//
Function GenerateCMLCatalog(DataTree, FilesArray)
	
	ErrorText = "";
	FileIsFormed = False;
	
	TargetNamespaceSchema = "urn:1C.ru:commerceml_2";
	Try
		
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		Directory = GetCMLObjectType("Directory", TargetNamespaceSchema);
		
		// Business information.
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);

		FillXDTOProperty(BusinessInformation, "GeneratingDate", XMLDateTime(TreeAttributeValue(DataTree,
			"GeneratingDate")), True, ErrorText);
		
		// Directory.
		FillXDTOProperty(Directory, "ID", TreeAttributeValue(DataTree, "ID"), True, ErrorText);
		FillXDTOProperty(Directory, "ContainsChangesOnly", TreeAttributeValue(DataTree,
			"ContainsChangesOnly"), False, ErrorText);
		FillXDTOProperty(Directory, "Description", TreeAttributeValue(DataTree, "Description"), True, ErrorText);
		
		// Owner.
		Owner = GetCMLObjectType("Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Owner, DataTree, "Owner", TargetNamespaceSchema, ErrorText);
		FillXDTOProperty(Directory, "Owner", Owner, True, ErrorText);
		
		// Products.
		StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
		If StringProductsTable.Rows.Count() > 0 Then
			Products = GetCMLObjectType("Directory.Products", TargetNamespaceSchema);
			For Each CurrentProduct IN StringProductsTable.Rows Do
				Product = GetCMLObjectType("Directory.Products.Product", TargetNamespaceSchema);
				GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText, FilesArray);
				Products.Product.Add(Product);
			EndDo;
			FillXDTOProperty(Directory, "Products", Products, True, ErrorText);
		EndIf;
		
		// For directory of products and services only unsigned data can be transferred
		FillInUnSignedHeaderData(DataTree, Directory, ErrorText);
		
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Directory.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Directory.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(Directory, "Signatories", Signatories, False, ErrorText);
		
		FillXDTOProperty(BusinessInformation, "Directory", Directory, True, ErrorText);
		// Record of the electronic document file.
		BusinessInformation.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file with price list by the scheme CML 2
// 
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GeneratePriceListCML(DataTree)
	
	ErrorText = "";
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	
	Try
		
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);
		
		GeneratingDate = TreeAttributeValue(DataTree, "GeneratingDate");
		FillXDTOProperty(BusinessInformation, "GeneratingDate", GeneratingDate, True, ErrorText);
		
		PriceList = GetCMLObjectType("OffersPackage", TargetNamespaceSchema);
		
		FillXDTOProperty(PriceList, "ContainsChangesOnly", False, True, ErrorText);
		FillXDTOProperty(PriceList, "ID", TreeAttributeValue(DataTree, "ID"), True, ErrorText);
		FillXDTOProperty(PriceList, "DirectoryId", TreeAttributeValue(DataTree, "ID"), True, ErrorText);
		
		FillXDTOProperty(PriceList, "Description", TreeAttributeValue(DataTree, "Description"), True, ErrorText);
		FillXDTOProperty(PriceList, "Definition", TreeAttributeValue(DataTree, "Definition"), True, ErrorText);
		
		FillXDTOProperty(PriceList, "ValidFrom", TreeAttributeValue(DataTree, "ValidFrom"), True, ErrorText);
		FillXDTOProperty(PriceList, "ValidUntil", TreeAttributeValue(DataTree, "ValidUntil"), True, ErrorText);
		
		// Owner.
		Owner = GetCMLObjectType("Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Owner, DataTree, "Owner", TargetNamespaceSchema, ErrorText);
		
		FillXDTOProperty(PriceList, "Owner", Owner, True, ErrorText);
		
		// Offers.
		ProductsTable = TableBranchInTree(DataTree, "Products");
				
		// If the table is
		// not found, for example, there
		// is an error in filling of the document tree, then do not generate an empty ED.
		If ProductsTable = Undefined Then
			Return False;
		EndIf;
		
		// If the products table
		// has no rows, do not generate empty ED.
		If ProductsTable.Rows.Count() = Undefined Then
			Return False;
		EndIf;
		
		Offers = GetCMLObjectType("OffersPackage.Offers", TargetNamespaceSchema);
		For Each ProductsTableRow IN ProductsTable.Rows Do
			
			Offer = GetCMLObjectType("OffersPackage.Offers.Offer", TargetNamespaceSchema);
			
			// Fill in product properties.
			GenerateDataByProductCML_206(Offer, ProductsTableRow, TargetNamespaceSchema, ErrorText);
			// Fill in offer properties.
			GenerateDataOnProductOffersCML_206(Offer, ProductsTableRow, TargetNamespaceSchema, ErrorText);
			
			// Add a row to the list.
			Offers.Offer.Add(Offer);
		EndDo;
		PriceList.Offers = Offers;
		
		//  Fill in the table "Types of prices".
		TablePriceTypes = TableBranchInTree(DataTree, "PriceTypes");
		
		PriceTypes = GetCMLObjectType("OffersPackage.PricesType", TargetNamespaceSchema);
		If TreeEmptyTable(TablePriceTypes) Then
			
			// If type of prices is not filled in - fill in something.
			PriceType = GetCMLObjectType("OffersPackage.PriceTypes.PriceType", TargetNamespaceSchema);
			PriceTypeIdentifier = String(New UUID);
			FillXDTOProperty(PriceType, "ID", PriceTypeIdentifier, True, ErrorText);
			PriceTypes.PriceType.Add(PriceType)
			
		Else
			// Or those in the tree.
			For Each CurRow IN TablePriceTypes.Rows Do
				
				XDTOPriceType = GetCMLObjectType("OffersPackage.PriceTypes.PriceType", TargetNamespaceSchema);
				FillInPriceType(CurRow, XDTOPriceType);
				
				PriceTypes.PriceType.Add(XDTOPriceType)
			EndDo;
		EndIf;
		// Add types of prices to price list.
		PriceList.PriceTypes = PriceTypes;
		
		// For Price list it is possible to send only unsigned data
		FillInUnSignedHeaderData(DataTree, PriceList, ErrorText);
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("OffersPackage.Party", TargetNamespaceSchema);
		Signer = GetCMLObjectType("OffersPackage.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(PriceList, "Signatories", Signatories, False, ErrorText);
		
		// Check XDTO.
		PriceList.Validate();
		BusinessInformation.OffersPackage = PriceList;
		BusinessInformation.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
 	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Purchase order.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateOrderCML(DataTree)
	
	ErrorText = "";
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	
	Try
		
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);
		
		GeneratingDate = TreeAttributeValue(DataTree, "GeneratingDate");
		FillXDTOProperty(BusinessInformation, "GeneratingDate", GeneratingDate, True, ErrorText);
		
		// Document.
		SalesDocument = GetCMLObjectType("Document", TargetNamespaceSchema);
		
		ID = TreeAttributeValue(DataTree, "ID");
		FillXDTOProperty(SalesDocument, "ID", ID, True, ErrorText);
		
		Number = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(SalesDocument, "Number", Number, True, ErrorText);
		
		Date = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(SalesDocument, "Date", Date, True, ErrorText);
		
		BusinessTransaction = TreeAttributeValue(DataTree, "BusinessTransaction");
		FillXDTOProperty(SalesDocument, "BusinessTransaction", BusinessTransaction, True, ErrorText);
		
		Currency = TreeAttributeValue(DataTree, "Currency");
		FillXDTOProperty(SalesDocument, "Currency", Currency, True, ErrorText);
		
		Comment = TreeAttributeValue(DataTree, "Comment");
		FillXDTOProperty(SalesDocument, "Comment", Comment, True, ErrorText);
		
		ExchangeRate = TreeAttributeValue(DataTree, "ExchangeRate");
		FillXDTOProperty(SalesDocument, "ExchangeRate", ExchangeRate, True, ErrorText);
		
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(SalesDocument, "Amount", Amount, True, ErrorText);
		
		Role = TreeAttributeValue(DataTree, "Role");
		FillXDTOProperty(SalesDocument, "Role", Role, True, ErrorText);

		// fill in counterparties
		Counterparties = GetCMLObjectType("Document.Counterparties", TargetNamespaceSchema);
		SchemaVersion = ElectronicDocumentsReUse.CML2SchemeVersion();
		
		// Define the role of Counterparty and company
		If Upper(Role) = Upper("Seller") Then
			CounterpartyRole = "Customer";
			CompanyRole = "Seller";
		Else
			CounterpartyRole = "Seller";
			CompanyRole = "Customer";
		EndIf;
		
		// Add Buyer to counterparties
		Customer = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Customer, DataTree, CounterpartyRole, TargetNamespaceSchema, ErrorText);
		Customer.Role = "Customer";
		Counterparties.Counterparty.Add(Customer);
		
		// add Company to counterparties
		Seller = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Seller, DataTree, CompanyRole,  TargetNamespaceSchema, ErrorText);
		Seller.Role = "Seller";
		Counterparties.Counterparty.Add(Seller);
		
		// add Consignee to counterparties
		Recipient = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Recipient, DataTree, "Recipient",  TargetNamespaceSchema, ErrorText);
		Recipient.Role = "Recipient";
		Counterparties.Counterparty.Add(Recipient);
		
		SalesDocument.Counterparties = Counterparties;
		
		// Fill in products
		Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
		StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
		
		If StringProductsTable.Rows.Count() > 0 Then
			Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
			For Each CurrentProduct IN StringProductsTable.Rows Do
				Product = GetCMLObjectType("Document.Products.Product", TargetNamespaceSchema);
				// Fill in product ID,
				// basic unit, barcode, i.e. the properties directly applied to products directory
				GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
				
				Products.Product.Add(Product);
				
			EndDo;
			
			FillXDTOProperty(SalesDocument, "Products", Products, True, ErrorText);
		EndIf;
		
		// Put additional data to AttributeValues of the document
		PutHeaderAdditData(DataTree, SalesDocument, ErrorText);
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Document.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Document.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(SalesDocument, "Signatories", Signatories, False, ErrorText);
		
		SalesDocument.Validate();
		BusinessInformation.Document.Add(SalesDocument);
		BusinessInformation.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice for payment.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateInvoiceForPaymentCML(DataTree)
	
	ErrorText = "";
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	
	Try
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);
		
		GeneratingDate = TreeAttributeValue(DataTree, "GeneratingDate");
		FillXDTOProperty(BusinessInformation, "GeneratingDate", GeneratingDate, True, ErrorText);
		
		DocumentEO = GetCMLObjectType("Document", TargetNamespaceSchema);
		
		BusinessTransaction = TreeAttributeValue(DataTree, "BusinessTransaction");
		FillXDTOProperty(DocumentEO, "BusinessTransaction", BusinessTransaction, True, ErrorText);
		
		ID = TreeAttributeValue(DataTree, "ID");
		FillXDTOProperty(DocumentEO, "ID", ID, True, ErrorText);
		
		DocNo = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(DocumentEO, "Number", DocNo, True, ErrorText);
		
		DocDate = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(DocumentEO, "Date", DocDate, True, ErrorText);
		
		PaymentDueDate = TreeAttributeValue(DataTree, "PaymentDueDate");
		FillXDTOProperty(DocumentEO, "PaymentDueDate", PaymentDueDate, True, ErrorText);
		
		Currency = TreeAttributeValue(DataTree, "Currency");
		FillXDTOProperty(DocumentEO, "Currency", Currency, True, ErrorText);
		
		ExchangeRate = TreeAttributeValue(DataTree, "ExchangeRate");
		FillXDTOProperty(DocumentEO, "ExchangeRate", ExchangeRate, True, ErrorText);
		
		DocAmount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(DocumentEO, "Amount", DocAmount, True, ErrorText);
		
		FillInCurrentAccount(DataTree, DocumentEO);
		
		// fill in counterparties
		Counterparties = GetCMLObjectType("Document.Counterparties", TargetNamespaceSchema);
		
		// Add Seller to counterparties
		Vendor = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Vendor, DataTree, "Seller", TargetNamespaceSchema, ErrorText);
		Counterparties.Counterparty.Add(Vendor);
		
		// add Customer to counterparties
		Customer = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Customer, DataTree, "Customer", TargetNamespaceSchema, ErrorText);
		Counterparties.Counterparty.Add(Customer);
		
		DocumentEO.Counterparties = Counterparties;
		DocumentEO.Role = "Seller";
		
		VATTotal = TreeAttributeValue(DataTree, "TotalByDocument.VATAmount");
		VATIncludedInCost = TreeAttributeValue(DataTree, "TotalByDocument.PriceIncludesVAT");
		
		Tax = GetCMLObjectType("Document.Taxes.Tax", TargetNamespaceSchema);
		Tax.Description = "VAT";
		Tax.IncludedInAmount = VATIncludedInCost;
		Tax.Amount = VATTotal;
		
		DocumentEOTaxes = GetCMLObjectType("Document.Taxes", TargetNamespaceSchema);
		DocumentEOTaxes.Tax.Add(Tax);
		
		DocumentEO.Taxes = DocumentEOTaxes;
		
		BasisDocumentNumber = TreeAttributeValue(DataTree, "BasisDocument.BasisDocumentNumber");
		BasisDocumentDate = TreeAttributeValue(DataTree, "BasisDocument.BasisDocumentDate");
		If ValueIsFilled(BasisDocumentNumber) AND ValueIsFilled(BasisDocumentDate) Then
			
			AddToDocumentAttributeValues("BasisDocumentNumber", BasisDocumentNumber, DocumentEO);
			AddToDocumentAttributeValues("BasisDocumentDate", BasisDocumentDate, DocumentEO);
			
			DocumentNameGrounds = TreeAttributeValue(DataTree, "BasisDocument.BasisDocumentName");
			DocumentCommentGrounds = TreeAttributeValue(DataTree, "GroundsDocument.Comment");
			
			AddToDocumentAttributeValues("DocumentNameGrounds", DocumentNameGrounds, DocumentEO);
			AddToDocumentAttributeValues("DocumentCommentGrounds", DocumentCommentGrounds, DocumentEO);
			
		EndIf;
		
		PartialPayment = TreeAttributeValue(DataTree, "PartialPayment");
		If Not ValueIsFilled(PartialPayment) Then
			PartialPayment = False;
		EndIf;
		
		If Not PartialPayment Then
			Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
			
			StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
			
			If StringProductsTable.Rows.Count() > 0 Then
				Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
				For Each CurrentProduct IN StringProductsTable.Rows Do
					Product = GetCMLObjectType("Document.Products.Product", TargetNamespaceSchema);
					// Fill in product ID,
					// basic unit, barcode, i.e. the properties directly applied to products directory
					GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
					
					Products.Product.Add(Product);
				EndDo;
				
				FillXDTOProperty(DocumentEO, "Products", Products, True, ErrorText);
			EndIf;
		EndIf;
		
		// Generate string of additional data and file
		PutHeaderAdditData(DataTree, DocumentEO, ErrorText);
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Document.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Document.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(DocumentEO, "Signatories", Signatories, False, ErrorText);
		
		BusinessInformation.Document.Add(DocumentEO);
		BusinessInformation.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Report on commission goods writeoff.
//
// Parameters:
//  ParametersStructure - structure of parameters for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateComissionGoodsWriteOffReportCML(DataTree)
	
	ErrorText = "";
		
	Try
		
		TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
		
		// Business information
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);
		
		GeneratingDate = TreeAttributeValue(DataTree, "GeneratingDate");
		FillXDTOProperty(BusinessInformation, "GeneratingDate", GeneratingDate, True, ErrorText);

		DocumentEO = GetCMLObjectType("Document", TargetNamespaceSchema);
		
		FillXDTOProperty(DocumentEO, "BusinessTransaction", "Report on the commission goods depreciation", True, ErrorText);
		FillXDTOProperty(DocumentEO, "Role", "Consignor", True, ErrorText);

		ID = TreeAttributeValue(DataTree, "ID");
		FillXDTOProperty(DocumentEO, "ID", ID, True, ErrorText);
		
		DocNo = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(DocumentEO, "Number", DocNo, True, ErrorText);
		
		DocDate = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(DocumentEO, "Date", DocDate, True, ErrorText);
		
		Currency = TreeAttributeValue(DataTree, "Currency");
		FillXDTOProperty(DocumentEO, "Currency", Currency, True, ErrorText);
		
		ExchangeRate = TreeAttributeValue(DataTree, "ExchangeRate");
		FillXDTOProperty(DocumentEO, "ExchangeRate", ExchangeRate, True, ErrorText);
		
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(DocumentEO, "Amount", Amount, True, ErrorText);
		
		// fill in counterparties
		Counterparties = GetCMLObjectType("Document.Counterparties", TargetNamespaceSchema);
		SchemaVersion = ElectronicDocumentsReUse.CML2SchemeVersion();
		
		// Add Principal to counterparties
		Consignor = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Consignor, DataTree, "Consignor", TargetNamespaceSchema, ErrorText);
		Consignor.Role = "Consignor";
		Counterparties.Counterparty.Add(Consignor);
		
		// add Company to counterparties
		Agent = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Agent, DataTree, "Agent", TargetNamespaceSchema, ErrorText);
		Agent.Role = "Agent";
		Counterparties.Counterparty.Add(Agent);
		
		DocumentEO.Counterparties = Counterparties;
		
		// Fill in products
		Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
		
		StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
		
		If StringProductsTable.Rows.Count() > 0 Then
			Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
			For Each CurrentProduct IN StringProductsTable.Rows Do
				Product = GetCMLObjectType("Document.Products.Product", TargetNamespaceSchema);
				// Fill in product ID,
				// basic unit, barcode, i.e. the properties directly applied to products directory
				GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
				
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(DocumentEO, "Products", Products, True, ErrorText);
		EndIf;
		
		
		// Put additional data to AttributeValues of the document
		PutHeaderAdditData(DataTree, DocumentEO, ErrorText);
		
		TotalRow = TreeAttributeValue(DataTree, "TotalsInWords");
		AddToDocumentAttributeValues("TotalsInWords", TotalRow, DocumentEO);
		
		TotalByDocument = TreeAttributeValue(DataTree, "TotalByDocument");
		AddToDocumentAttributeValues("TotalByDocument", TotalByDocument, DocumentEO);
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Document.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Document.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(DocumentEO, "Signatories", Signatories, False, ErrorText);
		
		BusinessInformation.Document.Add(DocumentEO);
		BusinessInformation.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Report on commission goods sales.
//
// DataTree
// Parameters - Values Tree - Group tree that contains data to create ED
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateReportAboutComissionGoodsSalesCML(DataTree)
	
	ErrorText = "";
	ProductsTable = New ValueTable;
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	Try
		
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);
		
		GeneratingDate = TreeAttributeValue(DataTree, "GeneratingDate");
		FillXDTOProperty(BusinessInformation, "GeneratingDate", GeneratingDate, True, ErrorText);
		
		// Document.
		SalesDocument = GetCMLObjectType("Document", TargetNamespaceSchema);
		
		ID = TreeAttributeValue(DataTree, "ID");
		FillXDTOProperty(SalesDocument, "ID", ID, True, ErrorText);
		
		Number = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(SalesDocument, "Number", Number, True, ErrorText);
		
		Date = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(SalesDocument, "Date", Date, True, ErrorText);
		
		BusinessTransaction = TreeAttributeValue(DataTree, "BusinessTransaction");
		FillXDTOProperty(SalesDocument, "BusinessTransaction", BusinessTransaction, True, ErrorText);
		
		Role = TreeAttributeValue(DataTree, "Role");
		FillXDTOProperty(SalesDocument, "Role", Role, True, ErrorText);
		
		Currency = TreeAttributeValue(DataTree, "Currency");
		FillXDTOProperty(SalesDocument, "Currency", Currency, True, ErrorText);
		
		ExchangeRate = TreeAttributeValue(DataTree, "ExchangeRate");
		FillXDTOProperty(SalesDocument, "ExchangeRate", ExchangeRate, True, ErrorText);
		
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(SalesDocument, "Amount", Amount, True, ErrorText);
		
		// fill in counterparties
		Counterparties = GetCMLObjectType("Document.Counterparties", TargetNamespaceSchema);
		SchemaVersion = ElectronicDocumentsReUse.CML2SchemeVersion();
		
		// Add Principal to counterparties
		Consignor = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Consignor, DataTree, "Consignor", TargetNamespaceSchema, ErrorText);
		Consignor.Role = "Consignor";
		Counterparties.Counterparty.Add(Consignor);
		
		// add Company to counterparties
		Agent = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Agent, DataTree, "Agent",  TargetNamespaceSchema, ErrorText);
		Agent.Role = "Agent";
		Counterparties.Counterparty.Add(Agent);
		
		SalesDocument.Counterparties = Counterparties;
		
		// Put additional data to AttributeValues of the document
		PutHeaderAdditData(DataTree, SalesDocument, ErrorText);
		
		// Fill in products
		Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
		StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
		
		If StringProductsTable.Rows.Count() > 0 Then
			Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
			AddedBuyersArray = New Array;
			For Each CurrentProduct IN StringProductsTable.Rows Do
				Product = GetCMLObjectType("Document.Products.Product", TargetNamespaceSchema);
				// Fill in product ID,
				// basic unit, barcode, i.e. the properties directly applied to products directory
				GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
				
				// Fill in the properties of the goods that applied to the document
				GenerateDataOnTabularSectionCMLDocumentProducts_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
				
				
				// Add customer to counterparties
				If CommonUseED.AttributeExistsInTree(CurrentProduct, "Products.LineNumber.Customer") Then
					Customer = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
					AddData = "";
					FillCMLParticipantData(Customer, CurrentProduct, "Products.LineNumber.Customer", TargetNamespaceSchema, ErrorText, AddData);
					CustomerID = "";
					If AddData.Property("ID", CustomerID) Then
						If AddedBuyersArray.Find(CustomerID) = Undefined Then
							Customer.Role = "Customer";
							Counterparties.Counterparty.Add(Customer);
							AddedBuyersArray.Add(CustomerID);
						EndIf;
						
						AttributeValues = GetCMLObjectType("Document.Products.Product.AdditionalAttributeValues", TargetNamespaceSchema);
						AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
						FillXDTOProperty(AttributeValue, "Description", "CustomerID", True, ErrorText);
						AttributeValue.Value.Add(CustomerID);
						AttributeValues.AttributeValue.Add(AttributeValue);
						
						// For compatibility with earlier BED versions it is required to send 3 more attributes:
						AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
						FillXDTOProperty(AttributeValue, "Description", "CustomerDescription", True, ErrorText);
						AttributeValue.Value.Add(AddData.Description);
						AttributeValues.AttributeValue.Add(AttributeValue);
						
						AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
						FillXDTOProperty(AttributeValue, "Description", "CustomerTIN", True, ErrorText);
						AttributeValue.Value.Add(AddData.TIN);
						AttributeValues.AttributeValue.Add(AttributeValue);
						
						AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
						FillXDTOProperty(AttributeValue, "Description", True, ErrorText);
						AttributeValues.AttributeValue.Add(AttributeValue);
						Product.AdditionalAttributeValues = AttributeValues;
					EndIf;
				EndIf;
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(SalesDocument, "Products", Products, True, ErrorText);
		EndIf;
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Document.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Document.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(SalesDocument, "Signatories", Signatories, False, ErrorText);
		
		SalesDocument.Validate();
		BusinessInformation.Document.Add(SalesDocument);
		BusinessInformation.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;

		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Agreement on.
//
// Parameters
//  DataTree - ValuesTree, contains data for ED generation
//
// Returns:
//  Boolean - flag of successful generation
//
Function FormTransferOfAuthorityActCML(DataTree)
	
	ErrorText = "";
	FileIsFormed = False;
	
	TargetNamespaceSchema = "urn:1C.ru:commerceml_2";
	Try
		BusinessInformation = GetCMLObjectType("BusinessInformation", TargetNamespaceSchema);
		Document = GetCMLObjectType("Document", TargetNamespaceSchema);
		
		// Business information.
		SchemaVersion = TrimAll(StrReplace(TreeAttributeValue(DataTree, "SchemaVersion"), "CML", ""));
		FillXDTOProperty(BusinessInformation, "SchemaVersion", SchemaVersion, True, ErrorText);

		FillXDTOProperty(BusinessInformation, "GeneratingDate", XMLDateTime(TreeAttributeValue(DataTree,
			"GeneratingDate")), True, ErrorText);
		
		// Document.
		FillXDTOProperty(Document, "ID",			TreeAttributeValue(DataTree, "ID"),		True, ErrorText);
		FillXDTOProperty(Document, "Number",		TreeAttributeValue(DataTree, "Number"),	True, ErrorText);
		FillXDTOProperty(Document, "Date",			TreeAttributeValue(DataTree, "Date"),		True, ErrorText);
		FillXDTOProperty(Document, "BusinessTransaction",	TreeAttributeValue(DataTree, "BusinessTransaction"),True,ErrorText);
		FillXDTOProperty(Document, "Role",			TreeAttributeValue(DataTree, "Role"),		True, ErrorText);
		FillXDTOProperty(Document, "Currency",		TreeAttributeValue(DataTree, "Currency"),	True, ErrorText);
		FillXDTOProperty(Document, "ExchangeRate",			TreeAttributeValue(DataTree, "ExchangeRate"),		True, ErrorText);
		FillXDTOProperty(Document, "Amount",		TreeAttributeValue(DataTree, "Amount"),	True, ErrorText);
		
		// Licensor.
		Licensor = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Licensor, DataTree, "Licensor", TargetNamespaceSchema, ErrorText);
		
		// Licensee.
		Licensee = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Licensee, DataTree, "Licensee", TargetNamespaceSchema, ErrorText);
		
		Counterparties = GetCMLObjectType("Document.Counterparties", TargetNamespaceSchema);
		Counterparties.Counterparty.Add(Licensor);
		Counterparties.Counterparty.Add(Licensee);
		
		// Payer.
		If TreeAttributeValue(DataTree, "Payer") = True Then
			Payer = GetCMLObjectType("Document.Counterparties.Counterparty", TargetNamespaceSchema);
			FillCMLParticipantData(Payer, DataTree, "Payer", TargetNamespaceSchema, ErrorText);
			Counterparties.Counterparty.Add(Payer);
		EndIf;
		FillXDTOProperty(Document, "Counterparties", Counterparties, True, ErrorText);
		
		// PaymentDueDate.
		PaymentDueDate = TreeAttributeValue(DataTree, "PaymentDueDate");
		If ValueIsFilled(PaymentDueDate) Then
			FillXDTOProperty(Document, "PaymentDueDate", PaymentDueDate, , ErrorText);
		EndIf;
		
		// Comment.
		Comment = TreeAttributeValue(DataTree, "Comment");
		If ValueIsFilled(Comment) Then
			FillXDTOProperty(Document, "Comment", Comment, , ErrorText);
		EndIf;
		
		// Taxes.
		Taxes = DataTree.Rows.Find("Taxes", "FullPath");
		If ValueIsFilled(Taxes.Value) Then
			Attribute = FillXDTOListWithSameNameTreeParameters(Taxes, "Document.Taxes", "Tax", TargetNamespaceSchema, ErrorText);
			If Attribute <> Undefined Then
				FillXDTOProperty(Document, "Taxes", Attribute, , ErrorText);
			EndIf;
		EndIf;
		
		// Discounts.
		Discounts = DataTree.Rows.Find("Discounts", "FullPath");
		If ValueIsFilled(Discounts.Value) Then
			Attribute = FillXDTOListWithSameNameTreeParameters(Discounts, "Document.Discounts", "Discount", TargetNamespaceSchema, ErrorText);
			If Attribute <> Undefined Then
				FillXDTOProperty(Document, "Discounts", Attribute, , ErrorText);
			EndIf;
		EndIf;
		
		// AddExpenses.
		AdditExpenses = DataTree.Rows.Find("AdditExpenses", "FullPath");
		If ValueIsFilled(AdditExpenses.Value) Then
			Attribute = FillXDTOListWithSameNameTreeParameters(AdditExpenses, "Document.AdditExpenses", "AdditExpense", TargetNamespaceSchema, ErrorText);
			If Attribute <> Undefined Then
				FillXDTOProperty(Document, "AdditExpenses", Attribute, , ErrorText);
			EndIf;
		EndIf;
		
		// Products.
		StringProductsTable = DataTree.Rows.Find("Products", "FullPath");
		If StringProductsTable.Rows.Count() > 0 Then
			Products = GetCMLObjectType("Document.Products", TargetNamespaceSchema);
			For Each CurrentProduct IN StringProductsTable.Rows Do
				Product = GetCMLObjectType("Document.Products.Product", TargetNamespaceSchema);
				
				GenerateDataByProductCML_206(Product, CurrentProduct, TargetNamespaceSchema, ErrorText);
					
				Products.Product.Add(Product);
			EndDo;
			FillXDTOProperty(Document, "Products", Products, True, ErrorText);
		EndIf;
		
		// Generate string and file of additional data
		PutHeaderAdditData(DataTree, Document, ErrorText);
		
		// Add preset of Signatory for filling at signing
		Signatories = GetCMLObjectType("Document.Signatories", TargetNamespaceSchema);
		Signer = GetCMLObjectType("Document.Signatories.Signer", TargetNamespaceSchema);
		FillXDTOProperty(Signer, "Surname", "-", True, ErrorText);
		FillXDTOProperty(Signer, "Name", "-", True, ErrorText);
		Signatories.Signer.Add(Signer);
		FillXDTOProperty(Document, "Signatories", Signatories, False, ErrorText);
		
		BusinessInformation.Document.Add(Document);
		
		// Record of the electronic document file.
		BusinessInformation.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
		Else
			ExportEDtoFile(BusinessInformation, TreeAttributeValue(DataTree, "FullFileName"));
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

Function GenerateCompanyDetailsCML(DataTree)
	
	ErrorText = "";
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	
	Try
		
		Counterparty = GetCMLObjectType("Counterparty", TargetNamespaceSchema);
		FillCMLParticipantData(Counterparty, DataTree, "Company", TargetNamespaceSchema, ErrorText);
		
		RowCurrentAccounts = DataTree.Rows.Find("BankAccounts", "FullPath");
		If ValueIsFilled(RowCurrentAccounts.Value) Then
			
			BankAccounts = Counterparty.BankAccounts;
			If BankAccounts = Undefined Then
				BankAccounts = GetCMLObjectType("Counterparty.CurrentAccounts", TargetNamespaceSchema);
			EndIf;
			
			For Each RowWithAccount IN RowCurrentAccounts.Rows Do
				
				If Not ValueIsFilled(RowWithAccount.Value) Then
					Continue;
				EndIf;
				
				CounterpartyBankAcc = GetCMLObjectType("BankAccount", TargetNamespaceSchema);
				
				AccountNo = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.AccountNo");
				FillXDTOProperty(CounterpartyBankAcc, "AccountNo", AccountNo, True, ErrorText);
				
				// Fill in a bank.
				CurrentAccountsBank = GetCMLObjectType("Bank", TargetNamespaceSchema);
				
				BankBic = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankBIN");
				FillXDTOProperty(CurrentAccountsBank, "BIN", BankBic, True, ErrorText);
				
				
				AccountCorrespondent = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.CorrBankAccount");
				If ValueIsFilled(AccountCorrespondent) Then
					FillXDTOProperty(CurrentAccountsBank, "AccountCorrespondent", AccountCorrespondent, True, ErrorText);
				EndIf;
				
				SWIFT = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankSWIFT");
				If ValueIsFilled(SWIFT) Then
					FillXDTOProperty(CurrentAccountsBank, "SWIFT", SWIFT, True, ErrorText);
				EndIf;
				
				BankDescription = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankBasicUnitName");
				FillXDTOProperty(CurrentAccountsBank, "Description", BankDescription, True, ErrorText);
				// add bank to current account
				CounterpartyBankAcc.Bank = CurrentAccountsBank;
				
				// fill in correspondent bank
				CurrentAccountCorBank = GetCMLObjectType("Bank", TargetNamespaceSchema);
				
				BicCorrBank = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankBINCorr");
				
				ThereIsCorrBank = False;
				If ValueIsFilled(BicCorrBank) Then
					FillXDTOProperty(CurrentAccountCorBank, "BIN", BicCorrBank, True, ErrorText);
					ThereIsCorrBank = True;
				EndIf;
				
				BalancedAccountCorrespondent = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankCorrAccountCorr");
				If ValueIsFilled(BalancedAccountCorrespondent) Then
					FillXDTOProperty(CurrentAccountCorBank, "AccountCorrespondent", BalancedAccountCorrespondent, True, ErrorText);
					ThereIsCorrBank = True;
				EndIf;
				
				SWIFTCorrespondent = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankSWIFTCorr");
				If ValueIsFilled(SWIFTCorrespondent) Then
					FillXDTOProperty(CurrentAccountCorBank, "SWIFT", SWIFTCorrespondent, True, ErrorText);
				EndIf;
				
				CorBankName = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.BankCorpBasicUnitName");
				If ValueIsFilled(CorBankName) Then
					FillXDTOProperty(CurrentAccountCorBank, "Description", CorBankName, True, ErrorText);
					ThereIsCorrBank = True;
				EndIf;
				
				// add correspondent bank to current account
				If ThereIsCorrBank Then
					CounterpartyBankAcc.CorrespondentBank = CurrentAccountCorBank;
				EndIf;
				
				Comment = TreeAttributeValue(RowWithAccount, "BankAccounts.LineNumber.Comment");
				If ValueIsFilled(Comment) Then
					CounterpartyBankAcc.Comment = Comment;
				EndIf;
				
				BankAccounts.BankAccount.Add(CounterpartyBankAcc);
			EndDo;
			
			Counterparty.BankAccounts = BankAccounts;
		EndIf;
		
		Counterparty.Validate();
		
		ExportEDtoFile(Counterparty, TreeAttributeValue(DataTree, "FullFileName"));
		FileIsFormed = True;
		
	Except
		
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Outdated - Generation of ED CML from DB documents

// Returns the result of successful generation of ED file with the directory of products
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateCMLCatalog(ParametersStructure)
	
	ErrorText = "";
	Try
		DirectoryEO = GetCMLObjectType("Directory", ParametersStructure.SchemaVersion);
		
		// Business information.
		FillXDTOProperty(DirectoryEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DirectoryEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True,
			ErrorText);
		FillXDTOProperty(DirectoryEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		FillXDTOProperty(DirectoryEO, "ID", ParametersStructure.ID, True, ErrorText);
		
		// Owner.
		Owner = GetCMLObjectType("Counterparty", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Owner, ParametersStructure, "Company", ErrorText,
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(DirectoryEO, "Owner", Owner, True, ErrorText);
		
		// Products.
		ProductsTable = ParametersStructure.ProductsTable;
		If ProductsTable.Count() > 0 Then
			Products = GetCMLObjectType("Directory.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				Product = GetCMLObjectType("Directory.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				Products.Product.Add(Product);
			EndDo;
			FillXDTOProperty(DirectoryEO, "Products", Products, True, ErrorText);
		EndIf;
		
		// Record of the electronic document file.
		DirectoryEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DirectoryEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of file ED Invoice for payment.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateInvoiceForPaymentCML(ParametersStructure)
	
	ErrorText = "";
	
	Try
		DocumentEO = GetCMLObjectType("InvoiceForPayment",ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True, ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		
		RecipientAttributes = GetCMLObjectType("InvoiceForPayment.RecipientDetails", ParametersStructure.SchemaVersion);
		FillXDTOProperty(RecipientAttributes, "AccountNo", ParametersStructure.BankAccount.AccountNo, True, ErrorText);
		
		// Bank
		Bank =  GetCMLObjectType("Bank", ParametersStructure.SchemaVersion);
		FillXDTOProperty(Bank, "AccountCorrespondent", ParametersStructure.BankAccount.CorrAccount, , ErrorText);
		FillXDTOProperty(Bank, "Description", ParametersStructure.BankAccount.Bank, , ErrorText);
		FillXDTOProperty(Bank, "BIN", ParametersStructure.BankAccount.BIN, True, ErrorText);
		FillXDTOProperty(RecipientAttributes, "Bank", Bank, True, ErrorText);
		
		// CorrespondentBank
		If ParametersStructure.Property("CorrespondentBank") Then
			CorrespondentBank =  GetCMLObjectType("Bank", ParametersStructure.SchemaVersion);
			FillXDTOProperty(CorrespondentBank, "AccountCorrespondent", ParametersStructure.CorrespondentBank.CorrAccount, , ErrorText);
			FillXDTOProperty(CorrespondentBank, "Description", ParametersStructure.CorrespondentBank.Bank, , ErrorText);
			FillXDTOProperty(CorrespondentBank, "BIN", ParametersStructure.CorrespondentBank.BIN, True, ErrorText);
			FillXDTOProperty(RecipientAttributes, "CorrespondentBank", CorrespondentBank, True, ErrorText);
		EndIf;
		
		FillXDTOProperty(DocumentEO, "RecipientAttributes", RecipientAttributes, True, ErrorText);
		FillXDTOProperty(DocumentEO, "PaymentDestination", ParametersStructure.PaymentDestination, True, ErrorText);
		FillXDTOProperty(DocumentEO, "AccountExpirationDate", ParametersStructure.PaymentDueDate, True, ErrorText);
		
		Vendor = GetCMLObjectType("InvoiceForPayment.Vendor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Vendor, ParametersStructure, "Company", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Vendor", Vendor, , ErrorText);
		
		Customer = GetCMLObjectType("InvoiceForPayment.Customer", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Customer, ParametersStructure, "Counterparty", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Customer", Customer, , ErrorText);
		
		TotalByDocument = GetCMLObjectType("InvoiceForPayment.TotalByDocument", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "AmountTotal", ParametersStructure.Amount, True, ErrorText);
		FillXDTOProperty(TotalByDocument, "TaxAmountTotal", ParametersStructure.VATAmount, , ErrorText);
		FillXDTOProperty(TotalByDocument, "PriceIncludesTax", ParametersStructure.PriceIncludesVAT, , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "TotalsInWords", ParametersStructure.TotalsInWords, , ErrorText);
		
		Head = GetCMLObjectType("IndividualAttributes", ParametersStructure.SchemaVersion);
		FillXDTOProperty(Head,
							  "FullDescr", 
							  ElectronicDocuments.SurnameInitialsOfIndividual(ParametersStructure.Head),
							  True,
							  ErrorText);
		FillXDTOProperty(DocumentEO, "Head", Head, True, ErrorText);
		
		Accountant = GetCMLObjectType("IndividualAttributes", ParametersStructure.SchemaVersion);
		FillXDTOProperty(Accountant, "FullDescr",
			ElectronicDocuments.SurnameInitialsOfIndividual(ParametersStructure.Accountant), True, ErrorText);
		FillXDTOProperty(DocumentEO, "Accountant", Accountant, True, ErrorText);
		
		If ParametersStructure.Property("NumberByCustomerData")
			AND ParametersStructure.Property("DateByCustomerData")
			AND ValueIsFilled(ParametersStructure.NumberByCustomerData)
			AND ValueIsFilled(ParametersStructure.DateByCustomerData) Then
			
			BasisDocuments = GetCMLObjectType("BasisDocuments", ParametersStructure.SchemaVersion);
			FillXDTOProperty(BasisDocuments, "BasisDocumentNumber", ParametersStructure.NumberByCustomerData, True, ErrorText);
			FillXDTOProperty(BasisDocuments, "BasisDocumentDate", ParametersStructure.DateByCustomerData, True, ErrorText);
			FillXDTOProperty(BasisDocuments, "BasisDocumentDescription", ParametersStructure.BasisDocument, True, ErrorText);
			DocumentEO.BasisDocuments.Add(BasisDocuments);
		EndIf;
		
		If ParametersStructure.Property("Currency") AND ValueIsFilled (ParametersStructure.Currency) Then
			Currency =  GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("PartialPayment") Then
			PartialPayment = ParametersStructure.PartialPayment;
		Else
			PartialPayment = False;
		EndIf;
		
		ProductsTable = New ValueTable;
		
		If ParametersStructure.Property("ProductsTable") Then
			ProductsTable = ParametersStructure.ProductsTable;
		EndIf;
		
		If Not PartialPayment Then
			If ProductsTable.Count() > 0 Then
				
				Products = GetCMLObjectType("InvoiceForPayment.Products", ParametersStructure.SchemaVersion);
				For Each CurProduct IN ProductsTable Do
					
					Product = GetCMLObjectType("InvoiceForPayment.Products.Product", ParametersStructure.SchemaVersion);
					GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
					
					FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, True, ErrorText);
					
					MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
					
					UnOfMeasStructure = New Structure();
					UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
					UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
					UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
					GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
					FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
					
					If ParametersStructure.PriceIncludesVAT Then
						AmountWithoutVAT = CurProduct.Amount - CurProduct.VATAmount;
					Else
						AmountWithoutVAT = CurProduct.Amount;
					EndIf;
					FillXDTOProperty(Product, "Price", CurProduct.Price, , ErrorText);
					
					Cost = GetCMLObjectType("Cost", ParametersStructure.SchemaVersion);
					FillXDTOProperty(Cost, "AmountWithoutTax", AmountWithoutVAT, , ErrorText);
					FillXDTOProperty(Cost, "TaxAmount", CurProduct.VATAmount, , ErrorText);
					FillXDTOProperty(Cost, "AmountTotal", CurProduct.SumWithVAT, True, ErrorText);
					
					// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
					TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
					FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
					FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
					
					TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
					If TaxRateVATAsNumber <> Undefined Then
						FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
					EndIf;
					Cost.Tax.Add(TaxByString);
					FillXDTOProperty(Product, "AmountsByProduct", Cost, True, ErrorText);
					
					If Not ProductsTable.Columns.Find("DiscountAmount") = Undefined AND ValueIsFilled(CurProduct.DiscountAmount) Then
						DiscountsByString =  GetCMLObjectType("InvoiceForPayment.Products.Product.Discounts", ParametersStructure.SchemaVersion);
						DiscountByString =  GetCMLObjectType("Discount", ParametersStructure.SchemaVersion);
						
						FillXDTOProperty(DiscountByString, "Description", "TotalDiscount", True, ErrorText);
						FillXDTOProperty(DiscountByString, "Amount", CurProduct.DiscountAmount, True, ErrorText);
						
						DiscountsByString.Discount.Add(DiscountByString);
						
						FillXDTOProperty(DiscountsByString, "DiscountsAmount", CurProduct.DiscountAmount, , ErrorText);
						FillXDTOProperty(DiscountsByString, "AmountWithoutDiscounts", CurProduct.Amount - CurProduct.DiscountAmount, , ErrorText);
						FillXDTOProperty(Product, "Discounts", DiscountsByString, , ErrorText);
					EndIf;
					
					Products.Product.Add(Product);
				EndDo;
				
				FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
			EndIf;
			
		EndIf;
		
		If ParametersStructure.Property("PaymentScheduleStagesTable") THEN
			PaymentScheduleStagesTable = ParametersStructure.PaymentScheduleStagesTable;
			If PaymentScheduleStagesTable.Count() > 0 Then
				
				ColumnArray = New Array();
				For Each Column in PaymentScheduleStagesTable.Columns Do
					ColumnArray.Add(Column.Name);
				EndDo;
				
				For Each CurStage IN PaymentScheduleStagesTable Do
					PaymentScheduleStage = GetCMLObjectType("PaymentSchedule", ParametersStructure.SchemaVersion);
					GenerateDataByPaymentScheduleStagesCML(PaymentScheduleStage, CurStage, ErrorText, ColumnArray);
					DocumentEO.PaymentStage.Add(PaymentScheduleStage);
				EndDo;
				
			EndIf;
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Report on commission goods writeoff.
//
// Parameters:
//  ParametersStructure - structure of parameters for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateComissionGoodsWriteOffReportCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("ComissionGoodsWriteOffReport", ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True, ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		
		Consignor = GetCMLObjectType("ComissionGoodsWriteOffReport.Principal", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignor, ParametersStructure, "Counterparty", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Consignor", Consignor, , ErrorText);
		
		Agent = GetCMLObjectType("ComissionGoodsWriteOffReport.Agent", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Agent, ParametersStructure, "Company", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Agent", Agent, , ErrorText);
		
		If ProductsTable.Count() > 0 Then
			Products = GetCMLObjectType("ComissionGoodsWriteOffReport.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				Product = GetCMLObjectType("ComissionGoodsWriteOffReport.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, True, ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				FillXDTOProperty(Product, "Price", Round(CurProduct.SumWithVAT / CurProduct.Quantity, 2), True, ErrorText);
				FillXDTOProperty(Product, "Amount", CurProduct.SumWithVAT, True, ErrorText);
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		FillXDTOProperty(DocumentEO, "TotalByDocument", ParametersStructure.Amount, True, ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", ParametersStructure.TotalRow, True, ErrorText);
		
		If ParametersStructure.Property("Currency") AND ValueIsFilled (ParametersStructure.Currency) Then
			Currency = GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, ,  ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Purchase order.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
// OUTDATED
//
Function DeleteGenerateOrderCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("CustomerOrder", ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True,
			ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Role", ParametersStructure.Role, True, ErrorText);
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		
		Performer = GetCMLObjectType("CustomerOrder.Contractor", ParametersStructure.SchemaVersion);
		If ParametersStructure.Role = "Customer" Then
			GenerateDataByCounterpartyCML(Performer, ParametersStructure, "Counterparty", ErrorText,
				ParametersStructure.SchemaVersion);
		ElsIf ParametersStructure.Role = "Seller" Then
			GenerateDataByCounterpartyCML(Performer, ParametersStructure, "Company", ErrorText,
				ParametersStructure.SchemaVersion);
		EndIf;
		FillXDTOProperty(DocumentEO, "Performer", Performer, , ErrorText);
		
		Customer = GetCMLObjectType("CustomerOrder.Customer", ParametersStructure.SchemaVersion);
		If ParametersStructure.Role = "Customer" Then
			GenerateDataByCounterpartyCML(Customer, ParametersStructure, "Company", ErrorText,
				ParametersStructure.SchemaVersion);
		ElsIf ParametersStructure.Role = "Seller" Then
			GenerateDataByCounterpartyCML(Customer, ParametersStructure, "Counterparty", ErrorText,
				ParametersStructure.SchemaVersion);
		EndIf;
		FillXDTOProperty(DocumentEO, "Customer", Customer, , ErrorText);
		
		If ProductsTable.Count() > 0 Then
			Products = GetCMLObjectType("CustomerOrder.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				Product = GetCMLObjectType("CustomerOrder.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, True, ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				
				If ParametersStructure.PriceIncludesVAT Then
					AmountWithoutVAT = CurProduct.Amount - CurProduct.VATAmount;
				Else
					AmountWithoutVAT = CurProduct.Amount;
				EndIf;
				FillXDTOProperty(Product, "Price", CurProduct.Price, , ErrorText);
				
				Cost = GetCMLObjectType("Cost", ParametersStructure.SchemaVersion);
				FillXDTOProperty(Cost, "AmountWithoutTax", AmountWithoutVAT, , ErrorText);
				FillXDTOProperty(Cost, "TaxAmount", CurProduct.VATAmount, , ErrorText);
				FillXDTOProperty(Cost, "AmountTotal", CurProduct.SumWithVAT, True, ErrorText);
				
				// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				Cost.Tax.Add(TaxByString);
				FillXDTOProperty(Product, "AmountsByProduct", Cost, True, ErrorText);
				
				If ValueIsFilled(CurProduct.DiscountAmount) Then
					DiscountsByString = GetCMLObjectType("CustomerOrder.Products.Product.Discounts", ParametersStructure.SchemaVersion);
					DiscountByString = GetCMLObjectType("Discount", ParametersStructure.SchemaVersion);
					
					FillXDTOProperty(DiscountByString, "Description", "TotalDiscount", True, ErrorText);
					FillXDTOProperty(DiscountByString, "Amount", CurProduct.DiscountAmount, True, ErrorText);
					FillXDTOProperty(DiscountByString, "Percent", CurProduct.DiscountPercent, True, ErrorText);
					DiscountsByString.Discount.Add(DiscountByString);
					
					FillXDTOProperty(DiscountsByString, "DiscountsAmount", CurProduct.DiscountAmount, , ErrorText);
					FillXDTOProperty(DiscountsByString, "AmountWithoutDiscounts", CurProduct.Amount - CurProduct.DiscountAmount, , ErrorText);
					FillXDTOProperty(Product, "Discounts", DiscountsByString, , ErrorText);
				EndIf;
				
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		TotalByDocument = GetCMLObjectType("CustomerOrder.TotalByDocument", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "AmountTotal", ParametersStructure.Amount, True, ErrorText);
		FillXDTOProperty(TotalByDocument, "TaxAmountTotal", ParametersStructure.VATAmount, True, ErrorText);
		FillXDTOProperty(TotalByDocument, "AmountWithoutDiscountTotal", ProductsTable.Total("Amount")
			- ProductsTable.Total("DiscountAmount"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "DiscountAmountTotal", ProductsTable.Total("DiscountAmount"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "PriceIncludesTax", ParametersStructure.PriceIncludesVAT, , ErrorText);
		
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, True, ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", ParametersStructure.TotalsInWords, , ErrorText);
		
		If ParametersStructure.Property("NumberByCustomerData")
			AND ValueIsFilled (ParametersStructure.NumberByCustomerData) Then
			
			BasisDocument = GetCMLObjectType("BasisDocuments", ParametersStructure.SchemaVersion);
			FillXDTOProperty(BasisDocument, "BasisDocumentNumber", ParametersStructure.NumberByCustomerData);
			FillXDTOProperty(BasisDocument, "BasisDocumentDate", ParametersStructure.DateByCustomerData);
			FillXDTOProperty(BasisDocument, "BasisDocumentDescription", "Based on client data");
			DocumentEO.BasisDocuments.Add(BasisDocument);
		EndIf;
		
		If ParametersStructure.Property("NumberBySupplierData")
			AND ValueIsFilled (ParametersStructure.NumberBySupplierData) Then
			
			BasisDocument = GetCMLObjectType("BasisDocuments",ParametersStructure.SchemaVersion);
			
			FillXDTOProperty(BasisDocument, "BasisDocumentNumber", ParametersStructure.NumberBySupplierData);
			FillXDTOProperty(BasisDocument, "BasisDocumentDate", ParametersStructure.DateBySupplierData);
			FillXDTOProperty(BasisDocument, "BasisDocumentDescription", "Based on vendor data");
			DocumentEO.BasisDocuments.Add(BasisDocument);
		EndIf;
		
		If ParametersStructure.Property("Currency") AND ValueIsFilled (ParametersStructure.Currency) Then
			Currency =  GetCMLObjectType("Currency", ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("ShippingAddress") Then
			ShippingAddress = ParametersStructure.ShippingAddress;
			ShippingAddressWarehouse = GetCMLObjectType("Warehouse", ParametersStructure.SchemaVersion);
			FillXDTOProperty(ShippingAddressWarehouse, "ID", String(New UUID), True, ErrorText);
			FillXDTOProperty(ShippingAddressWarehouse, "Description", ParametersStructure.ShippingAddress, True, ErrorText);
			FillXDTOProperty(DocumentEO, "ShippingAddressWarehouse", ShippingAddressWarehouse, , ErrorText);
		EndIf;
		
		// Steps of payment schedule.
		If ParametersStructure.Property("PaymentScheduleStagesTable") THEN
			PaymentScheduleStagesTable = ParametersStructure.PaymentScheduleStagesTable;
			If PaymentScheduleStagesTable.Count()>0 Then
				ColumnArray = New Array();
				For Each Column in PaymentScheduleStagesTable.Columns Do
					ColumnArray.Add(Column.Name);
				EndDo;
				For Each CurStage IN PaymentScheduleStagesTable Do
					PaymentScheduleStage = GetCMLObjectType("PaymentSchedule", ParametersStructure.SchemaVersion);
					GenerateDataByPaymentScheduleStagesCML(PaymentScheduleStage, CurStage, ErrorText, ColumnArray);
					DocumentEO.PaymentStage.Add(PaymentScheduleStage);
				EndDo;
			EndIf;
		EndIf;
		
		If ParametersStructure.Property("Comment") AND ValueIsFilled(ParametersStructure.Comment) Then
			FillXDTOProperty(DocumentEO,"Comment", ParametersStructure.Comment, , ErrorText);
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Report on commission goods sales.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGenerateReportOnComissionGoodsSalesCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("ComissionGoodsSalesReport",ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True, ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		
		Consignor = GetCMLObjectType("ComissionGoodsSalesReport.Principal", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignor, ParametersStructure, "Counterparty", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Consignor", Consignor, , ErrorText);
		
		Agent = GetCMLObjectType("ComissionGoodsSalesReport.Agent", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Agent, ParametersStructure, "Company", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Agent", Agent, , ErrorText);
		
		If ProductsTable.Count() > 0 Then
			Products = GetCMLObjectType("ComissionGoodsSalesReport.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				Product = GetCMLObjectType("ComissionGoodsSalesReport.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, True, ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				
				FillXDTOProperty(Product, "Price", Round(CurProduct.SalesAmount / CurProduct.Quantity, 2), True, ErrorText);
				AmountsByProduct = GetCMLObjectType("ComissionGoodsSalesReport.Products.Product.AmountsByProduct",
					ParametersStructure.SchemaVersion);
				FillXDTOProperty(AmountsByProduct, "AmountTotal", CurProduct.SalesAmount, True, ErrorText);
				FillXDTOProperty(AmountsByProduct, "TaxAmount", CurProduct.VATAmount, , ErrorText);
				If ParametersStructure.PriceIncludesVAT Then
					AmountWithoutVAT = CurProduct.Amount - CurProduct.VATAmount;
				Else
					AmountWithoutVAT = CurProduct.Amount;
				EndIf;
				FillXDTOProperty(AmountsByProduct, "AmountWithoutTax", AmountWithoutVAT, , ErrorText);
				
				// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
				
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				AmountsByProduct.Tax.Add(TaxByString);
				
				FillXDTOProperty(Product, "AmountsByProduct", AmountsByProduct, True, ErrorText);
				FillXDTOProperty(Product, "PrincipalPrice", Round(CurProduct.SumWithVAT/CurProduct.Quantity, 2), True, ErrorText);
				FillXDTOProperty(Product, "PrincipalAmount", CurProduct.SumWithVAT, True, ErrorText);
				FillXDTOProperty(Product, "BrokerageAmount", CurProduct.BrokerageAmount, , ErrorText);
				Products.Product.Add(Product);
			EndDo;
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		TotalByDocument = GetCMLObjectType("ReportOnComissionGoodsSales.TotalByDocument",
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "PrincipalAmountTotal", ProductsTable.Total("SumWithVAT"), True, ErrorText);
		FillXDTOProperty(TotalByDocument, "SalesAmountTotal", ProductsTable.Total("SalesAmount"), True, ErrorText);
		FillXDTOProperty(TotalByDocument, "TotalAmountRemuneration", ProductsTable.Total("BrokerageAmount"), , ErrorText);
		
		If ParametersStructure.Property("Percent") AND ValueIsFilled (ParametersStructure.Percent) Then
			FillXDTOProperty(TotalByDocument, "Percent", ParametersStructure.Percent, , ErrorText);
		EndIf;
		
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, True, ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", ParametersStructure.TotalRow, True, ErrorText);
		
		If ParametersStructure.Property("Service") AND ValueIsFilled (ParametersStructure.Service) Then
			Service = GetCMLObjectType("ComissionGoodsSalesReport.Service", ParametersStructure.SchemaVersion);
			GenerateDataByProductCML(Service, ParametersStructure.Service, ErrorText, ParametersStructure.SchemaVersion);
			If ParametersStructure.Property("BrokerageVATAmount")
				AND ParametersStructure.Property("VATCommissionFeePercent") Then
				
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", ParametersStructure.BrokerageVATAmount, , ErrorText, True);
				
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(ParametersStructure.VATCommissionFeePercent);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				FillXDTOProperty(Service, "Tax", TaxByString, , ErrorText);
			EndIf;
			FillXDTOProperty(DocumentEO, "Service", Service, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("BeginOfPeriod") Then
			FillXDTOProperty(DocumentEO,"StartDate", ParametersStructure.BeginOfPeriod, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("EndOfPeriod") Then
			FillXDTOProperty(DocumentEO,"EndDate", ParametersStructure.EndOfPeriod, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("Currency") AND ValueIsFilled (ParametersStructure.Currency) Then
			Currency = GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("PaymentForm") AND ValueIsFilled (ParametersStructure.PaymentForm) Then
			FillXDTOProperty(DocumentEO, "PaymentForm", ParametersStructure.PaymentForm, , ErrorText);
		EndIf;
		
		// Steps of payment schedule.
		If ParametersStructure.Property("PaymentScheduleStagesTable") Then
			PaymentScheduleStagesTable = ParametersStructure.PaymentScheduleStagesTable;
			If PaymentScheduleStagesTable.Count() > 0 Then
				ColumnArray = New Array();
				For Each Column in PaymentScheduleStagesTable.Columns Do
					ColumnArray.Add(Column.Name);
				EndDo;
				For Each CurStage IN PaymentScheduleStagesTable Do
					PaymentScheduleStage = GetCMLObjectType("PaymentSchedule", ParametersStructure.SchemaVersion);
					GenerateDataByPaymentScheduleStagesCML(PaymentScheduleStage, CurStage, ErrorText, ColumnArray);
					DocumentEO.PaymentStage.Add(PaymentScheduleStage);
				EndDo;
			EndIf;
		EndIf;
		
		If ParametersStructure.Property("CalculationMethod") AND ValueIsFilled (ParametersStructure.CalculationMethod) Then
			If ParametersStructure.CalculationMethod = "Percentage of the difference between sales amount and principal amount" Then
				FillXDTOProperty(DocumentEO, "CalculationMethod", "From difference", , ErrorText);
			ElsIf ParametersStructure.CalculationMethod = "Sale percentage" Then
				FillXDTOProperty(DocumentEO, "CalculationMethod", "From amount", , ErrorText);
			EndIf;
		EndIf;
		
		If ParametersStructure.Property("PayDate") AND ValueIsFilled (ParametersStructure.PayDate) Then
			FillXDTOProperty(DocumentEO, "PayDate", ParametersStructure.PayDate, , ErrorText);
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of the successful generation of ED file with price list
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function DeleteGeneratePriceListCML(ParametersStructure)
	
	ErrorText = "";
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		
		PriceER = GetCMLObjectType("PriceList", ParametersStructure.SchemaVersion);
		
		// Business information.
		FillXDTOProperty(PriceER, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(PriceER, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True,
			ErrorText);
		FillXDTOProperty(PriceER, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		FillXDTOProperty(PriceER, "ID", ParametersStructure.ID, True, ErrorText);
		
		// Owner.
		Counterparty = GetCMLObjectType("Counterparty", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, "Company", ErrorText,
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(PriceER, "Owner", Counterparty, True, ErrorText);
		
		PricesTypeIdentifier = String(New UUID);
		
		// Offers.
		If ProductsTable.Count()>0 Then
			Offers = GetCMLObjectType("PriceList.Offers", ParametersStructure.SchemaVersion);
			
			For Each CurProduct IN ProductsTable Do
				Offer = GetCMLObjectType("PriceList.Offers.Offer", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Offer, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				
				Prices = GetCMLObjectType("PriceList.Offers.Offer.Prices", ParametersStructure.SchemaVersion);
				Price = GetCMLObjectType("PriceList.Offers.Offer.Prices.Price", ParametersStructure.SchemaVersion);
				
				FillXDTOProperty(Price, "PriceTypeIdentifier", PricesTypeIdentifier, True,ErrorText);
				FillXDTOProperty(Price, "Price", CurProduct.Price, True,ErrorText);
				FillXDTOProperty(Price, "MinQuantity", CurProduct.Quantity, , ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Price, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				
				Prices.Price.Add(Price);
				FillXDTOProperty(Offer, "Prices", Prices, True, ErrorText);
				
				Offers.Offer.Add(Offer);
			EndDo;
			
			FillXDTOProperty(PriceER, 	"Offers",	Offers, True, ErrorText);
			
		EndIf;
		
		FillXDTOProperty(PriceER, "ValidFrom",XMLDate(ParametersStructure.Date), , ErrorText);
		
		// PriceTypes
		PriceTypes = GetCMLObjectType("PriceList.PriceTypes", ParametersStructure.SchemaVersion);
		PriceType = GetCMLObjectType("PriceType", ParametersStructure.SchemaVersion);
		FillXDTOProperty(PriceType, "ID", PricesTypeIdentifier, True, ErrorText);
		
		If ParametersStructure.Property("Definition") Then
			FillXDTOProperty(PriceType, "Definition", ParametersStructure.Definition, , ErrorText);
		EndIf;
		
		If ParametersStructure.Property("Currency") AND ValueIsFilled (ParametersStructure.Currency) Then
			Currency =  GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(PriceType, "Currency", Currency, , ErrorText);
		EndIf;
		
		PriceTypes.PriceType.Add(PriceType);
		FillXDTOProperty(PriceER, "PriceTypes", PriceTypes, , ErrorText);
		
		PriceER.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(PriceER, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Torg-12.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateCMLInvoice(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("TORG12", ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True, ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number",ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		FillXDTOProperty(DocumentEO, "OKUD", "0330212", True, ErrorText);
		
		If ParametersStructure.Property("Currency") Then
			Currency = GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, True, ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC",ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		Consignor = GetCMLObjectType("TORG12.Consignor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignor, ParametersStructure, ParametersStructure.ShipperType,
			ErrorText, ParametersStructure.SchemaVersion, "Consignor");
		FillXDTOProperty(DocumentEO, "Consignor", Consignor, , ErrorText);
		
		Consignee = GetCMLObjectType("TORG12.Consignee", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignee, ParametersStructure, "Counterparty", ErrorText,
			ParametersStructure.SchemaVersion,"Consignee");
		FillXDTOProperty(DocumentEO, "Consignee", Consignee, , ErrorText);
		
		Company = GetCMLObjectType("TORG12.Vendor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Company, ParametersStructure, "Company", ErrorText,
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Vendor", Company, , ErrorText);
		
		Counterparty = GetCMLObjectType("TORG12.Payer", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, "Counterparty", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Payer", Counterparty, , ErrorText);
		
		If ParametersStructure.Property("NumberByCustomerData") AND ParametersStructure.Property("DateByCustomerData") Then
			
			Basis = GetCMLObjectType("TORG12.Basis", ParametersStructure.SchemaVersion);
			FillXDTOProperty(Basis,"BasisDocumentNumber", ParametersStructure.NumberByCustomerData, True, ErrorText);
			FillXDTOProperty(Basis,"BasisDocumentDate", ParametersStructure.DateByCustomerData, True, ErrorText);
			FillXDTOProperty(Basis,"BasisDocumentDescription", "Purchase order", True, ErrorText);
			FillXDTOProperty(DocumentEO, "Basis", Basis, , ErrorText);
		EndIf;
		
		TotalByDocument = GetCMLObjectType("TORG12.TotalForDocument", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "RecCount", ProductsTable.Count(), , ErrorText);
		FillXDTOProperty(TotalByDocument, "PlacesQuantity", ProductsTable.Count(), , ErrorText);
		
		FillXDTOProperty(TotalByDocument, "AmountWithoutVAT", ProductsTable.Total("AmountWithoutVAT"), , ErrorText);
		FillXDTOProperty(TotalByDocument,"VATAmount", ProductsTable.Total("VATAmount"), , ErrorText);
		FillXDTOProperty(TotalByDocument,"AmountWithVAT", ProductsTable.Total("SumWithVAT"), , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, , ErrorText);
		
		TotalsInWords = GetCMLObjectType("TORG12.TotalsInWords", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalsInWords, "RecordsCountInWords", NumberInWords(ProductsTable.Count(), , ",,,,,,,,0"), , ErrorText);
		FillXDTOProperty(TotalsInWords, "PlacesCountInWords", NumberInWords(ProductsTable.Count(), , ",,,,,,,,0"), , ErrorText);
		FillXDTOProperty(TotalsInWords, "AmountTotalInWords",
			ElectronicDocumentsOverridable.AmountInWords(ProductsTable.Total("SumWithVAT"), CurrencyCode), , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", TotalsInWords, , ErrorText);
		
		If ProductsTable.Count() > 0 Then
			PP = 0;
			
			Products= GetCMLObjectType("TORG12.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				PP = PP + 1;
				
				Product = GetCMLObjectType("TORG12.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				FillXDTOProperty(Product, "SerialNumber", PP, , ErrorText);
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, , ErrorText);
				
				FillXDTOProperty(Product, "Price", CurProduct.Price, , ErrorText);
				FillXDTOProperty(Product, "AmountWithoutVAT", CurProduct.AmountWithoutVAT, , ErrorText);
				FillXDTOProperty(Product, "AmountWithVAT", CurProduct.SumWithVAT, , ErrorText);
				
				// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
				
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				FillXDTOProperty(Product, "Tax", TaxByString, , ErrorText);
				
				If Not (ProductsTable.Columns.Find("NumberByCustomerData") = Undefined
					OR ProductsTable.Columns.Find("DateByCustomerData") = Undefined)
					AND ValueIsFilled(CurProduct.NumberByCustomerData) AND ValueIsFilled(CurProduct.DateByCustomerData) Then
					
					ObjectTypeString = XDTOFactory.Type("http://www.w3.org/2001/XMLSchema", "string");
					NewObject = XDTOFactory.Create(ObjectTypeString, CurProduct.NumberByCustomerData);
					
					Product.Add (XMLForm.Element,"http://www.w3.org/2001/XMLSchema", "NumberByCustomerData", NewObject);
					DateObjectType = XDTOFactory.Type("http://www.w3.org/2001/XMLSchema", "dateTime");
					
					NewObject = XDTOFactory.Create(ObjectTypeString, CurProduct.DateByCustomerData);
					Product.Add (XMLForm.Element,"http://www.w3.org/2001/XMLSchema", "DateByCustomerData", NewObject);
				EndIf;
				
				If Not ProductsTable.Columns.Find("UsefulTime") = Undefined
					AND ValueIsFilled(CurProduct.UsefulTime) Then
					
					ObjectTypeString = XDTOFactory.Type("http://www.w3.org/2001/XMLSchema", "dateTime");
					NewObject = XDTOFactory.Create(ObjectTypeString, CurProduct.UsefulTime);
					Product.Add (XMLForm.Element,"http://www.w3.org/2001/XMLSchema", "UsefulTime", NewObject);
				EndIf;
				If (NOT (ProductsTable.Columns.Find("CCDNo") = Undefined)) AND ValueIsFilled(CurProduct.CCDNo) Then
					ObjectTypeString = XDTOFactory.Type("http://www.w3.org/2001/XMLSchema", "string");
					NewObject = XDTOFactory.Create(ObjectTypeString, CurProduct.CCDNo);
					Product.Add(XMLForm.Element,"http://www.w3.org/2001/XMLSchema", "CCDNo", NewObject);
				EndIf;
				
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Act of works completed.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateCMLCertificate(ParametersStructure)
	
	ErrorText = "";
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("ActAboutAcceptance",ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True,
			ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		If ParametersStructure.Property("Currency") Then
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
		EndIf;
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		
		Currency =  GetCMLObjectType("Currency", ParametersStructure.SchemaVersion);
		FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, , ErrorText);
		FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
		FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
		FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
		FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		
		// Company
		Counterparty =  GetCMLObjectType("AcceptanceCertificate.Contractor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, "Company", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Performer", Counterparty, , ErrorText);
		
		// Counterparty
		Counterparty =  GetCMLObjectType("ActAboutAcceptance.Customer", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, "Counterparty", ErrorText, ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Customer", Counterparty, , ErrorText);
		
		TotalByDocument = GetCMLObjectType("AcceptanceCertificate.TotalByDocument", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "AmountTotal", ProductsTable.Total("SumWithVAT"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "TaxAmount", ProductsTable.Total("VATAmount"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "AmountWithoutTax", ProductsTable.Total("AmountWithoutVAT"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "PriceIncludesTax", ParametersStructure.PriceIncludesVAT, , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, , ErrorText);
		
		If ProductsTable.Count() > 0 Then
			Products = GetCMLObjectType("ActAboutAcceptance.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				Product = GetCMLObjectType("ActAboutAcceptance.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, , ErrorText);
				Cost = GetCMLObjectType("Cost", ParametersStructure.SchemaVersion);
				
				FillXDTOProperty(Cost, "AmountWithoutTax", CurProduct.AmountWithoutVAT, , ErrorText);
				FillXDTOProperty(Product, "Price", CurProduct.Price, , ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				
				// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
				
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				Cost.Tax.Add(TaxByString);
				
				If ValueIsFilled(CurProduct.SumWithVAT) Then
					FillXDTOProperty(Cost,"AmountTotal", CurProduct.SumWithVAT, , ErrorText);
				EndIf;
				
				FillXDTOProperty(Product, "AmountsByProduct", Cost, , ErrorText);
				
				If ValueIsFilled(CurProduct.DiscountAmount) Then
					DiscountsByString = GetCMLObjectType("ActAboutAcceptance.Products.Product.Discounts", ParametersStructure.SchemaVersion);
					
					DiscountByString = GetCMLObjectType("Discount",ParametersStructure.SchemaVersion);
					FillXDTOProperty(DiscountByString, "Description", "TotalDiscount", True, ErrorText);
					FillXDTOProperty(DiscountByString, "Amount", CurProduct.DiscountAmount, True, ErrorText);
					
					DiscountsByString.Discount.Add(DiscountByString);
					FillXDTOProperty(DiscountsByString, "DiscountsAmount", CurProduct.DiscountAmount, , ErrorText);
					FillXDTOProperty(DiscountsByString, "AmountWithoutDiscounts", CurProduct.SumWithVAT - CurProduct.DiscountAmount, , ErrorText);
					FillXDTOProperty(Product, "Discounts", DiscountsByString, , ErrorText);
				EndIf;
				
				If Not ProductsTable.Columns.Find("Content") = Undefined
					AND ValueIsFilled(CurProduct.Content) THEN
					
					FillXDTOProperty(Product, "Definition", CurProduct.Content, , ErrorText);
				EndIf;
				
				Products.Product.Add(Product);
			EndDo;
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		DocumentText = GetCMLObjectType("AcceptanceCertificate.DocumentText", ParametersStructure.SchemaVersion);
		
		Title = ParametersStructure.AdditionalInformationCaps + Chars.LF +
		NStr("en='We, the undersigned, the representative of the SUPPLIER on one side and the representative
		|of the CUSTOMER on the other side prepared this certificate confirming that the SUPPLIER performed and the CUSTOMER accepted the following works (services):';ru='Мы, нижеподписавшиеся, представитель ИСПОЛНИТЕЛЯ, с одной стороны
		|и представитель ЗАКАЗЧИКА с другой стороны, составили настоящий акт в том, что ИСПОЛНИТЕЛЬ выполнил, а ЗАКАЗЧИК принял следующие работы (услуги):'");
		FillXDTOProperty(DocumentText, "Title", XMLString(Title), , ErrorText);
		
		Definition =  ParametersStructure.AdditionalInformation;
		FillXDTOProperty(DocumentText, "PerformedWorksDescription", Definition, , ErrorText);
		
		Claims = NStr("en='The works (services) mentioned above are completed in full volume and in due time. Customer has no
		|claims as of the volume, quality and terms of works (services) provided.';ru='Вышеперечисленные работы(услуги) выполнены полностью и в срок. Заказчик претензий по объему,
		|качеству и срокам работ (услуг) не имеет.'");
		FillXDTOProperty(DocumentText, "Claims", Claims, ,ErrorText);
		FillXDTOProperty(DocumentEO, "DocumentText", DocumentText, , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", ParametersStructure.TotalsInWords, , ErrorText);
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Returns the result of successful generation of ED file Report on commission goods sales.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//  Boolean - flag of successful generation
//
Function GenerateGoodsTransferReturnBetweenCompaniesCML(ParametersStructure)
	
	ErrorText = "";
	
	ProductsTable = New ValueTable;
	ProductsTable = ParametersStructure.ProductsTable;
	
	Try
		DocumentEO = GetCMLObjectType("TORG12", ParametersStructure.SchemaVersion);
		
		// Business information
		FillXDTOProperty(DocumentEO, "ExecutantId", ParametersStructure.Performer, True, ErrorText);
		FillXDTOProperty(DocumentEO, "GeneratingDate", XMLDateTime(ParametersStructure.GeneratingDate), True, ErrorText);
		FillXDTOProperty(DocumentEO, "SchemaVersion", ParametersStructure.SchemaVersion, True, ErrorText);
		
		FillXDTOProperty(DocumentEO, "ID", ParametersStructure.ID, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Number", ParametersStructure.Number, True, ErrorText);
		FillXDTOProperty(DocumentEO, "Date", XMLDate(ParametersStructure.Date), True, ErrorText);
		FillXDTOProperty(DocumentEO, "OKUD", "0330212", True, ErrorText);
		
		If ParametersStructure.Property("Currency") Then
			Currency =  GetCMLObjectType("Currency",ParametersStructure.SchemaVersion);
			CurrencyCode = XMLNumber(ParametersStructure.Currency.Code);
			
			FillXDTOProperty(Currency, "CodeRCC", CurrencyCode, True , ErrorText);
			FillXDTOProperty(Currency, "ExchangeRate", ParametersStructure.ExchangeRate, , ErrorText);
			FillXDTOProperty(Currency, "ShortDescriptionGCC", ParametersStructure.Currency.Description, , ErrorText);
			FillXDTOProperty(Currency, "DescriptionFullOfGCC", ParametersStructure.Currency.DescriptionFull, , ErrorText);
			FillXDTOProperty(DocumentEO, "Currency", Currency, , ErrorText);
		EndIf;
		
		Consignor = GetCMLObjectType("TORG12.Consignor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignor, ParametersStructure, ParametersStructure.ShipperType,
			ErrorText, ParametersStructure.SchemaVersion, "Consignor");
		FillXDTOProperty(DocumentEO, "Consignor", Consignor, , ErrorText);
		
		Consignee = GetCMLObjectType("TORG12.Consignee", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Consignee, ParametersStructure, "Counterparty", ErrorText,
			ParametersStructure.SchemaVersion,"Consignee");
		FillXDTOProperty(DocumentEO, "Consignee", Consignee, , ErrorText);
		
		Company = GetCMLObjectType("TORG12.Vendor", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Company, ParametersStructure, "Company", ErrorText,
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Vendor", Company, , ErrorText);
		
		Counterparty = GetCMLObjectType("TORG12.Payer", ParametersStructure.SchemaVersion);
		GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, "Counterparty", ErrorText,
			ParametersStructure.SchemaVersion);
		FillXDTOProperty(DocumentEO, "Payer", Counterparty, , ErrorText);
		
		TotalByDocument = GetCMLObjectType("TORG12.TotalForDocument", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalByDocument, "RecCount", ProductsTable.Count(), , ErrorText);
		FillXDTOProperty(TotalByDocument, "PlacesQuantity", ProductsTable.Count(), , ErrorText);
		If ParametersStructure.PriceIncludesVAT Then
			FillXDTOProperty(TotalByDocument, "AmountWithoutVAT",
				ProductsTable.Total("Amount") - ProductsTable.Total("VATAmount"), , ErrorText);
		Else	
			FillXDTOProperty(TotalByDocument,	"AmountWithoutVAT", ProductsTable.Total("Amount") , , ErrorText);
		EndIf;
		FillXDTOProperty(TotalByDocument, "VATAmount", ProductsTable.Total("VATAmount"), , ErrorText);
		FillXDTOProperty(TotalByDocument, "AmountWithVAT", ProductsTable.Total("SumWithVAT"), , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalByDocument", TotalByDocument, , ErrorText);
		
		TotalsInWords = GetCMLObjectType("TORG12.TotalsInWords", ParametersStructure.SchemaVersion);
		FillXDTOProperty(TotalsInWords, "RecordsCountInWords",
			NumberInWords(ProductsTable.Count(), ,",,,,,,,,0"), , ErrorText);
		FillXDTOProperty(TotalsInWords, "PlacesCountInWords",
			NumberInWords(ProductsTable.Count(), ,",,,,,,,,0"), , ErrorText);
		FillXDTOProperty(TotalsInWords, "AmountTotalInWords",
			ElectronicDocumentsOverridable.AmountInWords(ProductsTable.Total("SumWithVAT"), CurrencyCode), , ErrorText);
		FillXDTOProperty(DocumentEO, "TotalsInWords", TotalsInWords, , ErrorText);
		
		If ProductsTable.Count()>0 Then 
			PP = 0;
			Products = GetCMLObjectType("TORG12.Products", ParametersStructure.SchemaVersion);
			For Each CurProduct IN ProductsTable Do
				PP = PP + 1;
				Product = GetCMLObjectType("TORG12.Products.Product", ParametersStructure.SchemaVersion);
				GenerateDataByProductCML(Product, CurProduct, ErrorText, ParametersStructure.SchemaVersion);
				FillXDTOProperty(Product, "SerialNumber", PP, , ErrorText);
				
				MeasurementUnit = GetCMLObjectType("MeasurementUnit", ParametersStructure.SchemaVersion);
				UnOfMeasStructure = New Structure();
				UnOfMeasStructure.Insert("MeasurementUnitCode", CurProduct.PackageCode);
				UnOfMeasStructure.Insert("MeasurementUnitDescription", CurProduct.PackageDescription);
				UnOfMeasStructure.Insert("Factor", CurProduct.Factor);
				GenerateDataByMeasurementUnitCML(MeasurementUnit, UnOfMeasStructure, ErrorText);
				FillXDTOProperty(Product, "MeasurementUnit", MeasurementUnit, True, ErrorText);
				
				FillXDTOProperty(Product, "Quantity", CurProduct.Quantity, , ErrorText);
				If ParametersStructure.PriceIncludesVAT Then
					AmountWithoutVAT = CurProduct.Amount - CurProduct.VATAmount;
				Else	
					AmountWithoutVAT = CurProduct.Amount;
				EndIf;
				FillXDTOProperty(Product, "Price", Round(AmountWithoutVAT / CurProduct.Quantity, 2), , ErrorText);
				FillXDTOProperty(Product, "AmountWithoutVAT", AmountWithoutVAT, , ErrorText);
				FillXDTOProperty(Product, "AmountWithVAT", CurProduct.SumWithVAT, , ErrorText);
				
				// Fill tax in any case: and when VATRate = "WithoutVAT", and when VATRate = "0%".
				TaxByString = GetCMLObjectType("Tax", ParametersStructure.SchemaVersion);
				FillXDTOProperty(TaxByString, "TaxType", "VAT", True, ErrorText);
				FillXDTOProperty(TaxByString, "Amount", CurProduct.VATAmount, , ErrorText, True);
				
				TaxRateVATAsNumber = ElectronicDocumentsOverridable.GetVATRateAsNumber(CurProduct.VATRate);
				If TaxRateVATAsNumber <> Undefined Then
					FillXDTOProperty(TaxByString, "TaxRateAmount", TaxRateVATAsNumber, , ErrorText, True);
				EndIf;
				FillXDTOProperty(Product, "Tax", TaxByString, , ErrorText);
				
				Products.Product.Add(Product);
			EndDo;
			
			FillXDTOProperty(DocumentEO, "Products", Products, , ErrorText);
		EndIf;
		
		DocumentEO.Validate();
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(DocumentEO, ParametersStructure.FullFileName);
			FileIsFormed = True;
		EndIf;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// Structures of parameters common for FTS schemes

Procedure FillFTSServiceFieldsStructure(EDStructure, ParametersStructure)
	
	ParametersStructure.VersProg = "1C:Enterprise 8";
	ParametersStructure.VersForm = "5.01";
	ParametersStructure.IdSen = EDStructure.Sender;
	ParametersStructure.IdCust = EDStructure.Recipient;
	If EDStructure.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom
		OR EDStructure.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		FillEDFOperatorAttributes(ParametersStructure);
	Else // fill in with the data of Company or zero values as fields must be filled out in the format of FTS
		FillEDFBlankOperatorAttributes(ParametersStructure, EDStructure.Company);
	EndIf;
	CurDateTime = CurrentSessionDate();
	ParametersStructure.DocDate = Format(CurDateTime, "DF=dd.MM.yyyy");
	ParametersStructure.TempDoc = Format(CurDateTime, "DF=HH.mm.ss");
	ParametersStructure.EDKind = EDStructure.EDKind;
	ParametersStructure.CTD = EDStructure.CTD;
	ParametersStructure.UUID = EDStructure.UUID;
	
	If EDStructure.EDKind = Enums.EDKinds.TORG12Customer
		OR EDStructure.EDKind = Enums.EDKinds.TORG12Seller Then
		
		ParametersStructure.DescFirstDock = "Goods sale";
		ParametersStructure.RCMDFirstDoc = "0330212";
		ParametersStructure.NumForm = "TORG-12";
	ElsIf EDStructure.EDKind = Enums.EDKinds.ActCustomer
		OR EDStructure.EDKind = Enums.EDKinds.ActPerformer Then
		
		ParametersStructure.DescFirstDock = "Act of work completion (services rendered)";
	ElsIf EDStructure.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
		
		ParametersStructure.NumForm = "Correction document recipient";
	EndIf;
	YYYYMMDD = StrReplace(Format(CurDateTime, "DF=yyyy-MM-dd"), "-", "");
	FileStructure = New Structure("Prefix, RecipientID, SenderID, YYYYMMDD, UUID",
									 EDStructure.PrefixFileId,
									 EDStructure.Recipient,
									 EDStructure.Sender,
									 YYYYMMDD,
									 EDStructure.UUID);
	ParametersStructure.IdFile = ElectronicDocumentsService.FTSFileName(FileStructure);
	
EndProcedure

Procedure FTSServiceFieldsStructure(StructureServiceFields = Undefined)
	
	If TypeOf(StructureServiceFields) <> Type("Structure") Then
		StructureServiceFields = New Structure;
	EndIf;
	
	StructureServiceFields.Insert("VersProg");
	StructureServiceFields.Insert("VersForm");
	StructureServiceFields.Insert("IdFile");
	StructureServiceFields.Insert("IdSen");
	StructureServiceFields.Insert("IdCust");
	StructureServiceFields.Insert("DescEnt");
	StructureServiceFields.Insert("TINLP");
	StructureServiceFields.Insert("IdEDF");
	StructureServiceFields.Insert("CTD");
	StructureServiceFields.Insert("EDKind");
	
	StructureServiceFields.Insert("DocDate");
	StructureServiceFields.Insert("TempDoc");
	StructureServiceFields.Insert("DescFirstDock");
	StructureServiceFields.Insert("RCMDFirstDoc"); // Used only for TORG-12
	StructureServiceFields.Insert("NumForm");     // Used only for TORG-12
	StructureServiceFields.Insert("UUID");
	
EndProcedure

Procedure FillServiceFieldStructure(EDStructure, ParametersStructure)
	
	ParametersStructure.Insert("GeneratingDate", CurrentSessionDate());
	ParametersStructure.Insert("SchemaVersion", EDStructure.SchemaVersion);
	ParametersStructure.Insert("ID", EDStructure.EDNumber);
	ParametersStructure.Insert("EDKind", EDStructure.EDKind);
	ParametersStructure.Insert("EDDirection", EDStructure.EDDirection);
	
EndProcedure

Procedure ServiceFieldsStructure(StructureServiceFields = Undefined)
	
	If TypeOf(StructureServiceFields) <> Type("Structure") Then
		StructureServiceFields = New Structure;
	EndIf;
	
	StructureServiceFields.Insert("GeneratingDate");
	StructureServiceFields.Insert("SchemaVersion");
	StructureServiceFields.Insert("ID");
	StructureServiceFields.Insert("EDKind");
	StructureServiceFields.Insert("EDDirection");
	
EndProcedure

Function PowerOfAttorneyAttributesStructureFTS()
	
	InformationStructure = New Structure;
	
	InformationStructure.Insert("PowerOfAttorneyNumber");
	InformationStructure.Insert("DateOfPowerOfAttorney");
	InformationStructure.Insert("CompanyIssuedPowerOfAttorney");
	InformationStructure.Insert("AdditionalInformationAboutPowerOfAttorneyIssue");
	InformationStructure.Insert("AdditInformationAboutSubstitutedTrustee");
	InformationStructure.Insert("PersonIssuedPowerOfAttorney", New Structure("Position, Last name, First name, Middle name"));
	InformationStructure.Insert("SubstitutedTrustee", New Structure("Position, Last name, First name, Middle name"));
	
	Return InformationStructure;
	
EndFunction

Function ExchangeParticipantAttributesStructureFTS()
	
	ParticipantStructure = New Structure;
	
	ParticipantStructure.Insert("ThisIsInd");
	ParticipantStructure.Insert("CompanyDescription");
	ParticipantStructure.Insert("TIN");
	ParticipantStructure.Insert("CodeRCLF");
	ParticipantStructure.Insert("Surname");
	ParticipantStructure.Insert("Name");
	ParticipantStructure.Insert("Patronymic");
	ParticipantStructure.Insert("Address", AddressStructureFTS());
	ParticipantStructure.Insert("Phone");
	ParticipantStructure.Insert("Fax");
	ParticipantStructure.Insert("BankAccount", New Structure("AccountNumber, BankName, BIC"));
	
	Return ParticipantStructure;
	
EndFunction

Function SignerAttributesStructureFTS(ThisIsInd = False)
	
	ParticipantStructure = New Structure;
	
	ParticipantStructure.Insert("ThisIsInd");
	ParticipantStructure.Insert("TIN");
	ParticipantStructure.Insert("Surname");
	ParticipantStructure.Insert("Name");
	ParticipantStructure.Insert("Patronymic");
	ParticipantStructure.Insert("Position");
	ParticipantStructure.Insert("CertificateAboutRegistrationIP");
	ParticipantStructure.Insert("MandatoryFields", "TIN, Last name, First name, ThisIsIndivPerson" + ?(ThisIsInd,"",", Position"));
	
	Return ParticipantStructure;
	
EndFunction

Function StructureGeneralInformation()
	
	InformationStructure = New Structure;
	
	InformationStructure.Insert("SequentialRecordsNumbersQuantity");
	InformationStructure.Insert("RecordsSequenceNumbersQuantityInWords");
	InformationStructure.Insert("PlacesTotal");
	InformationStructure.Insert("TotalPlacesInWords");
	InformationStructure.Insert("CargoNetWeight");
	InformationStructure.Insert("CargoNetWeightInWords");
	InformationStructure.Insert("CargoGrossWeight");
	InformationStructure.Insert("CargoGrossWeightInWords");
	
	Return InformationStructure;
	
EndFunction

Function ComissionGoodsSalesReportGoodsTable()
	
	ProductsTable = New ValueTable;
	
	ProductsTable.Columns.Add("LineNumber");
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnitCode");
	ProductsTable.Columns.Add("BaseUnitDescription");
	ProductsTable.Columns.Add("BaseUnitDescriptionFull");
	ProductsTable.Columns.Add("BaseUnitInternationalAbbreviation");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("PackageCode");
	ProductsTable.Columns.Add("PackageDescription");
	ProductsTable.Columns.Add("Factor");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("SalesAmount");
	ProductsTable.Columns.Add("BrokerageAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("AdditionalAttributes");
	
	Return ProductsTable;
	
EndFunction

Function StructureParametersOnReportOfCommissionGoodsSales()
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	
	ParametersStructure.Insert("ProductsTable", ComissionGoodsSalesReportGoodsTable());
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("VATAmount");
	ParametersStructure.Insert("VATCommissionFeePercent");
	ParametersStructure.Insert("BrokerageVATAmount");
	ParametersStructure.Insert("BrokerageAmount");
	ParametersStructure.Insert("VATTaxation");
	ParametersStructure.Insert("PaymentScheduleStagesTable");
	ParametersStructure.Insert("BeginOfPeriod");
	ParametersStructure.Insert("EndOfPeriod");
	ParametersStructure.Insert("PaymentForm");
	ParametersStructure.Insert("CalculationMethod");
	ParametersStructure.Insert("Percent");
	ParametersStructure.Insert("PayDate");
	ParametersStructure.Insert("Service");
	ParametersStructure.Insert("TotalRow");
	
	AdditionalAttributesForTablesProducts = New Structure;
	AdditionalAttributesForTablesProducts.Insert("SaleDate");
	AdditionalAttributesForTablesProducts.Insert("VATRate");
	AdditionalAttributesForTablesProducts.Insert("CustomerDescription");
	AdditionalAttributesForTablesProducts.Insert("CustomerTIN");
	AdditionalAttributesForTablesProducts.Insert("CustomerFactAddress", AddressStructureFTS());
	AdditionalAttributesForTablesProducts.Insert("CustomerLegAddress", AddressStructureFTS());
	ParametersStructure.Insert("AdditionalAttributesForTablesProducts", AdditionalAttributesForTablesProducts);
	
	ParametersStructure.Insert("MandatoryFields", "Number, Date, Agent, Company, Counterparty, Amount, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "ID, Name, Quantity, BasicUnitCode, SalesAmount, AmountWithVAT");

	Return ParametersStructure;
	
EndFunction

// Structure of TORG12 parameters

Function Torg12InformationStructureOfCargoRelease()
	
	ReleaseStructure = New Structure;
	
	ReleaseStructure.Insert("AttachmentsSheetsCount");
	ReleaseStructure.Insert("AttachmentsSheetsCountInWords");
	ReleaseStructure.Insert("AmountReleased");
	ReleaseStructure.Insert("AmountReleasedInWords");
	ReleaseStructure.Insert("DateReleased");
	ReleaseStructure.Insert("ReleasePermitted", New Structure("Position, Last name, First name, Middle name"));
	ReleaseStructure.Insert("Accountant", New Structure("Position, Last name, First name, Middle name"));
	ReleaseStructure.Insert("ReleaseMade", New Structure("Position, Last name, First name, Middle name"));
	
	Return ReleaseStructure;
	
EndFunction

Function Torg12StructureTotalByInvoice()
	
	StructureTotal = New Structure;
	
	StructureTotal.Insert("PlacesQuantity");
	StructureTotal.Insert("GrossWeight");
	StructureTotal.Insert("NetWeight");
	StructureTotal.Insert("AmountWithoutVAT");
	StructureTotal.Insert("VATAmount");
	StructureTotal.Insert("SumWithVAT");
	
	Return StructureTotal;
	
EndFunction

Function Torg12InformationAboutProductTable()
	
	ProductsTable = New ValueTable;
	
	ProductsTable.Columns.Add("LineNumber");
	ProductsTable.Columns.Add("ProductsAndServicesDescription");
	ProductsTable.Columns.Add("CharacteristicDescription");
	ProductsTable.Columns.Add("Kind");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("ProductCode");
	ProductsTable.Columns.Add("MeasurementUnit");
	ProductsTable.Columns.Add("BaseUnitCode");
	ProductsTable.Columns.Add("PackagingKind");
	ProductsTable.Columns.Add("QuantityInOnePlace");
	ProductsTable.Columns.Add("PlacesQuantity");
	ProductsTable.Columns.Add("GrossWeight");
	ProductsTable.Columns.Add("NetWeight");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("AmountWithoutVAT");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("BasisDocument");
	
	Return ProductsTable;
	
EndFunction

Function Torg12StructureOfParameters(ThisIsInd)
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("ConsignmentNoteNumber");
	ParametersStructure.Insert("DateOfInvoice");
	
	ParametersStructure.Insert("OperationKind");
	ParametersStructure.Insert("BasisDocuments");
	
	ParametersStructure.Insert("ProductsTable", Torg12InformationAboutProductTable());
	ParametersStructure.Insert("Signer", SignerAttributesStructureFTS(ThisIsInd));
	ParametersStructure.Insert("CommonInformationAboutInvoice", StructureGeneralInformation());
	ParametersStructure.Insert("TotalByBill", Torg12StructureTotalByInvoice());
	
	InfoAboutShipper = New Structure;
	InfoAboutShipper.Insert("Consignor", ExchangeParticipantAttributesStructureFTS());
	InfoAboutShipper.Insert("OrganizationDepartment");
	InfoAboutShipper.Insert("CodeRCEAP");
	
	ParametersStructure.Insert("InfoAboutShipper", InfoAboutShipper);
	ParametersStructure.Insert("Consignee", ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Insert("Vendor", ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Insert("Payer", ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Insert("DocBasisDescription");
	ParametersStructure.Insert("DocBasisNumber");
	ParametersStructure.Insert("DocBasisDate");
	ParametersStructure.Insert("DocBasisAdditInformation");
	ParametersStructure.Insert("WayBillNumber");
	ParametersStructure.Insert("WaybillDate");
	ParametersStructure.Insert("OperationKindCode");
	ParametersStructure.Insert("InformationByCargoRelease", Torg12InformationStructureOfCargoRelease());
	
	MaxLength = GetXDTOschemaFieldProperty("OTORG12", "File.Document.PrInD.InfFul", "TextInf", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("AllowedLengthOfExtraDataCaps", MaxLength - 20); // 20 - service characters.
	MaxLength = GetXDTOschemaFieldProperty("OTORG12", "File.Document.PrInD.CN.Table.PrGd", "InfFullStr", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("StringAdditDataAllowedLength", MaxLength - 20); // 20 - service characters.
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	
	ParametersStructure.Insert("MandatoryFields", "ConsignmentNoteNumber, ConsignmentNoteDate, ProductsTable, Signatory");
	ParametersStructure.Insert("ValueTableRequiredFields", "LineNumber, UOM, AmountWithVAT");
	
	Return ParametersStructure;
	
EndFunction

Function Torg12BuyerParametersStructure(ThisIsInd)
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("Signer", SignerAttributesStructureFTS(ThisIsInd));
	ParametersStructure.Insert("CargoDateReceived");
	ParametersStructure.Insert("PowerOfAttorney", PowerOfAttorneyAttributesStructureFTS());
	ParametersStructure.Insert("CargoReceived", New Structure("Position, Last name, First name, Middle name"));
	ParametersStructure.Insert("CargoTaken", New Structure("Position, Last name, First name, Middle name"));
	
	MaxLength = GetXDTOschemaFieldProperty("PTORG12", "File.Document.PrRnIn.InfFul", "TextInf", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("AllowedLengthOfExtraDataCaps", MaxLength - 20); // 20 - service characters.
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("MandatoryFields", "Signer");
	
	Return ParametersStructure;
	
EndFunction

Function ESFParametersStructure(IsCorrectingSF, ThisIsInd = False)
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("InvNumber"); // Sequence number of an invoice for which a correction invoice is created (Row 1b)
	ParametersStructure.Insert("DateInv"); // Date of invoice creation for which a correction invoice is created (Row 1b)
	ParametersStructure.Insert("CurrencyCode"); // Cuurency: Code (Row 4) 
	ParametersStructure.Insert("CorrectionNumberSourceInv"); // (optional) Correction: No. (Row 1a)
	ParametersStructure.Insert("DateOfCorrectionSourceInvoice"); // (optional) Correction: Date (row 1a)
	
	ParametersStructure.Insert("Company", ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Company.Insert("MandatoryFields", "CompanyName, Address, ThisIsIndivPerson" + ?(ThisIsInd,", Last name, First name",""));
	
	ParametersStructure.Insert("Counterparty", ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Counterparty.Insert("MandatoryFields", "CompanyName, Address, ThisIsIndivPerson");
	
	ParametersStructure.Insert("Signer", SignerAttributesStructureFTS(True)); // in the parameters of a signatory for IR, position - optional attribute.
	
	ParametersStructure.Insert("BasisDocuments");
	
	If IsCorrectingSF Then
		ParametersStructure.Insert("NumberCorrInv"); // Sequence number of correction invoice (Row 1)
		ParametersStructure.Insert("DateOffsetInvoice"); // Creation date of correction invoice (Row 1)
		ParametersStructure.Insert("CorrectionNumberCorrInv"); // (optional) Correction: No. (Row 1a)
		ParametersStructure.Insert("DateOfCorrectionOffsetInvoice"); // (optional) Correction: Date (row 1a)
		
		// Information in the table of correction invoice
		ParametersStructure.Insert("ProductsTable", CorrESFInformationTableAboutProducts());
		
		// Attributes of the row Total increase (rows sum (B) by columns 5, 8 and 9)
		ParametersStructure.Insert("AmountWithoutVATTotalIncrease"); // Total increase, Cost of products (works, services), property rights without tax - total (row Total increase/Column 5)
		ParametersStructure.Insert("VATAmountTotalIncrease"); // Total increase, Cost of products (works, services), property rights with tax - total (row Total increase/Column 9)
		ParametersStructure.Insert("VATAmountIncrease"); // Total increase, Tax amount (row Total increase/Column 8)
		
		// Attributes of the row Total decrease (rows sum (D) by columns 5, 8 and 9)
		ParametersStructure.Insert("AmountWithoutVATTotalReduction"); // total decrease, Cost of products (works, services), property rights without tax - total (row Total decrease/Column 5)
		ParametersStructure.Insert("VATAmountTotalReduction"); // total decrease, Cost of products (works, services), property rights with tax - total (row Total decrease/Column 9)
		ParametersStructure.Insert("VATAmountReduction"); // total decrease, Tax amount (row Total decrease/Column 8)
		MaxLength = GetXDTOschemaFieldProperty("KORSFAKT", "File.Document.PrCInv.InfFul", "TextInf", XDTOFacetType.MaxLength);
		MaxRowLength = GetXDTOschemaFieldProperty("KORSFAKT", "File.Document.TablCInv.InfoInv", "InfFullStr", XDTOFacetType.MaxLength);
	Else
		// If the invoice is prepared for the execution of works (provision of services), consignor/consignee) - put dash.
		ParametersStructure.Insert("JustServices", False);
		
		// When forming ESF for consignor/consignee) only the following fields of the structure are used:
		// ThisIsIndPers, CompanyName, Surname, FirstName, SecondName, Address.
		ParametersStructure.Insert("Consignee", ExchangeParticipantAttributesStructureFTS());
		
		InfoAboutShipper = New Structure;
		InfoAboutShipper.Insert("Consignor", ExchangeParticipantAttributesStructureFTS());
		InfoAboutShipper.Insert("Same", False); // can be specified only for the consignor
		ParametersStructure.Insert("InfoAboutShipper", InfoAboutShipper);
	
		// Information about payment and settlement document (string 5)
		PaymentDocuments = New ValueTable();
		PaymentDocuments.Columns.Add("NumberPRD"); // Number of payment and settlement document
		PaymentDocuments.Columns.Add("DatePRD"); // Compilation date of payment and settlement document
		ParametersStructure.Insert("PaymentDocuments", PaymentDocuments);
		
		ParametersStructure.Insert("ProductsTable", ESFInformationTableAboutProduct());
		ParametersStructure.Insert("SumWithoutVATTotal"); // Cost of products (works, services), property rights without tax - total
		ParametersStructure.Insert("AmountVATAll"); // Cost of products (works, services), property rights with tax - total
		ParametersStructure.Insert("VATAmountTotal"); // VAT amount shown to customer
		MaxLength = GetXDTOschemaFieldProperty("SFAKT", "File.Document.PrInvoice.InfFul", "TextInf", XDTOFacetType.MaxLength);
		MaxRowLength = GetXDTOschemaFieldProperty("SFAKT", "File.Document.TablInv.InfoInv", "InfFullStr", XDTOFacetType.MaxLength);
	EndIf;
	
	ParametersStructure.Insert("AllowedLengthOfExtraDataCaps", MaxLength - 20); // 20 - service characters.
	ParametersStructure.Insert("StringAdditDataAllowedLength", MaxRowLength - 20); // 20 - service characters.
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	
	ParametersStructure.Insert("MandatoryFields", "InvNumber, InvDate, CurrencyCode, Company,
	|Counterparty, Signatory, ProductsTable" + ?(IsCorrectingSF, "", ", AmountWithVATTotal"));
	ParametersStructure.Insert("ValueTableRequiredFields",
		"LineNumber, ProductsAndServicesName, Excise, VATRate, VATRateType, Amount" //, VATAmount
		+ ?(IsCorrectingSF, ", ExciseUntil, VATRateBefore, VATRateTypeBefore, AmountBefore", "")); //VATAmountBefore, VATAmountDecrease, VATAmountIncrease, AmountDecrease, AmountIncrease
	
	
	Return ParametersStructure;
	
EndFunction

Function Act501InformationAboutPerformingServicesStructure()
	
	ExecutionStructure = New Structure;
	ExecutionStructure.Insert("CompletionDate");
	ExecutionStructure.Insert("ExecutantSignature", New Structure("Position, Last name, First name, Middle name"));
	ExecutionStructure.Insert("PowerOfAttorney", PowerOfAttorneyAttributesStructureFTS());
	
	Return ExecutionStructure;
	
EndFunction

Function Act501InformationAboutServicesTable()
	
	ServicesTable = New ValueTable;
	ServicesTable.Columns.Add("LineNumber");
	ServicesTable.Columns.Add("ProductsAndServicesDescription");
	ServicesTable.Columns.Add("MeasurementUnit");
	ServicesTable.Columns.Add("BaseUnitCode");
	ServicesTable.Columns.Add("Quantity");
	ServicesTable.Columns.Add("Price");
	ServicesTable.Columns.Add("AmountWithoutVAT");
	ServicesTable.Columns.Add("VATAmount");
	ServicesTable.Columns.Add("SumWithVAT");
	ServicesTable.Columns.Add("Definition");
	ServicesTable.Columns.Add("BasisDocument");
	
	ServicesTable.Columns.Add("ProductsAndServices");
	ServicesTable.Columns.Add("ID");
	
	Return ServicesTable;
	
EndFunction

Function Act501InformationAboutServicesDescriptionTable()
	
	ServicesDescriptionTable = New ValueTable;
	ServicesDescriptionTable.Columns.Add("LineNumber");
	ServicesDescriptionTable.Columns.Add("WorksBegin");
	ServicesDescriptionTable.Columns.Add("WorksEnd");
	ServicesDescriptionTable.Columns.Add("AmountNoVATTotal");
	ServicesDescriptionTable.Columns.Add("VATAmountTotal");
	ServicesDescriptionTable.Columns.Add("VATAmountTotal");
	ServicesDescriptionTable.Columns.Add("Services");
	
	Return ServicesDescriptionTable;
	
EndFunction

Function Act501ParametersStructure(ThisIsInd)
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("ActNumber");
	ParametersStructure.Insert("DateOfAct");
	
	ParametersStructure.Insert("OperationKind");
	ParametersStructure.Insert("BasisDocuments");
	
	ParametersStructure.Insert("Title", NStr("en='We, the undersigned, the representative of the SUPPLIER
		|on one side and the representative of the CUSTOMER on the other side prepared this certificate confirming that the SUPPLIER performed and the CUSTOMER accepted the following works (services).';ru='Мы, нижеподписавшиеся, представитель ИСПОЛНИТЕЛЯ,
		|с одной стороны и представитель ЗАКАЗЧИКА с другой стороны, составили настоящий акт в том, что ИСПОЛНИТЕЛЬ выполнил, а ЗАКАЗЧИК принял следующие работы (услуги).'"));
	
	ParametersStructure.Insert("Performer",  ExchangeParticipantAttributesStructureFTS());
	ParametersStructure.Insert("Customer",     ExchangeParticipantAttributesStructureFTS());
	
	ParametersStructure.Insert("ServicesDescriptionTable", Act501InformationAboutServicesDescriptionTable());
	ParametersStructure.Insert("ServicesTable", Act501InformationAboutServicesTable());
	
	ParametersStructure.Insert("InformationAboutServicesExecution", Act501InformationAboutPerformingServicesStructure());
	
	ParametersStructure.Insert("Signer",    SignerAttributesStructureFTS(ThisIsInd));
	
	MaxLength = GetXDTOschemaFieldProperty("IAKTPRM2", "File.Document.PrActI.InfFul", "TextInf", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("AllowedLengthOfExtraDataCaps", MaxLength - 20); // 20 - service characters.
	MaxLength = GetXDTOschemaFieldProperty("IAKTPRM2", "File.Document.PrActI.WorksDescr.Work", "InfFullStr", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("StringAdditDataAllowedLength", MaxLength - 20); // 20 - service characters.
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	
	ParametersStructure.Insert("MandatoryFields", "ActDate, ServicesDescriptionTable, Signatory");
	ParametersStructure.Insert("ValueTableRequiredFields", "AmountWithVATTotal, Services, Services.LineNumber, Services.UOM");
	
	Return ParametersStructure;
	
EndFunction

Function Act501CustomerParametersStructure(ThisIsInd)
	
	ParametersStructure = New Structure;
	
	ParametersStructure.Insert("Signer", SignerAttributesStructureFTS(ThisIsInd));
	ParametersStructure.Insert("ActNumber");
	ParametersStructure.Insert("DateOfAct");
	ParametersStructure.Insert("PowerOfAttorney", PowerOfAttorneyAttributesStructureFTS());
	ParametersStructure.Insert("SignatureOrder", New Structure("Position, Last name, First name, Middle name"));
	ParametersStructure.Insert("OrderDate");
	ParametersStructure.Insert("Claim");
	
	MaxLength = GetXDTOschemaFieldProperty("ZAKTPRM2", "File.Document.PrActI.InfFul", "TextInf", XDTOFacetType.MaxLength);
	ParametersStructure.Insert("AllowedLengthOfExtraDataCaps", MaxLength - 20); // 20 - service characters.
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("MandatoryFields", "Signer");
	
	Return ParametersStructure;
	
EndFunction

// Structure of address contains all possible variants of address completion:
// Structured address (by KLADR), arbitrary Russian/foreign.
// address type is selected from the list of
// values AddressTypes and corresponding structure is populated which is described in list item value.
// There shall be one mark in the list of types, otherwise
// the first type of address with mark will be taken and based on this type address data will be filled in ED.
//
Function AddressStructureFTS()
	
	StructureOfAddress = New Structure;
	
	StructureOfAddress.Insert("IndexOf");
	StructureOfAddress.Insert("CodeState");
	StructureOfAddress.Insert("District");
	StructureOfAddress.Insert("City");
	StructureOfAddress.Insert("Settlement");
	StructureOfAddress.Insert("Street");
	StructureOfAddress.Insert("Building");
	StructureOfAddress.Insert("Section");
	StructureOfAddress.Insert("Qart");
	StructureOfAddress.Insert("MandatoryFields", "CodeState");

	
	AddressAdvancesPaidInStorageTypes = New ValueList;
	AddressAdvancesPaidInStorageTypes.Add(StructureOfAddress, "Structured", True);
	AddressAdvancesPaidInStorageTypes.Add(New Structure("CountryCode, AddressInLine"), "Arbitrary", False);
	AddressAdvancesPaidInStorageTypes.Add(New Structure("CountryCode, AddressInLine"), "Foreign", False);
	
	Return AddressAdvancesPaidInStorageTypes;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Check of mandatory fields

Function CheckRequiredVTFieldsFilling(Source, VT, Val VTFields, VTName, ErrorText)
	
	If VT.Count() > 0 Then
		//MandatoryColumnsStructure = New Structure(VTFields);
		MandatoryColumnsArray = StringFunctionsClientServer.DecomposeStringIntoSubstringsArray(VTFields);
		ColumnsCount = MandatoryColumnsArray.Count();
		For IndexOf = 1 To ColumnsCount Do
			Item = TrimAll(MandatoryColumnsArray[ColumnsCount - IndexOf]);
			// add. Checking of existence of mandatory columns in nested tables (see the function Act501ParametersStructure.
			If Find(Item, ".") = 0 AND VT.Columns.Find(Item) = Undefined Then
					ErrorTemplate = NStr("en='In the table ""%1"" the column mandatory for filling is absent: ""%2"".';ru='В таблице ""%1"" отсутствует обязательная к заполнению колонка: ""%2.""'");
					UserPresentation = ElectronicDocumentsReUse.GetUserPresentation(
																												Source,
																												Item);
					TextCurrentErrors = StringFunctionsClientServer.SubstituteParametersInString(
																	ErrorTemplate,
																	VTName,
																	UserPresentation);
					ErrorText = ErrorText + TextCurrentErrors + Chars.LF;
					MandatoryColumnsArray.Delete(ColumnsCount - IndexOf);
			EndIf;
			
		EndDo;
		For Each String IN VT Do
			For Each Item IN MandatoryColumnsArray Do
				Item = TrimAll(Item);
				// Checking of mandatory fields completion in nested tables (see the function Act501ParametersStructure.
				If Find(Item, ".") <> 0 Then
					NestedTable = Left(Item, Find(Item, ".") - 1);
					NestedTableObligateParameter = Mid(Item, Find(Item, ".") + 1);
					
					UserVTPresentation = ElectronicDocumentsReUse.GetUserPresentation(
						Source, NestedTable);
					CheckRequiredVTFieldsFilling(Source, String[NestedTable], NestedTableObligateParameter,
						UserVTPresentation, ErrorText);
				Else
					ParameterValue = String[Item];
					If TypeOf(ParameterValue) = Type("Structure") Then
						CheckRequiredFieldsFilling(ParameterValue, ErrorText);
						
					ElsIf Not ValueIsFilled(ParameterValue) AND Not TypeOf(ParameterValue) = Type("Number") Then
						ErrorTemplate = NStr("en='In the row #%1 of the table ""%2"" the value ""%3"" is not filled.';ru='В строке №%1 таблицы ""%2"" не заполнено значение ""%3.""'");
						
						UserPresentation = ElectronicDocumentsReUse.GetUserPresentation(Source,
							Item);
						ErrorText = ErrorText + StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate,
							VT.IndexOf(String) + 1, VTName, UserPresentation) + Chars.LF;
					EndIf;
				EndIf;
			EndDo;
		EndDo;
	Else
		ErrorTemplate = NStr("en='Obligatory table is not filled in: ""%1.""';ru='Не заполнена обязательная таблица: ""%1.""'");
		ErrorText = ErrorText + StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, VTName) + Chars.LF;
	EndIf;
	ParametersFilled = Not ValueIsFilled(ErrorText);
	
	Return ParametersFilled;
	
EndFunction

// Checks the completion of mandatory fields in
// ParametersStructure if the value of mandatory field is a
// nested structure, then it is checked recursively in this function; if
// the value of mandatory field is a nested values table, then it is sent for checking to the function CheckVTMandatoryFieldsCompletion
// List of mandatory fields of checked structure, taken
// from structure item value
// with key "MandatoryFields" List of mandatory columns of values table,
// taken from structure item value with key "ValuesTableMandatoryFields"
//
// Parameters:
//  Source             - ref - Reference to the object of infobase.
//  ParametersStructure  - structure - tested structure with data.
//  ErrorText - String - String containing the description
//    of unfilled fields of checked structure, can be displayed to the user in the calling procedure.
//
// Returns:
//  ParametersFilled - Boolean - True - if mandatory fields are filled, otherwise - False.
//
Function CheckRequiredFieldsFilling(Source, ParametersStructure, ErrorText = "")
	
	MandatoryFields = "";
	ParameterValue = "";
	DataPrepared = False;
	
	If ParametersStructure.Property("DataPrepared", DataPrepared) AND Not DataPrepared Then
		Return False;
	EndIf;
	
	ErrorInfo = Undefined;
	If ParametersStructure.Property("ErrorText", ErrorInfo) AND ValueIsFilled(ErrorInfo) Then
		ErrorText = ErrorInfo;
		Return False;
	EndIf;
	
	RequiredFieldsStructure = ParametersStructure;
	If ParametersStructure.Property("MandatoryFields", MandatoryFields) Then
		RequiredFieldsStructure = New Structure(MandatoryFields);
	EndIf;
	
	For Each Item IN RequiredFieldsStructure Do
		If ParametersStructure.Property(Item.Key, ParameterValue) Then
			If TypeOf(ParameterValue) = Type("Structure") Then
				CheckRequiredFieldsFilling(Source, ParameterValue, ErrorText);
			ElsIf TypeOf(ParameterValue) = Type("ValueTable") Then
				VTFields = "";
				UserVTPresentation = ElectronicDocumentsReUse.GetUserPresentation(Source,
					Item.Key);
				If ParametersStructure.Property("ValueTableRequiredFields", VTFields) Then
					CheckRequiredVTFieldsFilling(Source, ParameterValue, VTFields, UserVTPresentation,
						ErrorText);
				Else
					ErrorTemplate = NStr("en='List of mandatory fields of the table is not completed: ""%1"".';ru='Не заполнен перечень обязательных полей таблицы: ""%1"".'");
					ErrorText = ErrorText + StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate,
						UserVTPresentation) + Chars.LF;
				EndIf;
			ElsIf TypeOf(ParameterValue) = Type("ValueList") Then
				For Each ItemOP IN ParameterValue Do
					If ItemOP.Check Then
						CheckStructure = New Structure("Item", ItemOP.Value);
						CheckRequiredFieldsFilling(Source, CheckStructure, ErrorText);
					EndIf;
				EndDo;
			Else
				If Not ValueIsFilled(ParameterValue) AND Not TypeOf(ParameterValue) = Type("Number") Then
					ErrorTemplate = NStr("en='Mandatory field of parameters structure is not filled in: ""%1"".';ru='Не заполнено обязательное поле структуры параметров: ""%1"".'");
					
					UserPresentation = ElectronicDocumentsReUse.GetUserPresentation(Source,
						Item.Key);
					ErrorText = ErrorText + StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate,
						UserPresentation) + Chars.LF;
				EndIf;
			EndIf;
		Else
			ErrorTemplate = NStr("en='Mandatory field is absent in parameters structure: ""%1"".';ru='Отсутствует обязательное поле в структуре параметров: ""%1"".'");
			ErrorText = ErrorText + StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate,
				Item.Key) + Chars.LF;
		EndIf;
	EndDo;
	ParametersFilled = Not ValueIsFilled(ErrorText);
	
	Return ParametersFilled;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Filling of files

Procedure FillBuyerData(SubordinatedEDFileName, BuyerEDDirection, BuyerData)
	
	Result = GenerateParseTree(SubordinatedEDFileName, BuyerEDDirection);
	
	If Result <> Undefined Then
	
		ParseTree = Result.ParseTree;
		ObjectString = Result.ObjectString;
		
		BuyerData.Insert("CargoReceivedPosition", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CargoReceivedPosition"));
		BuyerData.Insert("CargoReceivedSNP", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CargoReceivedSNP"));
		BuyerData.Insert("DateReceived", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateReceived"));
		
	EndIf;
	
EndProcedure

Procedure CustomerDatgaFill(SubordinatedEDFileName, BuyerEDDirection, ConsumerData)
	
	Result = GenerateParseTree(SubordinatedEDFileName, BuyerEDDirection);
	
	If Result <> Undefined Then
	
		ParseTree = Result.ParseTree;
		ObjectString = Result.ObjectString;
		ConsumerData.Insert("Claims", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Claims"));
		
		ConsumerData.Insert("AcceptedPosition", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "AcceptedPosition"));
		ConsumerData.Insert("AcceptedDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "AcceptedDescriptionFull"));
		ConsumerData.Insert("DateReceived", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateReceived"));
		
	EndIf;
	
EndProcedure

Function FillPowerOfAttorneyData(XDTOAuthorization, DataStructurePowerofattorney, ErrorText, TargetNamespaceSchema)
	
	ObjectFilled = False;
	If TypeOf(DataStructurePowerofattorney) = Type("Structure")
		AND (ValueIsFilled(DataStructurePowerofattorney.CompanyIssuedPowerOfAttorney)
		OR ValueIsFilled(DataStructurePowerofattorney.PowerOfAttorneyNumber)
		OR ValueIsFilled(DataStructurePowerofattorney.DateOfPowerOfAttorney)
		OR ValueIsFilled(DataStructurePowerofattorney.AdditionalInformationAboutPowerOfAttorneyIssue)
		OR ValueIsFilled(DataStructurePowerofattorney.AdditInformationAboutSubstitutedTrustee)) Then
		
		If ValueIsFilled(DataStructurePowerofattorney.PowerOfAttorneyNumber) Then
			FillXDTOProperty(XDTOAuthorization, "NumPowerOfAttorn",
			DataStructurePowerofattorney.PowerOfAttorneyNumber, , ErrorText);
		EndIf;
		If ValueIsFilled(DataStructurePowerofattorney.DateOfPowerOfAttorney) Then
			FillXDTOProperty(XDTOAuthorization, "DateGiven",
			DateDD_MM_YYYY(DataStructurePowerofattorney.DateOfPowerOfAttorney), , ErrorText);
		EndIf;
		
		If ValueIsFilled(DataStructurePowerofattorney.CompanyIssuedPowerOfAttorney)
			OR ValueIsFilled(DataStructurePowerofattorney.AdditionalInformationAboutPowerOfAttorneyIssue)
			OR ValueIsFilled(DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Position)
			OR ValueIsFilled(DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Surname) Then
			WhoIssued = GetCMLObjectType("PowerOfAttorneyType.WhoIssued", TargetNamespaceSchema);
			
			If ValueIsFilled(DataStructurePowerofattorney.CompanyIssuedPowerOfAttorney) Then
				FillXDTOProperty(WhoIssued, "EntDescWhoIssued",
				DataStructurePowerofattorney.CompanyIssuedPowerOfAttorney, , ErrorText);
			EndIf;
			If ValueIsFilled(DataStructurePowerofattorney.AdditionalInformationAboutPowerOfAttorneyIssue) Then
				FillXDTOProperty(WhoIssued, "AdditInfWho",
				DataStructurePowerofattorney.AdditionalInformationAboutPowerOfAttorneyIssue, , ErrorText);
			EndIf;
			If ValueIsFilled(DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Position) Then
				FillXDTOProperty(WhoIssued, "PositWho",
				DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Position, , ErrorText);
			EndIf;
			If ValueIsFilled(DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Surname) Then
				NameAndSurnameOfType = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
				FillXDTOProperty(NameAndSurnameOfType, "Surname",
				DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Surname, True, ErrorText);
				FillXDTOProperty(NameAndSurnameOfType, "Name",
				DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Name, True, ErrorText);
				If ValueIsFilled(DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Patronymic) Then
					FillXDTOProperty(NameAndSurnameOfType, "Patronymic",
					DataStructurePowerofattorney.PersonIssuedPowerOfAttorney.Patronymic, , ErrorText);
				EndIf;
				FillXDTOProperty(WhoIssued, "Initials", NameAndSurnameOfType, , ErrorText);
			EndIf;
			FillXDTOProperty(XDTOAuthorization, "WhoIssued", WhoIssued, , ErrorText);
		EndIf;
		
		If ValueIsFilled(DataStructurePowerofattorney.AdditInformationAboutSubstitutedTrustee)
			OR ValueIsFilled(DataStructurePowerofattorney.SubstitutedTrustee.Position)
			OR ValueIsFilled(DataStructurePowerofattorney.SubstitutedTrustee.Surname) Then
			ToWhomIssued = GetCMLObjectType("PowerOfAttorneyType.ToWhomIssued", TargetNamespaceSchema);
			
			If ValueIsFilled(DataStructurePowerofattorney.AdditInformationAboutSubstitutedTrustee) Then
				FillXDTOProperty(ToWhomIssued, "AdditInfoToWhom",
				DataStructurePowerofattorney.AdditInformationAboutSubstitutedTrustee, , ErrorText);
			EndIf;
			If ValueIsFilled(DataStructurePowerofattorney.SubstitutedTrustee.Position) Then
				FillXDTOProperty(ToWhomIssued, "Posit", DataStructurePowerofattorney.SubstitutedTrustee.Position, , ErrorText);
			EndIf;
			If ValueIsFilled(DataStructurePowerofattorney.SubstitutedTrustee.Surname) Then
				NameAndSurnameOfType = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
				FillXDTOProperty(NameAndSurnameOfType, "Surname", DataStructurePowerofattorney.SubstitutedTrustee.Surname, True, ErrorText);
				FillXDTOProperty(NameAndSurnameOfType, "Name", DataStructurePowerofattorney.SubstitutedTrustee.Name, True, ErrorText);
				If ValueIsFilled(DataStructurePowerofattorney.SubstitutedTrustee.Patronymic) Then
					FillXDTOProperty(NameAndSurnameOfType, "Patronymic", DataStructurePowerofattorney.SubstitutedTrustee.Patronymic, , ErrorText);
				EndIf;
				FillXDTOProperty(ToWhomIssued, "Initials", NameAndSurnameOfType, , ErrorText);
			EndIf;
			FillXDTOProperty(XDTOAuthorization, "ToWhomIssued", ToWhomIssued, , ErrorText);
		EndIf;
		ObjectFilled = True
	EndIf;
	
	Return ObjectFilled;
	
EndFunction

Function FillCMLPowerOfAttorneyData(XDTOAuthorization, DataTree, ErrorText, TargetNamespaceSchema, Prefix = "")
	
	ObjectFilled = False;
	Prefix = Prefix + ?(ValueIsFilled(Prefix), ".", "");
	WhoIssued = GetCMLObjectType("PowerOfAttorneyType.WhoIssued", TargetNamespaceSchema);
	BlockIsFilled = False;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "CompanyIssuedPowerOfAttorney") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "CompanyIssuedPowerOfAttorney");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(WhoIssued, "EntDescWhoIssued", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "PersonWhoIssuedPowerOfAttorney.Position") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "PersonWhoIssuedPowerOfAttorney.Position");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(WhoIssued, "PositWho", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "PersonWhoIssuedPowerOfAttorney.Surname") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "PersonWhoIssuedPowerOfAttorney.Surname");
		If ValueIsFilled(Attribute) Then
			NameAndSurnameOfType = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			FillXDTOProperty(NameAndSurnameOfType, "Surname", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, Prefix + "PersonIssuedPowerOfAttorney.Name");
			FillXDTOProperty(NameAndSurnameOfType, "Name", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, Prefix + "PersonWhoIssuedPowerOfAttorney.MiddleName");
			If ValueIsFilled(Attribute) Then
				FillXDTOProperty(NameAndSurnameOfType, "Patronymic", Attribute, , ErrorText);
			EndIf;
			FillXDTOProperty(WhoIssued, "Initials", NameAndSurnameOfType, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "PowerOfAttorneyNumber") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "PowerOfAttorneyNumber");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(XDTOAuthorization, "NumPowerOfAttorn", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "DateOfPowerOfAttorney") Then
		Attribute = DateDD_MM_YYYY(TreeAttributeValue(DataTree, Prefix + "DateOfPowerOfAttorney"));
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(XDTOAuthorization, "DateGiven", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "AdditionalInformationAboutPowerOfAttorneyIssue") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "AdditionalInformationAboutPowerOfAttorneyIssue");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(WhoIssued, "AdditInfWho", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	
	If BlockIsFilled Then
		FillXDTOProperty(XDTOAuthorization, "WhoIssued", WhoIssued, , ErrorText);
		ObjectFilled = True;
	EndIf;
	
	ToWhomIssued = GetCMLObjectType("PowerOfAttorneyType.ToWhomIssued", TargetNamespaceSchema);
	BlockIsFilled = False;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "AdditInformationAboutSubstitutedTrustee") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "AdditInformationAboutSubstitutedTrustee");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(ToWhomIssued, "AdditInfoToWhom", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "AuthorizedRepresentative.Position") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "AuthorizedRepresentative.Position");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(ToWhomIssued, "Posit", Attribute, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	If CommonUseED.AttributeExistsInTree(DataTree, Prefix + "AuthorizedRepresentative.Surname") Then
		Attribute = TreeAttributeValue(DataTree, Prefix + "AuthorizedRepresentative.Surname");
		If ValueIsFilled(Attribute) Then
			NameAndSurnameOfType = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			FillXDTOProperty(NameAndSurnameOfType, "Surname", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, Prefix + "SubstitutedTrustee.Name");
			FillXDTOProperty(NameAndSurnameOfType, "Name", Attribute, True, ErrorText);
			Attribute = TreeAttributeValue(DataTree, Prefix + "AuthorizedRepresentative.Patronymic");
			If ValueIsFilled(Attribute) Then
				FillXDTOProperty(NameAndSurnameOfType, "Patronymic", Attribute, , ErrorText);
			EndIf;
			FillXDTOProperty(ToWhomIssued, "Initials", NameAndSurnameOfType, , ErrorText);
			BlockIsFilled = True;
		EndIf;
	EndIf;
	
	If BlockIsFilled Then
		FillXDTOProperty(XDTOAuthorization, "ToWhomIssued", ToWhomIssued, , ErrorText);
		ObjectFilled = True;
	EndIf;
	
	Return ObjectFilled;
	
EndFunction

Function FillCMLSignerData(XDTOSigner, DataStructureToSeller, ErrorText, TargetNamespaceSchema)
	
	ObjectFilled = False;
	If TypeOf(DataStructureToSeller) = Type("Structure") Then
		If TypeOf(DataStructureToSeller.ThisIsInd) = Type("Boolean") AND DataStructureToSeller.ThisIsInd Then
			CO = GetCMLObjectType("File.Document.Signer.CO", TargetNamespaceSchema);
			Initials = GetCMLObjectType("File.Document.Signer.CO.Initials", TargetNamespaceSchema);
			FillXDTOProperty(Initials, "Surname", DataStructureToSeller.Surname, True, ErrorText);
			FillXDTOProperty(Initials, "Name", DataStructureToSeller.Name, True, ErrorText);
			If ValueIsFilled(DataStructureToSeller.Patronymic) Then
				FillXDTOProperty(Initials, "Patronymic", DataStructureToSeller.Patronymic, , ErrorText);
			EndIf;
			FillXDTOProperty(CO, "Initials", Initials, True, ErrorText);
			FillXDTOProperty(CO, "TINInd", DataStructureToSeller.TIN, True, ErrorText);
			If ValueIsFilled(DataStructureToSeller.CertificateAboutRegistrationIP) Then
				FillXDTOProperty(CO, "PrFedRegSN", DataStructureToSeller.CertificateAboutRegistrationIP, , ErrorText);
			EndIf;
			FillXDTOProperty(XDTOSigner, "CO", CO, True, ErrorText);
		Else
			LegalEntity = GetCMLObjectType("File.Document.Signer.LegalEntity", TargetNamespaceSchema);
			Initials = GetCMLObjectType("File.Document.Signer.LegalEntity.Initials", TargetNamespaceSchema);
			FillXDTOProperty(Initials, "Surname", DataStructureToSeller.Surname, True, ErrorText);
			FillXDTOProperty(Initials, "Name", DataStructureToSeller.Name, True, ErrorText);
			If ValueIsFilled(DataStructureToSeller.Patronymic) Then
				FillXDTOProperty(Initials, "Patronymic", DataStructureToSeller.Patronymic, , ErrorText);
			EndIf;
			FillXDTOProperty(LegalEntity, "Initials", Initials, True, ErrorText);
			FillXDTOProperty(LegalEntity, "TINLP", DataStructureToSeller.TIN, True, ErrorText);
			FillXDTOProperty(LegalEntity, "Posit", DataStructureToSeller.Position, True, ErrorText);
			FillXDTOProperty(XDTOSigner,"LegalEntity", LegalEntity, True, ErrorText);
		EndIf;
		ObjectFilled = True
	EndIf;
	
	Return ObjectFilled;
	
EndFunction

Function FillResponsiblePersonFTSCML(ReleasePermittedXDTO, Official, ErrorText, TargetNamespaceSchema)
	
	ObjectFilled = False;
	If TypeOf(Official) = Type("Structure") AND ValueIsFilled(Official.Surname) Then
		NameAndSurnameOfType = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
		FillXDTOProperty(NameAndSurnameOfType, "Surname", Official.Surname, True, ErrorText);
		FillXDTOProperty(NameAndSurnameOfType, "Name", Official.Name, True, ErrorText);
		If ValueIsFilled(Official.Patronymic) Then
			FillXDTOProperty(NameAndSurnameOfType, "Patronymic", Official.Patronymic, , ErrorText);
		EndIf;
		If ValueIsFilled(Official.Position) Then
			FillXDTOProperty(ReleasePermittedXDTO, "Position", Official.Position, , ErrorText);
		EndIf;
		FillXDTOProperty(ReleasePermittedXDTO, "Initials", NameAndSurnameOfType, True, ErrorText);
		ObjectFilled = True
	EndIf;
	
	Return ObjectFilled;
	
EndFunction

Function FillParticipantDataFTSCML(ParticipantXDTO, ParticipantParametersStructure, ErrorText, TargetNamespaceSchema)
	
	DataFilled = False;
	
	If TypeOf(ParticipantParametersStructure.ThisIsInd) = Type("Boolean") Then
		IdPr = GetCMLObjectType("ParticipantType.IdPr", TargetNamespaceSchema);
		
		If ParticipantParametersStructure.ThisIsInd Then
			PrPP = GetCMLObjectType("ParticipantType.IdPr.PrPP", TargetNamespaceSchema);
			FillXDTOProperty(PrPP, "TINInd", ParticipantParametersStructure.TIN, ,ErrorText);
			
			Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			FillXDTOProperty(Initials, "Surname", ParticipantParametersStructure.Surname,True ,ErrorText);
			FillXDTOProperty(Initials, "Name", ParticipantParametersStructure.Name, True ,ErrorText);
			FillXDTOProperty(Initials, "Patronymic", ParticipantParametersStructure.Patronymic, , ErrorText);
			
			FillXDTOProperty(PrPP, "NameAndSurnameIP", Initials, , ErrorText);
			FillXDTOProperty(IdPr, "PrPP",  PrPP, , ErrorText);
			If TargetNamespaceSchema = "IAKTPRM2" Then
				PrLP = GetCMLObjectType("ParticipantType.IdPr.PrLP", TargetNamespaceSchema);
				FillXDTOProperty(PrLP, "DescEnt", "---", , ErrorText);
				FillXDTOProperty(IdPr, "PrLP", PrLP, , ErrorText);
			EndIf;
			Description = ParticipantParametersStructure.Surname + " " + ParticipantParametersStructure.Name + " "
				+ ParticipantParametersStructure.Patronymic;
		Else
			PrLP = GetCMLObjectType("ParticipantType.IdPr.PrLP", TargetNamespaceSchema);
			FillXDTOProperty(PrLP, "DescEnt", ParticipantParametersStructure.CompanyDescription,  ,ErrorText);
			FillXDTOProperty(PrLP, "TINLP", ParticipantParametersStructure.TIN, , ErrorText);
			FillXDTOProperty(IdPr, "PrLP", PrLP, , ErrorText);
			If TargetNamespaceSchema = "IAKTPRM2" Then
				PrPP = GetCMLObjectType("ParticipantType.IdPr.PrPP", TargetNamespaceSchema);
				Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
				FillXDTOProperty(Initials, "Surname", "---", True ,ErrorText);
				FillXDTOProperty(Initials, "Name",     "---", True ,ErrorText);
				FillXDTOProperty(PrPP, "NameAndSurnameIP", Initials, , ErrorText);
				FillXDTOProperty(IdPr, "PrPP",  PrPP, , ErrorText);
			EndIf;
			Description = ParticipantParametersStructure.CompanyDescription;
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "IdPr", IdPr, , ErrorText);
		DataFilled = True;
	EndIf;
	
	Address = "";
	If ParticipantParametersStructure.Property("Address", Address) Then
		FillFTSAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema);
	EndIf;
	
	IsDataToBeFilled = False;
	Contact = GetCMLObjectType("ParticipantType.Contact", TargetNamespaceSchema);
	If ValueIsFilled(ParticipantParametersStructure.Phone) Then
		Length = Number(GetXDTOschemaFieldProperty(TargetNamespaceSchema, "ParticipantType.Contact", "Phone", XDTOFacetType.MaxLength));
		Value = TrimAll(Left(ParticipantParametersStructure.Phone, Length));
		If Length < StrLen(Value) Then
			MessagePattern = NStr("en='Operation execution: Filling of XDTO.
		|Phone number exceeds the permissible length of %1 characters. (exchange participant %2).';ru='Выполнение операции: Заполнение XDTO.
		|Номер телефона превышает допустимую длину %1 симв. (участник обмена %2).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, Length, Description);
			ErrorText = ?(ValueIsFilled(ErrorText), ErrorText + Chars.LF + MessageText, MessageText);
			ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText, 2);
		Else
			FillXDTOProperty(Contact, "Phone", Value, , ErrorText);
			IsDataToBeFilled = True;
		EndIf;
	EndIf;
	If ValueIsFilled(ParticipantParametersStructure.Fax) Then
		Length = Number(GetXDTOschemaFieldProperty(TargetNamespaceSchema, "ParticipantType.Contact", "Fax", XDTOFacetType.MaxLength));
		Value = TrimAll(Left(ParticipantParametersStructure.Fax, Length));
		If Length < StrLen(Value) Then
			MessagePattern = NStr("en='Operation execution: Filling of XDTO.
		|Fax number exceeds the permissible length of %1 characters. (exchange participant %2).';ru='Выполнение операции: Заполнение XDTO.
		|Номер факса превышает допустимую длину %1 симв. (участник обмена %2).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, Length, Description);
			ErrorText = ?(ValueIsFilled(ErrorText), ErrorText + Chars.LF + MessageText, MessageText);
			ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText, 2);
		Else
			FillXDTOProperty(Contact, "Fax", Value, , ErrorText);
			IsDataToBeFilled = True;
		EndIf;
	EndIf;
	If IsDataToBeFilled Then
		FillXDTOProperty(ParticipantXDTO, "Contact", Contact, , ErrorText);
		DataFilled = True;
	EndIf;
	
	IsDataToBeFilled = False; 
	BankingDetails = "AccountNumber, BankName, BIC";
	BankAttributes = GetCMLObjectType("ParticipantType.BankAttr", TargetNamespaceSchema);
	PrBank = GetCMLObjectType("ParticipantType.BankAttr.PrBank", TargetNamespaceSchema);
	For Each StructureItem IN ParticipantParametersStructure.BankAccount Do
		If ValueIsFilled(StructureItem.Value) AND Find(BankingDetails, StructureItem.Key) > 0 Then
			If StructureItem.Key = "AccountNo" Then
				FillXDTOProperty(BankAttributes, StructureItem.Key, StructureItem.Value, ,ErrorText);
			Else
				FillXDTOProperty(PrBank, StructureItem.Key, StructureItem.Value, ,ErrorText);
			EndIf;
			IsDataToBeFilled = True;
		EndIf;
	EndDo;
	If IsDataToBeFilled Then
		FillXDTOProperty(BankAttributes, "PrBank", PrBank, , ErrorText);
		FillXDTOProperty(ParticipantXDTO, "BankAttr", BankAttributes, , ErrorText);
		DataFilled = True;
	EndIf;
	
	Return DataFilled;
	
EndFunction

Function FillParticipantDataFTSForESFCML(ParticipantXDTO, ParticipantParametersStructure, ErrorText, TargetNamespaceSchema)
	
	DataFilled = False;
	
	If TypeOf(ParticipantParametersStructure.ThisIsInd) = Type("Boolean") Then
		IdPr = GetCMLObjectType("PrPurchSalesType.IdPr", TargetNamespaceSchema);
		
		If ParticipantParametersStructure.ThisIsInd Then
			PrPP = GetCMLObjectType("PrPurchSalesType.IdPr.PrPP", TargetNamespaceSchema);
			FillXDTOProperty(PrPP, "TINInd", ParticipantParametersStructure.TIN, ,ErrorText);
			
			Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			FillXDTOProperty(Initials, "Surname", ParticipantParametersStructure.Surname,True ,ErrorText);
			FillXDTOProperty(Initials, "Name", ParticipantParametersStructure.Name, True ,ErrorText);
			FillXDTOProperty(Initials, "Patronymic", ParticipantParametersStructure.Patronymic, , ErrorText);
			
			FillXDTOProperty(PrPP, "NameAndSurnameIP", Initials, , ErrorText);
			FillXDTOProperty(IdPr, "PrPP",  PrPP, , ErrorText);
		Else
			PrLP = GetCMLObjectType("PrPurchSalesType.IdPr.PrLP", TargetNamespaceSchema);
			FillXDTOProperty(PrLP, "DescEnt", ParticipantParametersStructure.CompanyDescription,  ,ErrorText);
			FillXDTOProperty(PrLP, "TINLP", ParticipantParametersStructure.TIN, , ErrorText);
			FillXDTOProperty(IdPr, "PrLP", PrLP, , ErrorText);
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "IdPr", IdPr, , ErrorText);
		DataFilled = True;
	EndIf;
	
	Address = "";
	If ParticipantParametersStructure.Property("Address", Address) Then
		FillFTSAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema);
	EndIf;
	
	Return DataFilled;
	
EndFunction

Procedure GenerateDataByCounterpartyCML(Counterparty, ParametersStructure, CounterpartyKind, ErrorText, SchemaVersion = "4.01", PropertyName = Undefined)
	
	If Not ValueIsFilled(PropertyName) Then
		PropertyName = CounterpartyKind;
	EndIf;
	
	CounterpartyData = Undefined;
	If Not ParametersStructure.Property(PropertyName, CounterpartyData) Then
		Return;
	EndIf;
	
	ThisIsInd = ElectronicDocumentsOverridable.ThisIsInd(CounterpartyData);
	CounterpartyId = ElectronicDocumentsOverridable.GetCounterpartyId(CounterpartyData, CounterpartyKind);
	FillXDTOProperty(Counterparty, "ID", CounterpartyId, True, ErrorText);
	
	// Filling in attributes of a legal entity or an individual.
	DataLegalIndividual = ElectronicDocumentsOverridable.GetDataLegalIndividual(CounterpartyData);
	
	FullDescrName = ?(ThisIsInd, "FullDescr", "OfficialName");
	FullDescr = "";
	DataLegalIndividual.Property(FullDescrName, FullDescr);
	
	If Not ValueIsFilled(FullDescr) Then
		FullDescr = ?(ValueIsFilled(DataLegalIndividual.FullDescr), DataLegalIndividual.FullDescr,
			DataLegalIndividual.Presentation);
	EndIf;
	
	CounterpartyAttributesName  = ?(ThisIsInd, "Ind", "LegalEntity");
	CounterpartyAttributesXDTO = GetCMLObjectType("Counterparty."+CounterpartyAttributesName, SchemaVersion);
	
	FillXDTOProperty(CounterpartyAttributesXDTO, FullDescrName, FullDescr, True, ErrorText);
	FillXDTOProperty(CounterpartyAttributesXDTO, "TIN", DataLegalIndividual.TIN, , ErrorText);
	
	// Legal entity.address or registration address
	If ValueIsFilled(DataLegalIndividual.LegalAddress) Then
		
		LegalAddressName  = ?(ThisIsInd, "RegistrationAddress", "LegalAddress");
		XDTOLegalAddress = GetCMLObjectType("Address", SchemaVersion);
		
		FillXDTOProperty(XDTOLegalAddress, "Presentation", DataLegalIndividual.LegalAddress, True, ErrorText);
		FillXDTOProperty(CounterpartyAttributesXDTO, LegalAddressName, XDTOLegalAddress, , ErrorText);
		
	EndIf;
	
	FillXDTOProperty(Counterparty, CounterpartyAttributesName, CounterpartyAttributesXDTO, , ErrorText);
	
	// BankAccounts.
	BankAcc = Undefined;
	If ((CounterpartyKind = "Company" AND ParametersStructure.Property("CompanyBankAcc", BankAcc))
		OR (CounterpartyKind = "Counterparty" AND ParametersStructure.Property("CounterpartyBankAcc", BankAcc))
		OR (CounterpartyKind = "Company" AND ParametersStructure.Property("ShipperBankAccount", BankAcc))
		OR (CounterpartyKind = "Counterparty" AND ParametersStructure.Property("ShipperBankAccount", BankAcc))
		OR (CounterpartyKind = "Counterparty" AND ParametersStructure.Property("ConsigneeBankAccount", BankAcc)))
		AND ValueIsFilled(BankAcc) Then
		
		BankAccounts = GetCMLObjectType("Counterparty.CurrentAccounts", SchemaVersion);
		BankAccount = GetCMLObjectType("BankAccount", SchemaVersion);
		FillXDTOProperty(BankAccount, "AccountNo", BankAcc.AccountNo, True, ErrorText);
		
		// Bank
		Bank = GetCMLObjectType("Bank", SchemaVersion);
		FillXDTOProperty(Bank, "AccountCorrespondent", BankAcc.Bank.CorrAccount, , ErrorText);
		FillXDTOProperty(Bank, "Description", BankAcc.Bank.Description, , ErrorText);
		FillXDTOProperty(Bank, "BIN", BankAcc.Bank.Code, True, ErrorText);
		FillXDTOProperty(BankAccount, "Bank", Bank, True, ErrorText);
		
		// Correspondent bank
		If ValueIsFilled(BankAcc.SettlementBank) Then
			BankCorr = GetCMLObjectType("Bank", SchemaVersion);
			FillXDTOProperty(BankCorr, "AccountCorrespondent", BankAcc.SettlementBank.CorrAccount, , ErrorText);
			FillXDTOProperty(BankCorr, "Description", BankAcc.SettlementBank.Description, , ErrorText);
			FillXDTOProperty(BankCorr, "BIN", BankAcc.SettlementBank.Code, True, ErrorText);
			FillXDTOProperty(BankAccount, "CorrespondentBank", BankCorr, , ErrorText);
		EndIf;
		
		BankAccounts.BankAccount.Add(BankAccount);
		FillXDTOProperty(Counterparty, "BankAccounts", BankAccounts, , ErrorText);
	EndIf;
	
	// Address
	If TypeOf(DataLegalIndividual) = Type("Structure") AND DataLegalIndividual.Property("ActualAddress")
		AND ValueIsFilled(DataLegalIndividual.ActualAddress) Then
		
		AddressXDTO = GetCMLObjectType("Address", SchemaVersion);
		FillXDTOProperty(AddressXDTO, "Presentation", DataLegalIndividual.ActualAddress, True, ErrorText);
		FillXDTOProperty(Counterparty, "Address", AddressXDTO, , ErrorText);
	EndIf;
	
	// Company contact information
	If (CounterpartyKind = "Company") Then
		ContactsTable = ElectronicDocumentsOverridable.GetContactInformation(CounterpartyData);
		If ContactsTable.Count()>0 Then
			Contacts = GetCMLObjectType("Counterparty.Contacts", SchemaVersion);
			AreContacts = False;
			For Each RowOfContact in ContactsTable Do
				Contact = GetCMLObjectType("ContactInformation", SchemaVersion);
				ErrorText = "";
				If RowOfContact.Type = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds",
					"CompanyEmail") Then
						
					Type = GetCMLTypeValue("ContactType", "Mail");
					FillXDTOProperty(Contact, "Type", Type, True, ErrorText);
					FillXDTOProperty(Contact, "Comment", RowOfContact.Comment, , ErrorText);
					FillXDTOProperty(Contact, "Value", RowOfContact.Value, True, ErrorText);
				ElsIf RowOfContact.Type = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds",
					"CompanyPhone") Then
					
					Type = GetCMLTypeValue("ContactType", "Work phone");
					FillXDTOProperty(Contact, "Type",Type,True, ErrorText);
					FillXDTOProperty(Contact, "Comment", RowOfContact.Comment, , ErrorText);
					FillXDTOProperty(Contact, "Value", RowOfContact.Value, True, ErrorText);
				ElsIf RowOfContact.Type = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds",
					"CounterpartyFax") Then
					
					Type = GetCMLTypeValue("ContactType", "Fax");
					FillXDTOProperty(Contact, "Type",Type,True, ErrorText);
					FillXDTOProperty(Contact, "Comment", RowOfContact.Comment, , ErrorText);
					FillXDTOProperty(Contact, "Value", RowOfContact.Value, True, ErrorText);
					
				EndIf;
				If ErrorText="" Then
					Contacts.Contact.Add(Contact);
					AreContacts = True;
				EndIf;
			EndDo;
			
			If AreContacts Then
				FillXDTOProperty(Counterparty, "Contacts",	Contacts, , ErrorText);
			EndIf;
		EndIf;
	EndIf
	
EndProcedure

Function FillShipperDataRecipientESFCML(ParticipantXDTO, ParticipantParametersStructure, ErrorText, TargetNamespaceSchema)
	
	Var ThisIsInd, Address, CompanyDescription, Surname, Name, Patronymic;
	
	DataFilled = False;
	
	If TypeOf(ParticipantParametersStructure) = Type("Structure")
		AND ParticipantParametersStructure.Property("ThisIsInd", ThisIsInd) AND TypeOf(ThisIsInd) = Type("Boolean") Then
		DescGOP = GetCMLObjectType("PrCargoSendRecType.NameGOP", TargetNamespaceSchema);
		If ThisIsInd Then
			NameAndSurnameIP = GetCMLObjectType("PrCargoSendRecType.DescGOP.NameAndSurnameIP",  TargetNamespaceSchema);
			ParticipantParametersStructure.Property("Surname", Surname);
			ParticipantParametersStructure.Property("Name", Name);
			ParticipantParametersStructure.Property("Patronymic", Patronymic);
			FillXDTOProperty(NameAndSurnameIP, "Surname", Surname, True, ErrorText);
			FillXDTOProperty(NameAndSurnameIP, "Name", Name, True, ErrorText);
			If ValueIsFilled(Patronymic) Then
				FillXDTOProperty(NameAndSurnameIP, "Patronymic", Patronymic, , ErrorText);
			EndIf;
			FillXDTOProperty(DescGOP, "NameAndSurnameIP", NameAndSurnameIP, True, ErrorText);
		Else
			ParticipantParametersStructure.Property("CompanyDescription", CompanyDescription);
			FillXDTOProperty(DescGOP, "DescEnt", CompanyDescription, True ,ErrorText);
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "DescGOP", DescGOP, True, ErrorText);
		
		If ParticipantParametersStructure.Property("Address", Address) Then
			FillFTSAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema);
		EndIf;
		DataFilled = True;
	EndIf;
	
	Return DataFilled;
	
EndFunction

Procedure FillFTSAddress(Counterparty, LocationAddress, ErrorText, TargetNamespaceSchema)
	
	If TypeOf(LocationAddress) = Type("ValueList") Then
		FilledType = Undefined;
		For Each Item IN LocationAddress Do
			If Item.Check Then
				FilledType = Item;
				Break;
			EndIf;
		EndDo;
		If FilledType <> Undefined AND TypeOf(FilledType.Value) = Type("Structure") Then
			AddressType = GetCMLObjectType("AddressType", TargetNamespaceSchema);
			InvoiceSchema = (Find(TargetNamespaceSchema, "SFAKT") <> 0);
			Address = FilledType.Value;
			If FilledType.Presentation = "Structured" Then
				AdrRF = GetCMLObjectType("AddressType.AdrRF", TargetNamespaceSchema);
				FillXDTOProperty(AdrRF, "CodeState", Address.CodeState, InvoiceSchema, ErrorText);
				AddressAttributes = "ZipCode, Region, City, Settlement, Street, House, Block, Apartment";
				For Each Item IN Address Do
					If Find(AddressAttributes, Item.Key) > 0 AND ValueIsFilled(Item.Value) Then
						FillXDTOProperty(AdrRF, Item.Key, Item.Value, , ErrorText);
					EndIf;
				EndDo;
				FillXDTOProperty(AddressType, "AdrRF", AdrRF, InvoiceSchema, ErrorText);
			ElsIf Not InvoiceSchema AND FilledType.Presentation = "Arbitrary" Then
				// IN the scheme of TORG-12 and the Act address in string form is sent in scheme item "AdrText".
				FillXDTOProperty(AddressType, "AdrText", Address.AddressByString, , ErrorText);
			Else
				// IN the scheme of invoice, address is passed as a string in the element of the scheme "AdrFOR".
				AddressXDTO = GetCMLObjectType("AddressType.AdrFRN", TargetNamespaceSchema);
				FillXDTOProperty(AddressXDTO, "StrCode", Address.CountryCode, InvoiceSchema, ErrorText);
				FillXDTOProperty(AddressXDTO, "AdrText", Address.AddressByString, InvoiceSchema, ErrorText);
				
				FillXDTOProperty(AddressType, "AdrFRN", AddressXDTO, InvoiceSchema, ErrorText);
			EndIf;
			
			FillXDTOProperty(Counterparty, "Address", AddressType, InvoiceSchema, ErrorText);
		EndIf;
	EndIf;
	
EndProcedure

Procedure GenerateDataByProductCML(Product, ParametersStructure, ErrorText, SchemaVersion = "4.01")
	
	// Form product ID.
	If ValueIsFilled(ParametersStructure.ID) Then
		ProductID = ParametersStructure.ID;
	Else
		ProductsAndServices = ParametersStructure.ProductsAndServices;
		ProductsAndServicesID = ProductsAndServices.UUID();
		
		CharacteristicID = ""; IDPackage = "";
		If ParametersStructure.Owner().Columns.Find("Characteristic") <> Undefined Then
			Characteristic = ParametersStructure.Characteristic;
			CharacteristicID = ?(ValueIsFilled(Characteristic), Characteristic.UUID(), "");
		EndIf;
		If ParametersStructure.Owner().Columns.Find("Package") <> Undefined Then
			Package = ParametersStructure.Package;
			IDPackage = ?(ValueIsFilled(Package), Package.UUID(), "");
		EndIf;
		
		ProductID = String(ProductsAndServicesID) + "#" + String(CharacteristicID) + "#" + String(IDPackage);
	EndIf;
	
	FillXDTOProperty(Product, "ID", ProductID, True, ErrorText);
	
	If ParametersStructure.Owner().Columns.Find("Barcode") <> Undefined Then
		FillXDTOProperty(Product, "Barcode", ParametersStructure.Barcode, , ErrorText);
	EndIf;
	
	If ParametersStructure.Owner().Columns.Find("SKU") <> Undefined Then
		FillXDTOProperty(Product, "SKU", ParametersStructure.SKU, , ErrorText);
	EndIf;
	
	If ParametersStructure.Owner().Columns.Find("ProductID") <> Undefined Then
		FillXDTOProperty(Product, "ProductID", ParametersStructure.ProductID, , ErrorText);
	EndIf;
	
	FillXDTOProperty(Product, "Description", ParametersStructure.Description, True, ErrorText);
	
	BaseUnit = GetCMLObjectType("Product.BaseUnit", SchemaVersion);
	FillXDTOProperty(BaseUnit, "Code", ParametersStructure.BaseUnitCode, True, ErrorText);
	FillXDTOProperty(BaseUnit, "Description", ParametersStructure.BaseUnitDescription, , ErrorText);
	FillXDTOProperty(BaseUnit, "DescriptionFull", ParametersStructure.BaseUnitDescriptionFull, , ErrorText);
	FillXDTOProperty(BaseUnit, "InternationalAbbreviation", ParametersStructure.BaseUnitInternationalAbbreviation, , ErrorText);
	FillXDTOProperty(Product, "BaseUnit", BaseUnit, True, ErrorText);
	
	If ParametersStructure.Owner().Columns.Find("Definition") <> Undefined Then
		FillXDTOProperty(Product, "Definition", ParametersStructure.Definition, , ErrorText);
	EndIf;
	
	If ParametersStructure.Owner().Columns.Find("AdditionalAttributes") <> Undefined
		AND ParametersStructure.AdditionalAttributes <> Undefined Then
		
		For Each Item IN ParametersStructure.AdditionalAttributes Do
			If Not ValueIsFilled(Item.Value) Then
				Continue;
			EndIf;
			AttributeValue = GetCMLObjectType("AttributeValue", SchemaVersion);
			FillXDTOProperty(AttributeValue, "Description", Item.Key, True, ErrorText);
			
			If TypeOf(Item.Value) = Type("Array") Then
				For Each ArrayElement IN Item.Value Do
					// For correct transfer of customer addresses, collect structure of FTS address in a string.
					If Item.Key = "CustomerFactAddress" OR Item.Key = "CustomerLegAddress" Then
						If TypeOf(ArrayElement) = Type("ValueList") Then
							FilledType = Undefined;
							For Each Item IN ArrayElement Do
								If Item.Check Then
									FilledType = Item;
									Break;
								EndIf;
							EndDo;
							If FilledType <> Undefined AND TypeOf(FilledType.Value) = Type("Structure") Then
								Address = FilledType.Value;
								If FilledType.Presentation = "Structured" Then
									ArrayElement = PrepareAdress(Address);
								Else
									ArrayElement = Address.AddressByString;
								EndIf;
							EndIf;
						EndIf;
					EndIf;
					AttributeValue.Value.Add(ArrayElement)
				EndDo;
			Else
				// For correct transfer of customer addresses, collect structure of FTS address in a string.
				If Item.Key = "CustomerFactAddress" OR Item.Key = "CustomerLegAddress" Then
					If TypeOf(Item.Value) = Type("ValueList") Then
						FilledType = Undefined;
						For Each Item IN Item.Value Do
							If Item.Check Then
								FilledType = Item;
								Break;
							EndIf;
						EndDo;
						If FilledType <> Undefined AND TypeOf(FilledType.Value) = Type("Structure") Then
							Address = FilledType.Value;
							If FilledType.Presentation = "Structured" Then
								Item.Value = PrepareAdress(Address);
							Else
								Item.Value = Address.AddressByString;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
				AttributeValue.Value.Add(Item.Value)
			EndIf;
			
			Product.AdditionalAttributes.Add(AttributeValue);
		EndDo;
	EndIf;
	
EndProcedure

Procedure GenerateDataByPaymentScheduleStagesCML(PaymentScheduleStage, ParametersStructure, ErrorText, ColumnArray)
	
	For Each Column in ColumnArray Do
		If Column = "PayKind" THEN
			
			If ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient", "Advance (before provision)")
				OR ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier", "Advance payment (before confirmation)") Then
				PaymentOption = "Advance";
			ElsIf ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient", "Credit (upon shipment)")
				OR ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier", "Credit (after receipt)") Then
				PaymentOption = "Credit";
			ElsIf ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient", "Advanced payment (before shipment)")
				OR ParametersStructure.PayKind = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier", "Preliminary payment (before receipt)") Then
				PaymentOption = "Prepayment";
			EndIf;
			
			FillXDTOProperty(PaymentScheduleStage,"PayKind", PaymentOption, True, ErrorText);
		ElsIf Column = "PaymentDate" THEN
			FillXDTOProperty(PaymentScheduleStage,"PaymentDate", XMLDate(ParametersStructure.PaymentDate), True, ErrorText);
		ElsIf Column = "PaymentPercent" THEN
			FillXDTOProperty(PaymentScheduleStage,"PaymentPercent", ParametersStructure.PaymentPercent, True, ErrorText);
		ElsIf Column = "PaymentAmount" THEN
			FillXDTOProperty(PaymentScheduleStage,"PaymentAmount", ParametersStructure.PaymentAmount, True, ErrorText);
		EndIf;
	EndDo;
	
EndProcedure

Procedure GenerateDataByMeasurementUnitCML(MeasurementUnit, ParametersStructure, ErrorText)
	
	FillXDTOProperty(MeasurementUnit, "Code", ParametersStructure.MeasurementUnitCode, , ErrorText);
	FillXDTOProperty(MeasurementUnit, "Description", ParametersStructure.MeasurementUnitDescription, ,ErrorText);
	FillXDTOProperty(MeasurementUnit, "Factor", ParametersStructure.Factor, , ErrorText);
	
EndProcedure

Procedure SetXDTOValue(XDTODataObject, PropertyName, Value, ErrorText)
	
	Try
		XDTODataObject.Set(PropertyName, Value);
	Except
		MessagePattern = NStr("en='Operation execution: Filling of XDTO.
		|Setup of ""%1"" property value failed!';ru='Выполнение операции: Заполнение XDTO.
		|Ошибка установки значения свойства ""%1""!'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, PropertyName);
		ErrorText = ?(ValueIsFilled(ErrorText), ErrorText + Chars.LF + MessageText, MessageText);
		
		ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText + Chars.LF
			+ DetailErrorDescription(ErrorInfo()), 2);
	EndTry
	
EndProcedure

Function XMLNumber(Value)
	
	Return Format(Value, "NDS=.; NZ=0; NG=");
	
EndFunction

Function XMLDateTime(Value)
	
	If ValueIsFilled(Value) Then
		Return Format(Value, "DF=yyyy-MM-dd'T'HH:mm:cc");
	EndIf;
	
	Return "0001-01-01T00:00:00";
	
EndFunction

Function XMLDate(Value)
	
	If ValueIsFilled(Value) Then
		Return Format(Value, "DF=yyyy-MM-dd");
	EndIf;
	
	Return "0001-01-01";
	
EndFunction

Function DateDD_MM_YYYY(DateTime)
	
	If TypeOf(DateTime) = Type("Date") Then
		ReturValue = Format(DateTime, "DF=dd.MM.yyyy");
	Else
		ReturValue = Left(DateTime, 10);
	EndIf;
	
	Return ReturValue;
	
EndFunction

Function ReturnVersionNumberFromIdED(SenderId)
	
	VersionNumber = 0;
	StartPosition = Find(SenderId, "##");
	If StartPosition > 0 Then
		VersionNumber = Mid(SenderId, StartPosition + 2, StrLen(SenderId) - (StartPosition + 1));
	EndIf;
	
	Return VersionNumber;
	
EndFunction

Procedure FillInCurrentAccount(DataTree, DocumentXDTO)
	
	AccountNo = TreeAttributeValue(DataTree, "CurrentAccount.AccountNumber");
	
	StructureAccount = New Structure("AccountNumber, BIC, AccountCorrespondent,
			|BankName, BicCorr, AccountCorr, NameCorr");
	
	If ValueIsFilled(AccountNo) Then
		
		// fill in current account
		StructureAccount.AccountNo = AccountNo;
		
		// Fill in a bank
		
		BankBic = TreeAttributeValue(DataTree, "BankAccount.Bank.BIN", False);
		If ValueIsFilled(BankBic) Then
			StructureAccount.BIN = BankBic;
		EndIf;
		
		AccountCorrespondent = TreeAttributeValue(DataTree, "BankAccount.Bank.AccountCorrespondent", False);
		If ValueIsFilled(AccountCorrespondent) Then	
			StructureAccount.AccountCorrespondent = AccountCorrespondent;
		EndIf;
		
		BankDescription = TreeAttributeValue(DataTree, "BankAccount.Bank.Description", False);
		If ValueIsFilled(BankDescription) Then
			StructureAccount.BankDescription = BankDescription;
		EndIf;
		
		// fill in correspondent bank
		
		BicCorrBank = TreeAttributeValue(DataTree, "BankAccount.CorrespondentBank.BIN");
		
		If ValueIsFilled(BicCorrBank) Then
			StructureAccount.BicCorr = BicCorrBank;
		EndIf;
		
		BalancedAccountCorrespondent = TreeAttributeValue(DataTree, "BankAccount.CorrespondentBank.AccountCorrespondent");
		If ValueIsFilled(BalancedAccountCorrespondent) Then
			StructureAccount.AccountCorr = BalancedAccountCorrespondent;
		EndIf;
		
		CorBankName = TreeAttributeValue(DataTree, "BankAccount.CorrespondentBank.Description");
		If ValueIsFilled(CorBankName) Then
			StructureAccount.NameCorr =  CorBankName;
		EndIf;
		
		PutStructureToAttributeValue("BankAccount", StructureAccount, DocumentXDTO);
	
	EndIf;
	

EndProcedure
////////////////////////////////////////////////////////////////////////////////
// CML

Function GetObjectTypeCML(Type, SchemaVersion)
	
	PathArray = SubstringArray(Type, ".");
	
	FirstItem = PathArray[0];
	If Left(FirstItem,1) = "{" AND Right(FirstItem,1) = "}" Then
		PackageName = Mid(FirstItem, 2, StrLen(FirstItem) - 2);
		Collection = XDTOFactory.packages.Get(PackageName).RootProperties;
	ElsIf SchemaVersion <> "4.02" Then
		ObjectType = XDTOFactory.Type(SchemaVersion, FirstItem);
		Collection = ObjectType.Properties;
	Else
		ObjectType = XDTOFactory.Type("http://v8.1c.ru/edi/edi_stnd", FirstItem);
		Collection = ObjectType.Properties;
	EndIf;
	
	PathArray.Delete(0);
	While PathArray.Count() > 0 Do
		
		If Collection = Undefined Then
			Return Undefined;
		EndIf;
		
		Property = Collection.Get(PathArray[0]);
		If Property = Undefined Then
			Return Undefined;
		EndIf;
		
		ObjectType = Property.Type;
		PathArray.Delete(0);
		Try
			Collection = ObjectType.Properties;
		Except
			Collection = Undefined;
		EndTry;
		
	EndDo;
	
	Return ObjectType;
	
EndFunction

Function GetCMLTypeValue(Type, Value)
	
	If TypeOf(Type) = Type("String") Then
		ValueType = GetCMLValueType(Type);
	Else
		ValueType = Type;
	EndIf;
	
	If ValueType = Undefined Then
		
		Return Undefined;
	EndIf;
	
	NewValue = XDTOFactory.Create(ValueType, Value);
	
	Return NewValue;
	
EndFunction


Procedure AddToDocumentAttributeValues(DescriptionAttribute, AddedValue, DocumentXDTO)
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	DocumentAttributesValues = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
	DocumentAttributesValues.Description = DescriptionAttribute;
	
	If TypeOf(AddedValue) = Type("Array") Then
		For Each ArrayElement IN AddedValue Do
			DocumentAttributesValues.Value.Add(ArrayElement);
		EndDo;
	ElsIf Find(DescriptionAttribute, "VATRate") > 0 Then
		DocumentAttributesValues.Value.Add(ElectronicDocumentsReUse.VATRateFromCorrespondence(, AddedValue));
		
	Else
		DocumentAttributesValues.Value.Add(AddedValue)
		
	EndIf;
	
	If DocumentXDTO.AttributeValues = Undefined Then
		
		If DocumentXDTO.Type() = GetObjectTypeCML("Document", TargetNamespaceSchema) Then
			XDTODocumentAttributeValues = GetCMLObjectType("Document.AttributeValues", TargetNamespaceSchema);
			
		ElsIf DocumentXDTO.Type() = GetObjectTypeCML("OffersPackage", TargetNamespaceSchema) Then
			XDTODocumentAttributeValues = GetCMLObjectType("OffersPackage.AttributesValues", TargetNamespaceSchema);
	
		Else
			XDTODocumentAttributeValues = GetCMLObjectType("Product.AttributeValues", TargetNamespaceSchema);
		EndIf;
		
		XDTODocumentAttributeValues.AttributeValue.Add(DocumentAttributesValues);
		
		DocumentXDTO.AttributeValues = XDTODocumentAttributeValues;
	Else
		
		DocumentXDTO.AttributeValues.AttributeValue.Add(DocumentAttributesValues);
	EndIf;
	
EndProcedure

Procedure FillInPriceType(TreeRow, XDTOPriceType)
	
	PriceType = TreeAttributeValue(TreeRow, "PriceTypes.LineNumber.PriceType");
	PriceTypeIdentifier = String(PriceType.UUID());
	FillXDTOProperty(XDTOPriceType, "ID", PriceTypeIdentifier);
	
	Description = TreeAttributeValue(TreeRow, "PriceTypes.LineNumber.Description");
	FillXDTOProperty(XDTOPriceType, "Description", Description);
	
	Currency = TreeAttributeValue(TreeRow, "PriceTypes.LineNumber.Currency");
	FillXDTOProperty(XDTOPriceType, "Currency", Currency);
	
	Tax = TableBranchInTree(TreeRow, "PriceTypes.LineNumber.IncludesVAT");
	If Not ValueIsFilled(Tax) Then
		Return;
	EndIf;
	
	TargetNamespaceSchema = ElectronicDocumentsReUse.CMLNamespace();
	
	
	PriceTypeTax =  GetCMLObjectType("OffersPackage.PriceTypes.PriceType.Tax", TargetNamespaceSchema);
	
	
	FillXDTOProperty(PriceTypeTax, "Description", "VAT");
	
	IncludedInAmount = TreeAttributeValue(TreeRow, "PriceTypes.LineNumber.IncludesVAT");
	FillXDTOProperty(PriceTypeTax, "IncludedInAmount", IncludedInAmount);
	
	
	FillXDTOProperty(PriceTypeTax, "Excise", False);
	
	XDTOPriceType.Tax.Add(PriceTypeTax);
	

	
EndProcedure

/////////////////////////////////////////////////////////////////////////////////
// Value tree

Function TableBranchInTree(TreeRow, AttributeName)
	
	FoundString = TreeRow.Rows.Find(AttributeName,"FullPath", True);
	If FoundString <> Undefined Then
		Return FoundString;
	EndIf;

EndFunction

Function TreeEmptyTable(TablePriceTypes)
	
	TableEmpty = False;
	
	If TablePriceTypes = Undefined Then
		TableEmpty = True;
	EndIf;
	
	If TablePriceTypes.Rows.Count() = 0 Then
		TableEmpty = True;
	EndIf;
	
	LineNumberValue = TablePriceTypes.Rows[0].Value;
	
	If Not ValueIsFilled(LineNumberValue) Then
		TableEmpty = True;
	EndIf;
	
	Return TableEmpty;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Files parsing

Procedure ReadActAboutReceivingXDTO(ED, ParseTree, NewED, Error)
	
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.AcceptanceCertificate;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	If EDProperty <> Undefined Then
		TotalByDocumentXDTO = ED.Get(EDProperty);
		PropertyAmountTotal = TotalByDocumentXDTO.Properties().Get("AmountTotal");
		If PropertyAmountTotal <> Undefined Then
			AddObjectHeaderAttribute(NewED, "DocumentAmount", TotalByDocumentXDTO.Get(PropertyAmountTotal));
		EndIf;
		PropertyPriceIncludesVAT = TotalByDocumentXDTO.Properties().Get("PriceIncludesTax");
		If PropertyPriceIncludesVAT <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PriceIncludesVAT", TotalByDocumentXDTO.Get(PropertyPriceIncludesVAT));
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Performer");
	If EDProperty <> Undefined Then
		Performer = ED.Get(EDProperty);
		If NewED.EDDirection = Enums.EDDirections.Outgoing Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Seller");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Customer");
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Customer");
	If EDProperty <> Undefined Then
		Customer = ED.Get(EDProperty);
		If NewED.EDDirection = Enums.EDDirections.Outgoing Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Customer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Seller");
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("DocumentText");
	If EDProperty <> Undefined Then
		DocumentText = ED.Get(EDProperty);
		PropertyTitle = DocumentText.Properties().Get("Title");
		If PropertyTitle <> Undefined Then
			AddObjectHeaderAttribute(NewED, "Title", DocumentText.Get(PropertyTitle));
		EndIf;
		PropertyTitle = DocumentText.Properties().Get("PerformedWorksDescription");
		If PropertyTitle <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PerformedWorksDescription", DocumentText.Get(PropertyTitle));
		EndIf;
		PropertyTitle = DocumentText.Properties().Get("Claims");
		If PropertyTitle <> Undefined Then
			AddObjectHeaderAttribute(NewED, "Claims", DocumentText.Get(PropertyTitle));
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("TotalsInWords");
	If EDProperty <> Undefined Then
		AddObjectHeaderAttribute(NewED, "TotalsInWords", ED.Get(EDProperty));
	EndIf;
	
	DataSet = ED["Products"].Product;
	ReadDataByTSAcceptanceCertificate(DataSet, ED, ParseTree, NewED, Error);
	
EndProcedure

Procedure ReadAct501XDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.ActPerformer;
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrActI.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined AND Find(InfFul.TextInf, "xml") = 0 Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	
	Performer = ED.Document.PrActI.Performer;
	If Performer <> Undefined Then
		If NewED.EDDirection = Enums.EDDirections.Outgoing
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Performer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Customer");
		EndIf;
	EndIf;
	
	Customer = Undefined;
	If Not ED.Document.PrActI.Properties().Get("Customer") = Undefined Then
		Customer = ED.Document.PrActI.Customer;
	ElsIf TypeOf(AdditDataTree) = Type("ValueTree") Then
		Customer = ConsumerDataFromAdditData(AdditDataTree);
	EndIf;
	
	If Customer <> Undefined Then
		If NewED.EDDirection = Enums.EDDirections.Outgoing
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Customer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Performer");
		EndIf;
	EndIf;
		
	Company = GetEDHeaderAttribute(NewED, "Company", ParseTree);
	If Company = Undefined Then // the Act is received from non-1C system, insert Company by ID
		SetPrivilegedMode(True);
		CustomerId = ED.PrAcDocFlow.IdCust;
		Query = New Query;
		Query.Text = "SELECT DISTINCT TOP 1
		               |	EDFProfileSettings.Company
		               |FROM
		               |	Catalog.EDFProfileSettings AS EDFProfileSettings
		               |WHERE
		               |	EDFProfileSettings.CompanyID = &CompanyID";
		Query.SetParameter("CompanyID", CustomerId);
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			CompanyById = Selection.Company;
		EndIf;
		If ValueIsFilled(CompanyById) Then
			Company = CompanyById;
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Companies");
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", Company.Code);
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CustomerId, "Company ID: " + CustomerId,
				Company, AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Company", FoundString.RowIndex);
		EndIf;
		SetPrivilegedMode(False);
	EndIf;
	Structure = New Structure("Company", Company);
	
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
		
		RowCurrency = NewED.Rows.Find("CurrencyCode", "Attribute", True);
		If RowCurrency <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			CurrencyCode = RowCurrency.AttributeValue;
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: "+CurrencyCode,
				Currency, AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		RowBasisDocument = NewED.Rows.Find("IDEDDocumentFoundation", "Attribute", True);
		If RowBasisDocument <> Undefined AND ValueIsFilled(Company) Then
			BasisDocument = GetBasisDocument(RowBasisDocument.AttributeValue, Structure);
			If BasisDocument <> Undefined Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BasisDocuments");
				AddObjectHeaderAttribute(FoundTypeInTree, "BasisDocuments", BasisDocument, BasisDocument);
				FoundString = FoundTypeInTree.Rows.Find(BasisDocument, "ObjectReference");
				FoundString.RowIndex = FoundTypeInTree.RowIndex + "_"
					+ String(FoundTypeInTree.Rows.IndexOf(FoundString));
				AddObjectHeaderAttribute(NewED, "Basis", FoundString.RowIndex, BasisDocument);
			EndIf;
		EndIf;
	EndIf;
	
	OperationKind = NewED.Rows.Find("OperationKind", "Attribute", True);
	If OperationKind <> Undefined Then
		OperationKind.AttributeValue = XMLValue(Type("EnumRef.EDOperationsKinds"), OperationKind.AttributeValue);
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Document.PrActI.NumCertificate);
	DocDate = ED.Document.PrActI.DateCertificate;
	AddObjectHeaderAttribute(NewED, "Date", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
	
	AddObjectHeaderAttribute(NewED, "Title", ED.Document.PrActI.Title);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	
	If ED.Document.PrActI.Delivered <> Undefined Then
		DocDate = ED.Document.PrActI.Delivered.ComplDate;
		If ValueIsFilled(DocDate) Then
			AddObjectHeaderAttribute(NewED, "CompletionDate", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
		EndIf;
		
		If ED.Document.PrActI.Delivered.ExecutSignature <> Undefined Then
			AddObjectHeaderAttribute(NewED, "DeliveredPosition", ED.Document.PrActI.Delivered.ExecutSignature.Position);
			Initials = ED.Document.PrActI.Delivered.ExecutSignature.Initials;
			AddObjectHeaderAttribute(NewED, "DeliveredDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
	EndIf;
	
	WorksDescriptionDataSet = ED.Document.PrActI.WorksDescr;
	DocumentAmount = 0;
	If TypeOf(WorksDescriptionDataSet) = Type("XDTOList") Then
		Ct = 1;
		For Each DescriptionItem IN WorksDescriptionDataSet Do
			
			DescriptionsList = FoundCreateObjectTypeInParseTree(ParseTree, "DescriptionsList");
			
			AddObjectHeaderAttribute(DescriptionsList, "WorkBeg",  DescriptionItem.WorkBeg);
			AddObjectHeaderAttribute(DescriptionsList, "WorkEnd",  DescriptionItem.WorkEnd);
			AddObjectHeaderAttribute(DescriptionsList, "Amount",     DescriptionItem.AmountNoVATTot);
			AddObjectHeaderAttribute(DescriptionsList, "VATAmount",  DescriptionItem.AmountVATTot);
			AddObjectHeaderAttribute(DescriptionsList, "SumWithVAT", DescriptionItem.AmountCtVATTot);
			
			DocumentAmount = DocumentAmount + ?(ValueIsFilled(DescriptionItem.AmountCtVATTot), DescriptionItem.AmountCtVATTot, 0);
			
			// Define ED variant for selection of an algorithm to fill in products and services
			AuthorEDCustomer = False;
			IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
				OR NewED.EDDirection = Enums.EDDirections.Intercompany);
			
			DataSet = DescriptionItem.Work;
			If TypeOf(DataSet) = Type("XDTOList") Then
				For Each Item IN DataSet Do
					ProductDesc = ""; ProductId = "";
					AreAdditAttributes = False;
					
					ListTS = New ValueList;
					ListTS.Add(Item.Number,      "Number");
					ListTS.Add(Item.WorksDesc,  "Description");
					ListTS.Add(Item.Quantity, "Quantity");
					ListTS.Add(Item.Price,       "Price");
					ListTS.Add(Item.AmountNoVAT,  "Amount");
					ListTS.Add(Item.AmountVAT,     "VATAmount");
					ListTS.Add(Item.AmountCtVAT,   "SumWithVAT");
					ListTS.Add(Item.Definition,   "Definition");
					ListTS.Add(Item.DescUnOfMeas,  "MeasurementUnitDescription");
					ListTS.Add(Item.OKEI,       "MeasurementUnitCode");
					
					// Delete first branch - only required for reading old documents.
					If ValueIsFilled(Item.InfFullStr) Then
						If Find(Item.InfFullStr, "xml") > 0 Then
							// IN inf.field xml-string of invalid format.
							XMLObject = New XMLReader;
							Try
								XMLObject.SetString(Item.InfFullStr);
								ServiceXDTO = XDTOFactory.ReadXML(XMLObject);
								ListTS.Add(ServiceXDTO["ID"], "ID");
							Except
							EndTry;
						Else
							// IN inf.field xml-string of Relevant format
							InfFul = Item.InfFullStr;
							ReadInfPol(InfFul, AdditDataTree, "Services", String(Ct) + "." + Item.Number);
						EndIf;
					EndIf;
					
					ProductId = "";
					FillTSRowByAdditData(AdditDataTree, ListTS, String(Ct) + "." + Item.Number, "Services", Error);
					
					ProductsAndServicesAttributes = New Structure;
					MeasurementUnitAttributes = New Structure;
					BaseMeasurementUnitAttributes = New Structure;
					
					For Each ItemOP IN ListTS Do
						
						// ProductsAndServices.
						If ItemOP.Presentation = "Description" Then
							ProductsAndServicesAttributes.Insert("Description", ItemOP.Value);
						ElsIf ItemOP.Presentation = "BaseUnitCode" Then
							BaseMeasurementUnitAttributes.Insert("Code", ItemOP.Value);
						ElsIf ItemOP.Presentation = "BaseUnitDescription" Then
							BaseMeasurementUnitAttributes.Insert("Description", ItemOP.Value);
						ElsIf ItemOP.Presentation = "MeasurementUnitCode" Then
							MeasurementUnitAttributes.Insert("Code", ItemOP.Value);
						ElsIf ItemOP.Presentation = "OKEI_Tov" Then
							MeasurementUnitAttributes.Insert("Code", ItemOP.Value);
						ElsIf ItemOP.Presentation = "MeasurementUnitDescription" Then
							MeasurementUnitAttributes.Insert("Description", ItemOP.Value);
						ElsIf ItemOP.Presentation = "ID" Then
							ProductId = ItemOP.Value;
						ElsIf ItemOP.Presentation = "VATRate" Then
							ItemOP.Value = ItemOP.Value;
						ElsIf ItemOP.Presentation = "IDEDDocumentFoundation" AND ValueIsFilled(Company) Then
							BasisDocument = GetBasisDocument(ItemOP.Value, Structure);
							If BasisDocument <> Undefined Then
								ListTS.Add(BasisDocument, "BasisDocument");
							EndIf;
						EndIf;
					EndDo;
					
					WorksDesc = "";
					ProductsAndServicesAttributes.Property("Description", WorksDesc);
					CodeUnMeas = "";
					If BaseMeasurementUnitAttributes.Property("Code", CodeUnMeas) Then
						UnOfMeasDescription = "";
						BaseMeasurementUnitAttributes.Property("Description", UnOfMeasDescription);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(CodeUnMeas),
							BaseMeasurementUnitAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(CodeUnMeas), UnOfMeasDescription,
							UnOfMeas, BaseMeasurementUnitAttributes, ParseTree, Error);
						If ValueIsFilled(FoundString) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
					
					CodeUnMeas = "";
					If MeasurementUnitAttributes.Property("Code", CodeUnMeas) Then
						UnOfMeasDescription = "";
						MeasurementUnitAttributes.Property("Description", UnOfMeasDescription);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(CodeUnMeas),
							MeasurementUnitAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString     = FindCreateStringInParsedTree( FoundTypeInTree, String(CodeUnMeas),
							UnOfMeasDescription, UnOfMeas, MeasurementUnitAttributes, ParseTree, Error);
						If ValueIsFilled(FoundString) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
					
					// Identification by products and services of the company when the parsing side ED - subsidiary company itself
					If IdentificationByCounterpartyProductsAndServices Then
						IdStructure = ParseProductID(ProductId);
						ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
					Else
						// Suppliers products and services.
						SupplierProductsAndServicesAttributes = New Structure;
						OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
						ProductsAndServicesOwner  = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
						
						SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
						
						If ValueIsFilled(WorksDesc) Then
							SupplierProductsAndServicesAttributes.Insert("Description", WorksDesc);
							
							// If empty ID arrived, then use product name instead of it.
							// Relevant for the incoming ED from accounting systems, other than 1C.
							If Not ValueIsFilled(ProductId) Then
								ProductId = Upper(StrReplace(WorksDesc, " ", "")) + "####";
							EndIf;
						EndIf;
						
						SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
						
						SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
							SupplierProductsAndServicesAttributes);
						
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, WorksDesc, SupplierProductsAndServices,
							SupplierProductsAndServicesAttributes, ParseTree, Error);
						ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
						
						If ValueIsFilled(SupplierProductsAndServices) Then
							ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
							SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
						EndIf;
						ProductAttributesStructure = GenerateProductStructure();
						ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes, ProductAttributesStructure);
						
						ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
					EndIf;
					
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, WorksDesc, ProductsAndServices,
					ProductsAndServicesAttributes, ParseTree, Error);
					
					ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
					
					AddObjectTSAttributes(DescriptionsList, "Work", ListTS);
				EndDo;
			EndIf;
			Ct = Ct + 1;
			AddObjectHeaderAttribute(NewED, "DescriptionsList", DescriptionsList);
		EndDo;
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "DocumentAmount", DocumentAmount);
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadAct501ConsumerXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.ActCustomer;
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrActI.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
	EndIf;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	If ED.Document.PrActI.Accepted <> Undefined Then
		If ED.Document.PrActI.Accepted.DateOrder <> Undefined Then
			DocDate = ED.Document.PrActI.Accepted.DateOrder;
			DateReceived = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2));
			AddObjectHeaderAttribute(NewED, "DateReceived", DateReceived);
		EndIf;
		If ED.Document.PrActI.Accepted.PowOfAttornOrder <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyNumber", ED.Document.PrActI.Accepted.PowOfAttornOrder.NumPowerOfAttorn);
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyDate", ED.Document.PrActI.Accepted.PowOfAttornOrder.DateGiven);
			PowerOfAttorneyIssued = "";
			If ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Company", ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued.EntDescWhoIssued);
				SecondaryStructure.Insert("Position", ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued.PositWho);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued.AdditInfWho);
				If ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued.Initials <> Undefined Then
					Initials = ED.Document.PrActI.Accepted.PowOfAttornOrder.WhoIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			If ED.Document.PrActI.Accepted.PowOfAttornOrder.ToWhomIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Position", ED.Document.PrActI.Accepted.PowOfAttornOrder.ToWhomIssued.Posit);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrActI.Accepted.PowOfAttornOrder.ToWhomIssued.AdditInfoToWhom);
				If ED.Document.PrActI.Accepted.PowOfAttornOrder.ToWhomIssued.Initials <> Undefined Then
					Initials = ED.Document.PrActI.Accepted.PowOfAttornOrder.ToWhomIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyIssued", PowerOfAttorneyIssued);
		ElsIf ED.Document.PrActI.Accepted.SignatureOrder <> Undefined Then
			AddObjectHeaderAttribute(NewED, "AcceptedPosition", ED.Document.PrActI.Accepted.SignatureOrder.Position);
			Initials = ED.Document.PrActI.Accepted.SignatureOrder.Initials;
			AddObjectHeaderAttribute(NewED, "AcceptedDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrActI.Accepted.Claim <> Undefined Then
			AddObjectHeaderAttribute(NewED, "Claim", ED.Document.PrActI.Accepted.Claim);
		EndIf;
	EndIf;
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadTORG12XDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.TORG12Seller;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Document.PrInD.CN.NumCW);
	DocDate = ED.Document.PrInD.CN.WBDate;
	AddObjectHeaderAttribute(NewED, "Date", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
	
	DocumentAmount = ?(ValueIsFilled(ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun), ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun,
		ED.Document.PrInD.ReleaseCargo.AmountRelease);
	AddObjectHeaderAttribute(NewED, "DocumentAmount", DocumentAmount);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.FileID);
	
	Consignor = Undefined;
	ShipperAdditParameters = New Structure;
	Vendor = ED.Document.PrInD.Vendor;
	If ED.Document.PrInD.CargoFrom <> Undefined AND ED.Document.PrInD.CargoFrom.CargoShpd <> Undefined Then
		ShipperAdditParameters.Insert("OrganizationDepartment", ED.Document.PrInD.CargoFrom.StructDep);
		ShipperAdditParameters.Insert("RCEAP", ED.Document.PrInD.CargoFrom.RCEAP);
		Consignor = ED.Document.PrInD.CargoFrom.CargoShpd;
		If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact = Undefined Then
			If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Phone = Undefined Then
				ShipperAdditParameters.Insert("PhoneNumbers", ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Phone);
			EndIf;
			If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Fax = Undefined Then
				ShipperAdditParameters.Insert("Fax", ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Fax);
			EndIf;
		EndIf;
	ElsIf Vendor <> Undefined Then
		Consignor = Vendor;
	EndIf;
	
	If ED.Document.PrInD.ReleaseCargo <> Undefined Then
		If ED.Document.PrInD.ReleaseCargo.ReleasePerm <> Undefined Then
			ShipperAdditParameters.Insert("HeadPost", ED.Document.PrInD.ReleaseCargo.ReleasePerm.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.ReleasePerm.Initials;
			ShipperAdditParameters.Insert("HeadDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrInD.ReleaseCargo.Accountant <> Undefined Then
			ShipperAdditParameters.Insert("ChiefAccountantPosition", ED.Document.PrInD.ReleaseCargo.Accountant.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.Accountant.Initials;
			ShipperAdditParameters.Insert("NameAndSurnameOfChiefAccountant",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrInD.ReleaseCargo.ReleaseMad <> Undefined Then
			ShipperAdditParameters.Insert("WarehousemanPosition", ED.Document.PrInD.ReleaseCargo.ReleaseMad.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.ReleaseMad.Initials;
			ShipperAdditParameters.Insert("WarehouseManSNP",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
	EndIf;
	
	If Consignor <> Undefined Then
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Consignor");
		If ShipperAdditParameters.Count() > 0 Then
			NodeIndex = ParseTree.Rows.Find("Consignor", "Attribute", True);
			If NodeIndex <> Undefined AND ValueIsFilled(NodeIndex.AttributeValue) Then
				ShipperRow = ParseTree.Rows.Find(NodeIndex.AttributeValue, "RowIndex", True);
				If ShipperRow <> Undefined Then
					For Each AdditParameter IN ShipperAdditParameters Do
						AddObjectHeaderAttribute(ShipperRow, AdditParameter.Key, AdditParameter.Value);
					EndDo;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
	If ED.Document.PrInD.CargoRece <> Undefined Then
		ReadCounterpartyData(ED.Document.PrInD.CargoRece, ED, ParseTree, NewED, Error, "Consignee");
	EndIf;
	
	// Consignor and Supplier - optional
	// items of xsd scheme but one of these
	// items must be filled (according to "in" art.2 p. 9 Federal Law from 21.11.1996 No 129-FZ).
	If Vendor = Undefined Then
		Vendor = Consignor;
	EndIf;
	
	If NewED.EDDirection = Enums.EDDirections.Outgoing 
		OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Seller");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Customer");
	EndIf;
	
	Payer = ED.Document.PrInD.Payer;
	If Payer <> Undefined Then
		If NewED.EDDirection = Enums.EDDirections.Outgoing
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Customer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Seller");
		EndIf;
	EndIf;
	
	Company = GetEDHeaderAttribute(NewED, "Company", ParseTree);
	Structure = New Structure("Company", Company);
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrInD.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined AND Find(InfFul.TextInf, "xml") = 0 Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
		
		RowCurrency = NewED.Rows.Find("CurrencyCode", "Attribute", True);
		If RowCurrency <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			CurrencyCode = RowCurrency.AttributeValue;
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode,
				Currency, AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		RowBasisDocument = NewED.Rows.Find("IDEDDocumentFoundation", "Attribute", True);
		If RowBasisDocument <> Undefined AND Company <> Undefined Then
			BasisDocument = GetBasisDocument(RowBasisDocument.AttributeValue, Structure);
			If BasisDocument <> Undefined Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BasisDocuments");
				AddObjectHeaderAttribute(FoundTypeInTree, "BasisDocuments", BasisDocument, BasisDocument);
				FoundString = FoundTypeInTree.Rows.Find(BasisDocument, "ObjectReference");
				FoundString.RowIndex = FoundTypeInTree.RowIndex + "_"
					+ String(FoundTypeInTree.Rows.IndexOf(FoundString));
				AddObjectHeaderAttribute(NewED, "Basis", FoundString.RowIndex, BasisDocument);
			EndIf;
		EndIf;
	EndIf;
	
	OperationKind = NewED.Rows.Find("OperationKind", "Attribute", True);
	If OperationKind <> Undefined Then
		OperationKind.AttributeValue = XMLValue(Type("EnumRef.EDOperationsKinds"), OperationKind.AttributeValue);
	EndIf;
	
	If ED.Document.PrInD.Basis <> Undefined Then
		DateByCustomerData = ED.Document.PrInD.Basis.DateBas;
		If ValueIsFilled(DateByCustomerData) Then
			AddObjectHeaderAttribute(NewED, "DateByCustomerData", Date(Mid(DateByCustomerData, 7, 4)
				+ Mid(DateByCustomerData, 4, 2) + Mid(DateByCustomerData, 1, 2)));
		EndIf;
		AddObjectHeaderAttribute(NewED, "NumberByCustomerData", ED.Document.PrInD.Basis.BasisNum);
		AddObjectHeaderAttribute(NewED, "BasisDescription", ED.Document.PrInD.Basis.DescBas);
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "OKUD", ED.Document.PrInD.RCMDFirstDoc);
	
	If ED.Document.PrInD.CN.WBCom <> Undefined Then
		AddObjectHeaderAttribute(NewED, "RecCount", ED.Document.PrInD.CN.WBCom.NumRecNum);
		AddObjectHeaderAttribute(NewED, "RecordsCountInWords", ED.Document.PrInD.CN.WBCom.NumRecNumWor);
		AddObjectHeaderAttribute(NewED, "PlacesQuantity", ED.Document.PrInD.CN.WBCom.TotSpots);
		AddObjectHeaderAttribute(NewED, "PlacesCountInWords", ED.Document.PrInD.CN.WBCom.TotSpotsEtc);
		AddObjectHeaderAttribute(NewED, "CargoWeightInWords", ED.Document.PrInD.CN.WBCom.GrossInFull);
		AddObjectHeaderAttribute(NewED, "CargoNetWeightInWords", ED.Document.PrInD.CN.WBCom.NetPr);
	EndIf;
	If ED.Document.PrInD.CN.Table.TotalInv <> Undefined Then
		AddObjectHeaderAttribute(NewED, "Amount", ED.Document.PrInD.CN.Table.TotalInv.AmountNoVATVs);
		AddObjectHeaderAttribute(NewED, "VATAmount", ED.Document.PrInD.CN.Table.TotalInv.AmountVATTotal);
		AddObjectHeaderAttribute(NewED, "AmountWithVAT", ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun);
	EndIf;
	
	If ED.Document.PrInD.ReleaseCargo <> Undefined Then
		AddObjectHeaderAttribute(NewED, "AmountTotalInWords", ED.Document.PrInD.ReleaseCargo.AmountReleasePr);
		DocDate = ED.Document.PrInD.ReleaseCargo.DateRelease;
		If ValueIsFilled(DocDate) Then
			AddObjectHeaderAttribute(NewED, "DateReleased", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
		EndIf;
		AddObjectHeaderAttribute(NewED, "SheetsCountInApplInWords", ED.Document.PrInD.ReleaseCargo.NumAppWo);
	EndIf;
	
	DataSet = ED.Document.PrInD.CN.Table.PrGd;
	
	// Define ED variant for selection of an algorithm to fill in products and services
	AuthorEDCustomer = False;
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
		OR NewED.EDDirection = Enums.EDDirections.Intercompany);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			ListTS.Add(Item.ItemNum,      "Number");
			ListTS.Add(Item.DescProd,     "Description");
			ListTS.Add(Item.CharacterTov, "CharacteristicDescription");
			ListTS.Add(Item.GradeItems,     "Kind");
			ListTS.Add(Item.GoodsSKU,  "SKU");
			ListTS.Add(Item.DescUnOfMeas,   "MeasurementUnitDescription");
			ListTS.Add(Item.OKEI_Tov,    "MeasurementUnitCode");
			ListTS.Add(Item.CodeProd,      "ProductCode");
	
			ListTS.Add(Item.Net,     "Quantity");
			ListTS.Add(Item.NumberOfSeats,   "Places");
			ListTS.Add(Item.KindPack,   "Package");
			ListTS.Add(Item.place,     "QuantityInOnePlace");
			ListTS.Add(Item.Net,     "NetWeight");
			ListTS.Add(Item.Gross,    "GrossWeight");
			ListTS.Add(Item.Price,      "Price");
			ListTS.Add(Item.AmountNoVAT, "Amount");
			ListTS.Add(Item.AmountVAT,    "VATAmount");
			ListTS.Add(Item.AmountCtVAT,  "SumWithVAT");
			
			// Delete first branch - only required for reading old documents.
			If ValueIsFilled(Item.InfFullStr) AND Find(Item.InfFullStr, "xml") > 0 Then
				
				ListTS.Add(Item.VATRate, "VATRate");
				
				// IN inf.field xml-string of invalid format.
				XMLObject = New XMLReader;
				Try
					XMLObject.SetString(Item.InfFullStr);
					XDTOProduct = XDTOFactory.ReadXML(XMLObject);
					ParseStringTSCML(XDTOProduct, ListTS, ED, ParseTree, NewED, Error);
				Except
				EndTry;
			Else
				If ValueIsFilled(Item.InfFullStr) Then
					// IN inf.field xml-string of Relevant format
					InfFul = Item.InfFullStr;
					ReadInfPol(InfFul, AdditDataTree, "Products", Item.ItemNum);
					FillTSRowByAdditData(AdditDataTree, ListTS, Item.ItemNum, "Products", Error);
				EndIf;
				ProductsAndServicesAttributes = New Structure;
				MeasurementUnitAttributes = New Structure;
				ProductId = "";
				VATRateTransferredByAdditParameter = False;
				For Each ItemOP IN ListTS Do
					
					// ProductsAndServices.
					If ItemOP.Presentation = "Description" Then
						ProductsAndServicesAttributes.Insert("Description", ItemOP.Value);
					ElsIf ItemOP.Presentation = "CharacteristicDescription" Then
						ProductsAndServicesAttributes.Insert("CharacteristicDescription", ItemOP.Value);
					ElsIf ItemOP.Presentation = "SKU" Then
						ProductsAndServicesAttributes.Insert("SKU", ItemOP.Value);
					ElsIf ItemOP.Presentation = "ProductCode" Then
						ProductsAndServicesAttributes.Insert("ProductCode", ItemOP.Value);
					ElsIf ItemOP.Presentation = "Kind" Then
						ProductsAndServicesAttributes.Insert("Kind", ItemOP.Value);
						
					ElsIf ItemOP.Presentation = "MeasurementUnitCode" Then
						MeasurementUnitAttributes.Insert("Code", ItemOP.Value);
					ElsIf ItemOP.Presentation = "OKEI_Tov" Then
						MeasurementUnitAttributes.Insert("Code", ItemOP.Value);
					ElsIf ItemOP.Presentation = "MeasurementUnitDescription" Then
						MeasurementUnitAttributes.Insert("Description", ItemOP.Value);
						
					ElsIf ItemOP.Presentation = "ID" Then
						ProductId = ItemOP.Value;
					ElsIf ItemOP.Presentation = "VATRate" Then
						ItemOP.Value = ItemOP.Value;
						VATRateTransferredByAdditParameter = True;
					ElsIf ItemOP.Presentation = "IDEDDocumentFoundation" AND ValueIsFilled(Company) Then
						BasisDocument = GetBasisDocument(ItemOP.Value, Structure);
						If BasisDocument <> Undefined Then
							ListTS.Add(BasisDocument, "BasisDocument");
						EndIf;
					EndIf;
				EndDo;
				// VAT rate can come with additional parameters.
				If Not VATRateTransferredByAdditParameter Then
					ListTS.Add(Item.VATRate, "VATRate");
				EndIf;
				
				CodeUnMeas = "";
				If MeasurementUnitAttributes.Property("Code", CodeUnMeas) Then
					UnOfMeasDescription = "";
					MeasurementUnitAttributes.Property("Description", UnOfMeasDescription);
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(CodeUnMeas),
						MeasurementUnitAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString     = FindCreateStringInParsedTree(FoundTypeInTree, String(CodeUnMeas),
						UnOfMeasDescription, UnOfMeas, MeasurementUnitAttributes, ParseTree, Error);
					If ValueIsFilled(FoundString) Then
						ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
					EndIf;
				EndIf;
				
				// Identification by products and services of the company when the parsing side ED - subsidiary company itself
				If IdentificationByCounterpartyProductsAndServices Then
					IdStructure = ParseProductID(ProductId);
					ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
					If ValueIsFilled(IdStructure.CharacteristicID) Then
						ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics",
							IdStructure.CharacteristicID);
						If ListTS.FindByValue(ProductsAndServicesCharacteristic) <> Undefined Then
							ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
						EndIf;
					EndIf;
					If ValueIsFilled(IdStructure.IDPackage) Then
						ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking",
							IdStructure.IDPackage);
						If ListTS.FindByValue(ProductsAndServicesPackaging) <> Undefined Then
							ListTS.Add(ProductsAndServicesPackaging, "Package");
						EndIf;
					EndIf;
				Else
					// Suppliers products and services.
					SupplierProductsAndServicesAttributes = New Structure;
					
					OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
					ProductsAndServicesOwner  = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
					SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
					
					NameID = ""; ProductCodeID = ""; SKUID = ""; IDCharacteristicName = "";
					If ProductsAndServicesAttributes.Property("Description") Then
						SupplierProductsAndServicesAttributes.Insert("Description", ProductsAndServicesAttributes.Description);
						NameID = Upper(StrReplace(ProductsAndServicesAttributes.Description, " ", ""));
					EndIf;
					If ProductsAndServicesAttributes.Property("ProductCode") Then
						SupplierProductsAndServicesAttributes.Insert("ProductCode", ProductsAndServicesAttributes.ProductCode);
						ProductCodeID = Upper(StrReplace(ProductsAndServicesAttributes.ProductCode, " ", ""));
					EndIf;
					If ProductsAndServicesAttributes.Property("SKU") Then
						SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
						SKUID = Upper(StrReplace(ProductsAndServicesAttributes.SKU, " ", ""));
					EndIf;
					If ProductsAndServicesAttributes.Property("CharacteristicDescription") Then
						SupplierProductsAndServicesAttributes.Insert("CharacteristicDescription",
							ProductsAndServicesAttributes.CharacteristicDescription);
						IDCharacteristicName = Upper(StrReplace(ProductsAndServicesAttributes.CharacteristicDescription, " ", ""));
					EndIf;
					
					// If empty ID arrived, then use product name instead of it.
					// Relevant for the incoming ED from accounting systems, other than 1C.
					If Not ValueIsFilled(ProductId) Then
						ProductId = NameID + "#" + IDCharacteristicName + "#" + ProductCodeID + "#" +SKUID;
					EndIf;
					
					SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
					SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
						SupplierProductsAndServicesAttributes);
					
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
						SupplierProductsAndServicesAttributes, ParseTree, Error);
					ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
					
					If ValueIsFilled(SupplierProductsAndServices) Then
						ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
						SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
					EndIf;
					ProductAttributesStructure = GenerateProductStructure();
					ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes, ProductAttributesStructure);
					
					ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
					If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
						ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
					EndIf;
					If ValueIsFilled(ProductAttributesStructure.Package) Then
						ListTS.Add(ProductAttributesStructure.Package, "Package");
					EndIf;
				EndIf;
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
					ProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
				
				AddObjectTSAttributes(NewED, "TSRow", ListTS);
			EndIf;
		EndDo;
	EndIf;
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadTORG12CustomerXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.TORG12Customer;
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrRnIn.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
	EndIf;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	If ED.Document.PrRnIn.ReceiveCargo <> Undefined Then
		DocDate = ED.Document.PrRnIn.ReceiveCargo.ReceivDate;
		DateReceived = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2));
		AddObjectHeaderAttribute(NewED, "DateReceived", DateReceived);
		If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyNumber", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.NumPowerOfAttorn);
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyDate", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.DateGiven);
			PowerOfAttorneyIssued = "";
			If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Company", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.EntDescWhoIssued);
				SecondaryStructure.Insert("Position", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.PositWho);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.AdditInfWho);
				If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.Initials <> Undefined Then
					Initials = ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Position", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Posit);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.AdditInfoToWhom);
				If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Initials <> Undefined Then
					Initials = ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyIssued", PowerOfAttorneyIssued);
		EndIf;
		If ED.Document.PrRnIn.ReceiveCargo.CargoReceived <> Undefined Then
			AddObjectHeaderAttribute(NewED, "CargoTakePosition", ED.Document.PrRnIn.ReceiveCargo.CargoReceived.Position);
			Initials = ED.Document.PrRnIn.ReceiveCargo.CargoReceived.Initials;
			AddObjectHeaderAttribute(NewED, "CargoAcceptedDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrRnIn.ReceiveCargo.CargoTaken <> Undefined Then
			AddObjectHeaderAttribute(NewED, "CargoReceivedPosition", ED.Document.PrRnIn.ReceiveCargo.CargoTaken.Position);
			Initials = ED.Document.PrRnIn.ReceiveCargo.CargoTaken.Initials;
			AddObjectHeaderAttribute(NewED, "CargoReceivedSNP",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
	EndIf;
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadInvoiceXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.TORG12;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	// Currency, rate
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("AmountTotal");
	If EDProperty <> Undefined Then
		AddObjectHeaderAttribute(NewED, "DocumentAmount", ED.Get(EDProperty));
	EndIf;
	
	EDProperty = ED.Properties().Get("Consignor");
	If EDProperty <> Undefined Then
		Consignor = ED.Get(EDProperty);
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Consignor");
	EndIf;
	
	EDProperty = ED.Properties().Get("Consignee");
	If EDProperty <> Undefined Then
		Consignee = ED.Get(EDProperty);
		ReadCounterpartyData(Consignee, ED, ParseTree, NewED, Error, "Consignee");
	EndIf;
	
	EDProperty = ED.Properties().Get("Vendor");
	If EDProperty <> Undefined Then
		Vendor = ED.Get(EDProperty);
		If NewED.EDDirection = Enums.EDDirections.Outgoing 
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Seller");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Customer");
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Payer");
	If EDProperty <> Undefined Then
		Payer = ED.Get(EDProperty);
		If NewED.EDDirection = Enums.EDDirections.Outgoing
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Customer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Seller");
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Basis");
	If EDProperty<>Undefined Then
		Basis = ED.Get(EDProperty);
		If Not Basis=Undefined Then
			AddObjectHeaderAttribute(NewED, "DateByCustomerData", Basis.BasisDocumentDate);
			AddObjectHeaderAttribute(NewED, "NumberByCustomerData", Basis.BasisDocumentNumber);
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("OKUD");
	If EDProperty<>Undefined Then
		AddObjectHeaderAttribute(NewED, "OKUD", ED.Get(EDProperty));
	EndIf;
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	If EDProperty <> Undefined Then
		TotalByDocumentXDTO = ED.Get(EDProperty);
		RecCount = TotalByDocumentXDTO.Properties().Get("RecCount");
		If RecCount<>Undefined Then
			AddObjectHeaderAttribute(NewED, "RecCount", TotalByDocumentXDTO.Get(RecCount));
		EndIf;
		PlacesQuantity = TotalByDocumentXDTO.Properties().Get("PlacesQuantity");
		If PlacesQuantity <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PlacesQuantity", TotalByDocumentXDTO.Get(PlacesQuantity));
		EndIf;
		AmountWithoutVAT = TotalByDocumentXDTO.Properties().Get("AmountWithoutVAT");
		If AmountWithoutVAT <> Undefined Then
			AddObjectHeaderAttribute(NewED, "Amount", TotalByDocumentXDTO.Get(AmountWithoutVAT));
		EndIf;
		VATAmount = TotalByDocumentXDTO.Properties().Get("VATAmount");
		If VATAmount <> Undefined Then
			AddObjectHeaderAttribute(NewED, "VATAmount", TotalByDocumentXDTO.Get(VATAmount));
		EndIf;
		AmountWithVAT = TotalByDocumentXDTO.Properties().Get("AmountWithVAT");
		If AmountWithVAT <> Undefined Then
			AddObjectHeaderAttribute(NewED, "SumWithVAT", TotalByDocumentXDTO.Get(AmountWithVAT));
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("TotalsInWords");
	If EDProperty <> Undefined Then
		ResultsInWritingXDTO = ED.Get(EDProperty);
		RecordsCountInWords = TotalByDocumentXDTO.Properties().Get("RecordsCountInWords");
		If RecordsCountInWords<>Undefined Then
			AddObjectHeaderAttribute(NewED, "RecordsCountInWords", TotalByDocumentXDTO.Get(
				RecordsCountInWords));
		EndIf;
		PlacesCountInWords = TotalByDocumentXDTO.Properties().Get("PlacesCountInWords");
		If PlacesCountInWords<>Undefined Then
			AddObjectHeaderAttribute(NewED, "PlacesCountInWords", TotalByDocumentXDTO.Get(PlacesCountInWords));
		EndIf;
		AmountTotalInWords = TotalByDocumentXDTO.Properties().Get("AmountTotalInWords");
		If AmountTotalInWords<>Undefined Then
			AddObjectHeaderAttribute(NewED, "AmountTotalInWords", TotalByDocumentXDTO.Get(AmountTotalInWords));
		EndIf;
	EndIf;
	
	DataSet = ED["Products"].Product;
	ReadDataByTSInvoice(DataSet, ED, ParseTree, NewED, Error);
	
EndProcedure

Procedure ReadDirectoryXDTO(ED, ParseTree, NewED, Error)
	
	NewED.ID = ED.Directory.ID;
	NewED.EDKind = Enums.EDKinds.ProductsDirectory;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.Directory.ID);
	
	// Fill in the information about the owner of the directory.
	// Counterparty
	Item = ED.Directory.Owner;
	CounterpartyAttributes = New Structure;
	For Each CurProperty IN Item.Properties() Do
		
		DataVal = Item[CurProperty.Name];
		
		If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
		ElsIf Not ValueIsFilled(DataVal) Then
			Continue;
		EndIf;
		
		If Upper(CurProperty.Name) = Upper("ID") Then 
			
			CounterpartyId = DataVal;
			// Parse ID for TIN
			SearchStructure = ParseCounterpartyID(CounterpartyId);
			If SearchStructure.Property("TIN") Then
				CounterpartyAttributes.Insert("TIN", SearchStructure.TIN);
			EndIf;
			
		ElsIf Upper(CurProperty.Name) = Upper("LegalEntity") OR Upper(CurProperty.Name) = Upper("Ind") Then
			ParticipantAttributes = DataVal;
			For Each ParticipantProperty IN ParticipantAttributes.Properties() Do
				ParticipantAttribute = ParticipantAttributes[ParticipantProperty.Name];
				If ParticipantAttribute <> Undefined Then
					If Upper(ParticipantProperty.Name) = Upper("LegalAddress")
						OR Upper(ParticipantProperty.Name) = Upper("RegistrationAddress") Then
						
						CounterpartyAttributes.Insert(ParticipantProperty.Name + "_Presentation", ParticipantAttribute.Presentation);
					ElsIf Upper(ParticipantProperty.Name) = Upper("OfficialName")
						OR Upper(ParticipantProperty.Name) = Upper("FullDescr") Then
						
						CounterpartyAttributes.Insert("FullDescr", ParticipantAttribute);
					Else
						CounterpartyAttributes.Insert(ParticipantProperty.Name, ParticipantAttribute);
					EndIf;
				EndIf;
			EndDo;
		Else
			CounterpartyAttributes.Insert(CurProperty.Name, DataVal);
		EndIf;
		
	EndDo;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Counterparties");
	AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("Counterparties");
	Counterparty = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, CounterpartyId,
		CounterpartyAttributes, ED.Directory.ID);
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: " + CounterpartyId,
		Counterparty, CounterpartyAttributes, ParseTree, Error);
	AddObjectHeaderAttribute(NewED, "Counterparty", FoundString.RowIndex);
	
	AddObjectHeaderAttribute(NewED, "GeneratingDate", ED.GeneratingDate);
	
	If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
		AttributesOfPartner = New Structure();
		AttributesOfPartner.Insert("Counterparty", Counterparty);
		AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("partners");
		ValAdditAnalytics = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, , AttributesOfPartner);
		
		If ValueIsFilled(ValAdditAnalytics) Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "partners");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ValAdditAnalytics.Code, "Code: "
				+ ValAdditAnalytics.Code, ValAdditAnalytics, AttributesOfPartner, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Partner", FoundString.RowIndex);
		EndIf;
	EndIf;
	
	// Fill in data about catalog products.
	DataSet = ED.Directory["Products"].Product;
	ReadDataByCatalogueProduct(DataSet, ED.Directory, ParseTree, NewED, Error);
	
	PutUnsignedDataToHeader(NewED);
	
EndProcedure

Procedure ReadPriceXDTO(ED, ParseTree, NewED, Error)
	
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.PriceList;
	AddObjectHeaderAttribute(NewED, "Date", ED.ValidFrom);
	AddObjectHeaderAttribute(NewED, "ValidUntil", ED.ValidUntil);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	// Counterparty
	Owner = ED.Owner;
	CounterpartyAttributes = New Structure;
	Role = "Customer";
	ReadCounterpartyDataCML(Owner, ED, ParseTree, NewED, Error, Role, CounterpartyAttributes);

	AddObjectHeaderAttribute(NewED, "GeneratingDate", ED.ValidFrom);
	
	// Products
	LineNumber = 0;
	
	Offers = ED.Offers.GetList("Offer");
	For Each Item IN Offers Do
		
		ListTS = New ValueList;
		ProductDescription = "";
		ProductId           = "";
		ProductSKU      = "";
		
		// ProductsAndServices.
		ProductsAndServicesAttributes = New Structure;
		SupplierProductsAndServicesAttributes = New Structure;
		
		OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
		ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
		SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
		
		For Each CurProperty IN Item.Properties() Do
			
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			
			// Parse Product properties.
			If Upper(CurProperty.Name) = Upper("ID") Then
				ProductsAndServicesAttributes.Insert("ID", DataVal);
				SupplierProductsAndServicesAttributes.Insert("ID", DataVal);
				ProductId = DataVal;
			ElsIf Upper(CurProperty.Name) = Upper("Description") Then
				ProductsAndServicesAttributes.Insert("Description", DataVal);
				SupplierProductsAndServicesAttributes.Insert("Description", DataVal);
			ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
				ProductsAndServicesAttributes.Insert("SKU", DataVal);
				SupplierProductsAndServicesAttributes.Insert("SKU", DataVal);
			ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code", DataVal.Code);
					
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
					UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
					
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.ShortDescription, UnOfMeas,
						UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						
						ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						
					EndIf;
				EndIf;
			EndIf;
			
		EndDo;
		
		SupplierProductsAndServicesAttributes.Insert("Description", ProductsAndServicesAttributes.Description);
		SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ProductId,
																								SupplierProductsAndServicesAttributes, ED.ID);
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, SupplierProductsAndServicesAttributes.Description,
														SupplierProductsAndServices, SupplierProductsAndServicesAttributes, ParseTree, Error);
		
		ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
		
		If ValueIsFilled(SupplierProductsAndServices) Then
			ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
			SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
		EndIf;
		
		ProductAttributesStructure = GenerateProductStructure();
		ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes,
			ProductAttributesStructure, ED.ID);
		ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
		If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
			ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(ProductAttributesStructure.Package) Then
			ListTS.Add(ProductAttributesStructure.Package, "Package");
		EndIf;
		
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId,
			SupplierProductsAndServicesAttributes.Description, ProductsAndServices, ProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex,"ProductsAndServices");
		
		PriceValue = 0;
		MeasurementUnit = "";
		Prices = Item.Prices.GetList("Price");
		For Each Price IN Prices Do
			PriceValue =Price.PriceForUnit;
			ListTS.Add(PriceValue, "Price");
			
			PropertyQuantity = Price.Properties().Get("MinQuantity");
			If PropertyQuantity<>Undefined Then
				ListTS.Add(Price.MinQuantity, "Quantity");
			EndIf;
	
			DataVal = Price.Unit;
			
			If Not DataVal = Undefined Then
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code", DataVal);
				
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal, UnOfMeasAttributes);
				
				If ValueIsFilled(UnOfMeas) Then
					Description = UnOfMeas.Description;
				Else
					Description = "pcs.";
				EndIf;
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal, Description, UnOfMeas,
																						UnOfMeasAttributes, ParseTree, Error);
				
				If ValueIsFilled(UnOfMeas) Then
					ListTS.Add(FoundString.RowIndex, "Package");
				EndIf;
			EndIf;
			
			Break;
			
		EndDo;
		
		Company = TreeAttributeRef(ParseTree, NewED, "Company");
		AdditParameters = New Structure;
		AdditParameters.Insert("Company", Company);
		
		LineNumber = LineNumber + 1;
		ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);
		
		AddObjectTSAttributes(NewED, "TSRow", ListTS);
		
	EndDo;
	
	// Read tab. part "Prices kinds"
	TablePriceTypes = New ValueTable;
	TablePriceTypes.Columns.Add("PriceTypeId");
	TablePriceTypes.Columns.Add("PriceType");
	TablePriceTypes.Columns.Add("Description");
	TablePriceTypes.Columns.Add("Currency");
	TablePriceTypes.Columns.Add("IncludesVAT");
	
	For Each CurRow IN ED.PriceTypes.PriceType Do
		NewRow = TablePriceTypes.Add();
		NewRow.PriceType = CurRow.ID;
		NewRow.Description = CurRow.Description;
		NewRow.Currency = CurRow.Currency;
		For Each Tax IN CurRow.Tax Do
			NewRow.IncludesVAT = Tax.IncludedInAmount;
		EndDo;
		
	EndDo;
	AddObjectHeaderAttribute(NewED, "PriceTypes", TablePriceTypes);
	
	PutUnsignedDataToHeader(NewED);
	
EndProcedure

Procedure DeleteReadPriceXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants.
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.PriceList;
	AddObjectHeaderAttribute(NewED, "Date", ED.ValidFrom);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	// Counterparty
	Item = ED.Owner;
	CounterpartyAttributes = New Structure;
	For Each CurProperty IN Item.Properties() Do
		
		DataVal = Item[CurProperty.Name];
		
		If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
		ElsIf Not ValueIsFilled(DataVal) Then
			Continue;
		EndIf;
		
		If Upper(CurProperty.Name) = Upper("ID") Then
			
			CounterpartyId = DataVal;
			// Parse ID for TIN.
			SearchStructure = ParseCounterpartyID(CounterpartyId);
			If SearchStructure.Property("TIN") Then
				CounterpartyAttributes.Insert("TIN", SearchStructure.TIN);
			EndIf;
			
		ElsIf Upper(CurProperty.Name) = Upper("LegalEntity") OR Upper(CurProperty.Name) = Upper("Ind") Then
			ParticipantAttributes = DataVal;
			For Each ParticipantProperty IN ParticipantAttributes.Properties() Do
				ParticipantAttribute = ParticipantAttributes[ParticipantProperty.Name];
				If ParticipantAttribute <> Undefined Then
					If Upper(ParticipantProperty.Name) = Upper("LegalAddress")
						OR Upper(ParticipantProperty.Name) = Upper("RegistrationAddress") Then
						
						CounterpartyAttributes.Insert(ParticipantProperty.Name+"_Presentation", ParticipantAttribute.Presentation);
					ElsIf Upper(ParticipantProperty.Name) = Upper("OfficialName")
						OR Upper(ParticipantProperty.Name) = Upper("FullDescr") Then
						
						CounterpartyAttributes.Insert("FullDescr", ParticipantAttribute);
					Else
						CounterpartyAttributes.Insert(ParticipantProperty.Name, ParticipantAttribute);
					EndIf;
				EndIf;
			EndDo;
		Else
			CounterpartyAttributes.Insert(CurProperty.Name, DataVal);
		EndIf;
		
	EndDo;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Counterparties");
	Counterparty = ElectronicDocumentsOverridable.FindRefToObject("Counterparties", CounterpartyId, CounterpartyAttributes, ED.ID);
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: " + CounterpartyId,
		Counterparty, CounterpartyAttributes, ParseTree, Error);
	AddObjectHeaderAttribute(NewED, "Counterparty", FoundString.RowIndex);
	AddObjectHeaderAttribute(NewED, "GeneratingDate", ED.ValidFrom);
	
	If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
		AttributesOfPartner = New Structure();
		AttributesOfPartner.Insert("Counterparty", Counterparty);
		AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("partners");
		ValAdditAnalytics = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, , AttributesOfPartner);
		
		If ValueIsFilled(ValAdditAnalytics) Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "partners");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ValAdditAnalytics.Code, "Code: "
				+ ValAdditAnalytics.Code, ValAdditAnalytics, AttributesOfPartner, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Partner", FoundString.RowIndex);
		EndIf;
	EndIf;
	
	// Products
	Offers = ED.Offers.GetList("Offer");
	For Each Item IN Offers Do
		
		ListTS = New ValueList;
		ProductDescription = "";
		ProductId           = "";
		ProductSKU      = "";
		
		// ProductsAndServices.
		ProductsAndServicesAttributes = New Structure;
		SupplierProductsAndServicesAttributes = New Structure;
		OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
		ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
		SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
		For Each CurProperty IN Item.Properties() Do
			
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			
			// Parse Product properties.
			If Upper(CurProperty.Name) = Upper("ID") Then
				ProductsAndServicesAttributes.Insert("ID", DataVal);
				SupplierProductsAndServicesAttributes.Insert("ID", DataVal);
				ProductId = DataVal;
			ElsIf Upper(CurProperty.Name) = Upper("Description") Then
				ProductsAndServicesAttributes.Insert("Description", DataVal);
				SupplierProductsAndServicesAttributes.Insert("Description", DataVal);
			ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
				ProductsAndServicesAttributes.Insert("SKU", DataVal);
				SupplierProductsAndServicesAttributes.Insert("SKU", DataVal);
			ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code", DataVal.Code);
					UnOfMeasAttributes.Insert("Description", DataVal.Description);
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.Description, UnOfMeas,
						UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
					EndIf;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code", DataVal.Code);
					UnOfMeasAttributes.Insert("Description", DataVal.Description);
					
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.Description, UnOfMeas,
						UnOfMeasAttributes, ParseTree, Error);
						
					If ValueIsFilled(UnOfMeas) Then
						ListTS.Add(FoundString.RowIndex, "Package");
					EndIf;
				EndIf;
			EndIf;
			
		EndDo;
		
		SupplierProductsAndServicesAttributes.Insert("Description", ProductsAndServicesAttributes.Description);
		SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ProductId,
			SupplierProductsAndServicesAttributes, ED.ID);
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, SupplierProductsAndServicesAttributes.Description,
			SupplierProductsAndServices, SupplierProductsAndServicesAttributes, ParseTree, Error);
		
		ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
		
		If ValueIsFilled(SupplierProductsAndServices) Then
			ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
			SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
		EndIf;
		
		ProductAttributesStructure = GenerateProductStructure();
		ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes,
			ProductAttributesStructure, ED.ID);
		ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
		If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
			ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(ProductAttributesStructure.Package) Then
			ListTS.Add(ProductAttributesStructure.Package, "Package");
		EndIf;
		
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId,
			SupplierProductsAndServicesAttributes.Description, ProductsAndServices, ProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex,"ProductsAndServices");
		
		PriceValue = 0;
		MeasurementUnit = "";
		Prices = Item.Prices.GetList("Price");
		For Each Price IN Prices Do
			PriceValue = Price.Price;
			ListTS.Add(PriceValue, "Price");
			DataVal = Price.MeasurementUnit;
			
			UnOfMeasAttributes = New Structure;
			UnOfMeasAttributes.Insert("Code", DataVal.Code);
			UnOfMeasAttributes.Insert("Description", DataVal.Description);
			PropertyQuantity = Price.Properties().Get("MinQuantity");
			If PropertyQuantity<>Undefined Then
				ListTS.Add(Price.MinQuantity, "Quantity");
			EndIf;
			UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.Description, UnOfMeas,
				UnOfMeasAttributes, ParseTree, Error);
			If ValueIsFilled(UnOfMeas) Then
				ListTS.Add(FoundString.RowIndex, "Package");
			EndIf;
			Break;
		EndDo;
		
		AddObjectTSAttributes(NewED, "TSRow", ListTS);
	EndDo;
	
EndProcedure

Procedure ReadInvoiceForPaymentXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.InvoiceForPayment;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	PaymentDestination = DocumentAdditAttributeValue("PaymentDestination", ED);
	AddObjectHeaderAttribute(NewED, "PaymentDestination", PaymentDestination);
	
	AddObjectHeaderAttribute(NewED, "AccountExpirationDate", ED.PaymentDueDate);
	
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		
		CurrencyCode = ED.Get(EDProperty);
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			If ValueIsFilled(Currency) Then
				AdditionalAttributes.Insert("Description", Currency.Description);
				AdditionalAttributes.Insert("DescriptionFull", Currency.DescriptionFull);
			EndIf;
			AdditionalAttributes.Insert("MKBCode", CurrencyCode);
			
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = ED.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	CounterpartyAdditParameters = Undefined;
	PropertyCurrentAccount = DocumentAdditAttributeValue("BankAccount", ED);
	
	If Not PropertyCurrentAccount = Undefined Then
		StructureCurrentAccount =  CurrentAccountDetails(PropertyCurrentAccount, ED, ParseTree, NewED, Error);
		
		CounterpartyAdditParameters = New Structure;
		CounterpartyAdditParameters.Insert("BankAccount", StructureCurrentAccount);
		
	EndIf;
	
	For Each CurCounterparty IN ED.Counterparties.Counterparty Do
		
		If CurCounterparty.Role = "Seller" Then
			If NewED.EDDirection = Enums.EDDirections.Outgoing Then
				Role = "Seller";
	
			ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
				Role = "Customer";
			EndIf;
	
		EndIf;
		
		If CurCounterparty.Role = "Customer" Then
			If NewED.EDDirection = Enums.EDDirections.Outgoing Then
				Role = "Customer";
				
			ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
				Role = "Seller";
			EndIf;
			
		EndIf;
		
		ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, Role, CounterpartyAdditParameters);
		
	EndDo;
	
	AmountTotal = DocumentAdditAttributeValue("AmountTotal", ED);
	AddObjectHeaderAttribute(NewED, "AmountTotal", AmountTotal);
	
	EDProperty = ED.Properties().Get("Taxes");
	TaxesToDocumentXDTO = ED.Get(EDProperty);
	TaxAmountTotal = 0;
	AmountIncludesVAT = False;
	
	For Each DocumentTax IN TaxesToDocumentXDTO.Tax Do
		
		TaxAmountTotal = TaxAmountTotal + DocumentTax.Amount;
		
		If DocumentTax.Description = "VAT" Then
			AmountIncludesVAT = DocumentTax.IncludedInAmount;
		EndIf;
		
	EndDo;
	
	AddObjectHeaderAttribute(NewED, "TaxAmountTotal", TaxAmountTotal);
	
	AddObjectHeaderAttribute(NewED, "PriceIncludesVAT", AmountIncludesVAT);
	
	TotalsInWords = DocumentAdditAttributeValue("TotalsInWords", ED);
	AddObjectHeaderAttribute(NewED, "TotalsInWords", TotalsInWords);
	
	EDProperty = ED.Properties().Get("Products");
	If EDProperty <> Undefined AND ED.Get(EDProperty) <> Undefined Then
		DataSet = ED["Products"].Product;
		ReadDataByTSInvoiceForPayment(DataSet, ED, ParseTree, NewED, Error);
		
	EndIf;
	
	If TypeOf(ED.Signatories) = Type("XDTODataObject") Then
		For Each Signer IN ED.Signatories.Signer Do
			
			If Upper(Signer.Position) = Upper("Head") Then
				Head = Signer.Surname + " " + Signer.Name + " " + Signer.Patronymic;
				AddObjectHeaderAttribute(NewED, "Head", Head);
			ElsIf Upper(Signer.Position) = Upper("Accountant") Then
				Accountant = Signer.Surname + " " + Signer.Name + " " + Signer.Patronymic;
				AddObjectHeaderAttribute(NewED, "Accountant", Accountant);
			EndIf;
			
		EndDo;
	EndIf;
	
	EDProperty = DocumentAdditAttributeValue("PaymentSchedule", ED);
	If EDProperty <> Undefined Then
		ReadDataByPaymentSchedule(EDProperty, ED, ParseTree, NewED, Error);
	EndIf;
	
	
	// Attribute values
	Company = TreeAttributeRef(ParseTree, NewED, "Company");
	
	AdditionalAttributes = New Structure;
	If ValueIsFilled(Company) Then
		AdditionalAttributes.Insert("Company", Company);
	EndIf;
	
	ReadDocumentHeaderAdditData(ED, NewED, Error, AdditionalAttributes);
	
	If Not ED.AttributeValues = Undefined Then
		ReadValueListDetailsCML(ED.AttributeValues.AttributeValue, NewED, Error, AdditionalAttributes);
	EndIf;
	
	BasisDocumentNumber = DocumentAdditAttributeValue("BasisDocumentNumber", ED);
	If Not BasisDocumentNumber = Undefined Then
		AddObjectHeaderAttribute(NewED, "BasisDocumentNumber", BasisDocumentNumber);
	EndIf;
	
	BasisDocumentDate = DocumentAdditAttributeValue("BasisDocumentDate", ED);
	If Not BasisDocumentDate = Undefined Then
		AddObjectHeaderAttribute(NewED, "BasisDocumentDate", BasisDocumentDate);
	EndIf;
	
EndProcedure

Procedure DeleteReadInvoiceForPaymentXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.InvoiceForPayment;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
			
	EDProperty = ED.Properties().Get("PaymentDestination");
	PaymentDestination = ED.Get(EDProperty);
	AddObjectHeaderAttribute(NewED, "PaymentDestination", PaymentDestination);
	
	EDProperty = ED.Properties().Get("AccountExpirationDate");
	AccountExpirationDate = ED.Get(EDProperty);
	AddObjectHeaderAttribute(NewED, "AccountExpirationDate", AccountExpirationDate);
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Vendor");
	Vendor = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Seller");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Customer");
	EndIf;
	
	EDProperty = ED.Properties().Get("Customer");
	Customer = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Customer");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Seller");
	EndIf;
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	TotalByDocumentXDTO = ED.Get(EDProperty);
	AmountTotal = TotalByDocumentXDTO.Properties().Get("AmountTotal");
	AddObjectHeaderAttribute(NewED, "AmountTotal",      TotalByDocumentXDTO.Get(AmountTotal));
	AddObjectHeaderAttribute(NewED, "DocumentAmount", TotalByDocumentXDTO.Get(AmountTotal));
	PropertyTaxAmountTotal = TotalByDocumentXDTO.Properties().Get("TaxAmountTotal");
	If PropertyTaxAmountTotal <> Undefined Then
		TaxAmountTotal = TotalByDocumentXDTO.Get(PropertyTaxAmountTotal);
		AddObjectHeaderAttribute(NewED, "TaxAmountTotal", TaxAmountTotal);
	EndIf;
	
	PropertyPriceIncludesVAT = TotalByDocumentXDTO.Properties().Get("PriceIncludesTax");
	If PropertyPriceIncludesVAT <> Undefined Then
		PriceIncludesVAT =  TotalByDocumentXDTO.Get(PropertyPriceIncludesVAT);
		AddObjectHeaderAttribute(NewED, "PriceIncludesVAT", PriceIncludesVAT);
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "TotalsInWords", ED.TotalsInWords);
	
	EDProperty = ED.Properties().Get("Products");
	If EDProperty <> Undefined AND ED.Get(EDProperty) <> Undefined Then
		DataSet = ED["Products"].Product;
		DeleteReadDataByInvoiceForPaymentTS(DataSet, ED, ParseTree, NewED, Error);
	EndIf;
	
	EDProperty = ED.Properties().Get("Head");
	If EDProperty <> Undefined Then
		Head = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "Head", Head.FullDescr);
	EndIf;
	
	EDProperty = ED.Properties().Get("Accountant");
	If EDProperty <> Undefined Then
		Accountant = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "Accountant", Accountant.FullDescr);
	EndIf;
	
	EDProperty = ED.Properties().Get("PaymentStage");
	If EDProperty <> Undefined Then
		DeleteReadDataByPaymentSchedule(ED.PaymentStage, ED, ParseTree, NewED, Error);
	EndIf;
	
	EDProperty = ED.Properties().Get("BasisDocuments");
	If EDProperty <> Undefined Then
		For Each BasisDocumentXDTO IN ED.BasisDocuments Do
			PropertyBasisDocumentNumber = BasisDocumentXDTO.Properties().Get("BasisDocumentNumber");
			If PropertyBasisDocumentNumber <> Undefined Then
				AddObjectHeaderAttribute(NewED, "BasisDocumentNumber", BasisDocumentXDTO.BasisDocumentNumber);
			EndIf;
			PropertyBasisDocumentDate = BasisDocumentXDTO.Properties().Get("BasisDocumentDate");
			If PropertyBasisDocumentDate <> Undefined Then
				AddObjectHeaderAttribute(NewED, "BasisDocumentDate", BasisDocumentXDTO.BasisDocumentDate);
			EndIf;
		EndDo;
	EndIf;
	
EndProcedure

Procedure ReadOrderXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	If ED.Role = "Customer" Then
		NewED.EDKind = Enums.EDKinds.ProductOrder;
	ElsIf ED.Role = "Seller" Then
		NewED.EDKind = Enums.EDKinds.ResponseToOrder;
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
			
	PaymentDestination = DocumentAdditAttributeValue("PaymentDestination", ED);
	AddObjectHeaderAttribute(NewED, "PaymentDestination", PaymentDestination);
	
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		
		If Upper(ED.Role) = Upper("Customer") Then
			CounterpartyRole = "Seller";
			CompanyRole = "Customer";
		Else
			CounterpartyRole = "Customer";
			CompanyRole = "Seller";
		EndIf;
		
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		
		If Upper(ED.Role) = Upper("Customer") Then
			CounterpartyRole = "Customer";
			CompanyRole = "Seller";
		Else
			CounterpartyRole = "Seller";
			CompanyRole = "Customer";
		EndIf;
		
	EndIf;
	
	For Each CurCounterparty IN ED.Counterparties.Counterparty Do
		
		If Upper(CurCounterparty.Role) = Upper("Customer") Then
			ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, CounterpartyRole);
		ElsIf Upper(CurCounterparty.Role) = Upper("Seller") Then
			ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, CompanyRole);
		Else
			ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, "Recipient");
		EndIf;
		
	EndDo;
	
	// Read the products.
	EDProperty = ED.Properties().Get("Products");
	DataSet = ED["Products"].Product;
	
	ReadDataByTSCustomerOrder(DataSet, ED, ParseTree, NewED, Error);
	
	Company = TreeAttributeRef(ParseTree, NewED, "Company");
	
	AdditionalAttributes = New Structure;
	If ValueIsFilled(Company) Then
		AdditionalAttributes.Insert("Company", Company);
	EndIf;
		
	// Attribute values.
	If Not ED.AttributeValues = Undefined Then
		ReadValueListDetailsCML(ED.AttributeValues.AttributeValue, NewED, Error, AdditionalAttributes);
	EndIf;
	
	// Read additional data from xdto and put them in the header in the values tree
	ReadDocumentHeaderAdditData(ED, NewED, Error, AdditionalAttributes);
	
	// Counterparty contract
	ContractNumber = GetParsedTreeStringAttributeValue(ParseTree, NewED, "ContractNumber");
	ContractDate = GetDateTimeFromString(GetParsedTreeStringAttributeValue(ParseTree, NewED, "ContractDate"));
	
	OwnerTreaty = TreeAttributeRef(ParseTree, NewED, "Counterparty");
		
	AttributesContract = New Structure;
	AttributesContract.Insert("ContractNo", ContractNumber);
	AttributesContract.Insert("ContractDate", ContractDate);
	AttributesContract.Insert("Owner", OwnerTreaty);
	
	CounterpartyContracts = ElectronicDocumentsOverridable.FindRefToObject("CounterpartyContracts", , AttributesContract);
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "CounterpartyContracts");
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ContractNumber, "Contract number: " + ContractNumber, CounterpartyContracts,
				AttributesContract, ParseTree, Error);
	AddObjectHeaderAttribute(NewED, "CounterpartyContract", FoundString.RowIndex);
	
	// Bank account 
	If CompanyRole = "Seller" Then
		OwnerBS = "Company";
		TypeOfAccount = "BankAccountsOfTheCompany";
		AccountName = "BankAccountOfTheCompany";
	Else
		OwnerBS = "Counterparty";
		TypeOfAccount = "BankAccountsOfCounterparties";
		AccountName = "CounterpartyBankAcc";
	EndIf;
	
	AccountOwner = TreeAttributeRef(ParseTree, NewED, OwnerBS);
	
	PropertyCurrentAccount = DocumentAdditAttributeValue("BankAccount", ED);
	If Not PropertyCurrentAccount = Undefined Then
		StructureCurrentAccount =  CurrentAccountDetails(PropertyCurrentAccount, ED, ParseTree, NewED, Error);
		
		AccountNo = StructureCurrentAccount.AccountNo;
		
		AccountAttributes = New Structure;
		AccountAttributes.Insert("Owner", AccountOwner);
		
		BankAccount = ElectronicDocumentsOverridable.FindRefToObject(TypeOfAccount, AccountNo, AccountAttributes);
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, TypeOfAccount);
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, AccountNo, "Account number: " + AccountNo, BankAccount,
				AccountAttributes, ParseTree, Error);
		AddObjectHeaderAttribute(NewED, "BankAccount", FoundString.RowIndex);
		
	Else
		
		BankAccount = TreeAttributeRef(ParseTree, NewED, AccountName);
		AddObjectHeaderAttribute(NewED, "BankAccount", BankAccount);
		
	EndIf;
	
	EDProperty = ED.Properties().Get("BasisDocuments");
	If EDProperty <> Undefined Then
		For Each BasisDocumentXDTO IN ED.BasisDocuments Do
			PropertyBasisDocumentDescription = BasisDocumentXDTO.Properties().Get("BasisDocumentDescription");
			If PropertyBasisDocumentDescription <> Undefined Then
				If BasisDocumentXDTO.BasisDocumentDescription = "Based on client data" Then
					PropertyBasisDocumentNumber = BasisDocumentXDTO.Properties().Get("BasisDocumentNumber");
					If PropertyBasisDocumentNumber <> Undefined Then
						AddObjectHeaderAttribute(NewED, "NumberByCustomerData", BasisDocumentXDTO.BasisDocumentNumber);
					EndIf;
					PropertyBasisDocumentDate = BasisDocumentXDTO.Properties().Get("BasisDocumentDate");
					If PropertyBasisDocumentDate <> Undefined Then
						AddObjectHeaderAttribute(NewED, "DateByCustomerData", BasisDocumentXDTO.BasisDocumentDate);
					EndIf;
				ElsIf BasisDocumentXDTO.BasisDocumentDescription = "Based on vendor data" Then
					PropertyBasisDocumentNumber = BasisDocumentXDTO.Properties().Get("BasisDocumentNumber");
					If PropertyBasisDocumentNumber <> Undefined Then
						AddObjectHeaderAttribute(NewED, "NumberBySupplierData", BasisDocumentXDTO.BasisDocumentNumber);
					EndIf;
					PropertyBasisDocumentDate = BasisDocumentXDTO.Properties().Get("BasisDocumentDate");
					If PropertyBasisDocumentDate <> Undefined Then
						AddObjectHeaderAttribute(NewED, "DateBySupplierData", BasisDocumentXDTO.BasisDocumentDate);
					EndIf;
				EndIf;
			EndIf;
		EndDo;
	EndIf;
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyCode = ED.Get(EDProperty);
		
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			If ValueIsFilled(Currency) Then
				AdditionalAttributes.Insert("Description", Currency.Description);
				AdditionalAttributes.Insert("DescriptionFull", Currency.DescriptionFull);
			EndIf;
			AdditionalAttributes.Insert("MKBCode", CurrencyCode);
			
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = ED.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	EDProperty = DocumentAdditAttributeValue("PaymentSchedule", ED);

	If EDProperty <> Undefined Then
		ReadDataByPaymentSchedule(EDProperty, ED, ParseTree, NewED, Error);
	EndIf;
	
	EDProperty = ED.Properties().Get("Comment");
	If EDProperty <> Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditionalInformation", ED.Comment);
	EndIf;
	
EndProcedure

Procedure DeleteReadOrderXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	If ED.Role = "Customer" Then
		NewED.EDKind = Enums.EDKinds.ProductOrder;
	ElsIf ED.Role = "Seller" Then
		NewED.EDKind = Enums.EDKinds.ResponseToOrder;
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	EDProperty = ED.Properties().Get("Performer");
	Performer = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, ED.Role);
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		If ED.Role = "Customer" Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Seller");
		ElsIf ED.Role = "Seller" Then
			ReadCounterpartyData(Performer, ED, ParseTree, NewED, Error, "Customer");
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("Customer");
	Customer = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		If ED.Role = "Customer" Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Seller");
		ElsIf ED.Role = "Seller" Then
			ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, "Customer");
		EndIf;
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Customer, ED, ParseTree, NewED, Error, ED.Role);
	EndIf;
	
	EDProperty = ED.Properties().Get("Products");
	DataSet = ED["Products"].Product;
	DeleteReadDataOnCustomerOrderTS(DataSet, ED, ParseTree, NewED, Error);
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	TotalByDocumentXDTO = ED.Get(EDProperty);
	AmountTotal = TotalByDocumentXDTO.Properties().Get("AmountTotal");
	
	AddObjectHeaderAttribute(NewED, "AmountTotal",      TotalByDocumentXDTO.Get(AmountTotal));
	AddObjectHeaderAttribute(NewED, "DocumentAmount", TotalByDocumentXDTO.Get(AmountTotal));
	PropertyTaxAmountTotal = TotalByDocumentXDTO.Properties().Get("TaxAmountTotal");
	If PropertyTaxAmountTotal <> Undefined Then
		TaxAmountTotal = TotalByDocumentXDTO.Get(PropertyTaxAmountTotal);
		AddObjectHeaderAttribute(NewED, "TaxAmountTotal", TaxAmountTotal);
	EndIf;
	
	PropertyAmountWithoutDiscountTotal = TotalByDocumentXDTO.Properties().Get("AmountWithoutDiscountTotal");
	If PropertyAmountWithoutDiscountTotal <> Undefined Then
		AmountWithoutDiscountTotal = TotalByDocumentXDTO.Get(PropertyAmountWithoutDiscountTotal);
		AddObjectHeaderAttribute(NewED, "AmountWithoutDiscountTotal", AmountWithoutDiscountTotal);
	EndIf;
	
	PropertyDiscountAmountTotal = TotalByDocumentXDTO.Properties().Get("DiscountAmountTotal");
	If PropertyDiscountAmountTotal <> Undefined Then
		DiscountAmountTotal = TotalByDocumentXDTO.Get(PropertyDiscountAmountTotal);
		AddObjectHeaderAttribute(NewED, "DiscountAmountTotal", DiscountAmountTotal);
	EndIf;
	
	PropertyPriceIncludesVAT = TotalByDocumentXDTO.Properties().Get("PriceIncludesTax");
	If PropertyPriceIncludesVAT <> Undefined Then
		PriceIncludesVAT = TotalByDocumentXDTO.Get(PropertyPriceIncludesVAT);
		AddObjectHeaderAttribute(NewED, "PriceIncludesVAT", PriceIncludesVAT);
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "TotalsInWords", ED.TotalsInWords);
	
	EDProperty = ED.Properties().Get("BasisDocuments");
	If EDProperty <> Undefined Then
		For Each BasisDocumentXDTO IN ED.BasisDocuments Do
			PropertyBasisDocumentDescription = BasisDocumentXDTO.Properties().Get("BasisDocumentDescription");
			If PropertyBasisDocumentDescription <> Undefined Then
				If BasisDocumentXDTO.BasisDocumentDescription = "Based on client data" Then
					PropertyBasisDocumentNumber = BasisDocumentXDTO.Properties().Get("BasisDocumentNumber");
					If PropertyBasisDocumentNumber <> Undefined Then
						AddObjectHeaderAttribute(NewED, "NumberByCustomerData", BasisDocumentXDTO.BasisDocumentNumber);
					EndIf;
					PropertyBasisDocumentDate = BasisDocumentXDTO.Properties().Get("BasisDocumentDate");
					If PropertyBasisDocumentDate <> Undefined Then
						AddObjectHeaderAttribute(NewED, "DateByCustomerData", BasisDocumentXDTO.BasisDocumentDate);
					EndIf;
				ElsIf BasisDocumentXDTO.BasisDocumentDescription = "Based on vendor data" Then
					PropertyBasisDocumentNumber = BasisDocumentXDTO.Properties().Get("BasisDocumentNumber");
					If PropertyBasisDocumentNumber <> Undefined Then
						AddObjectHeaderAttribute(NewED, "NumberBySupplierData", BasisDocumentXDTO.BasisDocumentNumber);
					EndIf;
					PropertyBasisDocumentDate = BasisDocumentXDTO.Properties().Get("BasisDocumentDate");
					If PropertyBasisDocumentDate <> Undefined Then
						AddObjectHeaderAttribute(NewED, "DateBySupplierData", BasisDocumentXDTO.BasisDocumentDate);
					EndIf;
				EndIf;
			EndIf;
		EndDo;
	EndIf;
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	If ED.ShippingAddressWarehouse <> Undefined Then
		AddObjectHeaderAttribute(NewED, "ShippingAddress", ED.ShippingAddressWarehouse.Description);
	EndIf;
	
	EDProperty = ED.Properties().Get("PaymentStage");
	If EDProperty <> Undefined Then
		DeleteReadDataByPaymentSchedule(ED.PaymentStage, ED, ParseTree, NewED, Error);
	EndIf;
	
	EDProperty = ED.Properties().Get("Comment");
	If EDProperty <> Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditionalInformation", ED.Comment);
	EndIf;
	
EndProcedure

Procedure ReadComissionGoodsWriteOffReportXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	// read counterparties
	For Each CurCounterparty IN ED.Counterparties.Counterparty Do
		
		If Upper(CurCounterparty.Role) = Upper("Consignor") Then
			
			If NewED.EDDirection = Enums.EDDirections.Outgoing Then
				ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, "Customer");
			ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then		
				ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, "Seller");
			EndIf;
			
		ElsIf Upper(CurCounterparty.Role) = Upper("Agent") Then
			
			If NewED.EDDirection = Enums.EDDirections.Outgoing Then
				ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, "Seller");
			ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
				ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, "Customer");
			EndIf;
			
		EndIf;
	EndDo;
	
	DataSet = ED["Products"].Product;
	ReadDataByTSComissionGoodsWriteOffReport(DataSet, ED, ParseTree, NewED, Error);
		
	// AdditionalAttributes
	If Not ED.AttributeValues = Undefined Then
		ReadValueListDetailsCML(ED.AttributeValues.AttributeValue, NewED, Error);
	EndIf;
	
	//Read additional data.
	ReadDocumentHeaderAdditData(ED, NewED, Error);
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyCode = ED.Get(EDProperty);
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			If ValueIsFilled(Currency) Then
				AdditionalAttributes.Insert("Description", Currency.Description);
				AdditionalAttributes.Insert("DescriptionFull", Currency.DescriptionFull);
			EndIf;
			AdditionalAttributes.Insert("MKBCode", CurrencyCode);
			
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = ED.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
EndProcedure

Procedure DeleteReadComissionGoodsWriteOffReportXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	EDProperty = ED.Properties().Get("Consignor");
	Consignor = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Customer");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then		
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Seller");
	EndIf;
	
	EDProperty = ED.Properties().Get("Agent");
	Agent = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Agent, ED, ParseTree, NewED, Error, "Seller");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Agent, ED, ParseTree, NewED, Error, "Customer");
	EndIf;
	
	DataSet = ED["Products"].Product;
	DeleteReadDataByTSComissionGoodsWriteOffReport(DataSet, ED, ParseTree, NewED, Error);
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	TotalByDocument = ED.Get(EDProperty);
	AddObjectHeaderAttribute(NewED, "TotalByDocument", TotalByDocument);
	AddObjectHeaderAttribute(NewED, "DocumentAmount",   TotalByDocument);
	
	AddObjectHeaderAttribute(NewED, "TotalsInWords", ED.TotalsInWords);
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
EndProcedure

Procedure ReadReportAboutComissionGoodsSalesXDTO(ED, ParseTree, NewED, Error)
	
	// unique number of ED in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.ComissionGoodsSalesReport;
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	//Read additional data.
	ReadDocumentHeaderAdditData(ED, NewED, Error);
	
	CounterpartiesIdArray = New Array;
	For Each CurCounterparty IN ED.Counterparties.Counterparty Do
		If CurCounterparty.Role = "Customer" Then
			Role = "CommissionGoodsBuyer";
		Else
			Role = CurCounterparty.Role;
		EndIf;
		ReadCounterpartyDataCML(CurCounterparty, ED, ParseTree, NewED, Error, Role, , CounterpartiesIdArray);
	EndDo;
	
	DataSet = ED["Products"].Product;
	ReadDataByTSReportAboutComissionGoodsSales(DataSet, ED, ParseTree, NewED, Error);
	
	// Attribute values
	If Not ED.AttributeValues = Undefined Then
		ReadValueListDetailsCML(ED.AttributeValues.AttributeValue, NewED, Error);
	EndIf;
	
	PaymentSchedule = DocumentAdditAttributeValue("PaymentSchedule", ED);
	If PaymentSchedule <> Undefined Then
		ReadDataByPaymentSchedule(PaymentSchedule, ED, ParseTree, NewED, Error);
	EndIf;

	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyCode = ED.Get(EDProperty);
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			If ValueIsFilled(Currency) Then
				AdditionalAttributes.Insert("Description", Currency.Description);
				AdditionalAttributes.Insert("DescriptionFull", Currency.DescriptionFull);
				AdditionalAttributes.Insert("MKBCode", Currency.Code);
			EndIf;

			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = ED.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;

EndProcedure

Procedure DeleteReadReportOnComissionGoodsSalesXDTO(ED, ParseTree, NewED, Error)
	
	// unique ED number in terms of exchange participants
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.ComissionGoodsSalesReport;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	AddObjectHeaderAttribute(NewED, "Number", ED.Number);
	AddObjectHeaderAttribute(NewED, "Date", ED.Date);
	
	EDProperty = ED.Properties().Get("Consignor");
	Consignor = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Customer");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Seller");
	EndIf;
	
	EDProperty = ED.Properties().Get("Agent");
	Agent = ED.Get(EDProperty);
	If NewED.EDDirection = Enums.EDDirections.Outgoing Then
		ReadCounterpartyData(Agent, ED, ParseTree, NewED, Error, "Seller");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Agent, ED, ParseTree, NewED, Error, "Customer");
	EndIf;
	
	DataSet = ED["Products"].Product;
	DeleteReadDataByTSReportOnComissionGoodsSales(DataSet, ED, ParseTree, NewED, Error);
	
	EDProperty = ED.Properties().Get("TotalByDocument");
	TotalByDocument = ED.Get(EDProperty);
	PropertyPrincipalAmountTotal = TotalByDocument.Properties().Get("PrincipalAmountTotal");
	PrincipalAmountTotal = TotalByDocument.Get(PropertyPrincipalAmountTotal);
	AddObjectHeaderAttribute(NewED, "PrincipalAmount", PrincipalAmountTotal);
	PropertySalesAmountTotal = TotalByDocument.Properties().Get("SalesAmountTotal");
	SalesAmountTotal = TotalByDocument.Get(PropertySalesAmountTotal);
	AddObjectHeaderAttribute(NewED, "DocumentAmount", SalesAmountTotal);
	PropertyBrokerageAmountTotal = TotalByDocument.Properties().Get("TotalAmountRemuneration");
	If PropertyBrokerageAmountTotal <> Undefined Then
		TotalAmountRemuneration = TotalByDocument.Get(PropertyBrokerageAmountTotal);
		AddObjectHeaderAttribute(NewED, "BrokerageAmount", TotalAmountRemuneration);
	EndIf;
	
	PropertyPercent = TotalByDocument.Properties().Get("Percent");
	If PropertyPercent <> Undefined Then
		Percent = TotalByDocument.Get(PropertyPercent);
		AddObjectHeaderAttribute(NewED, "PercentOfRemuneration", Percent);
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "TotalsInWords", ED.TotalsInWords);
	
	EDProperty = ED.Properties().Get("Currency");
	If EDProperty <> Undefined Then
		CurrencyXDTO = ED.Get(EDProperty);
		CurrencyCode = CurrencyXDTO.CodeRCC;
		If CurrencyCode <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			AdditionalAttributes.Insert("Description", CurrencyXDTO.ShortDescriptionGCC);
			AdditionalAttributes.Insert("DescriptionFull", CurrencyXDTO.DescriptionFullOfGCC);
			AdditionalAttributes.Insert("MKBCode", CurrencyXDTO.MKBCode);
			
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode, Currency,
				AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		ExchangeRate = CurrencyXDTO.ExchangeRate;
		If ExchangeRate <> Undefined Then
			AddObjectHeaderAttribute(NewED, "ExchangeRate", ExchangeRate);
		EndIf;
	EndIf;
	
	EDProperty = ED.Properties().Get("PaymentStage");
	If EDProperty <> Undefined Then
		DeleteReadDataByPaymentSchedule(ED.PaymentStage, ED, ParseTree, NewED, Error);
	EndIf;
	
	EDProperty = ED.Properties().Get("StartDate");
	If EDProperty <> Undefined Then
		StartDate = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "BeginOfPeriod", StartDate);
	EndIf;
	
	EDProperty = ED.Properties().Get("EndDate");
	If EDProperty <> Undefined Then
		EndDate = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "EndOfPeriod", EndDate);
	EndIf;
	
	EDProperty = ED.Properties().Get("PaymentForm");
	If EDProperty <> Undefined Then
		PaymentForm = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "PaymentForm",
			ElectronicDocumentsReUse.FindEnumeration("FormsOfPayment", PaymentForm));
	EndIf;
	
	EDProperty = ED.Properties().Get("CalculationMethod");
	If EDProperty <> Undefined Then
		CalculationMethod = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "CalculationMethodOfRemuneration",
			ElectronicDocumentsReUse.FindEnumeration("CalculationMethod", CalculationMethod));
	Else
		AddObjectHeaderAttribute(NewED, "CalculationMethodOfRemuneration",
			ElectronicDocumentsReUse.FindEnumeration("CalculationMethod", "Not calculated"));
	EndIf;
	
	EDProperty = ED.Properties().Get("PayDate");
	If EDProperty <> Undefined Then
		PayDate = ED.Get(EDProperty);
		AddObjectHeaderAttribute(NewED, "PaymentDate", PayDate);
	EndIf;
	
	EDProperty = ED.Properties().Get("Service");
	If EDProperty <> Undefined Then
		Service = ED.Get(EDProperty);
		If Service <> Undefined Then
			PropertyTax = Service.Properties().Get("Tax");
			If PropertyTax <> Undefined Then
				Tax = Service.Get(PropertyTax);
				If Upper(Tax.TaxType) = "VAT" Then
					TaxRate = ElectronicDocumentsReUse.VATRateFromDisplay(Tax.TaxRateAmount);
					AddObjectHeaderAttribute(NewED, "VATCommissionFeePercent", TaxRate);
					
					PropertyAmount = Tax.Properties().Get("Amount");
					If PropertyAmount <> Undefined Then
						AddObjectHeaderAttribute(NewED, "BrokerageVATAmount", Tax.Amount);
					EndIf;
				EndIf;
			EndIf;
		EndIf;
		
		AddObjectHeaderAttribute(NewED, "Service", Service.Description);
		
	EndIf;
	
EndProcedure

Procedure ReadCorrectingDocumentXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.AgreementAboutCostChangeSender;
	NewED.ObjectDescription = "TrueUp";
	
	AddObjectHeaderAttribute(NewED, "Number", ED.Document.PrInD.CN.NumCW);
	DocDate = ED.Document.PrInD.CN.WBDate;
	AddObjectHeaderAttribute(NewED, "Date", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
	
	DocumentAmount = 0;
	If ED.Document.PrInD.CN.Table.TotalInv <> Undefined
		AND ValueIsFilled(ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun) Then
		
		DocumentAmount = ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun;
	ElsIf ED.Document.PrInD.ReleaseCargo <> Undefined
		AND ValueIsFilled(ED.Document.PrInD.ReleaseCargo.AmountRelease) Then
		
		DocumentAmount = ED.Document.PrInD.ReleaseCargo.AmountRelease;
	EndIf;
	AddObjectHeaderAttribute(NewED, "DocumentAmount", DocumentAmount);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	
	Consignor = Undefined;
	ShipperAdditParameters = New Structure;
	Vendor = ED.Document.PrInD.Vendor;
	If ED.Document.PrInD.CargoFrom <> Undefined AND ED.Document.PrInD.CargoFrom.CargoShpd <> Undefined Then
		ShipperAdditParameters.Insert("OrganizationDepartment", ED.Document.PrInD.CargoFrom.StructDep);
		ShipperAdditParameters.Insert("RCEAP", ED.Document.PrInD.CargoFrom.RCEAP);
		Consignor = ED.Document.PrInD.CargoFrom.CargoShpd;
		If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact = Undefined Then
			If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Phone = Undefined Then
				ShipperAdditParameters.Insert("PhoneNumbers", ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Phone);
			EndIf;
			If Not ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Fax = Undefined Then
				ShipperAdditParameters.Insert("Fax", ED.Document.PrInD.CargoFrom.CargoShpd.Contact.Fax);
			EndIf;
		EndIf;
	ElsIf Vendor <> Undefined Then
		Consignor = Vendor;
	EndIf;
	
	If ED.Document.PrInD.ReleaseCargo <> Undefined Then
		If ED.Document.PrInD.ReleaseCargo.ReleasePerm <> Undefined Then
			ShipperAdditParameters.Insert("HeadPost", ED.Document.PrInD.ReleaseCargo.ReleasePerm.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.ReleasePerm.Initials;
			ShipperAdditParameters.Insert("HeadDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrInD.ReleaseCargo.Accountant <> Undefined Then
			ShipperAdditParameters.Insert("ChiefAccountantPosition", ED.Document.PrInD.ReleaseCargo.Accountant.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.Accountant.Initials;
			ShipperAdditParameters.Insert("NameAndSurnameOfChiefAccountant",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrInD.ReleaseCargo.ReleaseMad <> Undefined Then
			ShipperAdditParameters.Insert("WarehousemanPosition", ED.Document.PrInD.ReleaseCargo.ReleaseMad.Position);
			Initials = ED.Document.PrInD.ReleaseCargo.ReleaseMad.Initials;
			ShipperAdditParameters.Insert("WarehouseManSNP",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
	EndIf;
	
	If Consignor <> Undefined Then
		ReadCounterpartyData(Consignor, ED, ParseTree, NewED, Error, "Consignor");
		If ShipperAdditParameters.Count() > 0 Then
			NodeIndex = ParseTree.Rows.Find("Consignor", "Attribute", True);
			If NodeIndex <> Undefined AND ValueIsFilled(NodeIndex.AttributeValue) Then
				ShipperRow = ParseTree.Rows.Find(NodeIndex.AttributeValue, "RowIndex", True);
				If ShipperRow <> Undefined Then
					For Each AdditParameter IN ShipperAdditParameters Do
						AddObjectHeaderAttribute(ShipperRow, AdditParameter.Key, AdditParameter.Value);
					EndDo;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
	If ED.Document.PrInD.CargoRece <> Undefined Then
		ReadCounterpartyData(ED.Document.PrInD.CargoRece, ED, ParseTree, NewED, Error, "Consignee");
	EndIf;
	
	// Consignor and Supplier - optional
	// items of xsd scheme but one of these
	// items must be filled (according to "in" art.2 p. 9 Federal Law from 21.11.1996 No 129-FZ).
	If Vendor = Undefined Then
		Vendor = Consignor;
	EndIf;
	
	If NewED.EDDirection = Enums.EDDirections.Outgoing 
		OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Seller");
	ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
		ReadCounterpartyData(Vendor, ED, ParseTree, NewED, Error, "Customer");
	EndIf;
	
	Payer = ED.Document.PrInD.Payer;
	If Payer <> Undefined Then
		If NewED.EDDirection = Enums.EDDirections.Outgoing
			OR NewED.EDDirection = Enums.EDDirections.Intercompany Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Customer");
		ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
			ReadCounterpartyData(Payer, ED, ParseTree, NewED, Error, "Seller");
		EndIf;
	EndIf;
	
	Company = GetEDHeaderAttribute(NewED, "Company", ParseTree);
	Structure = New Structure("Company", Company);
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrInD.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined AND Find(InfFul.TextInf, "xml") = 0 Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
		
		RowCurrency = NewED.Rows.Find("CurrencyCode", "Attribute", True);
		If RowCurrency <> Undefined Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
			CurrencyCode = RowCurrency.AttributeValue;
			AdditionalAttributes = New Structure;
			AdditionalAttributes.Insert("Code", CurrencyCode);
			Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(CurrencyCode));
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CurrencyCode, "Currency code: " + CurrencyCode,
				Currency, AdditionalAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
		EndIf;
		
		RowBasisDocument = NewED.Rows.Find("IDEDDocumentFoundation", "Attribute", True);
		If RowBasisDocument <> Undefined AND ValueIsFilled(Company) Then
			BasisDocument = GetBasisDocument(RowBasisDocument.AttributeValue, Structure);
			If BasisDocument <> Undefined Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BasisDocuments");
				AddObjectHeaderAttribute(FoundTypeInTree, "BasisDocuments", BasisDocument, BasisDocument);
				FoundString = FoundTypeInTree.Rows.Find(BasisDocument, "ObjectReference");
				FoundString.RowIndex = FoundTypeInTree.RowIndex + "_"
					+ String(FoundTypeInTree.Rows.IndexOf(FoundString));
				AddObjectHeaderAttribute(NewED, "Basis", FoundString.RowIndex, BasisDocument);
			EndIf;
		EndIf;
	EndIf;
	
	OperationKind = NewED.Rows.Find("OperationKind", "Attribute", True);
	If OperationKind <> Undefined Then
		OperationKind.AttributeValue = XMLValue(Type("EnumRef.EDOperationsKinds"), OperationKind.AttributeValue);
	EndIf;
	
	If ED.Document.PrInD.Basis <> Undefined Then
		DateByCustomerData = ED.Document.PrInD.Basis.DateBas;
		If ValueIsFilled(DateByCustomerData) Then
			AddObjectHeaderAttribute(NewED, "DateByCustomerData", Date(Mid(DateByCustomerData, 7, 4)
				+ Mid(DateByCustomerData, 4, 2) + Mid(DateByCustomerData, 1, 2)));
		EndIf;
		AddObjectHeaderAttribute(NewED, "NumberByCustomerData", ED.Document.PrInD.Basis.BasisNum);
		AddObjectHeaderAttribute(NewED, "BasisDescription", ED.Document.PrInD.Basis.DescBas);
	EndIf;
	
	If ED.Document.PrInD.CN.WBCom <> Undefined Then
		AddObjectHeaderAttribute(NewED, "RecCount", ED.Document.PrInD.CN.WBCom.NumRecNum);
		AddObjectHeaderAttribute(NewED, "RecordsCountInWords", ED.Document.PrInD.CN.WBCom.NumRecNumWor);
		AddObjectHeaderAttribute(NewED, "PlacesQuantity", ED.Document.PrInD.CN.WBCom.TotSpots);
		AddObjectHeaderAttribute(NewED, "PlacesCountInWords", ED.Document.PrInD.CN.WBCom.TotSpotsEtc);
		AddObjectHeaderAttribute(NewED, "CargoWeightInWords", ED.Document.PrInD.CN.WBCom.GrossInFull);
	EndIf;
	If ED.Document.PrInD.CN.Table.TotalInv <> Undefined Then
		AddObjectHeaderAttribute(NewED, "Amount", ED.Document.PrInD.CN.Table.TotalInv.AmountNoVATVs);
		AddObjectHeaderAttribute(NewED, "VATAmount", ED.Document.PrInD.CN.Table.TotalInv.AmountVATTotal);
		AddObjectHeaderAttribute(NewED, "AmountWithVAT", ED.Document.PrInD.CN.Table.TotalInv.AmountCtVATSun);
	EndIf;
	If ED.Document.PrInD.ReleaseCargo <> Undefined Then
		AddObjectHeaderAttribute(NewED, "AmountTotalInWords", ED.Document.PrInD.ReleaseCargo.AmountReleasePr);
		DocDate = ED.Document.PrInD.ReleaseCargo.DateRelease;
		If ValueIsFilled(DocDate) Then
			AddObjectHeaderAttribute(NewED, "DateReleased", Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2)));
		EndIf;
		AddObjectHeaderAttribute(NewED, "SheetsCountInApplInWords", ED.Document.PrInD.ReleaseCargo.NumAppWo);
	EndIf;
	
	DataSet = ED.Document.PrInD.CN.Table.PrGd;
	
	// Define ED variant for selection of an algorithm to fill in products and services
	AuthorEDCustomer = False;
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
		OR NewED.EDDirection = Enums.EDDirections.Intercompany);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			ListTS.Add(Item.ItemNum,      "Number");
			ListTS.Add(Item.DescProd,     "Description");
			ListTS.Add(Item.CharacterTov, "CharacteristicDescription");
			ListTS.Add(Item.CodeProd,      "ProductCode");
			ListTS.Add(Item.GradeItems,     "Kind");
			ListTS.Add(Item.GoodsSKU,  "SKU");
			ListTS.Add(Item.DescUnOfMeas,   "MeasurementUnitDescription");
			ListTS.Add(Item.OKEI_Tov,    "MeasurementUnitCode");
	
			ListTS.Add(Item.NetBeforeCorrection, "QuantityBeforeCorrection");
			ListTS.Add(Item.Net,     "Quantity");
			ListTS.Add(Item.NumberOfSeats,   "Places");
			ListTS.Add(Item.KindPack,   "Package");
			ListTS.Add(Item.place,     "QuantityInOnePlace");
			ListTS.Add(Item.NetBeforeCorrection, "NetWeightBeforeCorrection");
			ListTS.Add(Item.Net,     "NetWeight");
			ListTS.Add(Item.Gross,    "GrossWeight");
			ListTS.Add(Item.PriceBeforeCorrection,      "PriceBeforeCorrection");
			ListTS.Add(Item.Price,      "Price");
			ListTS.Add(Item.AmountNoVATBeforeCorrection, "AmountBeforeCorrection");
			ListTS.Add(Item.AmountNoVAT, "Amount");
			ListTS.Add(Item.AmountVATBeforeAdjustment,    "VATAmountBeforeCorrection");
			ListTS.Add(Item.AmountVAT,    "VATAmount");
			ListTS.Add(Item.AmountCtVATBeforeCorrection,  "VATAmountBeforeAdjustments");
			ListTS.Add(Item.AmountCtVAT,  "SumWithVAT");
			
			// Delete first branch - only required for reading old documents.
			If ValueIsFilled(Item.InfFullStr) AND Find(Item.InfFullStr, "xml") > 0 Then
				
				ListTS.Add(Item.VATRate, "VATRate");
				
				// IN inf.field xml-string of invalid format.
				XMLObject = New XMLReader;
				Try
					XMLObject.SetString(Item.InfFullStr);
					XDTOProduct = XDTOFactory.ReadXML(XMLObject);
					ParseStringTSCML(XDTOProduct, ListTS, ED, ParseTree, NewED, Error);
				Except
				EndTry;
			Else
				If ValueIsFilled(Item.InfFullStr) Then
					// IN inf.field xml-string of Relevant format
					InfFul = Item.InfFullStr;
					ReadInfPol(InfFul, AdditDataTree, "Products", Item.ItemNum);
					FillTSRowByAdditData(AdditDataTree, ListTS, Item.ItemNum, "Products", Error);
				EndIf;
				ProductsAndServicesAttributes = New Structure;
				MeasurementUnitAttributes = New Structure;
				ProductId = "";
				VATRateTransferredByAdditParameter = False;
				For Each ItemOP IN ListTS Do
					
					// ProductsAndServices.
					If ItemOP.Presentation = "Description" Then
						ProductsAndServicesAttributes.Insert("Description", ItemOP.Value);
					ElsIf ItemOP.Presentation = "Characteristic" Then
						ProductsAndServicesAttributes.Insert("Characteristic", ItemOP.Value);
					ElsIf ItemOP.Presentation = "SKU" Then
						ProductsAndServicesAttributes.Insert("SKU", ItemOP.Value);
					ElsIf ItemOP.Presentation = "MeasurementUnitCode" Then
						MeasurementUnitAttributes.Insert("Code", ItemOP.Value);
					ElsIf ItemOP.Presentation = "MeasurementUnitDescription" Then
						MeasurementUnitAttributes.Insert("Description", ItemOP.Value);
					ElsIf ItemOP.Presentation = "ID" Then
						ProductId = ItemOP.Value;
						
					// Check the existence of VAT rate in additional parameters.
					ElsIf ItemOP.Presentation = "VATRate" Then
						VATRateTransferredByAdditParameter = True;
					ElsIf ItemOP.Presentation = "IDEDDocumentFoundation" AND ValueIsFilled(Company) Then
						BasisDocument = GetBasisDocument(ItemOP.Value, Structure);
						If BasisDocument <> Undefined Then
							ListTS.Add(BasisDocument, "BasisDocument");
						EndIf;
					EndIf;
				EndDo;
				// VAT rate can come with additional parameters.
				If Not VATRateTransferredByAdditParameter Then
					ListTS.Add(Item.VATRate, "VATRate");
				EndIf;
				
				ProductDesc = "";
				ProductsAndServicesAttributes.Property("Description", ProductDesc);
				
				CodeUnMeas = "";
				If MeasurementUnitAttributes.Property("Code", CodeUnMeas) Then
					UnOfMeasDescription = "";
					MeasurementUnitAttributes.Property("Description", UnOfMeasDescription);
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(CodeUnMeas),
						MeasurementUnitAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString     = FindCreateStringInParsedTree(FoundTypeInTree, String(CodeUnMeas),
						UnOfMeasDescription, UnOfMeas, MeasurementUnitAttributes, ParseTree, Error);
					If ValueIsFilled(FoundString) Then
						ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
					EndIf;
				EndIf;
				
				// Identification by products and services of the company when the parsing side ED - subsidiary company itself
				If IdentificationByCounterpartyProductsAndServices Then
					IdStructure = ParseProductID(ProductId);
					ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
					If ValueIsFilled(IdStructure.CharacteristicID) Then
						ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
						If ListTS.FindByValue(ProductsAndServicesCharacteristic) <> Undefined Then
							ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
						EndIf;
					EndIf;
					If ValueIsFilled(IdStructure.IDPackage) Then
						ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
						If ListTS.FindByValue(ProductsAndServicesPackaging) <> Undefined Then
							ListTS.Add(ProductsAndServicesPackaging, "Package");
						EndIf;
					EndIf;
				Else
					// Suppliers products and services.
					SupplierProductsAndServicesAttributes = New Structure;
					OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
					ProductsAndServicesOwner  = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
					
					SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
					SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
					If ProductsAndServicesAttributes.Property("SKU") Then
						SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
					EndIf;
					
					If ValueIsFilled(ProductDesc) Then
						SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
					EndIf;
					
					SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
						SupplierProductsAndServicesAttributes);
					
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
						SupplierProductsAndServicesAttributes, ParseTree, Error);
					ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
					
					If ValueIsFilled(SupplierProductsAndServices) Then
						ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
						SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
					EndIf;
					ProductAttributesStructure = GenerateProductStructure();
					ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes, ProductAttributesStructure);
					
					ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
					If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
						ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
					EndIf;
					If ValueIsFilled(ProductAttributesStructure.Package) Then
						ListTS.Add(ProductAttributesStructure.Package, "Package");
					EndIf;
				EndIf;
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
					ProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
				
				AddObjectTSAttributes(NewED, "TSRow", ListTS);
			EndIf;
		EndDo;
	EndIf;
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadCorrectingDocumentRecipientXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient;
	
	AdditDataTree = Undefined;
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow <> Undefined AND TypeOf(TreeRow.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = TreeRow.AttributeValue;
	EndIf;
	InfFul = ED.Document.PrRnIn.InfFul;
	If InfFul <> Undefined AND InfFul.TextInf <> Undefined Then
		ReadInfPol(InfFul.TextInf, AdditDataTree, "Header");
	EndIf;
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderByAdditData(AdditDataTree, NewED, Error);
	EndIf;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	If ED.Document.PrRnIn.ReceiveCargo <> Undefined Then
		DocDate = ED.Document.PrRnIn.ReceiveCargo.ReceivDate;
		DateReceived = Date(Mid(DocDate, 7, 4) + Mid(DocDate, 4, 2) + Mid(DocDate, 1, 2));
		AddObjectHeaderAttribute(NewED, "DateReceived", DateReceived);
		If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney <> Undefined Then
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyNumber", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.NumPowerOfAttorn);
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyDate", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.DateGiven);
			PowerOfAttorneyIssued = "";
			If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Company", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.EntDescWhoIssued);
				SecondaryStructure.Insert("Position", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.PositWho);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.AdditInfWho);
				If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.Initials <> Undefined Then
					Initials = ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.WhoIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued <> Undefined Then
				SecondaryStructure = New Structure;
				SecondaryStructure.Insert("Position", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Posit);
				SecondaryStructure.Insert("AdditionalInformation", ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.AdditInfoToWhom);
				If ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Initials <> Undefined Then
					Initials = ED.Document.PrRnIn.ReceiveCargo.PowerOfAttorney.ToWhomIssued.Initials;
					SecondaryStructure.Insert("Initials",
						ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
				EndIf;
				For Each Item IN SecondaryStructure Do
					If ValueIsFilled(Item.Value) Then
						PowerOfAttorneyIssued = PowerOfAttorneyIssued + ?(ValueIsFilled(PowerOfAttorneyIssued), ", ", "") + TrimAll(Item.Value);
					EndIf;
				EndDo;
			EndIf;
			AddObjectHeaderAttribute(NewED, "PowerOfAttorneyIssued", PowerOfAttorneyIssued);
		EndIf;
		If ED.Document.PrRnIn.ReceiveCargo.CargoReceived <> Undefined Then
			AddObjectHeaderAttribute(NewED, "CargoTakePosition", ED.Document.PrRnIn.ReceiveCargo.CargoReceived.Position);
			Initials = ED.Document.PrRnIn.ReceiveCargo.CargoReceived.Initials;
			AddObjectHeaderAttribute(NewED, "CargoAcceptedDescriptionFull",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
		If ED.Document.PrRnIn.ReceiveCargo.CargoTaken <> Undefined Then
			AddObjectHeaderAttribute(NewED, "CargoReceivedPosition", ED.Document.PrRnIn.ReceiveCargo.CargoTaken.Position);
			Initials = ED.Document.PrRnIn.ReceiveCargo.CargoTaken.Initials;
			AddObjectHeaderAttribute(NewED, "CargoReceivedSNP",
				ElectronicDocuments.SurnameInitialsOfIndividual(Initials.Surname + " " + Initials.Name + " " + Initials.Patronymic));
		EndIf;
	EndIf;
	
	TreeRow = NewED.Rows.Find("AdditDataTree", "Attribute");
	If TreeRow = Undefined Then
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
EndProcedure

Procedure ReadRightsDelegationActXDTO(ED, ParseTree, NewED, Error)
	
	Document = ED.Document[0];
	
	If Document.BusinessTransaction = "Transfer of rights" Then
		NewED.EDKind = Enums.EDKinds.RightsDelegationAct;
	EndIf;
	
	AddObjectHeaderAttribute(NewED, "GeneratingDate", ED.GeneratingDate);
	AddObjectHeaderAttribute(NewED, "DocumentID", Document.ID);
	
	// Counterparties
	For Each Counterparty IN Document.Counterparties.Counterparty Do
		ReadCounterpartyDataCML(Counterparty, ED, ParseTree, NewED, Error, Counterparty.Role);
	EndDo;
	
	Company = TreeAttributeRef(ParseTree, NewED, "Company");
	
	AdditionalAttributes = New Structure;
	If ValueIsFilled(Company) Then
		AdditionalAttributes.Insert("Company", Company);
	EndIf;
		
	// Attribute values
	If Not Document.AttributeValues = Undefined Then
		ReadValueListDetailsCML(Document.AttributeValues.AttributeValue, NewED, Error, AdditionalAttributes);
	EndIf;
	
	// Read additional data from xdto and put them in the header in the values tree
	ReadDocumentHeaderAdditData(Document, NewED, Error, AdditionalAttributes);
	
	OperationKind = NewED.Rows.Find("OperationKind", "Attribute", True);
	If OperationKind <> Undefined Then
		OperationKind.AttributeValue = XMLValue(Type("EnumRef.EDOperationsKinds"), OperationKind.AttributeValue);
	EndIf;
	
	For Each CurProperty IN Document.Properties() Do
		
		Item = Document.Get(CurProperty);
		If Item = Undefined Then
			Continue;
		EndIf;
		
		If IsSimpleTypeItemXDTO(Item) Then
			If CurProperty.Name = "Currency" Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Currencies");
				
				AdditionalAttributes = New Structure;
				AdditionalAttributes.Insert("Code", Item);
				
				Currency = ElectronicDocumentsOverridable.FindRefToObject("Currencies", String(Item));
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, Item, "Currency code: " + Item, Currency,
					AdditionalAttributes, ParseTree, Error);
				AddObjectHeaderAttribute(NewED, "Currency", FoundString.RowIndex);
			ElsIf CurProperty.Name = "Amount" Then
				AddObjectHeaderAttribute(NewED, "DocumentAmount", Item);
			Else
				AddObjectHeaderAttribute(NewED, CurProperty.Name, Item);
			EndIf;
			
		ElsIf CurProperty.Name = "Products" Then
			If TypeOf(Item.Product) = Type("XDTOList") Then
				LineNumber = 0;
				For Each Product IN Item.Product Do
					ListTS = New ValueList;
					
					ParseStringTSCML(Product, ListTS, ED, ParseTree, NewED, Error, LineNumber);
					
					
				EndDo;
			EndIf;
		ElsIf Find("Taxes Discounts AdditExpenses", CurProperty.Name) > 0 Then
			DataListValuesOfCML(Item, NewED, Error);
		EndIf;
		
	EndDo;
	
EndProcedure

Procedure ReadCompanyDetailsXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = "CompanyAttributes";

	AddObjectHeaderAttribute(NewED, "TIN",						ED.TIN);
	AddObjectHeaderAttribute(NewED, "OKPO",						ED.OKPO);
	AddObjectHeaderAttribute(NewED, "Description",				ED.Description);
	AddObjectHeaderAttribute(NewED, "OfficialName",	ED.OfficialName);
	AddObjectHeaderAttribute(NewED, "DefaultActivityKind",	ED.DefaultActivityKind);
	AddObjectHeaderAttribute(NewED, "EGRPO",						ED.EGRPO);
	AddObjectHeaderAttribute(NewED, "OKVED",						ED.OKVED);
	AddObjectHeaderAttribute(NewED, "RCEAP",						ED.RCEAP);
	AddObjectHeaderAttribute(NewED, "RCOLF",						ED.RCOLF);
	AddObjectHeaderAttribute(NewED, "OKFS",						ED.OKFS);
	AddObjectHeaderAttribute(NewED, "OKPO",						ED.OKPO);
	AddObjectHeaderAttribute(NewED, "RegistrationDate",			ED.RegistrationDate);
	AddObjectHeaderAttribute(NewED, "FullDescr",			ED.FullDescr);
	AddObjectHeaderAttribute(NewED, "Appeal",					ED.Appeal);
	AddObjectHeaderAttribute(NewED, "Surname",					ED.Surname);
	AddObjectHeaderAttribute(NewED, "Name",						ED.Name);
	AddObjectHeaderAttribute(NewED, "Patronymic",					ED.Patronymic);
	AddObjectHeaderAttribute(NewED, "BirthDate",				ED.BirthDate);
	AddObjectHeaderAttribute(NewED, "BirthPlace",				ED.BirthPlace);
	AddObjectHeaderAttribute(NewED, "Gender",						ED.Gender);
	AddObjectHeaderAttribute(NewED, "IdentityCard",		ED.IdentityCard);
	AddObjectHeaderAttribute(NewED, "RegistrationAddress",			ED.RegistrationAddress);
	AddObjectHeaderAttribute(NewED, "Position",					ED.Position);
	AddObjectHeaderAttribute(NewED, "Comment",				ED.Comment);
	
	
	ReadCounterpartyDataCML(ED, ED, ParseTree, NewED, Error, "Customer");
	
EndProcedure

Function FillInAgentDataFromAdditData(ParseTree, NewED, TargetNamespaceSchema, Error)
	
	CommissionInv = False;
	StrCommissionAgent = NewED.Rows.Find("AgentData", "Attribute", True);
	AgentName = NewED.Rows.Find("AgentName", "Attribute", True);
	AgentAdded = False;
	If ValueIsFilled(StrCommissionAgent) Then
		CommissionInv = True;
		If NewED.EDDirection = Enums.EDDirections.Incoming Then
			XMLObject = New XMLReader;
			Try
				XMLString = "<PrPurchSalesType xmlns=""" + TargetNamespaceSchema + """> " + StrCommissionAgent.AttributeValue
					+ " <Address> <AdrRF CodeState=""00""/> </Address> </PrPurchSalesType>";
				XMLObject.SetString(XMLString);
				Agent = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("PrPurchSalesType", TargetNamespaceSchema));
				XMLObject.Close();
				ReadCounterpartyData(Agent, Agent, ParseTree, NewED, Error, "Agent");
				AgentAdded = True;
			Except
				Error = True;
				MessageText = NStr("en='Failed to read Commission
		|agent data when extracting the data of ED(corr)invoice (see details in event log monitor).';ru='Не удалось
		|прочитать данные Комиссионера при извлечении данных ЭД (корр)счет-фактура (подробности см. в Журнале регистрации).'");
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																							DetailErrorDescription(ErrorInfo()),
																							MessageText);
			EndTry;
		EndIf;
	EndIf;
	If ValueIsFilled(AgentName) Then
		// From application solutions with BED, version 1.1.15.3 and less data about commission agent
		// can come in the form of data set CommissionAgentName, CommissionAgentTIN.
		CommissionInv = True;
		If NewED.EDDirection = Enums.EDDirections.Incoming AND Not AgentAdded Then
			CounterpartyAttributes = New Structure;
			CounterpartyAttributes.Insert("FullDescr", AgentName.AttributeValue);
			TINString = NewED.Rows.Find("TINCommissionAgent", "Attribute", True);
			CounterpartyAttributes.Insert("TIN", ?(ValueIsFilled(TINString), TINString.AttributeValue, ""));
			CounterpartyId = CounterpartyAttributes.TIN;
			CounterpartyKind = "Companies";
			AttributeName = "Company";
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, CounterpartyKind);
			Counterparty = ElectronicDocumentsOverridable.FindRefToObject(CounterpartyKind, CounterpartyId, CounterpartyAttributes);
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: " + CounterpartyId,
				Counterparty, CounterpartyAttributes, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, AttributeName, FoundString.RowIndex);
		EndIf;
	EndIf;
	
	Return CommissionInv;
	
EndFunction

// Receives the data of electronic document from the file, fills in
// the values tree for import to IB, creates/modifies necessary IB objects.
// 
// Parameters:
//  ParametersStructure - parameters structure for parsing of
// the electronic document, ParsingTree - values tree, data structure for import
//  to IB, EDDirection - direction of electronic document which requires parsing.
//
// Returns:
//  Structure of parameters with attributes of created/changed IB objects
//
Function GetDataFromFile(ParametersStructure, ParseTree, EDDirection = Undefined)
	
	If Not ParametersStructure.Property("DataFileRef") Then
		Return ParametersStructure;
	EndIf;
	
	If ParametersStructure.Property("EDOwner") Then
		RefToOwner = ParametersStructure.EDOwner;
	Else
		RefToOwner = Undefined;
	EndIf;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ElectronicDocuments");
	NewED = FoundTypeInTree.Rows.Add();
	
	If EDDirection = Undefined Then
		
		If ParametersStructure.Property("EDDirection") Then
			EDDirection = ParametersStructure.EDDirection;
		EndIf;
		
		If EDDirection = Undefined Then
			EDDirection = Enums.EDDirections.Incoming;
		EndIf;
		
	EndIf;
	
	NewED.EDDirection = EDDirection;
	
	AdditDataFileRef = "";
	AdditDataTree = Undefined;
	If ParametersStructure.Property("AdditDataFileRef", AdditDataFileRef) Then
		TempFile = GetTempFileName("xml");
		FileBinaryData = GetFromTempStorage(AdditDataFileRef);
		FileBinaryData.Write(TempFile);
		AdditDataTree = ParseUniversalAdditFile(TempFile);
		DeleteFiles(TempFile);
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
		ParametersStructure.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	RecordingError = False;
	TempFile = GetTempFileName("xml");
	FileBinaryData = GetFromTempStorage(ParametersStructure.DataFileRef);
	FileBinaryData.Write(TempFile);
	Result = ReadFileCMLbyXDTO(TempFile, ParseTree, NewED, True);
	DeleteFiles(TempFile);
	If Result Then
		// Fill in the references to the objects from the
		// matches tree if there are no references, then create objects
		FillRefsToObjectsInTree(ParseTree, RecordingError);
		
		If (NOT ValueIsFilled(RefToOwner)) Or ParametersStructure.Property("FillInDocument") Then
			
			Try
				RefToOwner = ElectronicDocumentsOverridable.SaveVBDObjectData(NewED, ParseTree,
				RefToOwner);
			Except
				MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
				MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
				BriefErrorDescription(ErrorInfo()));
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Document filling according to ED.';ru='Заполнение документа на основе ЭД.'"),
				DetailErrorDescription(ErrorInfo()),
				MessageText);
				RecordingError = True;
			EndTry;
			
			If Not ValueIsFilled(RefToOwner) Then
				MessageText = NStr("en='Failed to create the document
		|of data base (see details in Event log monitor).';ru='Не удалось создать
		|документ базы данных (подробности см. в Журнале регистрации).'");
				EDActualKinds = ElectronicDocumentsReUse.GetEDActualKinds();
				If EDActualKinds.Find(NewED.EDKind) = Undefined Then
					MessagePattern = NStr("en='Electronic document of the kind ""%1"" is not supported in the current configuration';ru='Электронный документ вида ""%1"" в текущей конфигурации не поддерживается'");
					EventLogMonitorText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, NewED.EDKind);
				Else
					EventLogMonitorText = NStr("en='It is required
		|to check the work of function ElectonicDocumentsOverridable.SaveObjectDataInDB';ru='Необходимо
		|проверить работу функции ЭлектронныеДокументыПереопределяемый.СохранитьДанныеОбъектаВБД'");
				EndIf;
				OperationKind = NStr("en='Document filling according to ED.';ru='Заполнение документа на основе ЭД.'");
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
										OperationKind, EventLogMonitorText, MessageText);
				RecordingError = True;
			EndIf;
			
		EndIf;
		// Fill up the structure of parameters from data file.
		ParametersStructure.Insert("EDOwner", RefToOwner);
		ParametersStructure.Insert("EDKind",      NewED.EDKind);
		EDNumber = NewED.ID;
		If Not ValueIsFilled(EDNumber) Then
			UID = New UUID;
			EDNumber = String(UID) + "##1";
		EndIf;
		ParametersStructure.Insert("EDNumber", EDNumber);
		EDVersionNumber = ReturnVersionNumberFromIdED(NewED.ID);
		Try
			EDVersionNumber = Number(EDVersionNumber);
		Except
		EndTry;
		ParametersStructure.Insert("EDVersionNumber",             EDVersionNumber);
		ParametersStructure.Insert("EDDirection",             NewED.EDDirection);
		SenderDocumentNumber = GetEDHeaderAttribute(NewED, "Number");
		ParametersStructure.Insert("SenderDocumentNumber", SenderDocumentNumber);
		CorrectionNumber = GetEDHeaderAttribute(NewED, "CorrectionNumber");
		If ValueIsFilled(CorrectionNumber) Then
			NumberTemplate = NStr("en='%1 (correct. %2)';ru='%1 (испр. %2)'");
			SenderDocumentNumber = StringFunctionsClientServer.SubstituteParametersInString(
										NumberTemplate, SenderDocumentNumber, CorrectionNumber);
			ParametersStructure.Insert("SenderDocumentNumber", SenderDocumentNumber);
		EndIf;
		ParametersStructure.Insert("SenderDocumentDate",  GetEDHeaderAttribute(NewED, "Date"));
		ParametersStructure.Insert("DocumentAmount",            GetEDHeaderAttribute(NewED, "DocumentAmount"));
		CompanyRecipient = GetEDHeaderAttribute(NewED, "Company", ParseTree);
		If ValueIsFilled(CompanyRecipient) Then
			ParametersStructure.Insert("Company", CompanyRecipient);
		Else
			
		EndIf;
		ParametersStructure.Insert("Counterparty", GetEDHeaderAttribute(NewED, "Counterparty", ParseTree));
		
	EndIf;
	ParametersStructure.Insert("Imported", Not RecordingError);
	
	Return ParametersStructure;
	
EndFunction

// Parse string structure of "TIN_KPP" kind
//
// Returns:
//  Structure of parameters with TIN
//
Function ParseCounterpartyID(Val RowID)
	
	SeparatorPosition1 = Find(RowID, "#");
	SearchStructure = New Structure;
	SeparatorPosition1 = Find(RowID, "_");
	If SeparatorPosition1 > 0 Then
		TIN = Left(RowID, SeparatorPosition1 - 1);
	ElsIf StrLen(RowID) > 0 Then
		TIN = TrimAll(RowID);
	EndIf;
	
	SearchStructure.Insert("TIN", TIN);
	
	Return SearchStructure;
	
EndFunction

// Function converts a string to date and time
//
// Parameters:
//  Vl - String - date in the format "YYYY-MM-DD HH:MM:SS"
//
// Returns:
//  Value of type "DateTime"
//
Function GetDateTimeFromString(Vl)
	
	Result = Undefined;
	Vl = StrReplace(Vl, "-", "");
	Vl = StrReplace(Vl, ":", "");
	If StrLen(Vl) - Find(Vl, " ") = 5 Then // time in the format H:MM:SS
		Vl = StrReplace(Vl, " ", "0");
	ElsIf Find(Vl, "T") > 0 Then //time in the format YYYYMMDDTHHMMSS
		Vl = StrReplace(Vl, "T", "");
	Else // time in the format HH:MM:SS
		Vl = StrReplace(Vl, " ", "");
	EndIf;
	
	Try
		Result = Date(Vl); // date and time in the format "YYYYMMDDHHMMSS"
	Except
		Try
			Result = Date(Left(Vl, 8)); // only date "YYYYMMDD"
		Except
		EndTry;
	EndTry;
	
	Return Result;
	
EndFunction

Function ReadFileCMLbyXDTO(FileName, ParseTree, NewED, ShowErrors = False)
	
	XMLObject = New XMLReader;
	Error = False;
	UnknownED = False;
	
	Try
		XMLObject.OpenFile(FileName);
		If XMLObject.Read() Then
			RootItemName = Upper(XMLObject.Name);
		EndIf;
		
		ED = XDTOFactory.ReadXML(XMLObject);
		
		IsPropertyIdFile = ED.Properties().Get("IdFile") <> Undefined;
		CMLNamespace = ElectronicDocumentsReUse.CMLNamespace();
		AsynchExchangeNamespace = ElectronicDocumentsService.AsynchronousExchangeWithBanksNamespace();

		If Upper(ED.Type().Name) = Upper("anyType") Then // type of item is not indicated in an explicit form
			If IsPropertyIdFile Then //reading files without namespace by
				// FTS formats Handle the case when a third party XML file arrives.
				If Not ValueIsFilled(XMLObject.NamespaceURI) Then
					
					// Insert 1C namespace into ED temporary file.
					Add1CNameSpaceToExternalEDFile(XMLObject, ED, FileName);
				EndIf;
				
				If Find(ED.IdFile, "OTORG12") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OTORG12"));
					ReadTORG12XDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "PTORG12") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "PTORG12"));
					ReadTORG12CustomerXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "IAKTPRM") > 0 Then
					If CertificateInNewFormat(FileName) Then
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM2"));
					Else
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "IAKTPRM"));
					EndIf;
					ReadAct501XDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "ZAKTPRM") > 0 Then
					If CertificateInNewFormat(FileName) Then
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "ZAKTPRM2"));
					Else
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "ZAKTPRM"));
					EndIf;
					ReadAct501ConsumerXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "OKORDOC") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "OKORDOC"));
					ReadCorrectingDocumentXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "PKORDOC") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "PKORDOC"));
					ReadCorrectingDocumentRecipientXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "DP_IZVPOL") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "DP_IZVPOL"));
					ReadNotificationXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "DP_UVUTOCH") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "DP_UVUTOCH"));
					ReadRefinementXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "DP_PRANNUL") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "DP_PRANNUL"));
					ReadCancellationOfferXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "POD_DPIZVPOL") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "DP_IZVPOL"));
					ReadConfirmationXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "DP_PDOTPR") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject,GetCMLValueType("File", "DP_PDOTPR"));
					ReadSendingDataConfirmationXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "DP_PDPOL") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "DP_PDPOL"));
					ReadReceivingDataConfirmationXDTO(ED, ParseTree, NewED, Error);
				ElsIf Find(ED.IdFile, "POD") > 0 Then
					ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("File", "PDO"));
					ReadConfirmationXDTO(ED, ParseTree, NewED, Error);
				Else
					UnknownED = True;
				EndIf;
			Else // Non-FTS formats
				XMLObject.OpenFile(FileName);
				If ED.Properties().Get("SectionBankAcc") <> Undefined Then
					ClientBankExchange = GetCMLValueType("ClientBankExchange", "urn:1C.ru:ClientBankExchange");
					ED = XDTOFactory.ReadXML(XMLObject, ClientBankExchange);
					ReadStatementXDTO(ED, ParseTree, NewED, Error);
				Else // read the file by type the name of which matches the type of XDTO object
					If RootItemName = Upper("PayDocRu") Then // tranfer order in rubles
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("PayDocRu", AsynchExchangeNamespace));
						ReadTransferOrderAsyncXDTO(ED, ParseTree, NewED, Error);
					ElsIf RootItemName = Upper("Statement") Then // Extract
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("Statement", AsynchExchangeNamespace));
						ReadStatementAsyncXDTO(ED, ParseTree, NewED, Error);
					ElsIf RootItemName = Upper("StatementRequest") Then // query on statement
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("StatementRequest", AsynchExchangeNamespace));
						ReadStatementQueryAsyncXDTO(ED, ParseTree, NewED, Error);
					ElsIf RootItemName = Upper("StatusDocNotice") Then // notification of ED state
						StatusDocNotice = GetCMLValueType("StatusDocNotice", AsynchExchangeNamespace);
						ED = XDTOFactory.ReadXML(XMLObject, StatusDocNotice);
						ReadNotificationOnStateAsyncXDTO(ED, ParseTree, NewED, Error);
					ElsIf RootItemName = Upper("StatusRequest") Then // query on ED state
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("StatusRequest", AsynchExchangeNamespace));
						ReadQueryOnStateAsyncXDTO(ED, ParseTree, NewED, Error);
					ElsIf RootItemName = Upper("Probe") Then // query - probe
						ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("Probe", AsynchExchangeNamespace));
						ReadQueryProbeAsyncXDTO(ED, ParseTree, NewED, Error);
					Else
						UnknownED = True;
					EndIf;
				EndIf;
			EndIf;
		Else // type is indicated in explicit form
			If ED.Type() = GetCMLValueType("Directory", "4.02") Then
				DeleteReadDirectoryXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("PriceList", "4.02") Then
				DeleteReadPriceXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("ActAboutAcceptance", "4.02") Then
				ReadActAboutReceivingXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("TORG12", "4.02") Then
				ReadInvoiceXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("InvoiceForPayment", "4.02") Then
				DeleteReadInvoiceForPaymentXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("ComissionGoodsWriteOffReport", "4.02") Then
				DeleteReadComissionGoodsWriteOffReportXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("ComissionGoodsSalesReport", "4.02") Then
				DeleteReadReportOnComissionGoodsSalesXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("CustomerOrder", "4.02") Then
				DeleteReadOrderXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("ClientBankExchange","urn:1C.ru:ClientBankExchange") Then
				If ED.PaymentDocumentSection.Count()=1 AND ED.SectionBankAcc=Undefined Then
					ReadPaymentOrderXDTO(ED, ParseTree, NewED, Error);
				ElsIf NewED.EDDirection = Enums.EDDirections.Incoming Then
					ReadStatementXDTO(ED, ParseTree, NewED, Error);
				Else
					ReadStatementRequestXDTO(ED, ParseTree, NewED, Error);
				EndIf;
			ElsIf ED.Type() = GetCMLValueType("StatementType","http://www.bssys.com/en/") Then
				ReadExtractSberbankXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("PayDocRu","http://www.bssys.com/en/") Then
				ReadPaymentOrderSberbankXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("StmtReqType","http://www.bssys.com/en/") Then
				ReadQueryStatementSberbankXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("Ticket","http://www.bssys.com/en/") Then
				ReadReceiptSberbankXDTO(ED, ParseTree, NewED, Error);
			ElsIf ED.Type() = GetCMLValueType("BusinessInformation",CMLNamespace) Then
				If ED.Document <> Undefined AND ED.Document.Count() > 0 Then
					EDocument = ED.Document[0];
					If Upper(EDocument.BusinessTransaction) = Upper("Report on the commission goods sales") Then
						
						ReadReportAboutComissionGoodsSalesXDTO(EDocument, ParseTree, NewED, Error);
						
					ElsIf Upper(EDocument.BusinessTransaction) = Upper("Report on the commission goods depreciation") Then
						
						ReadComissionGoodsWriteOffReportXDTO(EDocument, ParseTree, NewED, Error);
		
					ElsIf Upper(EDocument.BusinessTransaction) = Upper("Invoice for payment") Then
						
						ReadInvoiceForPaymentXDTO(EDocument, ParseTree, NewED, Error);
	
					ElsIf Upper(EDocument.BusinessTransaction) = Upper("Product order") Then
						
						ReadOrderXDTO(EDocument, ParseTree, NewED, Error);
						
					ElsIf Upper(EDocument.BusinessTransaction) = Upper("Transfer of rights") Then
						
						ReadRightsDelegationActXDTO(ED, ParseTree, NewED, Error);
						
					EndIf;
					
				ElsIf Not ED.OffersPackage = Undefined Then
					
					ReadPriceXDTO(ED.OffersPackage, ParseTree, NewED, Error);
					
				ElsIf ED.Properties().Get("Directory") <> Undefined AND ED.Get("Directory") <> Undefined Then
					ReadDirectoryXDTO(ED, ParseTree, NewED, Error);
					
				Else
					UnknownED = True;
				EndIf;
				
			ElsIf ED.Type() = GetCMLValueType("Counterparty",CMLNamespace) Then
				ReadCompanyDetailsXDTO(ED, ParseTree, NewED, Error)
			Else
				UnknownED = True;
			EndIf;
		EndIf;
		If UnknownED Then
			If Users.InfobaseUserWithFullAccess( , , False) Then
				MessageText = StringFunctionsClientServer.SubstituteParametersInString(
					NStr("en='Unknown ED type when reading the data out of the file %1!';ru='Неизвестный тип ЭД при чтении данных из файла %1!'"), FileName);
				CommonUseClientServer.MessageToUser(MessageText);
			EndIf;
			Error = True;
		Else
			Rows = ParseTree.Rows.FindRows(New Structure("Attribute", "VATRate"), True);
			For Each TreeRow IN Rows Do
				VATRate = ElectronicDocumentsReUse.VATRateFromDisplay(TreeRow.AttributeValue);
				If ValueIsFilled(VATRate) Then
					TreeRow.AttributeValue = VATRate;
				EndIf;
			EndDo;
		EndIf;
	Except
		Error = True;
		MessageText = Undefined;
		If Users.InfobaseUserWithFullAccess( , , False) OR ShowErrors Then
			MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
				FileName, BriefErrorDescription(ErrorInfo()));
		EndIf;
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
			NStr("en='ED reading';ru='Чтение ЭД.'"), DetailErrorDescription(ErrorInfo()), MessageText, 5);
	EndTry;
	XMLObject.Close();
	
	Return Not Error;
	
EndFunction

Function CompositeAddress(Parameters)
	
	ReturVal = "";
	For Each Property IN Parameters.Properties() Do
		ExtParameter = "";
		If Not ValueIsFilled(Parameters[Property.Name]) Then
			Continue;
		EndIf;
		If Property.Name = "IndexOf" Then
			ExtParameter = Parameters[Property.Name];
		ElsIf Property.Name = "CodeState" Then
			ExtParameter = ElectronicDocumentsOverridable.StateName(Parameters.CodeState);
		Else
			ExtParameter = "";
			If Property.Name = "Building" Then
				ExtParameter = "building No ";
			ElsIf Property.Name = "Section" Then
				ExtParameter = "building ";
			ElsIf Property.Name = "Qart" Then
				ExtParameter = "apartment ";
			EndIf;
			ExtParameter = ExtParameter + Parameters[Property.Name];
		EndIf;
		If ValueIsFilled(ExtParameter) Then
			ReturVal = ?(ValueIsFilled(ReturVal), ReturVal + ", ", "") + ExtParameter;
		EndIf;
	EndDo;
	
	Return ReturVal;
	
EndFunction

Function InitializeParseTree()
	
	ParseTree = New ValueTree;
	ParseTree.Columns.Add("ObjectType");
	ParseTree.Columns.Add("ObjectReference");
	ParseTree.Columns.Add("DescriptionOfType");
	ParseTree.Columns.Add("RowIndex");
	ParseTree.Columns.Add("Attribute");
	ParseTree.Columns.Add("AttributeValue");
	ParseTree.Columns.Add("ObjectDescription");
	ParseTree.Columns.Add("EDKind");
	ParseTree.Columns.Add("ID");
	ParseTree.Columns.Add("EDDirection");
	ParseTree.Columns.Add("AddData");
	
	Return ParseTree;
	
EndFunction

Function DateFromString(String)
	
	Return Date(Mid(String, 7, 4) + Mid(String, 4, 2) + Mid(String, 1, 2) + "000000");
	
EndFunction

Procedure ReadCounterpartyData(Item, ED, ParseTree, NewED, Error, Role = "")
	
	CounterpartyKind  = "";
	AdditAnalyticsKind = "";
	If (ValueIsFilled(NewED.EDDirection) AND NewED.EDDirection = Enums.EDDirections.Intercompany) Then
		CounterpartyKind = "Companies";
		If Role = "Seller" OR Role = "Performer" Then
			AttributeName = "Company";
			BankAccountKind = "BankAccountsOfTheCompany";
		ElsIf Role = "Customer" OR Role = "Customer" Then
			AttributeName = "Counterparty";
			BankAccountKind = "BankAccountsOfCounterparties";
		ElsIf Role = "Consignor" OR Role = "Consignee" Then
			AttributeName = Role;
			BankAccountKind = "BankAccountsOfCounterparties";
		EndIf;
	ElsIf Role = "Agent" Then
		If (ValueIsFilled(NewED.EDDirection) AND NewED.EDDirection = Enums.EDDirections.Incoming) Then
			CounterpartyKind = "Companies";
			AttributeName = "Company";
			BankAccountKind = "BankAccountsOfTheCompany";
		Else
			CounterpartyKind = "Counterparties";
			AttributeName = "Agent";
			AdditAnalyticsKind = "partners";
			AdditAnalytics = "Partner";
			BankAccountKind = "BankAccountsOfCounterparties";
		EndIf;
	ElsIf Role = "Seller" OR Role = "Performer" Then
		CounterpartyKind = "Companies";
		AttributeName = "Company";
		BankAccountKind = "BankAccountsOfTheCompany";
	ElsIf Role = "Customer" OR Role = "Customer" Then
		CounterpartyKind = "Counterparties";
		AttributeName = "Counterparty";
		AdditAnalyticsKind = "partners";
		AdditAnalytics = "Partner";
		BankAccountKind = "BankAccountsOfCounterparties";
	ElsIf Role = "Consignor" OR Role = "Consignee" Then
		CounterpartyKind = "Counterparties";
		AttributeName = Role;
		AdditAnalyticsKind = "partners";
		AdditAnalytics = "Partner";
		BankAccountKind = "BankAccountsOfCounterparties";
	ElsIf Role = "CommissionCustomer" Then
		CounterpartyKind = "Counterparties";
		AttributeName = "Customer";
		AdditAnalyticsKind = "partners";
		AdditAnalytics = "Partner";
		BankAccountKind = "CustomerBankAccounts";
	EndIf;
	
	// Counterparty
	CounterpartyAttributes = New Structure;
	If TypeOf(Item) = Type("Structure") Then
		CounterpartyAttributes = Item;
	ElsIf Item.Type().NamespaceURI = "OTORG12"
		OR Item.Type().NamespaceURI = "IAKTPRM"
		OR Item.Type().NamespaceURI = "IAKTPRM2"
		OR Item.Type().NamespaceURI = "OKORDOC"
		OR Item.Type().NamespaceURI = "SFAKT"
		OR Item.Type().NamespaceURI = "KORSFAKT" Then
		CounterpartyId = "";
		If Item.IdPr <> Undefined Then
			If Item.IdPr.PrLP <> Undefined AND Not Item.IdPr.PrLP.DescEnt = "---" Then
				CounterpartyAttributes.Insert("FullDescr", Item.IdPr.PrLP.DescEnt);
				CounterpartyAttributes.Insert("TIN", Item.IdPr.PrLP.TINLP);
				If Item.IdPr.PrLP.Properties().Get("RCOLF") <> Undefined Then
					CounterpartyAttributes.Insert("RCOLF", Item.IdPr.PrLP.RCOLF);
				EndIf;
				If ValueIsFilled(Item.IdPr.PrLP.TINLP) Then
					CounterpartyId = Item.IdPr.PrLP.TINLP;
				EndIf;
				CounterpartyAttributes.Insert("LegalEntityIndividual", ElectronicDocumentsReUse.FindEnumeration("LegalEntityIndividual", "LegalEntity"));
			ElsIf Item.IdPr.PrPP <> Undefined Then
				CounterpartyAttributes.Insert("FullDescr",
					Item.IdPr.PrPP.NameAndSurnameIP.Surname +" "+ Item.IdPr.PrPP.NameAndSurnameIP.Name
					+ " " + Item.IdPr.PrPP.NameAndSurnameIP.Patronymic);
				CounterpartyAttributes.Insert("TIN", Item.IdPr.PrPP.TINInd);
				CounterpartyId = Item.IdPr.PrPP.TINInd;
				CounterpartyAttributes.Insert("LegalEntityIndividual", ElectronicDocumentsReUse.FindEnumeration("LegalEntityIndividual", "Ind"));
			EndIf;
		EndIf;
		If Item.Properties().Get("OKPO") <> Undefined Then
			CounterpartyAttributes.Insert("OKPO", Item.OKPO);
		EndIf;
		ItemAddress = Item.Address;
		If ItemAddress <> Undefined Then
			AddressPrefix = ?(Role = "Consignor" OR Role = "Consignee", "Fact", "Legal");
			If ItemAddress.AdrRF <> Undefined Then
				CounterpartyAttributes.Insert(AddressPrefix + "Address_Presentation", CompositeAddress(ItemAddress.AdrRF));
			ElsIf ItemAddress.AddrFRN <> Undefined Then
				CounterpartyAttributes.Insert(AddressPrefix + "Address_Presentation", ItemAddress.AddrFRN.AdrText);
				CounterpartyAttributes.Insert("CountryCode", ItemAddress.AddrFRN.StrCode);
			ElsIf ValueIsFilled(ItemAddress.AdrText) Then
				CounterpartyAttributes.Insert(AddressPrefix + "Address_Presentation", ItemAddress.AdrText);
			EndIf;
		EndIf;
		If Item.Properties().Get("Contact") <> Undefined Then
			ItemContacts = Item.Contact;
			If ItemContacts <> Undefined Then
				If ItemContacts.Phone <> Undefined Then
					CounterpartyAttributes.Insert("PhoneNumbers", ItemContacts.Phone);
				EndIf;
				If ItemContacts.Fax <> Undefined Then
					CounterpartyAttributes.Insert("Fax", ItemContacts.Fax);
				EndIf;
			EndIf;
		EndIf;
	Else
		For Each CurProperty IN Item.Properties() Do
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			If Upper(CurProperty.Name) = Upper("ID") Then
				CounterpartyId = DataVal;
			ElsIf Upper(CurProperty.Name) = Upper("Role") Then
				If Upper(DataVal) = Upper("Seller") Then
					If NewED.EDKind=Enums.EDKinds.ProductOrder Then
						CounterpartyKind = "Companies";
						AttributeName = "Company";
						BankAccountKind = "BankAccountsOfTheCompany";
					Else
						CounterpartyKind = "Counterparties";
						AttributeName = "Counterparty";
						// additional analytics on Partner
						AdditAnalyticsKind = "partners";
						AdditAnalytics = "Partner";
						BankAccountKind = "BankAccountsOfCounterparties";
					EndIf;
				ElsIf Upper(DataVal) = Upper("Customer") Then
					If NewED.EDKind = Enums.EDKinds.ProductOrder Then
						CounterpartyKind = "Counterparties";
						AttributeName = "Counterparty";
						BankAccountKind = "BankAccountsOfCounterparties";
						// additional analytics on Partner
						AdditAnalyticsKind = "partners";
						AdditAnalytics = "Partner";
					Else
						CounterpartyKind = "Companies";
						AttributeName = "Company";
						BankAccountKind = "BankAccountsOfTheCompany";
					EndIf;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("LegalEntity") OR Upper(CurProperty.Name) = Upper("Ind") Then
				ParticipantAttributes = DataVal;
				For Each ParticipantProperty IN ParticipantAttributes.Properties() Do
					ParticipantAttribute = ParticipantAttributes[ParticipantProperty.Name];
					If ParticipantAttribute <> Undefined Then
						If Upper(ParticipantProperty.Name) = Upper("LegalAddress")
							OR Upper(ParticipantProperty.Name) = Upper("RegistrationAddress") Then
							CounterpartyAttributes.Insert(ParticipantProperty.Name+"_Presentation", ParticipantAttribute.Presentation);
						ElsIf Upper(ParticipantProperty.Name) = Upper("OfficialName")
							OR Upper(ParticipantProperty.Name) = Upper("FullDescr") Then
							CounterpartyAttributes.Insert("FullDescr", ParticipantAttribute);
						Else // the rest by names
							CounterpartyAttributes.Insert(ParticipantProperty.Name, ParticipantAttribute);
						EndIf;
					EndIf;
				EndDo;
			ElsIf Upper(CurProperty) = Upper("Address") Then
				CounterpartyAttributes.Insert("ActualAddress_Presentation", DataVal.Presentation);
			ElsIf Upper(CurProperty) = Upper("Contacts") Then
				ContactsTable = New ValueTable();
				ContactsTable.Columns.Add("Kind");
				ContactsTable.Columns.Add("Presentation");
				ContactsTable.Columns.Add("FieldsValues");
				For Each Contact in DataVal.Contact Do
					Kind = Undefined;
					If Contact.Type = "Mail" Then
						Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyEmail");
					ElsIf Contact.Type = "Work phone" Then
						Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyPhone");
					ElsIf Contact.Type = "Fax" Then
						Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyFax");
					EndIf;
					If ValueIsFilled(Kind) Then // add only if there are kinds of contact information in the receiving configuration
						NewCont = ContactsTable.Add();
						NewCont.Type = Kind;
						NewCont.Presentation = Contact.Value;
						NewCont.FieldsValues = Contact.Comment;
					EndIf;
				EndDo;
				CounterpartyAttributes.Insert(CurProperty.Name, ContactsTable);
			Else // the rest by names
				CounterpartyAttributes.Insert(CurProperty.Name, DataVal);
			EndIf;
		EndDo;
	EndIf;
	// fill in values depending on the kind
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, CounterpartyKind);
	Counterparty = ElectronicDocumentsOverridable.FindRefToObject(CounterpartyKind, CounterpartyId, CounterpartyAttributes);
			
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: "+CounterpartyId,
		Counterparty, CounterpartyAttributes, ParseTree, Error);
	AddObjectHeaderAttribute(NewED, AttributeName, FoundString.RowIndex);
	
	// Define current account of the counterparty
	If Not TypeOf(Item) = Type("Structure") Then
		If Item.Properties().Get("BankAccounts") <> Undefined Then
			BankAccounts = Item.BankAccounts;
			If BankAccounts <> Undefined Then
				XDTOBankAccounts = BankAccounts.GetList("BankAccount");
				For Each XDTOBankAccount IN XDTOBankAccounts Do
					ReadDataByBankAccount(NewED, XDTOBankAccount, ParseTree, BankAccountKind, Role, Counterparty, Error);
					Break;
				EndDo;
			EndIf;
		ElsIf Item.Properties().Get("BankAttr") <> Undefined AND Item.BankAttr <> Undefined Then
			ReadDataByBankAccountTorg12(NewED, Item.BankAttr, ParseTree, BankAccountKind, Role, Counterparty, Error);
		EndIf;
	EndIf;
	
	If ED.Properties().Get("RecipientAttributes") <> Undefined Then
		EDProperty = ED.Properties().Get("RecipientAttributes");
		RecipientAttributes = ED.Get(EDProperty);
		ReadDataByBankAccount(NewED, RecipientAttributes, ParseTree, BankAccountKind, Role, Counterparty, Error);
	EndIf;
	
	// Add additional analytics if filled in
	If ValueIsFilled(AdditAnalyticsKind) Then
		If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
			AttributesOfPartner = New Structure();
			AttributesOfPartner.Insert("Counterparty", Counterparty);
			AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("partners");
			
			ValAdditAnalytics = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, , AttributesOfPartner);
			If ValueIsFilled(ValAdditAnalytics) Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "partners");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ValAdditAnalytics.Code, "Code: "
					+ ValAdditAnalytics.Code, ValAdditAnalytics, AttributesOfPartner, ParseTree, Error);
				AddObjectHeaderAttribute(NewED, "Partner", FoundString.RowIndex);
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

Procedure ReadDataByTSAcceptanceCertificate(DataSet, ED, ParseTree, NewED, Error)
	
	// Define ED variant for selection of an algorithm to fill in products and services.
	AuthorEDCustomer = False;
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) AND Not Upper(CurProperty.Name) = Upper("Taxes") Then
					Continue;
				EndIf;
				// Parse Product properties
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code", String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code),
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
							
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
						
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code", String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code),
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ListTS.Add(FoundString.RowIndex, "Package");
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("AmountsByProduct") Then
					
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Tax") Then
								Taxes = DataVal.GetList(CurProp);
								For Each Tax IN Taxes Do
									If Upper(Tax.TaxType) = "VAT" Then
										ListTS.Add(Tax.TaxRateAmount, "VATRate");
										ListTS.Add(Tax.Amount, "VATAmount");
									EndIf;
								EndDo;
							EndIf;
							If Upper(CurProp.Name) = Upper("AmountWithoutTax") Then
								ListTS.Add(DataVal.AmountWithoutTax, "Amount");
							EndIf;
							If Upper(CurProp.Name) = Upper("AmountTotal") Then
								ListTS.Add(DataVal.AmountTotal, "SumWithVAT");
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Discounts") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Discount") Then
								Discounts = DataVal.GetList(CurProp);
								For Each Discount IN Discounts Do
									If Upper(Discount.Description) = "TotalDiscount" Then
										ListTS.Add(Discount.Amount, "DiscountAmount");
									EndIf;
								EndDo;
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Definition") Then
					ListTS.Add(DataVal, "Content");
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages in which the goods were shipped.
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of coefficient if there is UOM property, get the value.
					Coeff = "";
					If Item.MeasurementUnit <> Undefined Then
						Coeff = Item.MeasurementUnit.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem in DataVal Do
						ValueArray = New Array;
						For Each ValueItem in DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description,ValueArray);
					EndDo;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
				
			EndDo;
			
			// Identification by products and services of the company when the parsing side ED - subsidiary company itself.
			If IdentificationByCounterpartyProductsAndServices Then 
				IdStructure = ParseProductID(ProductId);
				ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
				If ValueIsFilled(IdStructure.CharacteristicID) Then
					ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
					ListTS.Add(ProductsAndServicesCharacteristic,"Characteristic");
				EndIf;
				If ValueIsFilled(IdStructure.IDPackage) Then
					ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
					ListTS.Add(ProductsAndServicesPackaging,"Package");
				EndIf;
				
			Else
				// Suppliers products and services.
				SupplierProductsAndServicesAttributes = New Structure;
				OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
				ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
				SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
				SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
				If ProductsAndServicesAttributes.Property("SKU") Then
					SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
				EndIf;
				If ValueIsFilled(ProductDesc) Then
					SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
				EndIf;
				If AreAdditAttributes Then
					SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
				EndIf;
				SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
					SupplierProductsAndServicesAttributes, ED.ID);
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
					SupplierProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
				
				If ValueIsFilled(SupplierProductsAndServices) Then
					ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
				EndIf;
				
				ProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("ProductsAndServices", "",
					SupplierProductsAndServicesAttributes, ED.ID);
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex,"ProductsAndServices");
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
			
		EndDo;
	EndIf;
	
EndProcedure

Procedure ParseStringTSCML(Item, ListTS, ED, ParseTree, NewED, Error, LineNumber = Undefined)
	
	IDED = ?(ED.Properties().Get("ID") = Undefined, "", ED.ID);
	
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
		OR NewED.EDDirection = Enums.EDDirections.Intercompany);
	
	ProductDesc = "";
	ProductId = "";
	AreAdditAttributes = False;
	
	// ProductsAndServices.
	ProductsAndServicesAttributes = New Structure;
	For Each CurProperty IN Item.Properties() Do
		DataVal = Item[CurProperty.Name];
		If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
		ElsIf Not ValueIsFilled(DataVal) Then
			Continue;
		EndIf;
		
		// Parse Product properties.
		If Upper(CurProperty.Name) = Upper("ID") Then
			ProductsAndServicesAttributes.Insert("ID", DataVal);
			ProductId = ProductsAndServicesAttributes.ID;
		ElsIf Upper(CurProperty.Name) = Upper("Description") Then
			ProductsAndServicesAttributes.Insert("Description", DataVal);
			ProductDesc = ProductsAndServicesAttributes.Description;
		ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
			ProductsAndServicesAttributes.Insert("SKU", DataVal);
		ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
			If TypeOf(DataVal) = Type("XDTODataObject") Then
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code", DataVal.Code);
				DescUnOfMeas = "";
				If DataVal.Properties().Get("Description") <> Undefined Then
					UnOfMeasAttributes.Insert("Description", DataVal.Description);
					DescUnOfMeas = DataVal.Description;
				EndIf;
				If DataVal.Properties().Get("ShortDescription") <> Undefined Then
					UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
					DescUnOfMeas = DataVal.ShortDescription;
				EndIf;
				If DataVal.Properties().Get("DescriptionFull") <> Undefined Then
					UnOfMeasAttributes.Insert("DescriptionFull", DataVal.DescriptionFull);
				EndIf;
				If DataVal.Properties().Get("InternationalAbbreviation") <> Undefined Then
					UnOfMeasAttributes.Insert("InternationalAbbreviation", DataVal.InternationalAbbreviation);
				EndIf;
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DescUnOfMeas,
					UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
				If ValueIsFilled(FoundString) Then
					ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
				EndIf;
			EndIf;
		ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
			If TypeOf(DataVal) = Type("XDTODataObject") Then
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code", String(DataVal.Code));
				If Not DataVal.Properties().Get("Description") = Undefined Then
					UnOfMeasAttributes.Insert("Description", DataVal.Description);
				EndIf;
				If Not DataVal.Properties().Get("Factor") = Undefined Then
					UnOfMeasAttributes.Insert("Factor", DataVal.Factor);
				EndIf;
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code), UnOfMeasAttributes);
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString     = FindCreateStringInParsedTree( FoundTypeInTree, String(DataVal.Code),
					DataVal.Description, UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
				If ValueIsFilled(FoundString) Then
					ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
				EndIf;
			EndIf;
		ElsIf Upper(CurProperty.Name) = Upper("Tax") Then
			If TypeOf(DataVal) = Type("XDTODataObject") Then
				If Upper(DataVal.TaxType) = "VAT" Then
					ListTS.Add(DataVal.TaxRateAmount, "VATRate");
					ListTS.Add(DataVal.Amount, "VATAmount");
				EndIf;
			EndIf;
		ElsIf Upper(CurProperty.Name) = Upper("AmountWithoutVAT") Then
			ListTS.Add(DataVal, "Amount");
		ElsIf Upper(CurProperty.Name) = Upper("AmountWithVAT") Then
			ListTS.Add(DataVal, "SumWithVAT");
		ElsIf Upper(CurProperty.Name) = Upper("DateByCustomerData") OR Upper(CurProperty.Name) = Upper("UsefulTime") Then
			ListTS.Add(GetDateTimeFromString(DataVal), CurProperty.Name);
		ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
			AreAdditAttributes = True;
			AdditAttributesStructure = New Structure;
			For Each DataItem in DataVal Do
				ValueArray = New Array;
				For Each ValueItem in DataItem.Value Do
					ValueArray.Add(ValueItem)
				EndDo;
				AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
			EndDo;
			
		// Scheme 2:
		ElsIf Upper(CurProperty.Name) = Upper("Unit") Then
			UnOfMeasAttributes = New Structure;
			If ValueIsFilled(DataVal) Then
				UnOfMeasAttributes.Insert("Code", DataVal);
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal), UnOfMeasAttributes);
				DescriptionUNITS = ?(ValueIsFilled(UnOfMeas), UnOfMeas.Description, Undefined);
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString     = FindCreateStringInParsedTree( FoundTypeInTree, String(DataVal), DescriptionUNITS,
					UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
				If ValueIsFilled(FoundString) Then
					ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
				EndIf;
			EndIf;
		ElsIf Upper(CurProperty.Name) = Upper("Taxes") Then
			If TypeOf(DataVal.Tax) = Type("XDTOList") Then
				StructuresArray = New Array;
				For Each Tax IN DataVal.Tax Do
					TaxStructure = New Structure;
					For Each TaxProperties IN Tax.Properties() Do
						TaxValue = Tax.Get(TaxProperties);
						If Not ValueIsFilled(TaxValue) Then
							Continue;
						EndIf;
						TaxStructure.Insert(TaxProperties.Name, TaxValue);
					EndDo;
					StructuresArray.Add(TaxStructure);
				EndDo;
				If StructuresArray.Count() > 0 Then
					TaxStructure = StructuresArray[0];
					VATRate = "";
					VATIncludedInAmount = "";
					VATAmount = 0;
					If Not TaxStructure.Property("Rate", VATRate) Then
						VATRate = "Without VAT";
					EndIf;
					If Not TaxStructure.Property("IncludedInAmount", VATIncludedInAmount) Then
						VATIncludedInAmount = False;
					EndIf;
					If Not TaxStructure.Property("Amount", VATAmount) Then
						VATAmount = 0;
					EndIf;
					ListTS.Add(VATRate, "VATRate");
					ListTS.Add(VATAmount, "VATAmount");
					ListTS.Add(VATIncludedInAmount, "VATIncludedInAmount");
				EndIf;
				If StructuresArray.Count() > 1 Then
					ListTS.Add(StructuresArray, "Taxes");
				EndIf;
			EndIf;
			
		ElsIf Upper(CurProperty.Name) = Upper("Discounts")
			OR Upper(CurProperty.Name) = Upper("AdditExpenses") Then
			
			StructuresArray = New Array;
			For Each ListIt IN DataVal[CurProperty.Name] Do
				DataStructure = New Structure;
				For Each PropertyAddList IN ListIt.Properties() Do
					ValueOfAdditionalList = Tax.Get(PropertyAddList);
					If Not ValueIsFilled(ValueOfAdditionalList) Then
						Continue;
					EndIf;
					TaxStructure.Insert(PropertyAddList.Name, ValueOfAdditionalList);
				EndDo;
				StructuresArray.Add(DataStructure);
			EndDo;
			ListTS.Add(StructuresArray, CurProperty.Name);
			
		ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributeValues")
			OR Upper(CurProperty.Name) = Upper("AttributeValues") Then
			
			AdditionalAttributes = New Structure;
			Company = TreeAttributeRef(ParseTree, NewED, "Company");
			If ValueIsFilled(Company) Then
				AdditionalAttributes.Insert("Company", Company);
			EndIf;
			
			ReadValueListDetailsCML(DataVal.AttributeValue, ListTS, Error, AdditionalAttributes);
			
		ElsIf Upper(CurProperty.Name) = Upper("Amount") Then
			ListTS.Add(DataVal, "Amount");
			
		ElsIf Upper(CurProperty.Name) = Upper("PriceForUnit") Then
			ListTS.Add(DataVal, "Price");
			
		Else
			ListTS.Add(DataVal, CurProperty.Name);
			
		EndIf;
	EndDo;
	
	// Identification by products and services of the company when the parsing side ED - subsidiary company itself
	If IdentificationByCounterpartyProductsAndServices Then
		IdStructure = ParseProductID(ProductId);
		ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
		If ValueIsFilled(IdStructure.CharacteristicID) Then
			ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
			ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(IdStructure.IDPackage) Then
			ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
			ListTS.Add(ProductsAndServicesPackaging, "Package");
		EndIf;
	Else
		// Suppliers products and services.
		SupplierProductsAndServicesAttributes = New Structure;
		OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
		ProductsAndServicesOwner  = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
		
		SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
		SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
		If ProductsAndServicesAttributes.Property("SKU") Then
			SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
		EndIf;
		
		If ValueIsFilled(ProductDesc) Then
			SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
		EndIf;
		
		If AreAdditAttributes Then
			SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
		EndIf;
		
		SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
			SupplierProductsAndServicesAttributes, IDED);
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
			SupplierProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
		
		If ValueIsFilled(SupplierProductsAndServices) Then
			ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
			SupplierProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
		EndIf;
		ProductAttributesStructure = GenerateProductStructure();
		ElectronicDocumentsOverridable.GetProductAttributes(SupplierProductsAndServicesAttributes, ProductAttributesStructure, IDED);
		
		ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
		If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
			ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(ProductAttributesStructure.Package) Then
			ListTS.Add(ProductAttributesStructure.Package, "Package");
		EndIf;
	EndIf;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
		ProductsAndServicesAttributes, ParseTree, Error);
	ListTS.Add(FoundString.RowIndex,"ProductsAndServices");
	
	Company = TreeAttributeRef(ParseTree, NewED, "Company");
	AdditParameters = New Structure;
	AdditParameters.Insert("Company", Company);
	
	LineNumber = LineNumber + 1;
	ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);
	
	AddObjectTSAttributes(NewED, "TSRow", ListTS);
	
EndProcedure

Procedure ReadDataByTSInvoice(DataSet, ED, ParseTree, NewED, Error)
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ParseStringTSCML(Item, ListTS, ED, ParseTree, NewED, Error);
		EndDo;
	EndIf;
	
EndProcedure

Function PaymentKindValue(DataVal, EDRole)
	
	ReturnValue = "";
	
	If DataVal = "Advance" Then
		If EDRole = "Seller" Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
			"Advance (before provision)");
		ElsIf EDRole = "Customer"  Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
			"Advance payment (before confirmation)");
		EndIf;
	ElsIf DataVal = "Prepayment" Then
		If EDRole = "Seller" Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
			"Advanced payment (before shipment)");
		ElsIf EDRole = "Customer" Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
			"Preliminary payment (before receipt)");
		EndIf;
	ElsIf DataVal = "Credit" Then
		If EDRole = "Seller" Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
			"Credit (upon shipment)");
		ElsIf EDRole = "Customer" Then 
			ReturnValue = ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
			"Credit (after receipt)");
		EndIf;
	Else
		ReturnValue = DataVal;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Procedure ReadDataByPaymentSchedule(DataSet, ED, ParseTree, NewED, Error)
	
	If Not TypeOf(DataSet) = Type("XDTOList") Then
		Return;
	EndIf;
	
	ListTS = New ValueList;
	LineNumberOld = 1;
	
	For Each Item IN DataSet Do
		ListTS = New ValueList;
		FillInAttributesList(ListTS, Item, ED);
		
		AddObjectTSAttributes(NewED, "PaymentScheduleStages", ListTS);
		
	EndDo;
		
EndProcedure

Procedure FillInAttributesList(ListTS, Val Item, ED)
	
	While StrLen(Item) > 0 Do
		
		SeparatorPosition = Find(Item, "#");
		AttributeValue = Left(Item, SeparatorPosition );
		Item = StrReplace(Item, AttributeValue, "");
		
		Position = Find(AttributeValue, "&");
		
		Attribute = Left(AttributeValue, Position - 1);
		
		AttributeValue = StrReplace(AttributeValue, Attribute, "");
		AttributeValue = StrReplace(AttributeValue,"&","");
		AttributeValue = StrReplace(AttributeValue,"#","");
		
		If Upper(Attribute) = Upper("PaymentOption") Then
			AttributeValue = PaymentKindValue(AttributeValue, ED.Role);
		EndIf;
		
		ListTS.Add(AttributeValue, Attribute);
		
	EndDo;
	
EndProcedure

Procedure DeleteReadDataByPaymentSchedule(DataSet, ED, ParseTree, NewED, Error)
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
					
				ElsIf Not ValueIsFilled(DataVal)
					AND Not Upper(CurProperty.Name) = Upper("Taxes") 
					AND Not Upper(CurProperty.Name) = Upper("PaymentPercent") Then
					
					Continue;
					
				EndIf;
				
				If Upper(CurProperty.Name) = Upper("PaymentDate") Then
					ListTS.Add(DataVal, "PaymentDate");	
				ElsIf Upper(CurProperty.Name) = Upper("PaymentPercent") Then
					ListTS.Add(DataVal, "PaymentPercent");	
				ElsIf Upper(CurProperty.Name) = Upper("PaymentAmount") Then
					ListTS.Add(DataVal, "PaymentAmount");
				ElsIf Upper(CurProperty.Name) = Upper("PayKind") Then
					If DataVal = "Advance" Then
						If ED.Role = "Seller" Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
								"Advance (before provision)"), "PaymentOption");
						ElsIf ED.Role = "Customer"  Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
								"Advance payment (before confirmation)"), "PaymentOption");
						EndIf;
					ElsIf DataVal = "Prepayment" Then
						If ED.Role = "Seller" Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
								"Advanced payment (before shipment)"), "PaymentOption");
						ElsIf ED.Role = "Customer" Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
								"Preliminary payment (before receipt)"), "PaymentOption");
						EndIf;
					ElsIf DataVal = "Credit" Then
						If ED.Role = "Seller" Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantOfPaymentByClient",
								"Credit (upon shipment)"), "PaymentOption");
						ElsIf ED.Role = "Customer" Then 
							ListTS.Add(ElectronicDocumentsReUse.FindEnumeration("VariantsOfPaymentToSupplier",
								"Credit (after receipt)"), "PaymentOption");
						EndIf;
					EndIf;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
			EndDo;
			AddObjectTSAttributes(NewED, "PaymentScheduleStages", ListTS);
		EndDo;
	EndIf;
	
EndProcedure

Procedure ReadDataByCatalogueProduct(DataSet, ED, ParseTree, NewED, Error)
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		
		LineNumber = 0;
		For Each Item IN DataSet Do
			
			ListTS = New ValueList;
			ProductDescription = "";
			ProductId = "";
			ProductSKU = "";
			AreAdditAttributes = False;
			ThereArePropertiesValues = False;
			
			// ProductsAndServices.
			ProductsAndServicesAttributes = New Structure;
			SupplierProductsAndServicesAttributes = New Structure;
			OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
			ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
			SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties.
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					SupplierProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = SupplierProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					SupplierProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code", DataVal.Code);
						
						If DataVal.Properties().Get("Description") <> Undefined Then
							BasicValueDescription = DataVal.Description;
							UnOfMeasAttributes.Insert("Description", DataVal.Description);
						EndIf;
						If DataVal.Properties().Get("DescriptionFull") <> Undefined Then
							BasicValueDescription = DataVal.DescriptionFull;
							UnOfMeasAttributes.Insert("DescriptionFull", DataVal.DescriptionFull);
						EndIf;
						If DataVal.Properties().Get("InternationalAbbreviation") <> Undefined Then
							UnOfMeasAttributes.Insert("InternationalAbbreviation", DataVal.InternationalAbbreviation);
						EndIf;
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code,
							BasicValueDescription, UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						SupplierProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
						
						If DataVal.Properties().Get("Recalculation") <> Undefined Then
							Conversion = DataVal.Recalculation;
							If TypeOf(Conversion) = Type("XDTOList") Then
								
								ResidueStorageUnits = New ValueTable;
								ResidueStorageUnits.Columns.Add("Description");
								ResidueStorageUnits.Columns.Add("Factor");
								For Each RecalculationElement IN Conversion Do
									
									NewRow = ResidueStorageUnits.Add();
									NewRow.Description = RecalculationElement.Unit;
									NewRow.Factor  = RecalculationElement.Factor;
									
								EndDo;
								ProductsAndServicesAttributes.Insert("Recalculation", ResidueStorageUnits);
								
							EndIf;
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem in DataVal Do
						ValueArray = New Array;
						For Each ValueItem in DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
					EndDo;
				ElsIf Upper(CurProperty.Name) = Upper("PropertyValues") Then
					ThereArePropertiesValues = True;
					PropertyArray = New Array;
					For Each DataItem IN DataVal.PropertyValues Do
						ValueArray = New Array;
						For Each ValueItem in DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						PropertyStructure = New Structure("ID, Name, Value");
						FillPropertyValues(PropertyStructure, DataItem);
						PropertyStructure.Value = ValueArray;
						PropertyArray.Add(PropertyStructure);
					EndDo;
				ElsIf Upper(CurProperty.Name) = Upper("Picture") Then
					ImagesArray = New Array;
					For Each Picture IN DataVal Do
						ImagesArray.Add(Picture);
					EndDo;
					If ImagesArray.Count() > 0 Then
						SupplierProductsAndServicesAttributes.Insert("Images", ImagesArray);
					EndIf;
				EndIf;
			EndDo;
			
			SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
			If ProductsAndServicesAttributes.Property("SKU") Then
				SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
			EndIf;
			If ValueIsFilled(ProductDesc) Then
				SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
			EndIf;
			If AreAdditAttributes Then
				SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
			EndIf;
			
			If ThereArePropertiesValues Then
				SupplierProductsAndServicesAttributes.Insert("PropertyValues", PropertyArray);
			EndIf;
			
			SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
				SupplierProductsAndServicesAttributes, ED.ID);
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
			FoundString     = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
				SupplierProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
			
			If ValueIsFilled(SupplierProductsAndServices) Then
				ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
			EndIf;
			ProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("ProductsAndServices", "", SupplierProductsAndServicesAttributes, ED.ID);
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString     = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			
			LineNumber = LineNumber + 1;
			ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS);
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
			
		EndDo;
		
	EndIf;
	
EndProcedure

Procedure ReadDataByBankAccountTorg12(
					NewED,
					XDTOBankAccount,
					ParseTree,
					BankAccountKind,
					Role,
					Counterparty,
					Error)
	
	// Processing of the account bank
	
	BankXDTO = XDTOBankAccount.PrBank;
	
	BankingDetails = New Structure;
	BankingDetails.Insert("Code",			BankXDTO.BIN);
	BankingDetails.Insert("Description", BankXDTO.DescBank);
	
	BankRef = ElectronicDocumentsOverridable.FindRefToObject("Banks", BankingDetails.Code, BankingDetails);
	
	// Create bank object in parsing tree
	TypeBanksInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Banks");
	
	RowOfBank = FindCreateStringInParsedTree(TypeBanksInTree, BankingDetails.Code, "BIC: " + BankingDetails.Code,
	BankRef, BankingDetails, ParseTree, Error);
	
	// Processing of the account
	BankAccAttributes = New Structure;
	BankAccAttributes.Insert("AccountNo", XDTOBankAccount.AccountNo);
	
	If ValueIsFilled(Counterparty) Then
		BankAccAttributes.Insert("Owner", Counterparty);
	EndIf;
	
	BankAccountRef = ElectronicDocumentsOverridable.FindRefToObject(BankAccountKind, BankAccAttributes.AccountNo, BankAccAttributes);
	
	// Create an object of current account in parsing tree
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, BankAccountKind);
	
	AccountString = FindCreateStringInParsedTree(FoundTypeInTree, BankAccAttributes.AccountNo, "Account number: " + BankAccAttributes.AccountNo,
	BankAccountRef, BankAccAttributes, ParseTree, Error);
	
	// Fill in details of bank account.
	AddObjectHeaderAttribute(AccountString, "Bank", RowOfBank.RowIndex);
	If BankAccountKind = "BankAccountsOfCounterparties" Then
		If Role = "Consignor" Then
			AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
		ElsIf Role = "Consignee" Then
			AddObjectHeaderAttribute(NewED, "ConsigneeBankAccount", AccountString.RowIndex);
		Else
			AddObjectHeaderAttribute(NewED, "CounterpartyBankAcc", AccountString.RowIndex);
		EndIf
	ElsIf BankAccountKind = "BankAccountsOfTheCompany" Then
		If Role = "Consignor" Then
			AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
		Else
			AddObjectHeaderAttribute(NewED, "BankAccountOfTheCompany", AccountString.RowIndex);
		EndIf;
	EndIf;
	
EndProcedure

Procedure ReadDataByBankAccount(
					NewED,
					XDTOBankAccount,
					ParseTree,
					BankAccountKind,
					Role,
					Counterparty,
					Error)
					
	If TypeOf(XDTOBankAccount) = Type("XDTODataObject") Then
		BankXDTO = XDTOBankAccount.Bank;
		
		BankingDetails = New Structure;
		BankingDetails.Insert("Code",          BankXDTO.BIN);
		BankingDetails.Insert("Description", BankXDTO.Description);
		BankingDetails.Insert("CorrAccount",     BankXDTO.AccountCorrespondent);
		
	Else
		
		BankingDetails = New Structure;
		BankingDetails.Insert("Code",          XDTOBankAccount.BIN);
		BankingDetails.Insert("Description", XDTOBankAccount.BankDescription);
		BankingDetails.Insert("CorrAccount",     XDTOBankAccount.AccountCorrespondent);
		
	EndIf;
	
	BankRef = ElectronicDocumentsOverridable.FindRefToObject("Banks", BankingDetails.Code, BankingDetails);
	
	// Create bank object in parsing tree.
	TypeBanksInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Banks");
	
	RowOfBank = FindCreateStringInParsedTree(TypeBanksInTree, BankingDetails.Code, "BIC: " + BankingDetails.Code,
	BankRef, BankingDetails, ParseTree, Error);
	
	//Processing of bank correspondent
	IsBankCorrespondent = False;
	
	If TypeOf(XDTOBankAccount) = Type("XDTODataObject") Then
		EDProperty = XDTOBankAccount.Properties().Get("CorrespondentBank");
		If EDProperty <> Undefined AND XDTOBankAccount.CorrespondentBank <> Undefined Then
		
			IsBankCorrespondent = True;
			BankCorrespondentXDTO = XDTOBankAccount.CorrespondentBank;
			
			BankCorrespondentAttributes = New Structure;
			BankCorrespondentAttributes.Insert("Code",          BankCorrespondentXDTO.BIN);
			BankCorrespondentAttributes.Insert("Description", BankCorrespondentXDTO.Description);
			BankCorrespondentAttributes.Insert("CorrAccount",     BankCorrespondentXDTO.AccountCorrespondent);
			
		EndIf;
	ElsIf XDTOBankAccount.Property("BICCorr") AND ValueIsFilled(XDTOBankAccount.BICCorr) Then
		
			IsBankCorrespondent = True;
			
			BankCorrespondentAttributes = New Structure;
			BankCorrespondentAttributes.Insert("Code",          XDTOBankAccount.BICCorr);
			BankCorrespondentAttributes.Insert("Description", XDTOBankAccount.NameCorr);
			BankCorrespondentAttributes.Insert("CorrAccount",     XDTOBankAccount.AccountCorr);
			
	EndIf;
	
	If IsBankCorrespondent Then
		
		BankCorrespondentRef = ElectronicDocumentsOverridable.FindRefToObject("Banks",
			BankCorrespondentAttributes.Code, BankCorrespondentAttributes);
		
		// Create bank object in parsing tree
		TypeBanksCorrInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Banks");
		
		RowOfBankCorrespondent = FindCreateStringInParsedTree(TypeBanksCorrInTree, BankCorrespondentAttributes.Code,
		"BIC: " + BankCorrespondentAttributes.Code, BankCorrespondentRef, BankCorrespondentAttributes, ParseTree,
		Error);
		
	EndIf;
	
	// Processing of the account	
	BankAccAttributes = New Structure;
	BankAccAttributes.Insert("AccountNo", XDTOBankAccount.AccountNo);
	
	If ValueIsFilled(Counterparty) Then
		BankAccAttributes.Insert("Owner", Counterparty);
	EndIf;
	
	BankAccountRef = ElectronicDocumentsOverridable.FindRefToObject(BankAccountKind,
		BankAccAttributes.AccountNo, BankAccAttributes);
	
	// Create an object of current account in parsing tree.
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, BankAccountKind);
	
	AccountString = FindCreateStringInParsedTree(FoundTypeInTree, BankAccAttributes.AccountNo, "Account number: "
		+ BankAccAttributes.AccountNo,
	BankAccountRef, BankAccAttributes, ParseTree, Error);
	
	// Fill in details of bank account.
	AddObjectHeaderAttribute(AccountString, "Bank", RowOfBank.RowIndex);
	If IsBankCorrespondent Then
		AddObjectHeaderAttribute(AccountString, "CorrespondentBank", RowOfBankCorrespondent.RowIndex);
	EndIf;
	
	If BankAccountKind = "BankAccountsOfCounterparties" Then
		If Role = "Consignor" Then
			AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
		ElsIf Role = "Consignee" Then
			AddObjectHeaderAttribute(NewED, "ConsigneeBankAccount", AccountString.RowIndex);
		Else
			AddObjectHeaderAttribute(NewED, "CounterpartyBankAcc", AccountString.RowIndex);
		EndIf
	ElsIf BankAccountKind = "BankAccountsOfTheCompany" Then
		If Role = "Consignor" Then
			AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
		Else
			AddObjectHeaderAttribute(NewED, "BankAccountOfTheCompany", AccountString.RowIndex);
		EndIf;
	EndIf;
	
EndProcedure

Procedure ReadDataOnCounterpartyCMLCurrentAccounts(
					NewED,
					XDTOBankAccounts,
					ParseTree,
					BankAccountKind,
					Role,
					Counterparty,
					Error)
					
	DataSet = XDTOBankAccounts.BankAccount;
	If Not TypeOf(DataSet) = Type("XDTOList") Then
		Return;
	EndIf;
	
	For Each XDTOBankAccount IN DataSet Do
		
		ListTS = New ValueList;
		
		BankXDTO = XDTOBankAccount.Bank;
		
		BankingDetails = New Structure;
		BankingDetails.Insert("Code",          BankXDTO.BIN);
		BankingDetails.Insert("Description", BankXDTO.Description);
		BankingDetails.Insert("CorrAccount",     BankXDTO.AccountCorrespondent);
		BankingDetails.Insert("SWIFT",     	BankXDTO.SWIFT);

		BankRef = ElectronicDocumentsOverridable.FindRefToObject("Banks", BankingDetails.Code, BankingDetails);
		
		ListTS.Add(BankXDTO.BIN,						"BankBIN");
		ListTS.Add(BankXDTO.Description,			"BankBasicUnitName");
		ListTS.Add(BankXDTO.AccountCorrespondent,	"CorrBankAccount");
		ListTS.Add(BankXDTO.SWIFT,					"BankSWIFT");
		
		// Create bank object in parsing tree.
		TypeBanksInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Banks");
		
		RowOfBank = FindCreateStringInParsedTree(TypeBanksInTree, BankingDetails.Code, "BIC: " + BankingDetails.Code,
																		BankRef, BankingDetails, ParseTree, Error);
		
		//Processing of bank correspondent
		IsBankCorrespondent = False;
		EDProperty = XDTOBankAccount.Properties().Get("CorrespondentBank");
		If EDProperty <> Undefined AND XDTOBankAccount.CorrespondentBank <> Undefined Then
			
			IsBankCorrespondent = True;
			BankCorrespondentXDTO = XDTOBankAccount.CorrespondentBank;
			
			BankCorrespondentAttributes = New Structure;
			BankCorrespondentAttributes.Insert("Code",			BankCorrespondentXDTO.BIN);
			BankCorrespondentAttributes.Insert("Description",	BankCorrespondentXDTO.Description);
			BankCorrespondentAttributes.Insert("CorrAccount",		BankCorrespondentXDTO.AccountCorrespondent);
			BankCorrespondentAttributes.Insert("SWIFT",			BankCorrespondentXDTO.SWIFT);
			
			ListTS.Add(BankCorrespondentXDTO.BIN,					"BankBINCorr");
			ListTS.Add(BankCorrespondentXDTO.Description,			"BankCorpBasicUnitName");
			ListTS.Add(BankCorrespondentXDTO.AccountCorrespondent,	"BankCorrAccountCorr");
			ListTS.Add(BankCorrespondentXDTO.SWIFT,					"BankSWIFTCorr");
			
			BankCorrespondentRef = ElectronicDocumentsOverridable.FindRefToObject("Banks",
										BankCorrespondentAttributes.Code, BankCorrespondentAttributes);
			
			// Create bank object in parsing tree
			TypeBanksCorrInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Banks");
			
			RowOfBankCorrespondent = FindCreateStringInParsedTree(TypeBanksCorrInTree, BankCorrespondentAttributes.Code,
				"BIC: " + BankCorrespondentAttributes.Code, BankCorrespondentRef, BankCorrespondentAttributes, ParseTree,
				Error);
			
		EndIf;	
		
		// Processing of the account	
		BankAccAttributes = New Structure;
		BankAccAttributes.Insert("AccountNo", XDTOBankAccount.AccountNo);
		
		ListTS.Add(XDTOBankAccount.AccountNo,		"AccountNo");
		ListTS.Add(XDTOBankAccount.Comment,	"Comment");
		
		
		If ValueIsFilled(Counterparty) Then
			BankAccAttributes.Insert("Owner", Counterparty);
		EndIf;
		
		BankAccountRef = ElectronicDocumentsOverridable.FindRefToObject(BankAccountKind,
												BankAccAttributes.AccountNo, BankAccAttributes);
		
		// Create an object of current account in parsing tree.
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, BankAccountKind);
		
		AccountString = FindCreateStringInParsedTree(FoundTypeInTree,
					BankAccAttributes.AccountNo, "Account number: "+ BankAccAttributes.AccountNo,
					BankAccountRef, BankAccAttributes, ParseTree, Error);
		
		// Fill in details of bank account.
		AddObjectHeaderAttribute(AccountString, "Bank", RowOfBank.RowIndex);
		If IsBankCorrespondent Then
			AddObjectHeaderAttribute(AccountString, "CorrespondentBank", RowOfBankCorrespondent.RowIndex);
		EndIf;	
		
		If BankAccountKind = "BankAccountsOfCounterparties" Then
			If Role = "Consignor" Then
				AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
			ElsIf Role = "Consignee" Then
				AddObjectHeaderAttribute(NewED, "ConsigneeBankAccount", AccountString.RowIndex);
			Else
				AddObjectHeaderAttribute(NewED, "CounterpartyBankAcc", AccountString.RowIndex);
			EndIf	
		ElsIf BankAccountKind = "BankAccountsOfTheCompany" Then
			If Role = "Consignor" Then
				AddObjectHeaderAttribute(NewED, "ShipperBankAccount", AccountString.RowIndex);
			Else	
				AddObjectHeaderAttribute(NewED, "BankAccountOfTheCompany", AccountString.RowIndex);
			EndIf;
		EndIf;	
		
		AddObjectTSAttributes(NewED, "RowTSCurrentAccount", ListTS);
		
	EndDo;
	
EndProcedure

Procedure ReadDataByTSInvoiceForPayment(DataSet, ED, ParseTree, NewED, Error)
	
	// Define ED variant for selection of an algorithm to fill in products and services.
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing);
	
	If Not TypeOf(DataSet) = Type("XDTOList") Then
		Return;
	EndIf;
	
	LineNumber = 0;
	For Each Item IN DataSet Do
		ListTS = New ValueList;
		ProductDesc = "";
		ProductId = "";
		AreAdditAttributes = False;
		PriceIncludesVAT = Undefined;
		ItemAmount = Undefined;
		VATAmount = 0;
		
		// ProductsAndServices
		ProductsAndServicesAttributes = New Structure;
		For Each CurProperty IN Item.Properties() Do
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			
			// Parse Product properties.
			If Upper(CurProperty.Name) = Upper("ID") Then
				ProductsAndServicesAttributes.Insert("ID", DataVal);
				ProductId = ProductsAndServicesAttributes.ID;
			ElsIf Upper(CurProperty.Name) = Upper("Description") Then
				ProductsAndServicesAttributes.Insert("Description", DataVal);
				ProductDesc = ProductsAndServicesAttributes.Description;
			ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
				ProductsAndServicesAttributes.Insert("SKU", DataVal);
			ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code", DataVal.Code);
					UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code,
					UnOfMeasAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, DataVal.Code, DataVal.ShortDescription,
					UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
					EndIf;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("Unit") Then
				
				
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code", String(DataVal));
				
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal),
				UnOfMeasAttributes);
				
				If ValueIsFilled(UnOfMeas) Then
					NameUnits = UnOfMeas.Description;
				Else
					NameUnits = "pcs";
				EndIf;
				UnOfMeasAttributes.Insert("Description", NameUnits);
				
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(DataVal), NameUnits,
				UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
				If ValueIsFilled(UnOfMeas) Then
					ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
				EndIf;
				
			ElsIf Upper(CurProperty.Name) = Upper("Taxes") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					For Each CurProp IN DataVal.Properties() Do
						If Upper(CurProp.Name) = Upper("Tax") Then
							Taxes = DataVal.GetList(CurProp);
							For Each Tax IN Taxes Do
								If Upper(Tax.Description) = "VAT" Then
									ListTS.Add(Tax.Rate,"VATRate");
									VATAmount = Number(Tax.Amount);
									ListTS.Add(VATAmount, "VATAmount");
									If TypeOf(Tax.IncludedInAmount) = Type("Boolean") Then
										PriceIncludesVAT = Tax.IncludedInAmount;
										ListTS.Add(PriceIncludesVAT, "PriceIncludesVAT");
									EndIf;
								EndIf;
							EndDo;
						EndIf;
					EndDo;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("Discounts") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					For Each CurProp IN DataVal.Properties() Do
						If Upper(CurProp.Name) = Upper("Discount") Then
							Discounts = DataVal.GetList(CurProp);
							For Each Discount IN Discounts Do
								If Upper(Discount.Description) = "TotalDiscount" Then
									ListTS.Add(Discount.Amount,"DiscountAmount");
								EndIf;
							EndDo;
						EndIf;
					EndDo;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
				// Remember the number of packages in which the goods were shipped.
				ListTS.Add(Number(DataVal), "PackingQuantity");
				// Calculate
				// with account of the coefficient if there is UOM property, get the value.
				Coeff = "";
				If Item.Unit <> Undefined Then
					Coeff = Item.Factor;
				EndIf;
				If Not ValueIsFilled(Coeff) Then
					Coeff = 1;
				EndIf;
				ListTS.Add(Coeff, "Factor");
				ListTS.Add(Number(DataVal) * Coeff, "Quantity");
			ElsIf Upper(CurProperty.Name) = Upper("DateByCustomerData") Then
				ListTS.Add(GetDateTimeFromString(DataVal), CurProperty.Name);
			ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
				AreAdditAttributes = True;
				AdditAttributesStructure = New Structure;
				For Each DataItem in DataVal Do
					ValueArray = New Array;
					For Each ValueItem in DataItem.Value Do
						ValueArray.Add(ValueItem)
					EndDo;
					AdditAttributesStructure.Insert(DataItem.Description,ValueArray);
				EndDo;
				
			ElsIf Upper(CurProperty.Name) = Upper("PriceForUnit") Then
				
				ListTS.Add(DataVal, "Price");
			ElsIf Upper(CurProperty.Name) = Upper("Amount") Then
				ItemAmount = ListTS.Add(Number(DataVal), "Amount");
				
			ElsIf Upper(CurProperty.Name) = Upper("AttributeValues") Then
			
				AdditionalAttributes = New Structure;
				Company = TreeAttributeRef(ParseTree, NewED, "Company");
				If ValueIsFilled(Company) Then
					AdditionalAttributes.Insert("Company", Company);
				EndIf;
				
				ReadValueListDetailsCML(DataVal.AttributeValue, ListTS, Error, AdditionalAttributes);
				
			Else
				ListTS.Add(DataVal, CurProperty.Name);
			EndIf;
			
		EndDo;
		
		If TypeOf(ItemAmount) = Type("ValueListItem") Then
			Amount = ItemAmount.Value;
			If PriceIncludesVAT = True Then
				ListTS.Add(Amount, "SumWithVAT");
				ItemAmount.Value = Amount - VATAmount;
			ElsIf PriceIncludesVAT = False Then
				ListTS.Add(Amount + VATAmount, "SumWithVAT");
			Else
				ListTS.Add(Amount, "SumWithVAT");
			EndIf;
		EndIf;
		
		// Identification by products and services of the company when the parsing side ED - subsidiary company itself.
		If IdentificationByCounterpartyProductsAndServices Then
			IdStructure = ParseProductID(ProductId);
			ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
			If ValueIsFilled(IdStructure.CharacteristicID) Then
				ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
				ListTS.Add(ProductsAndServicesCharacteristic,"Characteristic");
			EndIf;
			If ValueIsFilled(IdStructure.IDPackage) Then
				ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking",IdStructure.IDPackage);
				ListTS.Add(ProductsAndServicesPackaging,"Package");
			EndIf;
			
		Else // The rest of cases - search by supplier's products and services.
			// Suppliers products and services.
			SupplierProductsAndServicesAttributes = New Structure;
			OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
			ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
			SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
			SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
			If ProductsAndServicesAttributes.Property("SKU") Then
				SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
			EndIf;
			If ValueIsFilled(ProductDesc) Then
				SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
			EndIf;
			If AreAdditAttributes Then
				SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
			EndIf;
			SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
			SupplierProductsAndServicesAttributes, ED.ID);
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
			SupplierProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
			
			If ValueIsFilled(SupplierProductsAndServices) Then
				ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
			EndIf;
			ProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("ProductsAndServices", "", SupplierProductsAndServicesAttributes, ED.ID);
		EndIf;
		
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
		ProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
		
		Company = TreeAttributeRef(ParseTree, NewED, "Company");
		AdditParameters = New Structure;
		AdditParameters.Insert("Company", Company);

		LineNumber = LineNumber + 1;
		ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);
		
		AddObjectTSAttributes(NewED, "TSRow", ListTS);
		
		
	EndDo;
	
EndProcedure

Procedure DeleteReadDataByInvoiceForPaymentTS(DataSet, ED, ParseTree, NewED, Error)
	
	// Define ED variant for selection of an algorithm to fill in products and services.
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			// ProductsAndServices
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties.
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code", DataVal.Code);
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code,
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, DataVal.Code, DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code", String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code),
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("AmountsByProduct") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Tax") Then
								Taxes = DataVal.GetList(CurProp);
								For Each Tax IN Taxes Do
									If Upper(Tax.TaxType) = "VAT" Then
										ListTS.Add(Tax.TaxRateAmount, "VATRate");
										ListTS.Add(Tax.Amount, "VATAmount");
									EndIf;
								EndDo;
							EndIf;
							If Upper(CurProp.Name) = Upper("AmountWithoutTax") Then
								ListTS.Add(DataVal.AmountWithoutTax, "Amount");
							EndIf;
							
							If Upper(CurProp.Name) = Upper("AmountTotal") Then
								ListTS.Add(DataVal.AmountTotal, "SumWithVAT");
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Discounts") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Discount") Then
								Discounts = DataVal.GetList(CurProp);
								For Each Discount IN Discounts Do
									If Upper(Discount.Description) = "TotalDiscount" Then
										ListTS.Add(Discount.Amount,"DiscountAmount");
									EndIf;
								EndDo;
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages in which the goods were shipped.
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of the coefficient if there is UOM property, get the value.
					Coeff = "";
					If Item.MeasurementUnit <> Undefined Then
						Coeff = Item.MeasurementUnit.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("DateByCustomerData") Then
					ListTS.Add(GetDateTimeFromString(DataVal), CurProperty.Name);
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem in DataVal Do
						ValueArray = New Array;
						For Each ValueItem in DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description,ValueArray);
					EndDo;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
				
			EndDo;
			
			// Identification by products and services of the company when the parsing side ED - subsidiary company itself.
			If IdentificationByCounterpartyProductsAndServices Then
				IdStructure = ParseProductID(ProductId);
				ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
				If ValueIsFilled(IdStructure.CharacteristicID) Then
					ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
					ListTS.Add(ProductsAndServicesCharacteristic,"Characteristic");
				EndIf;
				If ValueIsFilled(IdStructure.IDPackage) Then
					ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking",IdStructure.IDPackage);
					ListTS.Add(ProductsAndServicesPackaging,"Package");
				EndIf;
				
			Else // The rest of cases - search by supplier's products and services.
				// Suppliers products and services.
				SupplierProductsAndServicesAttributes = New Structure;
				OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
				ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
				SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
				SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
				If ProductsAndServicesAttributes.Property("SKU") Then
					SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
				EndIf;
				If ValueIsFilled(ProductDesc) Then
					SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
				EndIf;
				If AreAdditAttributes Then
					SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
				EndIf;
				SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
					SupplierProductsAndServicesAttributes, ED.ID);
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
				SupplierProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex,"SupplierProductsAndServices");
				
				If ValueIsFilled(SupplierProductsAndServices) Then
					ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
				EndIf;
				ProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("ProductsAndServices", "", SupplierProductsAndServicesAttributes, ED.ID);
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
			
		EndDo;
	EndIf;
	
EndProcedure

Procedure ReadDataByTSCustomerOrder(DataSet, ED, ParseTree, NewED, Error)
	
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
		AND NewED.EDKind=Enums.EDKinds.ResponseToOrder) OR (NewED.EDDirection = Enums.EDDirections.Incoming
		AND NewED.EDKind=Enums.EDKinds.ProductOrder);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		LineNumber = 0;
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			PriceIncludesVAT = Undefined;
			ItemAmount = Undefined;
			VATAmount = 0;
			
			// ProductsAndServices
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          DataVal.Code);
						UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code,
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.ShortDescription,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Unit") Then
					
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code",          String(DataVal));
					
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal),
						UnOfMeasAttributes);
					If ValueIsFilled(UnOfMeas) Then
						NameUnits = UnOfMeas.Description;
					Else
						NameUnits = "pcs";
					EndIf;
					UnOfMeasAttributes.Insert("Description",          NameUnits);
					
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, String(DataVal), NameUnits,
						UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						
						ListTS.Add(UnOfMeas,"MeasurementUnit");
						
					EndIf;
					
				ElsIf Upper(CurProperty.Name) = Upper("Taxes") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Tax") Then
								Taxes = DataVal.GetList(CurProp);
								For Each Tax IN Taxes Do
									If Upper(Tax.Description) = "VAT" Then
										ListTS.Add(Tax.Rate,"VATRate");
										VATAmount = Number(Tax.Amount);
										ListTS.Add(VATAmount, "VATAmount");
										If TypeOf(Tax.IncludedInAmount) = Type("Boolean") Then
											PriceIncludesVAT = Tax.IncludedInAmount;
											ListTS.Add(PriceIncludesVAT, "PriceIncludesVAT");
										EndIf;
									EndIf;
								EndDo;
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Discounts") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Discount") Then
								Discounts = DataVal.GetList(CurProp);
								For Each Discount IN Discounts Do
									If Upper(Discount.Description) = "TotalDiscount" Then
										ListTS.Add(Discount.Amount,"DiscountAmount");
										ListTS.Add(Discount.Percent,"ManualDiscountPercentage");
									EndIf;
								EndDo;
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages that were
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of the coefficient if there is UOM property, get the value.
					Coeff = "";
					If Item.Unit <> Undefined Then
						Coeff = Item.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem IN DataVal Do
						ValueArray = New Array;
						For Each ValueItem IN DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
					EndDo;
					
				ElsIf Upper(CurProperty.Name) = Upper("PriceForUnit") Then
					ListTS.Add(DataVal, "Price");
				ElsIf Upper(CurProperty.Name) = Upper("Amount") Then
					ItemAmount = ListTS.Add(Number(DataVal), "Amount");
					
				ElsIf Upper(CurProperty.Name) = Upper("AttributeValues") Then
					
					DataVal = Item[CurProperty.Name];
					AdditionalAttributes = New Structure;
					Company = TreeAttributeRef(ParseTree, NewED, "Company");
					If ValueIsFilled(Company) Then
						AdditionalAttributes.Insert("Company", Company);
					EndIf;
					
					ReadValueListDetailsCML(DataVal.AttributeValue, ListTS, Error, AdditionalAttributes);
					
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
				
				
				
			EndDo;
			
			If TypeOf(ItemAmount) = Type("ValueListItem") Then
				Amount = ItemAmount.Value;
				If PriceIncludesVAT = True Then
					ListTS.Add(Amount, "SumWithVAT");
					ItemAmount.Value = Amount - VATAmount;
				ElsIf PriceIncludesVAT = False Then
					ListTS.Add(Amount + VATAmount, "SumWithVAT");
				Else
					ListTS.Add(Amount, "SumWithVAT");
				EndIf;
			EndIf;
			
			// Identification by products and services of the company when the parsing side ED - subsidiary company itself.
			If IdentificationByCounterpartyProductsAndServices Then 
				IdStructure = ParseProductID(ProductId);
				ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
				If ValueIsFilled(IdStructure.CharacteristicID) Then
					ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
					ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
				EndIf;
				If ValueIsFilled(IdStructure.IDPackage) Then
					ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
					ListTS.Add(ProductsAndServicesPackaging, "Package");
				EndIf;
			Else
				// Suppliers products and services.
				SupplierProductsAndServicesAttributes = New Structure;
				OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
				ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
				
				SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
				SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
				If ProductsAndServicesAttributes.Property("SKU") Then
					SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
				EndIf;
				If ValueIsFilled(ProductDesc) Then
					SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
				EndIf;
				If AreAdditAttributes Then
					SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
				EndIf;
				SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
					SupplierProductsAndServicesAttributes, ED.ID);
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
					SupplierProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
				
				If ValueIsFilled(SupplierProductsAndServices) Then
					ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
				EndIf;
				
				ProductAttributesStructure = GenerateProductStructure();
				ElectronicDocumentsOverridable.GetProductAttributes(ProductsAndServicesAttributes, ProductAttributesStructure, ED.ID);
		
				ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
				If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
					ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
				EndIf;
				If ValueIsFilled(ProductAttributesStructure.Package) Then
					ListTS.Add(ProductAttributesStructure.Package, "Package");
				EndIf;
				
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			
			Company = TreeAttributeRef(ParseTree, NewED, "Company");
			AdditParameters = New Structure;
			AdditParameters.Insert("Company", Company);
			
			LineNumber = LineNumber + 1;
			ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);

			AddObjectTSAttributes(NewED, "TSRow", ListTS);
			
		EndDo;
	EndIf;
	
EndProcedure

Procedure DeleteReadDataOnCustomerOrderTS(DataSet, ED, ParseTree, NewED, Error)
	
	IdentificationByCounterpartyProductsAndServices = (NewED.EDDirection = Enums.EDDirections.Outgoing
		AND NewED.EDKind=Enums.EDKinds.ResponseToOrder) OR (NewED.EDDirection = Enums.EDDirections.Incoming
		AND NewED.EDKind=Enums.EDKinds.ProductOrder);
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			// ProductsAndServices
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          DataVal.Code);
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code,
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code),
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ListTS.Add(FoundString.RowIndex, "MeasurementUnit");
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("AmountsByProduct") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Tax") Then
								Taxes = DataVal.GetList(CurProp);
								For Each Tax IN Taxes Do
									If Upper(Tax.TaxType) = "VAT" Then
										ListTS.Add(Tax.TaxRateAmount,"VATRate");
										ListTS.Add(Tax.Amount, "VATAmount");
									EndIf;
								EndDo;
							EndIf;
							If Upper(CurProp.Name) = Upper("AmountWithoutTax") Then
								ListTS.Add(DataVal.AmountWithoutTax, "Amount");
							EndIf;	
							If Upper(CurProp.Name) = Upper("AmountTotal") Then
								ListTS.Add(DataVal.AmountTotal, "SumWithVAT");
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Discounts") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Discount") Then
								Discounts = DataVal.GetList(CurProp);
								For Each Discount IN Discounts Do
									If Upper(Discount.Description) = "TotalDiscount" Then
										ListTS.Add(Discount.Amount,"DiscountAmount");
										ListTS.Add(Discount.Percent,"ManualDiscountPercentage");
									EndIf;
								EndDo;
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages that were
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of the coefficient if there is UOM property, get the value.
					Coeff = "";
					If Item.MeasurementUnit <> Undefined Then
						Coeff = Item.MeasurementUnit.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem IN DataVal Do
						ValueArray = New Array;
						For Each ValueItem IN DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
					EndDo;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
				
			EndDo;
			
			// Identification by products and services of the company when the parsing side ED - subsidiary company itself.
			If IdentificationByCounterpartyProductsAndServices Then 
				IdStructure = ParseProductID(ProductId);
				ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
				If ValueIsFilled(IdStructure.CharacteristicID) Then
					ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
					ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
				EndIf;
				If ValueIsFilled(IdStructure.IDPackage) Then
					ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
					ListTS.Add(ProductsAndServicesPackaging, "Package");
				EndIf;
			Else
				// Suppliers products and services.
				SupplierProductsAndServicesAttributes = New Structure;
				OwnerAttributeName = GetSupplierProductsAndServicesOwnerAttributeName();
				ProductsAndServicesOwner = GetEDHeaderAttribute(NewED, OwnerAttributeName, ParseTree);
				
				SupplierProductsAndServicesAttributes.Insert("Owner", ProductsAndServicesOwner);
				SupplierProductsAndServicesAttributes.Insert("ID", ProductId);
				If ProductsAndServicesAttributes.Property("SKU") Then
					SupplierProductsAndServicesAttributes.Insert("SKU", ProductsAndServicesAttributes.SKU);
				EndIf;
				If ValueIsFilled(ProductDesc) Then
					SupplierProductsAndServicesAttributes.Insert("Description", ProductDesc);
				EndIf;
				If AreAdditAttributes Then
					SupplierProductsAndServicesAttributes.Insert("AdditionalAttributes", AdditAttributesStructure);
				EndIf;
				SupplierProductsAndServices = ElectronicDocumentsOverridable.FindRefToObject("SuppliersProductsAndServices", ,
					SupplierProductsAndServicesAttributes, ED.ID);
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "SuppliersProductsAndServices");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, SupplierProductsAndServices,
					SupplierProductsAndServicesAttributes, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex, "SupplierProductsAndServices");
				
				If ValueIsFilled(SupplierProductsAndServices) Then
					ProductsAndServicesAttributes.Insert("SupplierProductsAndServices", SupplierProductsAndServices);
				EndIf;
				
				ProductAttributesStructure = GenerateProductStructure();
				ElectronicDocumentsOverridable.GetProductAttributes(ProductsAndServicesAttributes, ProductAttributesStructure, ED.ID);
		
				ProductsAndServices = ProductAttributesStructure.ProductsAndServices;
				If ValueIsFilled(ProductAttributesStructure.Characteristic) Then
					ListTS.Add(ProductAttributesStructure.Characteristic, "Characteristic");
				EndIf;
				If ValueIsFilled(ProductAttributesStructure.Package) Then
					ListTS.Add(ProductAttributesStructure.Package, "Package");
				EndIf;
				
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
		EndDo;
	EndIf;
	
EndProcedure

Procedure ReadDataByTSComissionGoodsWriteOffReport(DataSet, ED, ParseTree, NewED, Error)
	
	If Not TypeOf(DataSet) = Type("XDTOList") Then
		Return;
	EndIf;
	
	LineNumber = 0;
	For Each Item IN DataSet Do
		ListTS = New ValueList;
		ProductDesc = "";
		ProductId = "";
		AreAdditAttributes = False;
		PriceIncludesVAT = Undefined;
		ItemAmount = Undefined;
		VATAmount = 0;
		
		// ProductsAndServices
		ProductsAndServicesAttributes = New Structure;
		For Each CurProperty IN Item.Properties() Do
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			
			// Parse Product properties.
			If Upper(CurProperty.Name) = Upper("ID") Then
				ProductsAndServicesAttributes.Insert("ID", DataVal);
				ProductId = ProductsAndServicesAttributes.ID;
			ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
				ProductsAndServicesAttributes.Insert("SKU", DataVal)
			ElsIf Upper(CurProperty.Name) = Upper("Description") Then
				ProductsAndServicesAttributes.Insert("Description", DataVal);
				ProductDesc = ProductsAndServicesAttributes.Description;
			ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code",          DataVal.Code);
					UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
					
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.ShortDescription,
					UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
					EndIf;

				EndIf;
				
			ElsIf Upper(CurProperty.Name) = Upper("Unit") Then
				
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code",          String(DataVal));
				
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal),
				UnOfMeasAttributes);
				If ValueIsFilled(UnOfMeas) Then
					NameUnits = UnOfMeas.Description;
				Else
					NameUnits = "pcs";
				EndIf;
				UnOfMeasAttributes.Insert("Description",          NameUnits);
				
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, String(DataVal), NameUnits,
				UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
				If ValueIsFilled(UnOfMeas) Then
					ListTS.Add(UnOfMeas,"MeasurementUnit");
					ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);

				EndIf;
				
			ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
				// Remember the number of packages in which the goods were shipped.
				ListTS.Add(Number(DataVal), "PackingQuantity");
				// Calculate
				// with account of the coefficient if there is UOM property, get the value.
				Coeff = "";
				If Item.BaseUnit <> Undefined Then
					Coeff = Item.Factor;
				EndIf;
				If Not ValueIsFilled(Coeff) Then
					Coeff = 1;
				EndIf;
				ListTS.Add(Coeff, "Factor");
				ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				
			ElsIf Upper(CurProperty.Name) = Upper("PriceForUnit") Then
				ListTS.Add(DataVal, "Price");
				
			ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
				AreAdditAttributes = True;
				AdditAttributesStructure = New Structure;
				For Each DataItem in DataVal Do
					ValueArray = New Array;
					For Each ValueItem in DataItem.Value Do
						ValueArray.Add(ValueItem)
					EndDo;
					AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
				EndDo;
			ElsIf Upper(CurProperty.Name) = Upper("Taxes") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					For Each CurProp IN DataVal.Properties() Do
						If Upper(CurProp.Name) = Upper("Tax") Then
							Taxes = DataVal.GetList(CurProp);
							For Each Tax IN Taxes Do
								If Upper(Tax.Description) = "VAT" Then
									ListTS.Add(Tax.Rate,"VATRate");
									VATAmount = Number(Tax.Amount);
									ListTS.Add(VATAmount, "VATAmount");
									If TypeOf(Tax.IncludedInAmount) = Type("Boolean") Then
										PriceIncludesVAT = Tax.IncludedInAmount;
										ListTS.Add(PriceIncludesVAT, "PriceIncludesVAT");
									EndIf;
								EndIf;
							EndDo;
						EndIf;
					EndDo;
				EndIf;
			ElsIf Upper(CurProperty.Name) = Upper("Amount") Then
				ItemAmount = ListTS.Add(Number(DataVal), "Amount");
			Else
				ListTS.Add(DataVal, CurProperty.Name);
			EndIf;
			
		EndDo;
		
		If TypeOf(ItemAmount) = Type("ValueListItem") Then
			Amount = ItemAmount.Value;
			If PriceIncludesVAT = True Then
				ListTS.Add(Amount, "SumWithVAT");
				ItemAmount.Value = Amount - VATAmount;
			ElsIf PriceIncludesVAT = False Then
				ListTS.Add(Amount + VATAmount, "SumWithVAT");
			Else
				ListTS.Add(Amount, "SumWithVAT");
			EndIf;
		EndIf;
		
		IdStructure = ParseProductID(ProductId);
		ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
		If ValueIsFilled(IdStructure.CharacteristicID) Then
			ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
			ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(IdStructure.IDPackage) Then
			ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
			ListTS.Add(ProductsAndServicesPackaging, "Package");
		EndIf;
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
		ProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
		
		Company = TreeAttributeRef(ParseTree, NewED, "Company");
		AdditParameters = New Structure;
		AdditParameters.Insert("Company", Company);

		LineNumber = LineNumber + 1;
		ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);
		
		AddObjectTSAttributes(NewED, "TSRow", ListTS);

		
	EndDo;
	
	
EndProcedure

Procedure DeleteReadDataByTSComissionGoodsWriteOffReport(DataSet, ED, ParseTree, NewED, Error)
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			// ProductsAndServices
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties.
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal)
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          DataVal.Code);
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, DataVal.Code, DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code), UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages in which the goods were shipped.
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of the coefficient if there is UOM property, get the value.
					Coeff = "";
					If Item.MeasurementUnit <> Undefined Then
						Coeff = Item.MeasurementUnit.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem in DataVal Do
						ValueArray = New Array;
						For Each ValueItem in DataItem.Value Do
							ValueArray.Add(ValueItem)
						EndDo;
						AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
					EndDo;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
				
			EndDo;
			
			IdStructure = ParseProductID(ProductId);
			ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
			If ValueIsFilled(IdStructure.CharacteristicID) Then
				ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics", IdStructure.CharacteristicID);
				ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
			EndIf;
			If ValueIsFilled(IdStructure.IDPackage) Then
				ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking", IdStructure.IDPackage);
				ListTS.Add(ProductsAndServicesPackaging, "Package");
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
		EndDo;
	EndIf;
	
EndProcedure

Procedure ReadDataByTSReportAboutComissionGoodsSales(DataSet, ED, ParseTree, NewED, Error)
	
	If Not TypeOf(DataSet) = Type("XDTOList") Then
		Return;
	EndIf;
	
	LineNumber = 0;
	For Each Item IN DataSet Do
		ListTS = New ValueList;
		ProductDesc = "";
		ProductId = "";
		AreAdditAttributes = False;
		PriceIncludesVAT = Undefined;
		ItemAmount = Undefined;
		VATAmount = 0;
		
		// ProductsAndServices.
		ProductsAndServicesAttributes = New Structure;
		For Each CurProperty IN Item.Properties() Do
			DataVal = Item[CurProperty.Name];
			If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
			ElsIf Not ValueIsFilled(DataVal) Then
				Continue;
			EndIf;
			
			// Parse Product properties.
			If Upper(CurProperty.Name) = Upper("ID") Then
				ProductsAndServicesAttributes.Insert("ID", DataVal);
				ProductId = ProductsAndServicesAttributes.ID;
				
			ElsIf Upper(CurProperty.Name) = Upper("Description") Then
				ProductsAndServicesAttributes.Insert("Description", DataVal);
				ProductDesc = ProductsAndServicesAttributes.Description;
				
			ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
				ProductsAndServicesAttributes.Insert("SKU", DataVal);
				
			ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					UnOfMeasAttributes = New Structure;
					UnOfMeasAttributes.Insert("Code",          DataVal.Code);
					UnOfMeasAttributes.Insert("Description", DataVal.ShortDescription);
					
					UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
					FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
					FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, DataVal.Code, DataVal.ShortDescription, 
					UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
					If ValueIsFilled(UnOfMeas) Then
						ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
					EndIf;
				EndIf;
				
			ElsIf Upper(CurProperty.Name) = Upper("Unit") Then
				
				UnOfMeasAttributes = New Structure;
				UnOfMeasAttributes.Insert("Code", String(DataVal));
				
				UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal),
						UnOfMeasAttributes);
						
				If ValueIsFilled(UnOfMeas) Then
					NameUnits = UnOfMeas.Description;
				Else
					NameUnits = "pcs.";
				EndIf;
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
				
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(DataVal), NameUnits,
																				UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
																				
				If ValueIsFilled(UnOfMeas) Then
					ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
				EndIf;

			ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
				// Remember the number of packages that were
				ListTS.Add(Number(DataVal), "PackingQuantity");
				// Calculate
				// with account of the coefficient if there is the property UOM, get the value.
				Coeff = "";
				If Item.Unit <> Undefined Then
					Coeff = Item.Factor;
				EndIf;
				If Not ValueIsFilled(Coeff) Then
					Coeff = 1;
				EndIf;
				ListTS.Add(Coeff, "Factor");
				ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				
			ElsIf Upper(CurProperty.Name) = Upper("Taxes") Then
				If TypeOf(DataVal) = Type("XDTODataObject") Then
					For Each CurProp IN DataVal.Properties() Do
						If Upper(CurProp.Name) = Upper("Tax") Then
							Taxes = DataVal.GetList(CurProp);
							For Each Tax IN Taxes Do
								If Upper(Tax.Description) = "VAT" Then
									ListTS.Add(Tax.Rate,"VATRate");
									VATAmount = Number(Tax.Amount);
									ListTS.Add(VATAmount, "VATAmount");
									If TypeOf(Tax.IncludedInAmount) = Type("Boolean") Then
										PriceIncludesVAT = Tax.IncludedInAmount;
										ListTS.Add(PriceIncludesVAT, "PriceIncludesVAT");
									EndIf;
								EndIf;
							EndDo;
						EndIf;
					EndDo;
				EndIf;

			ElsIf Upper(CurProperty.Name) = Upper("PriceForUnit") Then
				//ListTS.Add(DataVal, "SalePrice");
				ListTS.Add(DataVal, "Price");
			ElsIf Upper(CurProperty.Name) = Upper("Amount") Then
				ItemAmount = ListTS.Add(Number(DataVal), "Amount");
			ElsIf Upper(CurProperty.Name) = Upper("AdditionalInformation") Then
				AreAdditAttributes = True;
				AdditAttributesStructure = New Structure;
				For Each DataItem IN DataVal.AttributeValue Do
					If DataItem.Description = "SalePrice" Then
						ListTS.Add(DataItem.Value[0], "SalePrice");
					EndIf;
					
					If DataItem.Description = "SalesAmount" Then
						ListTS.Add(DataItem.Value[0], "SalesAmount");
					EndIf;
					
					If DataItem.Description = "BrokerageAmount" Then
						ListTS.Add(DataItem.Value[0], "BrokerageAmount");
					EndIf;
				EndDo;
			ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributeValues") Then
				For Each DataItem IN DataVal.AttributeValue Do
					If DataItem.Description = "CustomerID" AND ValueIsFilled(DataItem.Value[0]) Then
						CounterpartiesRows = ParseTree.Rows.Find("Counterparties", "ObjectType", True);
						CustomerRow = CounterpartiesRows.Rows.Find(DataItem.Value[0], "ID", True);
						If CustomerRow <> Undefined Then
							ListTS.Add(CustomerRow.RowIndex, "Customer");
						Else
							ListTS.Add(Undefined, "Customer");
						EndIf;
						ListTS.Add(DataItem.Value[0], "CustomerID");
					Else
						ListTS.Add(DataItem.Value[0], DataItem.Description);
					EndIf;
				EndDo;
			EndIf;
			
		EndDo;
		
		If TypeOf(ItemAmount) = Type("ValueListItem") Then
			Amount = ItemAmount.Value;
			If PriceIncludesVAT = True Then
				ListTS.Add(Amount, "SumWithVAT");
				ItemAmount.Value = Amount - VATAmount;
			ElsIf PriceIncludesVAT = False Then
				ListTS.Add(Amount + VATAmount, "SumWithVAT");
			Else
				ListTS.Add(Amount, "SumWithVAT");
			EndIf;
		EndIf;
		
		If AreAdditAttributes Then
			ListTS.Add(AdditAttributesStructure, "AdditionalAttributes");
		EndIf;
		
		IdStructure = ParseProductID(ProductId);
		ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
		If ValueIsFilled(IdStructure.CharacteristicID) Then
			ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics",
			IdStructure.CharacteristicID);
			ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
		EndIf;
		If ValueIsFilled(IdStructure.IDPackage) Then
			ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking",
			IdStructure.IDPackage);
			ListTS.Add(ProductsAndServicesPackaging, "Package");
		EndIf;
		
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
		FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
		ProductsAndServicesAttributes, ParseTree, Error);
		ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
		
		
		Company = TreeAttributeRef(ParseTree, NewED, "Company");
		AdditParameters = New Structure;
		AdditParameters.Insert("Company", Company);
		
		LineNumber = LineNumber + 1;
		ReadTSRowAdditData(Item, NewED, "Products", LineNumber, ListTS, AdditParameters);
		
		AddObjectTSAttributes(NewED, "TSRow", ListTS);
		
	EndDo;
	
EndProcedure

Procedure DeleteReadDataByTSReportOnComissionGoodsSales(DataSet, ED, ParseTree, NewED, Error)
	
	If TypeOf(DataSet) = Type("XDTOList") Then
		For Each Item IN DataSet Do
			ListTS = New ValueList;
			ProductDesc = "";
			ProductId = "";
			AreAdditAttributes = False;
			
			// ProductsAndServices.
			ProductsAndServicesAttributes = New Structure;
			For Each CurProperty IN Item.Properties() Do
				DataVal = Item[CurProperty.Name];
				If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
				ElsIf Not ValueIsFilled(DataVal) Then
					Continue;
				EndIf;
				
				// Parse Product properties.
				If Upper(CurProperty.Name) = Upper("ID") Then
					ProductsAndServicesAttributes.Insert("ID", DataVal);
					ProductId = ProductsAndServicesAttributes.ID;
				ElsIf Upper(CurProperty.Name) = Upper("Description") Then
					ProductsAndServicesAttributes.Insert("Description", DataVal);
					ProductDesc = ProductsAndServicesAttributes.Description;
				ElsIf Upper(CurProperty.Name) = Upper("SKU") Then
					ProductsAndServicesAttributes.Insert("SKU", DataVal);
				ElsIf Upper(CurProperty.Name) = Upper("BaseUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          DataVal.Code);
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", DataVal.Code, UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(	FoundTypeInTree, DataVal.Code, DataVal.Description, 
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("BaseUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("MeasurementUnit") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						UnOfMeasAttributes = New Structure;
						UnOfMeasAttributes.Insert("Code",          String(DataVal.Code));
						UnOfMeasAttributes.Insert("Description", DataVal.Description);
						UnOfMeas = ElectronicDocumentsOverridable.FindRefToObject("UOM", String(DataVal.Code),
							UnOfMeasAttributes);
						FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "UOM");
						FoundString = FindCreateStringInParsedTree(FoundTypeInTree, String(DataVal.Code), DataVal.Description,
							UnOfMeas, UnOfMeasAttributes, ParseTree, Error);
						If ValueIsFilled(UnOfMeas) Then
							ProductsAndServicesAttributes.Insert("MeasurementUnit", FoundString.RowIndex);
						EndIf;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Quantity") Then
					// Remember the number of packages that were
					ListTS.Add(Number(DataVal), "PackingQuantity");
					// Calculate
					// with account of the coefficient if there is the property UOM, get the value.
					Coeff = "";
					If Item.MeasurementUnit <> Undefined Then
						Coeff = Item.MeasurementUnit.Factor;
					EndIf;
					If Not ValueIsFilled(Coeff) Then
						Coeff = 1;
					EndIf;
					ListTS.Add(Coeff, "Factor");
					ListTS.Add(Number(DataVal) * Coeff, "Quantity");
				ElsIf Upper(CurProperty.Name) = Upper("AmountsByProduct") Then
					If TypeOf(DataVal) = Type("XDTODataObject") Then
						For Each CurProp IN DataVal.Properties() Do
							If Upper(CurProp.Name) = Upper("Tax") Then
								Taxes = DataVal.GetList(CurProp);
								For Each Tax IN Taxes Do
									If Upper(Tax.TaxType) = "VAT" Then
										ListTS.Add(Tax.TaxRateAmount,"VATRate");
										ListTS.Add(Tax.Amount, "VATAmount");
									EndIf;
								EndDo;
							ElsIf Upper(CurProp.Name) = Upper("AmountTotal") Then
								ListTS.Add(DataVal.AmountTotal, "SalesAmount");
							ElsIf Upper(CurProp.Name) = Upper("AmountWithoutTax") Then
								ListTS.Add(DataVal.AmountWithoutTax, "AmountWithoutVAT");
							EndIf;
						EndDo;
					EndIf;
				ElsIf Upper(CurProperty.Name) = Upper("Price") Then
					ListTS.Add(DataVal, "SalePrice");
				ElsIf Upper(CurProperty.Name) = Upper("PrincipalPrice") Then
					ListTS.Add(DataVal, "Price");
				ElsIf Upper(CurProperty.Name) = Upper("PrincipalAmount") Then
					ListTS.Add(DataVal, "Amount");
				ElsIf Upper(CurProperty.Name) = Upper("AdditionalAttributes") Then
					AreAdditAttributes = True;
					AdditAttributesStructure = New Structure;
					For Each DataItem IN DataVal Do
						
						If DataItem.Value.Count() > 1 Then
							ValueArray = New Array;
							For Each ValueItem IN DataItem.Value Do
							// For customer addresses parse address string to the structure of FTS address
							If DataItem.Description = "CustomerFactAddress" OR DataItem.Description = "CustomerLegAddress" Then
								ValueItem = SplitAddres(ValueItem);
							ElsIf DataItem.Description = "SaleDate" Then
								ValueItem = GetDateTimeFromString(ValueItem);
							EndIf;
							ValueArray.Add(ValueItem)
						EndDo;
							AdditAttributesStructure.Insert(DataItem.Description, ValueArray);
						Else
						
							ValueItem = DataItem.Value[0];
							// For customer addresses parse address string to the structure of FTS address
							If DataItem.Description = "CustomerFactAddress" OR DataItem.Description = "CustomerLegAddress" Then
								ValueItem = SplitAddres(ValueItem);
							ElsIf DataItem.Description = "SaleDate" Then
								ValueItem = GetDateTimeFromString(ValueItem);
							EndIf;
							AdditAttributesStructure.Insert(DataItem.Description, ValueItem);
						EndIf;
					EndDo;
				Else
					ListTS.Add(DataVal, CurProperty.Name);
				EndIf;
			EndDo;
			
			If AreAdditAttributes Then
				ListTS.Add(AdditAttributesStructure, "AdditionalAttributes");
			EndIf;
			
			IdStructure = ParseProductID(ProductId);
			ProductsAndServices = CatalogItemById("ProductsAndServices", IdStructure.ProductId);
			If ValueIsFilled(IdStructure.CharacteristicID) Then
				ProductsAndServicesCharacteristic = CatalogItemById("ProductsAndServicesCharacteristics",
					IdStructure.CharacteristicID);
				ListTS.Add(ProductsAndServicesCharacteristic, "Characteristic");
			EndIf;
			If ValueIsFilled(IdStructure.IDPackage) Then
				ProductsAndServicesPackaging = CatalogItemById("ProductsAndServicesPacking",
					IdStructure.IDPackage);
				ListTS.Add(ProductsAndServicesPackaging, "Package");
			EndIf;
			
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ProductsAndServices");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ProductId, ProductDesc, ProductsAndServices,
				ProductsAndServicesAttributes, ParseTree, Error);
			ListTS.Add(FoundString.RowIndex, "ProductsAndServices");
			
			AddObjectTSAttributes(NewED, "TSRow", ListTS);
			
		EndDo;
	EndIf;
	
EndProcedure

// For internal use only
Procedure FillRefsToObjectsInTree(ParseTree, Error) Export
	
	FilterWithoutRefsToObjects = New Structure;
	FilterWithoutRefsToObjects.Insert("ObjectReference", Undefined);
	ObjectTypesCreationOrder = ElectronicDocumentsOverridable.FillObjectTypesCreationOrderTable();
	For Each RowObjectType IN ObjectTypesCreationOrder Do
		FoundTypeString = ParseTree.Rows.Find(RowObjectType.ObjectType, "ObjectType");
		If FoundTypeString = Undefined Then
			Continue;
		EndIf;
		// Supplier's products and services will always be repopulated
		If RowObjectType.ObjectType = "SuppliersProductsAndServices" Then
			For Each ObjectString IN FoundTypeString.Rows Do
				ObjectReference = ElectronicDocumentsOverridable.CreateObjectVBD(ObjectString, ParseTree);
				If ValueIsFilled(ObjectReference) Then
					ObjectString.ObjectReference = ObjectReference;
				Else
					Text = StringFunctionsClientServer.SubstituteParametersInString(
						NStr("en='Failed to create catalog item ""%1""';ru='Ошибка создания элемента справочника ""%1""'"), RowObjectType.ObjectType);
					CommonUseClientServer.MessageToUser(Text);
					Error = True;
					Return;
				EndIf;
			EndDo;
		Else
			RowsWithoutReferencesToObjects = FoundTypeString.Rows.FindRows(FilterWithoutRefsToObjects);
			For Each ObjectString IN RowsWithoutReferencesToObjects Do
				ObjectReference = ElectronicDocumentsOverridable.CreateObjectVBD(ObjectString, ParseTree);
				If ValueIsFilled(ObjectReference) Then
					ObjectString.ObjectReference = ObjectReference;
				Else
					Text = StringFunctionsClientServer.SubstituteParametersInString(
						NStr("en='Failed to create catalog item ""%1""';ru='Ошибка создания элемента справочника ""%1""'"), RowObjectType.ObjectType);
					CommonUseClientServer.MessageToUser(Text);
					Error = True;
					Return;
				EndIf;
			EndDo;
		EndIf;
	EndDo;
	
EndProcedure

Procedure AddObjectHeaderAttribute(ItemString, AttributeName, AttributeValue, ObjectReference = Undefined)
	
	// Add to the header attributes ElectronicDocuments
	NewRow                   = ItemString.Rows.Add();
	NewRow.Attribute          = AttributeName;
	NewRow.AttributeValue = AttributeValue;
	If ObjectReference <> Undefined Then
		NewRow.ObjectReference = ObjectReference;
	EndIf;
	
EndProcedure

// For internal use only
Procedure AddObjectTSAttributes(ItemString, TSName, AttributesList)
	
	// Add to the attributes TS ElectronicDocuments
	NewRow          = ItemString.Rows.Add();
	NewRow.Attribute = TSName;
	For Each CurListItm IN AttributesList Do
		NewTSRow                   = NewRow.Rows.Add();
		NewTSRow.Attribute          = CurListItm.Presentation;
		NewTSRow.AttributeValue = CurListItm.Value;
	EndDo;
	
EndProcedure

Function FoundCreateObjectTypeInParseTree(ParseTree, ObjectTypeValue)
	
	FoundString = ParseTree.Rows.Find(ObjectTypeValue, "ObjectType");
	If FoundString = Undefined Then
		FoundString = ParseTree.Rows.Add();
		FoundString.ObjectType = ObjectTypeValue;
		FoundString.RowIndex = String(ParseTree.Rows.IndexOf(FoundString));
	EndIf;
	
	Return FoundString;
	
EndFunction

Function FindCreateStringInParsedTree(RowTypeInTree, IDObject, ObjectDescription, ObjectReference, AdditionalAttributes, ParseTree, Error)
	
	If ValueIsFilled(ObjectReference) Then
		FoundString = RowTypeInTree.Rows.Find(ObjectReference, "ObjectReference");
		If FoundString = Undefined Then
			FoundString = RowTypeInTree.Rows.Add();
			FoundString.ObjectReference = ObjectReference;
			FoundString.ID = IDObject;
			FoundString.ObjectDescription = ObjectDescription;
			FoundString.DescriptionOfType = DetermineObjectType(RowTypeInTree.ObjectType);
			FoundString.RowIndex = RowTypeInTree.RowIndex + "_"
				+ String(RowTypeInTree.Rows.IndexOf(FoundString));
			AddAdditAttributes(FoundString, AdditionalAttributes, ParseTree);
		Else
			If Not IsProductsAndServices(ObjectReference) Then
				AddAdditAttributes(FoundString, AdditionalAttributes, ParseTree);
				// Verify that Descriptions match on one link
				If FoundString.ObjectDescription <> ObjectDescription Then
					// Error: objects with different descriptions exist by reference in ED
					Error = True;
					MessageText = StringFunctionsClientServer.SubstituteParametersInString(
						NStr("en='Error in electronic document data: for one object <%1> two descriptions <%2> exist and <%3>';ru='Ошибка в данных эл.документа: на один Объект <%1>, два Описания <%2> и <%3>'"), ObjectReference,
						FoundString.ObjectDescription, ObjectDescription);
					CommonUseClientServer.MessageToUser(MessageText);
					FoundString.ObjectDescription = ObjectDescription;
				EndIf;
			Else
				// Products and services may have it when there are several items inc.data
				// has reference to one catalog item.
				FilterParameters = New Structure;
				FilterParameters.Insert("ObjectReference",  ObjectReference);
				FilterParameters.Insert("ObjectDescription", ObjectDescription);
				FilterParameters.Insert("ID",              IDObject);
				FoundStrings = RowTypeInTree.Rows.FindRows(FilterParameters);
				If FoundStrings.Count() = 0 Then
					FoundString = RowTypeInTree.Rows.Add();
					FoundString.ObjectReference  = ObjectReference;
					FoundString.ID              = IDObject;
					FoundString.ObjectDescription = ObjectDescription;
					FoundString.DescriptionOfType    = DetermineObjectType(
						RowTypeInTree.ObjectType);
					FoundString.RowIndex    = RowTypeInTree.RowIndex + "_" + String(RowTypeInTree.Rows.IndexOf(
						FoundString));
					AddAdditAttributes(FoundString, AdditionalAttributes, ParseTree);
				ElsIf FoundStrings.Count() = 1 Then
					FoundString = FoundStrings[0];
				Else // Unexpected
					// situation Error: objects with different descriptions exist in ED by the reference
					Error = True;
					MessageText = StringFunctionsClientServer.SubstituteParametersInString(
						NStr("en='Error in data of the electonic document: nonunique description for ID <%1>, Description <%2>';ru='Ошибка в данных эл.документа: неуникальное описание для ИД <%1>, Описание <%2>'"),
						IDObject, ObjectDescription);
					CommonUseClientServer.MessageToUser(MessageText);
				EndIf;
			EndIf;
		EndIf;
	ElsIf ValueIsFilled(IDObject) Then
		
		FoundString = RowTypeInTree.Rows.Find(IDObject, "ID");
		If FoundString = Undefined Then
			FoundString = RowTypeInTree.Rows.Add();
			FoundString.ID              = IDObject;
			FoundString.ObjectDescription = ObjectDescription;
			If ThisIsReferenceObject(RowTypeInTree.ObjectType) Then
				FoundString.DescriptionOfType = DetermineObjectType(
					RowTypeInTree.ObjectType);
			EndIf;
			FoundString.RowIndex    = RowTypeInTree.RowIndex + "_" + String(RowTypeInTree.Rows.IndexOf(
				FoundString));
			AddAdditAttributes(FoundString, AdditionalAttributes, ParseTree);
		Else
			Return FoundString;
		EndIf;
	Else
		FoundString = RowTypeInTree.Rows.Find(ObjectDescription, "ObjectDescription");
		If FoundString = Undefined Then
			FoundString = RowTypeInTree.Rows.Add();
			FoundString.ObjectDescription = ObjectDescription;
			FoundString.DescriptionOfType    = DetermineObjectType(
				RowTypeInTree.ObjectType);
			FoundString.RowIndex    = RowTypeInTree.RowIndex + "_" + String(RowTypeInTree.Rows.IndexOf(
				FoundString));
			AddAdditAttributes(FoundString, AdditionalAttributes, ParseTree);
		EndIf;
	EndIf;
	
	Return FoundString;
	
EndFunction

Procedure AddAdditAttributes(RowOfParseTree, AdditionalAttributes, ParseTree, Cancel = False)
	
	For Each CurItm IN AdditionalAttributes Do
		
		If Not TypeOf(CurItm.Value) = Type("XDTODataObject") Then
					
			If ValueIsFilled(CurItm.Value) Then
				If TypeOf(CurItm.Value) = Type("Array") AND Not CurItm.Key = "PropertyValues" AND Not CurItm.Key = "Images" Then
					For Each ArrayCurItm IN CurItm.Value Do
						If TypeOf(ArrayCurItm) = Type("Structure") Then
							AddAdditAttributes(RowOfParseTree, ArrayCurItm, ParseTree, Cancel);
						EndIf;
					EndDo;
				Else
					// Search as there might be already such attribute with the same value.
					FoundString = RowOfParseTree.Rows.Find(CurItm.Key, "Attribute", True);
					If FoundString <> Undefined AND FoundString.AttributeValue = CurItm.Value Then
						Continue;
					EndIf;
					
					NewRow = RowOfParseTree.Rows.Add();
					NewRow.Attribute          = CurItm.Key;
					NewRow.AttributeValue = CurItm.Value;
					// If RowIndex then try to find ReferenceToObject.
					If TypeOf(NewRow.AttributeValue) = Type("String") Then
						FoundString = ParseTree.Rows.Find(NewRow.AttributeValue, "RowIndex", True);
						If FoundString <> Undefined Then
							If ValueIsFilled(FoundString.ObjectReference) Then
								NewRow.ObjectReference = FoundString.ObjectReference;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
		EndIf;
		
	EndDo;
	
EndProcedure

Function ThisIsReferenceObject(ObjectType)
	
	If ObjectType = "Stamp" Then
		Return False;
	EndIf;
	
	Return True;
	
EndFunction

Function ParseProductID(val ID)
	
	ReturnStructure = New Structure("ProductID, CharacteristicID, PackageID");
	If Not ValueIsFilled(ID) Then
		Return ReturnStructure;
	EndIf;
	
	Pos = Find(ID, "#");
	If Pos > 0 Then
		
		ReturnStructure.ProductID = Mid(ID, 1 , Pos - 1);
		If StrLen(ID) > Pos Then
			
			ID = Mid(ID, Pos + 1);
			Pos = Find(ID, "#");
			If Pos > 0 Then
				ReturnStructure.CharacteristicID = Mid(ID, 1 ,Pos - 1);
			EndIf;
			
			If StrLen(ID) > Pos Then
				ReturnStructure.IDPackage = Mid(ID, Pos + 1);
			EndIf;
		EndIf;
	EndIf;
	
	Return ReturnStructure;
	
EndFunction

Function GenerateProductStructure()
	
	ReturnStructure = New Structure("ProductsAndServices, Characteristic, Package");
	Return ReturnStructure;
	
EndFunction

Function ConsumerDataFromAdditData(AdditDataTree)
	
	Customer = Undefined;
	RowHeader = AdditDataTree.Rows.Find("Header");
	If Not RowHeader = Undefined Then
		ConsumerDataStructure = New Structure;
		GenerateStructureByAdditData(RowHeader, ConsumerDataStructure);
		Customer = New Structure;
		ConsumerDescription = "";
		If ConsumerDataStructure.Property("Customer", ConsumerDescription) Then //LegalEntity
			Customer.Insert("FullDescr", ConsumerDescription);
			CustomerTIN = "";
			If ConsumerDataStructure.Property("CustomerTIN", CustomerTIN) Then
				Customer.Insert("TIN", CustomerTIN);
			EndIf;
			Customer.Insert("LegalEntityIndividual", ElectronicDocumentsReUse.FindEnumeration("LegalEntityIndividual", "LegalEntity"));
		Else // Ind
			SurnameConsumer = "";
			If ConsumerDataStructure.Property("CustomerSurname", SurnameConsumer) Then
				ConsumerDescription = SurnameConsumer;
			EndIf;
			NameConsumer = "";
			If ConsumerDataStructure.Property("CustomerName", NameConsumer) Then
				ConsumerDescription = ConsumerDescription + " " + NameConsumer;
			EndIf;
			ConsumerPatronimic = "";
			If ConsumerDataStructure.Property("CustomerPatronimic", ConsumerPatronimic) Then
				ConsumerDescription = ConsumerDescription + " " + ConsumerPatronimic;
			EndIf;
			Customer.Insert("FullDescr", ConsumerDescription);
			CustomerTIN = "";
			If ConsumerDataStructure.Property("CustomerTIN", CustomerTIN) Then
				Customer.Insert("TIN", CustomerTIN);
			EndIf;
			Customer.Insert("LegalEntityIndividual", ElectronicDocumentsReUse.FindEnumeration("LegalEntityIndividual", "Ind"));
		EndIf;
	EndIf;
	
	Return Customer;

EndFunction

// Returns reference to catalog item
//
// Parameters:
//  Description - String, name of the
//  catalog in ID metadata - Unique identifier of item
//
// Returns:
//  Reference to catalog item
//
Function CatalogItemById(Description, ID)
	
	Result = Undefined;
	
	AppliedCatalogName = ElectronicDocumentsReUse.GetAppliedCatalogName(Description);
	If ValueIsFilled(AppliedCatalogName) Then
		If ValueIsFilled(ID) Then
			UID = New UUID(ID);
			Result = Catalogs[AppliedCatalogName].GetRef(UID);
		Else
			Result = ElectronicDocumentsReUse.GetEmptyRef(Description);
		EndIf;
	EndIf;
	
	Return Result;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Xml reading by the scheme of CML2 version

Function DocumentAdditAttributeValue(AttributeName, ED)
	
	AttributeValue = Undefined;
	
	If Not TypeOf(ED.AttributeValues) = Type("XDTODataObject") Then
		Return AttributeValue;
	EndIf;
	
	For Each CurAttribute IN ED.AttributeValues.AttributeValue Do
		If Upper(CurAttribute.Description) = Upper(AttributeName) Then
			If CurAttribute.Value.Count() = 1 Then
				AttributeValue = CurAttribute.Value[0];
			Else
				AttributeValue = CurAttribute.Value;
			EndIf;
			Break;
		EndIf;
	EndDo;
	
	Return AttributeValue;
	
EndFunction

Function IsSimpleTypeItemXDTO(Item)
	
	ItIsSimpleType = True;
	PointType = TypeOf(Item);
	If PointType = Type("XDTOList")
		OR PointType = Type("XDTODataObject")
		OR PointType = Type("XDTODataValue") Then
		ItIsSimpleType = False;
	EndIf;
	
	Return ItIsSimpleType;
	
EndFunction

Function ThisAdditionalAttribute(DescriptionAttribute)
	
	CharacterNumber = Find(DescriptionAttribute, "add_");
	
	Return CharacterNumber > 0;
	
EndFunction

// Procedure reads the universal data structure of scheme
// 2 (developed for random data transfer in the header and tabular sections: list from the set of pairs:
// attribute name and list of attribute values.
//
// Parameters:
//  AttributeValues - XDTOList - list of attributes and values.
//  Receiver - String of data tree, list of values - tree string to which the extracted data
//    from xml file or values list are placed (when parsing products table).
//  Error - Boolean - error flag.
//
Procedure ReadValueListDetailsCML(AttributeValues, Receiver, Error, AdditionalAttributes = Undefined)
	
	AdditionalAttributes = New Structure;
	
	UsualAttributes = New Structure;

	For Each Attribute IN AttributeValues Do
		
		If Not TypeOf(Attribute.Value) = Type("XDTOList") Then
			Continue;;
		EndIf;
		
		If Not Attribute.Value.Count() > 0 Then
			Continue;
		EndIf;
		
		AttributeValue = Attribute.Value;
		
		If ThisAdditionalAttribute(Attribute.Description) Then
			RememberTreeAttributes(AdditionalAttributes, Attribute.Description, AttributeValue, Receiver, AdditionalAttributes);
		Else
			RememberTreeAttributes(UsualAttributes, Attribute.Description, AttributeValue, Receiver, AdditionalAttributes);
		EndIf;
		
	EndDo;
	
	If AdditionalAttributes.Count() > 0 Then
		
		AddAttributeToReceiver("AdditionalInformationDigitallySigned", AdditionalAttributes, Receiver)
		
	EndIf;
	
	For Each KeyValue IN UsualAttributes Do
		
		AddAttributeToReceiver(KeyValue.Key, KeyValue.Value, Receiver);
		
	EndDo;
	
EndProcedure

Function AdditionalAttributeValue(AttributeValue)
	
	ValueArray = New Array;
	For Each Value IN AttributeValue Do
		ValueArray.Add(Value);
	EndDo;
	AttributeValue = ?(ValueArray.Count() > 1, ValueArray, ValueArray[0]);
	
	Return AttributeValue;
	
EndFunction

Procedure RememberTreeAttributes(AttributesStructure, DescriptionAttribute, AttributeValue, Receiver, AdditionalAttributes)
	
	AttributeName = StrReplace(DescriptionAttribute, "add_", "");
	
	If AdditionalAttributes = Undefined Then
		AdditionalAttributes = New Structure;
	EndIf;
	
	If Find(AttributeName, "_Table") > 0 Then
		
		AttributeName = StrReplace(AttributeName, "_Table", "");
		AttributeValue = TableFromRow(AttributeValue);
		
		If Upper(AttributeName) = Upper("BasisDocuments")
			Or Upper(AttributeName) = Upper("BasisDocument") Then
			
			ArrayBEFORE = New Array;
			
			For Each CurRow IN AttributeValue Do
				
				BasisDocument = GetBasisDocument(CurRow.Description, AdditionalAttributes);
				ArrayBEFORE.Add(BasisDocument);
			EndDo;
			
			If ArrayBEFORE.Count() = 1 Then
				AttributeValue = ArrayBEFORE[0];
			Else
				AttributeValue = ArrayBEFORE;
			EndIf;
			
		EndIf;
		
	ElsIf Upper(AttributeName) = Upper("TransactionDocuments") Then
		
		AttributeValue = TableFromRow(AttributeValue);
		
	ElsIf Upper(AttributeName) = Upper("PriceIncludesVAT") Then
		
		PriceIncludesVAT = AdditionalAttributeValue(AttributeValue);
		
		If Upper(PriceIncludesVAT) = Upper("false") Then
			AttributeValue = False;
		ElsIf Upper(PriceIncludesVAT) = Upper("true") Then
			AttributeValue = True;
		EndIf;
		
	ElsIf Upper(AttributeName) = Upper("DateOfCorrection") Then
		
		CorrectionDateValue = AdditionalAttributeValue(AttributeValue);
		Try
			AttributeValue = DateFromString(CorrectionDateValue);
		Except
			AttributeValue = DateDD_MM_YYYY(CorrectionDateValue);
		EndTry;
	Else
		AttributeValue = AdditionalAttributeValue(AttributeValue);
		
	EndIf;
	
	AttributesStructure.Insert(AttributeName, AttributeValue);
	
EndProcedure

Function TableFromRow(Val AttributeValues)
	
	TableDisplay = AttributeValues[0];
	
	Try
		ResultTable = ValueFromStringInternal(TableDisplay);
	Except
		Try
			ResultTable = TableFromRowWithDelimiter(TableDisplay);
		Except
		    Return New ValueTable;
		EndTry;
	EndTry;
	
	Return ResultTable;
	
EndFunction

Procedure AddAttributeToReceiver(DescriptionAttribute, AttributeValue, Receiver)
	
	If TypeOf(Receiver) = Type("ValueList") Then
		Receiver.Add(AttributeValue, DescriptionAttribute);
	Else
		
		AddObjectHeaderAttribute(Receiver, DescriptionAttribute, AttributeValue);
		
	EndIf;
	
EndProcedure

Procedure ReadCounterpartyDataCML(Item, ED, ParseTree, NewED, Error, Role = "", AdditParameters = Undefined, CounterpartiesIdArray = "")

	CounterpartyKind  = "";
	AdditAnalyticsKind = "";
	If Role = "Vendor"
		OR (Role = "Licensor" OR Role = "Agent") AND NewED.EDDirection = Enums.EDDirections.Outgoing
		OR (Role = "Licensee" OR Role = "Consignor") AND NewED.EDDirection = Enums.EDDirections.Incoming
		OR Role = "Seller"
		OR Role = "Performer" Then
		CounterpartyKind = "Companies";
		AttributeName = "Company";
		BankAccountKind = "BankAccountsOfTheCompany";
	ElsIf Role = "Customer"
		OR (Role = "Licensee" OR Role = "Consignor") AND NewED.EDDirection = Enums.EDDirections.Outgoing
		OR (Role = "Licensor" OR Role = "Agent") AND NewED.EDDirection = Enums.EDDirections.Incoming Then
		
		CounterpartyKind = "Counterparties";
		AttributeName = "Counterparty";
		BankAccountKind = "BankAccountsOfCounterparties";
		AdditAnalytics = "Partner";
		AdditAnalyticsKind = "partners";
		
	ElsIf Role = "Payer" Or Role = "Recipient" Then
		CounterpartyKind = "Counterparties";
		AttributeName = Role;
		BankAccountKind = "BankAccountsOfCounterparties";
		AdditAnalytics = "Partner";
	ElsIf Role = "CommissionGoodsBuyer" Then
		CounterpartyKind = "Counterparties";
		AttributeName = "Customer";
		BankAccountKind = "BankAccountsOfCounterparties";
		AdditAnalytics = "Partner";
	EndIf;
	
	CounterpartyAttributes = New Structure;
	For Each CurProperty IN Item.Properties() Do
		
		DataVal = Item[CurProperty.Name];
		
		If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
		ElsIf Not ValueIsFilled(DataVal) Then
			Continue;
		EndIf;
		
		If Upper(CurProperty.Name) = Upper("ID") Then
			
			CounterpartyId = DataVal;
			// Parse ID for TIN
			SearchStructure = ParseCounterpartyID(CounterpartyId);
			If SearchStructure.Property("TIN") Then
				CounterpartyAttributes.Insert("TIN", SearchStructure.TIN);
			EndIf;
			
			// IN case of commission trade, there may be
			// several counterparties in ED, some of which may have matching
			// identifiers (Consignor/Commission agent and Buyer), in this case, it is required to add only data of Consignor/Commission agent to parsing tree.
			If CounterpartyKind = "Counterparties"
				AND TypeOf(CounterpartiesIdArray) = Type("Array") Then
				If CounterpartiesIdArray.Find(CounterpartyId) = Undefined Then
					CounterpartiesIdArray.Add(CounterpartyId);
				Else
					Continue;
				EndIf;
			EndIf;
		ElsIf Upper(CurProperty.Name) = Upper("OfficialName")
			OR Upper(CurProperty.Name) = Upper("FullDescr") Then
			CounterpartyAttributes.Insert("FullDescr", DataVal);
			LegalEntityIndividual = ?(Upper(CurProperty.Name) = Upper("FullDescr"), "Ind", "LegalEntity");
			CounterpartyAttributes.Insert("LegalEntityIndividual", ElectronicDocumentsReUse.FindEnumeration("LegalEntityIndividual", LegalEntityIndividual));
		ElsIf Upper(CurProperty.Name) = Upper("Address") OR Upper(CurProperty.Name) = Upper("LegalAddress") Then
			If Role = "Payer" OR Role = "Vendor" Then
				AddressPrefix = "LegalAddress";
			Else
				AddressPrefix = ?(Upper(CurProperty.Name) = Upper("Address"), "ActualAddress", "LegalAddress");
			EndIf;
			For Each Property IN DataVal.Properties() Do
				Attribute = DataVal[Property.Name];
				If Attribute <> Undefined Then
					If Upper(Property.Name) = Upper("Presentation") Then
						CounterpartyAttributes.Insert(AddressPrefix + "_Presentation", Attribute);
					ElsIf Upper(Property.Name) = Upper("AddressField") Then
						StructureOfAddress = New Structure;
						For Each ItemOfAddress IN Attribute Do
							NormType = ItemOfAddress.Type;
							If NormType = "Postal index" Then
								NormType = "IndexOf";
							ElsIf NormType = "Region" Then
								NormType = "CodeState";
							ElsIf NormType = "Settlement" Then
								NormType = "Settlement";
							ElsIf NormType = "Apartment" Then
								NormType = "Qart";
							EndIf;
							StructureOfAddress.Insert(NormType, ItemOfAddress.Value);
						EndDo;
						If ValueIsFilled(StructureOfAddress) Then
							CounterpartyAttributes.Insert("AddressStructure", StructureOfAddress);
						EndIf;
					Else
						CounterpartyAttributes.Insert(Property.Name, Attribute);
					EndIf;
				EndIf;
			EndDo;
		ElsIf Upper(CurProperty.Name) = Upper("Head") Then
			StAttributes = New Structure;
			For Each Property IN DataVal.Properties() Do
				Attribute = DataVal[Property.Name];
				If Attribute <> Undefined Then
					If IsSimpleTypeItemXDTO(Attribute) Then
						StAttributes.Insert(Attribute, Property.Name);
					EndIf;
				EndIf;
			EndDo;
			CounterpartyAttributes.Insert("Head", StAttributes);
		ElsIf Upper(CurProperty.Name) = Upper("Contacts") Then
			ContactsTable = New ValueTable();
			ContactsTable.Columns.Add("Kind");
			ContactsTable.Columns.Add("Presentation");
			ContactsTable.Columns.Add("FieldsValues");
			For Each Contact in DataVal.Contact Do
				Kind = Undefined;
				If Contact.Type = "Mail" Then
					Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyEmail");
				ElsIf Contact.Type = "Work phone" Then
					Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyPhone");
				ElsIf Contact.Type = "Fax" Then
					Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyFax");
				EndIf;
				If ValueIsFilled(Kind) Then // add only if there are kinds of contact information in the receiving configuration
					NewCont = ContactsTable.Add();
					NewCont.Type = Kind;
					NewCont.Presentation = Contact.Value;
					NewCont.FieldsValues = Contact.Comment;
				EndIf;
			EndDo;
			CounterpartyAttributes.Insert(CurProperty.Name, ContactsTable);

		Else
			CounterpartyAttributes.Insert(CurProperty.Name, DataVal);
		EndIf;
		
	EndDo;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, CounterpartyKind);
	Counterparty = ElectronicDocumentsOverridable.FindRefToObject(CounterpartyKind, CounterpartyId, CounterpartyAttributes);
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: " + CounterpartyId,
		Counterparty, CounterpartyAttributes, ParseTree, Error);
	If Role <> "CommissionGoodsBuyer" Then
		AddObjectHeaderAttribute(NewED, AttributeName, FoundString.RowIndex);
	EndIf;
	
	CurrentAccountInAdditData = False;
	If TypeOf(AdditParameters) = Type("Structure") Then
		If AdditParameters.Property("BankAccount") Then
			CurrentAccountInAdditData = True;
		EndIf;
	EndIf;
	
	// Define current account of the counterparty
	If Not TypeOf(Item) = Type("Structure") Then
		If Item.Properties().Get("BankAccount") <> Undefined
			AND TypeOf(Item.BankAccount) = Type("XDTODataObject") Then
			
			If NewED.EDKind = Enums.EDKinds.InvoiceForPayment Then
				If Upper(Role) = Upper("Seller") AND Not CurrentAccountInAdditData Then
					ReadDataByBankAccount(NewED, Item.BankAccount, ParseTree,
						"BankAccountsOfCounterparties", Role, Counterparty, Error);
				EndIf;
			Else
				
				ReadDataByBankAccount(NewED, Item.BankAccount, ParseTree,
												 BankAccountKind, Role, Counterparty, Error);
			EndIf;
		EndIf;
		
		If Item.Properties().Get("BankAccounts") <> Undefined
			AND TypeOf(Item.BankAccounts) = Type("XDTODataObject") Then
			
			If Upper(NewED.EDKind) = Upper("CompanyAttributes") Then
				
				
				// This procedure reads the current accounts of a counterparty and adds them as rows of document tabular section.
				// Used when details of a company are exchanged.
				ReadDataOnCounterpartyCMLCurrentAccounts(NewED, Item.BankAccounts, ParseTree,
					BankAccountKind, Role, Counterparty, Error);
			Else
				
				For Each BankAccount IN Item.BankAccounts.BankAccount Do
					ReadDataByBankAccount(FoundString, BankAccount, ParseTree,
						BankAccountKind, Role, Counterparty, Error);
				EndDo;
			EndIf;
			
		EndIf;
	EndIf;
	
	// During reading of document InvoiceForPayment CML in AdditParameters the structure
	// with CurrentAccount details is transferred which is located in the header of template "InvoiceForPayment" of data processor "ElectronicDocuments".
	If CurrentAccountInAdditData Then
		ReadDataByBankAccount(NewED, AdditParameters.BankAccount, ParseTree,
										 BankAccountKind, Role, Counterparty, Error);
	EndIf;
	
	// Add additional analytics if filled in
	If ValueIsFilled(AdditAnalyticsKind) Then
		If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
			AttributesOfPartner = New Structure();
			AttributesOfPartner.Insert("Counterparty", Counterparty);
			AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("partners");
			
			ValAdditAnalytics = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, , AttributesOfPartner);
			If ValueIsFilled(ValAdditAnalytics) Then
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "partners");
				FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ValAdditAnalytics.Code, "Code: "
					+ ValAdditAnalytics.Code, ValAdditAnalytics, AttributesOfPartner, ParseTree, Error);
				AddObjectHeaderAttribute(NewED, "Partner", FoundString.RowIndex);
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// Procedure reads simple list containing items of simple types (string, number, ...).
// Read data of list item is placed to the structure (key - parameter name, value - value),
// structures of parameters are placed in the array, the array is written in the
// values tree with the name of XDTO object, the element of which is the list.
//
// Parameters:
//  XDTODataObject - XDTO object - object that contains a single item - readable XDTO list.
//  NewED - value tree row - String of data tree to which the array of read data is placed.
//  Error - String - text of the error which occurred during processing of XDTO list.
//
Procedure DataListValuesOfCML(XDTODataObject, NewED, Error)
	
	StructuresArray = New Array;
	PropertiesOfObject = XDTODataObject.Properties();
	If PropertiesOfObject.Count() > 0 Then
		If PropertiesOfObject[0].UpperBound = -1 Then
			ListName = PropertiesOfObject[0].Name;
			For Each ItemOfList IN XDTODataObject[ListName] Do
				DataStructure = New Structure;
				For Each Item IN ItemOfList.Properties() Do
					Value = ItemOfList[Item.Name];
					DataStructure.Insert(Item.Name, Value);
				EndDo;
				StructuresArray.Add(DataStructure);
			EndDo;
		EndIf;
	EndIf;
	
	If StructuresArray.Count() > 0 Then
		AddObjectHeaderAttribute(NewED, XDTODataObject.OwningProperty().Name, StructuresArray);
	EndIf;
	
EndProcedure

Function GroupValueInTree(DataTree, FullPath) 
	
	FoundString = DataTree.Rows.Find(FullPath, "FullPath", True);
	If FoundString <> Undefined Then
		Return FoundString.Rows;
	EndIf;
	
EndFunction

Function TreeAttributeRef(Tree, TreeRow, AttributeName)
	
	AttributeIndex = GetParsedTreeStringAttributeValue(Tree, TreeRow, AttributeName);
	If AttributeIndex = Undefined Then
		Return Undefined;
	EndIf;
	
	Delimiter = Find(AttributeIndex,"_");
	IndexIndicator = Left(AttributeIndex, Delimiter - 1);
	
	RowsAttributeRef = Tree.Rows.Find(IndexIndicator, "RowIndex");
	If RowsAttributeRef = Undefined Then
		Return Undefined;
	EndIf;
	
	AttributeString = RowsAttributeRef.Rows[0];
	
	Return AttributeString.ObjectReference;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Work with parsing tree

Function IsParsingTreeRefferentialValue(ParseTree, Value, RowOnLink = Undefined)
	
	ValueByString = String(Value);
	
	If Find(ValueByString, "_") > 0 Then
		RowOnLink =  ParseTree.Rows.Find(ValueByString, "RowIndex", True);
	EndIf;
	
	Return ?(RowOnLink = Undefined, False, True);
	
EndFunction

// For internal use only
Function GetParsedTreeStringAttributeValue(ParseTree, TreeRow, PathToAttribute) Export
	
	DotPos = Find(PathToAttribute, ".");
	If DotPos > 0 Then
		MainAttributeName     = Left(PathToAttribute, DotPos - 1);
		SubordinateAttributeName = Right(PathToAttribute, StrLen(PathToAttribute) - DotPos);
	Else
		MainAttributeName     = PathToAttribute;
		SubordinateAttributeName = "";
	EndIf;
	
	MainAttribute = TreeRow.Rows.Find(MainAttributeName, "Attribute");
	
	If MainAttribute <> Undefined Then
		MainAttributeValue = MainAttribute.AttributeValue;
		If SubordinateAttributeName <> "" Then
			RowOnLink = Undefined;
			If IsParsingTreeRefferentialValue(ParseTree, MainAttributeValue, RowOnLink) Then
				Return GetParsedTreeStringAttributeValue(ParseTree, RowOnLink, SubordinateAttributeName);
			EndIf;
			
			// Not possibile to get the value of a subordinate attribute.
			Return Undefined;
		Else
			// Not necessary to receive the value of a subordinate attribute.
			Return MainAttributeValue
		EndIf;
	Else
		// Such attribute does not exist.
		Return Undefined;
	EndIf;
	
EndFunction

// Returns tree with file data
//
// Parameters:
//  FullFileName - String,
//  path to file EDDirection - EnumRef.EDDirections - direction of
//  electronic document AdditDataFile - String, path to the
//  file with additional data ImagesFile - String,  path to file - archive containing images
//
// Returns:
//  Structure - tree data
//
Function GenerateParseTree(FullFileName, EDDirection = Undefined, AdditDataFile = Undefined, PicturesFile = Undefined) Export
	
	ParseTree = InitializeParseTree();
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "ElectronicDocuments");
	NewED = FoundTypeInTree.Rows.Add();
	
	If EDDirection = Undefined Then
		NewED.EDDirection = Enums.EDDirections.Incoming;
	Else 
		NewED.EDDirection = EDDirection;
	EndIf;
	
	If AdditDataFile <> Undefined Then
		AdditDataTree = ParseUniversalAdditFile(AdditDataFile);
		DeleteFiles(AdditDataFile);
		AddObjectHeaderAttribute(NewED, "AdditDataTree", AdditDataTree);
	EndIf;
	
	If PicturesFile <> Undefined Then
		ImagesTree = ImagesTree(PicturesFile);
		AddObjectHeaderAttribute(NewED, "ImagesTree", ImagesTree);
	EndIf;
	
	Result = ReadFileCMLbyXDTO(FullFileName, ParseTree, NewED);
	
	If Not Result Then // ED parsing error
		Return Undefined;
	EndIf;
	
	FoundString = ParseTree.Rows.Find("ElectronicDocuments","ObjectType"); // section ElectronicDocuments
	ObjectString = FoundString.Rows[0];
	
	Return New Structure("ParsingTree, ObjectRow", ParseTree, ObjectString);
	
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Work with Agreement on cost change

Procedure FillInHeaderAttributesCostCorrection(PrintInfo, Template, SpreadsheetDocument)

	TitlePart1 = StringFunctionsClientServer.SubstituteParametersInString(NStr("en='Agreement on the change of cost of No %1 from %2';ru='Соглашение об изменении стоимости № %1 от %2'"),
														PrintInfo.DocumentNumber, Format(PrintInfo.DocumentDate, "DF=dd.MM.yyyy"));
	TitlePart2 = ?(ValueIsFilled(PrintInfo.CorrectionNumber), 
				StringFunctionsClientServer.SubstituteParametersInString(NStr("en=', correction No %1 from %2';ru=', исправление № %1 от %2'"),
				PrintInfo.CorrectionNumber, Format(Date(PrintInfo.DateOfCorrection), "DF=dd.MM.yyyy")), "");
				
	TitlePart3 = ?(ValueIsFilled(PrintInfo.OriginalDocumentPresentation), PrintInfo.OriginalDocumentPresentation
						+ StringFunctionsClientServer.SubstituteParametersInString(NStr("en=' No %1 from %2';ru=' № %1 от %2'"),
						PrintInfo.InitialDocumentNumber,
						Format(Date(PrintInfo.InitialDocumentDate), "DF=dd.MM.yyyy")), "");
						
	TitlePart4 = ?(ValueIsFilled(PrintInfo.SourceDocumentCorrectionNumber),
				StringFunctionsClientServer.SubstituteParametersInString(NStr("en=' with account of correction No %1 from %2';ru=' с учетом исправления № %1 от %2'"),
				PrintInfo.SourceDocumentCorrectionNumber, Format(Date(PrintInfo.SourceDocumentCorrectionDate),"DF=dd.MM.yyyy")), "");
				
	HeaderText = TitlePart1 + TitlePart2 + Chars.CR + TitlePart3 + TitlePart4;
		
	TemplateAreaHeader = Template.GetArea("Title");
	TemplateAreaHeader.Parameters.Title = HeaderText;
	SpreadsheetDocument.Put(TemplateAreaHeader);
	
		
	TemplateArea = Template.GetArea("Header");
	TemplateArea.Parameters.Fill(PrintInfo);
	
	TemplateArea.Parameters.Basis = 
		?(ValueIsFilled(PrintInfo.BasisDescription), PrintInfo.BasisDescription, "")
		+ ?(ValueIsFilled(PrintInfo.BasisNumber), " # " + PrintInfo.BasisNumber, "")
		+ ?(ValueIsFilled(PrintInfo.BasisDate), " dated " + Format(PrintInfo.BasisDate, "DLF=D"), "");
		
	TemplateArea.Parameters.VendorPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutVendor,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,AccountNo,Bank,BIN");
	
	TemplateArea.Parameters.PayerPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutCustomer,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,AccountNo,Bank,BIN");
		
	SpreadsheetDocument.Put(TemplateArea);

EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with TORG-12

Function GetConsignmentDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.ActualAddress_Presentation"));
	InfoAboutCounterparty.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.AccountNumber"));
	InfoAboutCounterparty.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Description"));
	InfoAboutCounterparty.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Code"));
	InfoAboutCounterparty.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	InfoAboutCounterparty.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.PhoneNumbers"));
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.FullDescr"));
	InformationAboutCompany.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.TIN"));
	InformationAboutCompany.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.LegalAddress_Presentation"));
	InformationAboutCompany.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.ActualAddress_Presentation"));
	InformationAboutCompany.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CompanyBankAcc.AccountNumber"));
	InformationAboutCompany.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.Description"));
	InformationAboutCompany.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.Code"));
	InformationAboutCompany.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.CorrAccount"));
	InformationAboutCompany.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.PhoneNumbers"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
		
		FillingDataHeader.Insert("CompanyByOKPO",       GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.OKPO"));
		FillingDataHeader.Insert("VendorPresentation", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.Name"));
		FillingDataHeader.Insert("VendorByOKPO",         GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.OKPO"));
		FillingDataHeader.Insert("PayerPresentation",GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.Name"));
		FillingDataHeader.Insert("PayerByRCEO",        GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.OKPO"));
		FillingDataHeader.Insert("ConsigneeByARBOC",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.OKPO"));
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
		
		FillingDataHeader.Insert("CompanyByOKPO",       GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.OKPO"));
		FillingDataHeader.Insert("VendorPresentation", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.Name"));
		FillingDataHeader.Insert("VendorByOKPO",         GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.OKPO"));
		FillingDataHeader.Insert("PayerPresentation",GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.Name"));
		FillingDataHeader.Insert("PayerByRCEO",        GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.OKPO"));
		FillingDataHeader.Insert("ConsigneeByARBOC",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.OKPO"));
	EndIf;
	
	InfoAboutShipper = New Structure;
	InfoAboutShipper.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.FullDescr"));
	InfoAboutShipper.Insert("TIN", 				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.TIN"));
	InfoAboutShipper.Insert("LegalAddress",	 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.LegalAddress_Presentation"));
	InfoAboutShipper.Insert("ActualAddress",	 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.ActualAddress_Presentation"));
	InfoAboutShipper.Insert("AccountNo",		 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsignorBankAccount.AccountNumber"));
	InfoAboutShipper.Insert("Bank",				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.Description"));
	InfoAboutShipper.Insert("BIN",				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.Code"));
	InfoAboutShipper.Insert("CorrAccount",			 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.CorrAccount"));
	InfoAboutShipper.Insert("PhoneNumbers",			 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.PhoneNumbers"));
	
	FillingDataHeader.Insert("InfoAboutShipper", InfoAboutShipper);
	
	InfoAboutConsignee = New Structure;
	InfoAboutConsignee.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.FullDescr"));
	InfoAboutConsignee.Insert("TIN", 			   	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.TIN"));
	InfoAboutConsignee.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.LegalAddress_Presentation"));
	InfoAboutConsignee.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.ActualAddress_Presentation"));
	InfoAboutConsignee.Insert("AccountNo",		 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.AccountNumber"));
	InfoAboutConsignee.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.Description"));
	InfoAboutConsignee.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.Code"));
	InfoAboutConsignee.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.CorrAccount"));
	InfoAboutConsignee.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "MeansPhoneNumbers"));
	
	FillingDataHeader.Insert("InfoAboutConsignee", InfoAboutConsignee);
	
	FillingDataHeader.Insert("DepartmentsPresentation", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.StructuralDepartment"));
	
	FillingDataHeader.Insert("BasisNumber", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "NumberByCustomerData"));
	FillingDataHeader.Insert("BasisDate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateByCustomerData"));
	FillingDataHeader.Insert("BasisDescription", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BasisDescription"));
	
	FillingDataHeader.Insert("DocumentNumber",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number"));
	FillingDataHeader.Insert("DocumentDate",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date"));
	
	FillingDataHeader.Insert("ExchangeRate", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ExchangeRate"));
	FillingDataHeader.Insert("CurrencyCode",         GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Currency.Description"));
	FillingDataHeader.Insert("PriceIncludesVAT", 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PriceIncludesVAT"));
	FillingDataHeader.Insert("ShippingAddress", 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShippingAddress"));
	
	DateOfCorrection = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfCorrection");
	If ValueIsFilled(DateOfCorrection) Then
		FillingDataHeader.Insert("DateOfCorrection",	Date(DateOfCorrection));
		FillingDataHeader.Insert("CorrectionNumber",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CorrectionNumber"));
	EndIf;

	
	FillingDataFooter = New Structure;
	
	FillingDataFooter.Insert("SheetsCountInApplication", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SheetsCountInApplInWords"));
	FillingDataFooter.Insert("RecordsSequenceNumbersQuantityInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "RecordsCountInWords"));
	FillingDataFooter.Insert("TotalPlacesInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PlacesCountInWords"));
	FillingDataFooter.Insert("CargoWeightInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CargoWeightInWords"));
	FillingDataFooter.Insert("CargoNetWeightInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CargoNetWeightInWords"));

	FillingDataFooter.Insert("AmountInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AmountTotalInWords"));
	FillingDataFooter.Insert("DateReleased", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DateReleased"));
	
	FillingDataFooter.Insert("HeadPost", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ManagerPosition"));
	FillingDataFooter.Insert("ChiefAccountantPosition", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ChiefAccountantPosition"));
	FillingDataFooter.Insert("WarehousemanPosition", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.StorekeeperPosition"));
	FillingDataFooter.Insert("HeadDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ManagerName"));
	FillingDataFooter.Insert("NameAndSurnameOfChiefAccountant", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ChiefAccountantDescriptionFull"));
	FillingDataFooter.Insert("WarehouseManSNP", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.StorekeeperName"));
	
	VT = New ValueTable;
	
	VT.Columns.Add("ProductCode");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("PackagingKind");
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("BaseUnitCodeRCUM");
	VT.Columns.Add("BaseUnitDescription");
	VT.Columns.Add("Price", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Amount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("VATAmount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("SumWithVAT", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Quantity", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("NetWeight", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("GrossWeight", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("PlacesQuantity", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("QuantityInOnePlace", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	
	
	ProductsAndServicesName = "ProductsAndServices";
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		
		NewRow.ProductCode = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductCode");
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Description");
		
		CharacteristicDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "CharacteristicDescription");
		If ValueIsFilled(CharacteristicDescription) Then
			NewRow.ProductDescription = NewRow.ProductDescription + ", " + CharacteristicDescription;
		EndIf;
		
		Kind = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Kind");
		If ValueIsFilled(Kind) Then
			NewRow.ProductDescription = NewRow.ProductDescription + ", " + Kind;
		EndIf;
		
		SKU = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SKU");
		If ValueIsFilled(SKU) Then
			NewRow.ProductDescription = NewRow.ProductDescription + ", " + SKU;
		EndIf;

		NewRow.BaseUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "MeasurementUnitDescription");
		NewRow.BaseUnitCodeRCUM = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "MeasurementUnitCode");
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
		NewRow.QuantityInOnePlace = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "QuantityInOnePlace");
		
		NewRow.PlacesQuantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Places");
		
		NewRow.GrossWeight = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "GrossWeight");
		NewRow.NetWeight = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "NetWeight");
		
		NewRow.PackagingKind = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Package");
		
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SumWithVAT");
		NewRow.VATAmount = ?(ValueIsFilled(NewRow.VATAmount),NewRow.VATAmount,0);
		If Not ValueIsFilled(NewRow.VATRate) Then
			NewRow.VATRate = NStr("en='Without VAT';ru='без НДС'");
		Else
			NewRow.VATRate = String(NewRow.VATRate);
		EndIf;
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", FillingDataHeader);
	DataForObject.Insert("Footer", FillingDataFooter);
	DataForObject.Insert("Products", VT);
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	Return DataForObject;
	
EndFunction

// Procedure populates tabular document TORG12.
//
Procedure FillInTabularDocumentTORG12_ED(SpreadsheetDocument, PrintInfo, BuyerData)
	
	SpreadsheetDocument.LeftMargin = 5;
	SpreadsheetDocument.RightMargin = 5;
	SpreadsheetDocument.HeaderSize = 0;
	SpreadsheetDocument.FooterSize = 0;
	SpreadsheetDocument.FitToPage = True;
	SpreadsheetDocument.PageOrientation = PageOrientation.Landscape;
	
	Template = Catalogs.EDAttachedFiles.GetTemplate(?(BuyerData.Count() > 0, "ED_CustomerTORG12", "ED_TORG12"));
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_ED_TORG12";
	
	FillHeaderAttributesTORG12(PrintInfo.Header, Template, SpreadsheetDocument);
	
	PageNumber = 1;
	TotalAmounts = StructureTotalAmounts();
	
	CoefficientConversion = 1;
	RowData = StructureStringData(CoefficientConversion);
	
	// Create array to check output
	OutputedAreasArray = New Array;
	
	// Displaying multiline part of the document
	AreaTitleTables = Template.GetArea("TabTitle|TableMainData");
	TemplateArea           = Template.GetArea("Row|TableMainData");
	TotalsAreaByPage = Template.GetArea("TotalByPage|TableMainData");
	AreaTotal            = Template.GetArea("Total|TableMainData");
	FooterArea          = Template.GetArea("Footer");
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataTableRows = New ValueTable;
	AdditDataTableRows.Columns.Add("NumberStr");
	AdditDataTableRows.Columns.Add("DigitallySignedData");
	AdditDataTableRows.Columns.Add("UnDigitallySignedData");
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		AreaTitleTablesDD = Template.GetArea("TabTitle|TableAdditData");
		AreaTemplateDD           = Template.GetArea("Row|TableAdditData");
		AreaTableTitleDDSES = Template.GetArea("TableTitle|TableWithEDSAdditData");
		DDSESTemplateArea           = Template.GetArea("Row|TableWithEDSAdditData");
		AreaTableTitleDDBWithoutES = Template.GetArea("TabTitle|TableWithoutEDSAdditData");
		TemplateAreaDDWithoutES           = Template.GetArea("Row|TableWithoutEDSAdditData");
	EndIf;
	
	// Display tabular section of the document
	TSProducts = PrintInfo.Products;
	
	LineCount = TSProducts.Count();
	
	For Each ProductsRow IN TSProducts Do
		
		RowData.Number = RowData.Number + 1;
		
		TemplateArea.Parameters.Fill(ProductsRow);
		
		RowData.Places = ProductsRow.PlacesQuantity;
		
		RowData.CoefficientConversion  = ?(ValueIsFilled(ProductsRow.QuantityInOnePlace),ProductsRow.QuantityInOnePlace,1);
		RowData.Quantity  = ProductsRow.Quantity;
		RowData.GrossWeight = ProductsRow.GrossWeight;
		
		RowData.Amount     = ProductsRow.Amount;
		RowData.VATAmount  = ProductsRow.VATAmount;
		RowData.SumWithVAT = ProductsRow.SumWithVAT;
		
		RowData.Price = ProductsRow.Price;
		
		TemplateArea.Parameters.Fill(RowData);
		
		
		If RowData.Number = 1 Then // first string
			
			AreaTitleTables.Parameters.PageNumber = "Page " + PageNumber;
			SpreadsheetDocument.Put(AreaTitleTables);
			If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
				SpreadsheetDocument.Join(AreaTitleTablesDD);
			Else
				If AdditDataExistanceStructure.AreDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDSES);
				EndIf;
				If AdditDataExistanceStructure.AreNotDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
				EndIf;
			EndIf;
			
		Else
			
			OutputedAreasArray.Clear();
			OutputedAreasArray.Add(TemplateArea);
			OutputedAreasArray.Add(TotalsAreaByPage);
			
			If RowData.Number = LineCount Then
				
				OutputedAreasArray.Add(AreaTotal);
				OutputedAreasArray.Add(FooterArea);
				
			EndIf;
			
			If RowData.Number <> 1 AND Not SpreadsheetDocumentFitsPage(SpreadsheetDocument,OutputedAreasArray) Then
				
				TotalsAreaByPage.Parameters.Fill(TotalAmounts);
				SpreadsheetDocument.Put(TotalsAreaByPage);
				
				// Clear results for a page.
				ResetTotalsByPage(TotalAmounts);
				
				PageNumber = PageNumber + 1;
				SpreadsheetDocument.PutHorizontalPageBreak();
				AreaTitleTables.Parameters.PageNumber = "Page " + PageNumber;
				SpreadsheetDocument.Put(AreaTitleTables);
				If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
					SpreadsheetDocument.Join(AreaTitleTablesDD);
				Else
					If AdditDataExistanceStructure.AreDigitallySigned Then
						SpreadsheetDocument.Join(AreaTableTitleDDSES);
					EndIf;
					If AdditDataExistanceStructure.AreNotDigitallySigned Then
						SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
					EndIf;
				EndIf;
				
			EndIf;
			
		EndIf;
		
		SpreadsheetDocument.Put(TemplateArea);
		CalculateTotalAmounts(TotalAmounts, RowData);
		If AdditDataTableRows.Count() > 0 Then
			ADTableString = AdditDataTableRows.Find(String(RowData.Number), "NumberStr");
			If ADTableString <> Undefined Then
				If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
					AreaTemplateDD.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
					AreaTemplateDD.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
					SpreadsheetDocument.Join(AreaTemplateDD);
				Else
					If AdditDataExistanceStructure.AreDigitallySigned Then
						DDSESTemplateArea.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
						SpreadsheetDocument.Join(DDSESTemplateArea);
					EndIf;
					If AdditDataExistanceStructure.AreNotDigitallySigned Then
						TemplateAreaDDWithoutES.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
						SpreadsheetDocument.Join(TemplateAreaDDWithoutES);
					EndIf;
				EndIf;
			EndIf;
		EndIf;
		
	EndDo;
	
	// Display totals on the last page
	TotalsAreaByPage = Template.GetArea("TotalByPage");
	TotalsAreaByPage.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TotalsAreaByPage);
	
	// Display totals on the full document
	TemplateArea = Template.GetArea("Total");
	TemplateArea.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TemplateArea);
	
	// Display the footer of the document
	FillFooterAttributesTORG12(PrintInfo.Footer, Template, SpreadsheetDocument, BuyerData);
	
	FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	
EndProcedure

// Procedure of filling of TORG-12 header attributes.
//
// Parameters:
//  PrintInfo - QueryResultSelection - Document
//  header data Template - TORG-12
//  Template TabularDocument - Spreadsheet document
//
Procedure FillHeaderAttributesTORG12(PrintInfo, Template, SpreadsheetDocument)
	
	// Displaying general header attributes
	TemplateArea = Template.GetArea("Header");
	TemplateArea.Parameters.Fill(PrintInfo);
	
	TemplateArea.Parameters.Basis = 
		?(ValueIsFilled(PrintInfo.BasisDescription), PrintInfo.BasisDescription, "")
		+ ?(ValueIsFilled(PrintInfo.BasisNumber), " # " + PrintInfo.BasisNumber, "")
		+ ?(ValueIsFilled(PrintInfo.BasisDate), " dated " + Format(PrintInfo.BasisDate, "DLF=D"), "");
	
	TemplateArea.Parameters.CompanyPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutShipper,
		"FullDescr,TIN,ActualAddress,PhoneNumbers,AccountNo,Bank,BIN,CorrAccount");
	
	TemplateArea.Parameters.PresentationOfConsignee = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutConsignee,
		"FullDescr,TIN,ActualAddress,PhoneNumbers,AccountNo,Bank,BIN,CorrAccount");
		
	TemplateArea.Parameters.VendorPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutVendor,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,AccountNo,Bank,BIN");
	
	TemplateArea.Parameters.PayerPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.InfoAboutCustomer,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,AccountNo,Bank,BIN");
		
	TemplateArea.Parameters.ShippingAddress = PrintInfo.ShippingAddress;
	
	CorrectionNumber = Undefined;
	DateOfCorrection = Undefined;
	
	PrintInfo.Property("CorrectionNumber", CorrectionNumber);
	PrintInfo.Property("DateOfCorrection", DateOfCorrection);
	
	FillInCorrectionDateNumber(TemplateArea, DateOfCorrection, CorrectionNumber);
	
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

Procedure FillInCorrectionDateNumber(TemplateArea, DateOfCorrection, CorrectionNumber)
	
	If Not( ValueIsFilled(CorrectionNumber) AND ValueIsFilled(DateOfCorrection)) Then
		Return;
	EndIf;
	
	TemplateArea.Parameters.FixText 	= NStr("en='Correction';ru='Исправление'")+ "   ";
	TemplateArea.Parameters.CorrectionNumber 	= CorrectionNumber;
	TemplateArea.Parameters.DateOfCorrection 	= Format(DateOfCorrection, "DLF=D");
	
	CorrectionAttributesBorderLine = New Line(SpreadsheetDocumentCellLineType.Solid, 1);
	AreaCorrectionNumber = TemplateArea.Areas.CorrectionNumber;
	AreaCorrectionNumber.BottomBorder 	= CorrectionAttributesBorderLine;
	AreaCorrectionNumber.LeftBorder 	= CorrectionAttributesBorderLine;
	AreaCorrectionNumber.RightBorder 	= CorrectionAttributesBorderLine;
	
	AreaCorrectionDate = TemplateArea.Areas.DateOfCorrection;
	AreaCorrectionDate.BottomBorder 	= CorrectionAttributesBorderLine;
	AreaCorrectionDate.LeftBorder 	= CorrectionAttributesBorderLine;
	AreaCorrectionDate.RightBorder 	= CorrectionAttributesBorderLine;
	
EndProcedure

// Procedure of filling of TORG12 footer details.
//
// Parameters:
//  PrintInfo - QueryResultSelection - Data of
//  document header SumTotals - Structure - Structure of document
//  sum totals Template - TORG-12
//  Template TabularDocument - Spreadsheet document
//
Procedure FillFooterAttributesTORG12(PrintInfo, Template, SpreadsheetDocument, BuyerData, CostCorrection = False)
	
	TemplateArea = Template.GetArea("Footer");
	
	TemplateArea.Parameters.Fill(PrintInfo);
	TemplateArea.Parameters.Fill(BuyerData);
	
	FullDocumentDate = Format(PrintInfo.DateReleased, "DF=""dd MMMM yyyy """"year""""""");
	StringLength = StrLen(FullDocumentDate);
	FirstSeparator = Find(FullDocumentDate, " ");
	SecondSeparator = Find(Right(FullDocumentDate, StringLength - FirstSeparator), " ") + FirstSeparator;
	TemplateArea.Parameters.DocumentDateDay = """" + Left(FullDocumentDate, FirstSeparator -1 ) + """";
	TemplateArea.Parameters.DocumentDateMonth = Mid(FullDocumentDate, FirstSeparator + 1, SecondSeparator - FirstSeparator - 1);
	TemplateArea.Parameters.DocumentDateYear = Right(FullDocumentDate, StringLength - SecondSeparator);
	
	If CostCorrection Then
		If BuyerData.Property("DateReceived") Then
			FullDateAccepted = Format(BuyerData.DateReceived, "DF=""dd MMMM yyyy """"year""""""");
			StringLength = StrLen(FullDateAccepted);
			FirstSeparator = Find(FullDateAccepted, " ");
			SecondSeparator = Find(Right(FullDateAccepted, StringLength - FirstSeparator), " ") + FirstSeparator;
			TemplateArea.Parameters.DateReceivedDay = """" + Left(FullDateAccepted, FirstSeparator -1 ) + """";
			TemplateArea.Parameters.DateReceivedMonth = Mid(FullDateAccepted, FirstSeparator + 1, SecondSeparator - FirstSeparator - 1);
			TemplateArea.Parameters.DateReceivedYear = Right(FullDateAccepted, StringLength - SecondSeparator);
		EndIf;
	EndIf;
	
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with ACCOUNT (CUSTOMER ORDER)

Function GetOrderBillDataToPrint(ObjectString, ParseTree, Type = "Account")
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutRecipient", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
	EndIf;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.FullDescr"));
	InformationAboutCompany.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.TIN"));
	InformationAboutCompany.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.LegalAddress_Presentation"));
	InformationAboutCompany.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutRecipient", InformationAboutCompany);
	EndIf;
	
	FillingDataHeader.Insert("RecipientBankBIC",               GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.Code"));
	FillingDataHeader.Insert("RecipientBankPresentation",      GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.Description"));
	FillingDataHeader.Insert("RecipientBankAccountPresentation", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	FillingDataHeader.Insert("RecipientAccountPresentation",      GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.AccountNumber"));
	FillingDataHeader.Insert("BankBICCorrespondent",           GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.CorrespondentBank.Code"));
	FillingDataHeader.Insert("CorrespondentBank",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.CorrespondentBank.Description"));
	FillingDataHeader.Insert("CorrespondentBankAccount",          GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.CorrespondentBank.CorrAccount"));
	
	FillingDataHeader.Insert("Number",             GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Number"));
	FillingDataHeader.Insert("Date",              GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Date"));
	FillingDataHeader.Insert("CurrencyCode",         GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Description"));
	FillingDataHeader.Insert("PaymentDate",       GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"PaymentDueDate"));
	FillingDataHeader.Insert("PaymentDate",       GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"AccountExpirationDate"));
	FillingDataHeader.Insert("TotalsInWords",     GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"TotalsInWords"));
	FillingDataHeader.Insert("Head",      GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Head"));
	FillingDataHeader.Insert("Accountant",         GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Accountant"));
	FillingDataHeader.Insert("PaymentDestination", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"PaymentDestination"));
	FillingDataHeader.Insert("Amount",             GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"AmountTotal"));
	FillingDataHeader.Insert("VATAmount",          GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"TaxAmountTotal"));
	FillingDataHeader.Insert("PriceIncludesVAT",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PriceIncludesVAT"));
	FillingDataHeader.Insert("AdditionalInformation", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AdditionalInformation"));
	FillingDataHeader.Insert("ShippingAddress",     GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"ShippingAddress"));
	
	VT = New ValueTable;
	
	VT.Columns.Add("Product");
	VT.Columns.Add("Code");
	VT.Columns.Add("SKU");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("Amount");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("DiscountAmount");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		If ObjectString.EDDirection = Enums.EDDirections.Incoming Then
			NewRow.Product = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
				"SupplierProductsAndServices.Name");
			ProductID = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SupplierProductsAndServices.Code");
			Pos = Find(ProductID, "#");
			If Pos > 0 Then
				ProductId = Mid(ProductID, 1, Pos - 1);
			EndIf;
			NewRow.Code = ProductID;
		ElsIf ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
			NewRow.Product = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Name");
			NewRow.Code   = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Code");
		EndIf;
		
		NewRow.SKU          = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.SKU");
		Package                     = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"UOM.Name");
		BaseMeasurementUnit      = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.BaseUnit.Description");
		NewRow.MeasurementUnit = ?(ValueIsFilled(Package), Package, BaseMeasurementUnit);
		NewRow.Quantity       = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"PackingQuantity");
		NewRow.Price             = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Amount            = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		
		VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		If Not ValueIsFilled(VATAmount) Then
			NewRow.VATAmount         = 0;
		Else
			NewRow.VATAmount         = VATAmount;
		EndIf;
		NewRow.VATRate        = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.DiscountAmount      = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "DiscountAmount");
		
	EndDo;
	
	// PaymentStages
	VTPaymentStages = New ValueTable;
	
	If Type = "Order" Then
		VTPaymentStages.Columns.Add("PaymentOption");
	EndIf;
	VTPaymentStages.Columns.Add("PaymentDate");
	VTPaymentStages.Columns.Add("PaymentPercent");
	VTPaymentStages.Columns.Add("PaymentAmount");
	VTPaymentStages.Columns.Add("LineNumber");
	LineNumber = 1;
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "PaymentScheduleStages"));
	For Each TSRow IN TSRows Do
		
		NewRow = VTPaymentStages.Add();
		If Type = "Order" Then
			NewRow.PaymentOption = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PaymentOption");
		EndIf;
		NewRow.PaymentDate    = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PaymentDate");
		NewRow.PaymentPercent = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PaymentPercent");
		NewRow.PaymentAmount   = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PaymentAmount");
		NewRow.LineNumber    = LineNumber;
		LineNumber = LineNumber + 1;
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",       FillingDataHeader);
	DataForObject.Insert("Products",      VT);
	DataForObject.Insert("PaymentStages", VTPaymentStages);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document Invoice-order.
//
Procedure FillInTabularDocumentAccountOrder_ED(SpreadsheetDocument, PrintInfo, Type = "Account")
	
	UseManualDiscounts         = ElectronicDocumentsServiceCallServer.GetFunctionalOptionValue("UseManualDiscountsInSales");
	UseAutomaticDiscounts = ElectronicDocumentsServiceCallServer.GetFunctionalOptionValue("UseAutomaticDiscountsInSales");
	
	CodesColumn = ElectronicDocumentsOverridable.AdditionalColumnName();
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_InvoiceOrder");
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_ED_InvoiceOrder";
	
	TableProducts = PrintInfo.Products;
	
	If TableProducts.Count() > 0 Then
		PartialPayment = False;
	Else
		PartialPayment = True;
	EndIf;
	
	AreDiscounts = ElectronicDocumentsOverridable.NeedToOutputDiscounts(TableProducts, UseManualDiscounts
		OR UseAutomaticDiscounts);
	
	OutputCodes  = ValueIsFilled(CodesColumn);
	PrintInfo.Insert("ConsiderVAT", TableProducts.Columns.Find("VATAmount") <> Undefined
		AND TableProducts.Total("VATAmount") > 0);
	
	If PrintInfo.ConsiderVAT AND AreDiscounts THEN
		AreaColumnProduct = Template.Area("ProductWithVATWithDiscount");
	ElsIf PrintInfo.ConsiderVAT Then
		AreaColumnProduct = Template.Area("ProductWithVATOrWithDiscount");
	Else
		AreaColumnProduct = Template.Area("Product");
	EndIf;
	
	If Not OutputCodes Then
		
		If PrintInfo.ConsiderVAT Then
			AreaColumnProduct.ColumnWidth = AreaColumnProduct.ColumnWidth * 1.2;
		Else
			AreaColumnProduct.ColumnWidth = AreaColumnProduct.ColumnWidth * 1.14;
		EndIf;
		
	EndIf;
	
	If AreDiscounts THEN
		
		NumberArea = Template.GetArea("TableWithVATWithDiscountHeader|LineNumber");
		CodesArea  = Template.GetArea("TableWithVATWithDiscountHeader|CodesColumn");
		AreaProduct  = Template.GetArea("TableWithVATWithDiscountHeader|ProductWithVATWithDiscount");
		DataArea = Template.GetArea("TableWithVATWithDiscountHeader|DataWithVATWithDiscount");
		
	ElsIf PrintInfo.ConsiderVAT Then
		
		NumberArea = Template.GetArea("TableWithVATHeader|LineNumber");
		CodesArea  = Template.GetArea("TableWithVATHeader|CodesColumn");
		AreaProduct  = Template.GetArea("TableWithVATHeader|ProductWithVATOrWithDiscount");
		DataArea = Template.GetArea("TableWithVATHeader|DataWithVATOrWithDiscount");
		
	Else
		
		NumberArea = Template.GetArea("TableHeader|LineNumber");
		CodesArea  = Template.GetArea("TableHeader|CodesColumn");
		AreaProduct  = Template.GetArea("TableHeader|Product");
		DataArea = Template.GetArea("TableHeader|Data");
		
	EndIf;
	
	TablePaymentStages = New ValueTable;
	TablePaymentStages.Columns.Add("PaymentDate");
	If PrintInfo.Property("PaymentDate") Then
		NewRow = TablePaymentStages.Add();
		NewRow.PaymentDate = PrintInfo.PaymentDate;
	EndIf; 
	
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataTableRows = AdditDataTable();
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	AdditionalInformationExists = False;
	If AdditDataTableRows.Count() > 0 Then
		
		AdditionalInformationExists = True;
		
		If AreDiscounts Then
			AreaTitleTablesDD = Template.GetArea("TableWithVATWithDiscountHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("TableWithVATWithDiscountRow|TableWithEDSAdditData");
			
		ElsIf PrintInfo.ConsiderVAT Then
			
			AreaTitleTablesDD = Template.GetArea("TableWithVATHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("TableWithVATRow|TableWithEDSAdditData");
			
		Else
			AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("TableRow|TableWithEDSAdditData");
			
		EndIf;
	EndIf;
	
	FillHeaderAttributesInvoiceOrder(PrintInfo, Template, SpreadsheetDocument, TablePaymentStages, Type);
	AccordanceOfRatesVAT = New Map;
	If PartialPayment Then
		
		SpreadsheetDocument.Put(Template.GetArea("TableHeaderPartialPayment"));
		
		AreaTableRow = Template.GetArea("TableRowPartialPayment");
		
		AreaTableRow.Parameters.Product = PrintInfo.Header.PaymentDestination;
		AreaTableRow.Parameters.Amount = PrintInfo.Header.Amount;
		SpreadsheetDocument.Put(AreaTableRow);
		
		AreaTotalAmount = Template.GetArea("TotalPartialPayment");
		AreaTotalAmount.Parameters.Total = PrintInfo.Header.Amount;
		SpreadsheetDocument.Join(AreaTotalAmount);
		
		If ValueIsFilled(PrintInfo.Header.VATAmount) Then
			
			VATArea = Template.GetArea("TotalVATPartialPayment");
			VATArea.Parameters.VAT = NStr("en='Including VAT:';ru='Inclusive TVA:'");
			VATArea.Parameters.TotalVAT = PrintInfo.Header.VATAmount;
			SpreadsheetDocument.Put(VATArea);
		EndIf;
		
	Else
		
		SpreadsheetDocument.Put(NumberArea);
		
		If OutputCodes Then
			
			CodesArea.Parameters.CodesColumnName = CodesColumn;
			SpreadsheetDocument.Join(CodesArea);
			
		EndIf;
		
		AreaProduct.Parameters.Product = NStr("en='Goods (works, services)';ru='Товары (работы, услуги)'");
		SpreadsheetDocument.Join(AreaProduct);
		SpreadsheetDocument.Join(DataArea);
		
		If AdditionalInformationExists Then
			SpreadsheetDocument.Join(AreaTitleTablesDD);
		EndIf;
		
		
		If AreDiscounts Then
			
			NumberArea = Template.GetArea("TableWithVATWithDiscountRow|LineNumber");
			CodesArea  = Template.GetArea("TableWithVATWithDiscountRow|CodesColumn");
			AreaProduct  = Template.GetArea("TableWithVATWithDiscountRow|ProductWithVATWithDiscount");
			DataArea = Template.GetArea("TableWithVATWithDiscountRow|DataWithVATWithDiscount");
			
			
		ElsIf PrintInfo.ConsiderVAT Then
			
			NumberArea = Template.GetArea("TableWithVATRow|LineNumber");
			CodesArea  = Template.GetArea("TableWithVATRow|CodesColumn");
			AreaProduct  = Template.GetArea("TableWithVATRow|ProductWithVATOrWithDiscount");
			DataArea = Template.GetArea("TableWithVATRow|DataWithVATOrWithDiscount");
			
		Else
			
			NumberArea = Template.GetArea("TableRow|LineNumber");
			CodesArea  = Template.GetArea("TableRow|CodesColumn");
			AreaProduct  = Template.GetArea("TableRow|Product");
			DataArea = Template.GetArea("TableRow|Data");
			
		EndIf;
		
		Amount          = 0;
		VATAmount       = 0;
		TotalDiscounts	   = 0;
		TotalWithoutDiscounts = 0;
		
		LineNumber = 0;
		
		For Each ProductsRow IN TableProducts Do
			
			LineNumber = LineNumber + 1;
			
			NumberArea.Parameters.LineNumber = LineNumber;
			SpreadsheetDocument.Put(NumberArea);
			
			If OutputCodes Then
				
				CodesArea.Parameters.SKU = ProductsRow.SKU;
				SpreadsheetDocument.Join(CodesArea);
				
			EndIf;
			
			AreaProduct.Parameters.Product = ProductsRow.Product;
			SpreadsheetDocument.Join(AreaProduct);
			
			DataArea.Parameters.Fill(ProductsRow);
			
			If PrintInfo.Header.PriceIncludesVAT Then
				AmountByRow = ProductsRow.Amount + ProductsRow.VATAmount;
			Else
				AmountByRow = ProductsRow.Amount;
			EndIf;
			
			DataArea.Parameters.Amount = AmountByRow;
			
			If AreDiscounts THEN
				DiscountAmount = ?(ValueIsFilled(ProductsRow.DiscountAmount), ProductsRow.DiscountAmount, 0);
				DataArea.Parameters.AmountWithoutDiscount = AmountByRow + DiscountAmount;
			EndIf;
			
			SpreadsheetDocument.Join(DataArea);
			
			DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure, LineNumber,SpreadsheetDocument, AreaTemplateDD);
			
			If AreDiscounts Then
				TotalDiscounts = TotalDiscounts + DiscountAmount;
				TotalWithoutDiscounts = TotalWithoutDiscounts + AmountByRow + DiscountAmount;
			EndIf;
			
			Amount = Amount + AmountByRow;
			VATAmount = VATAmount + ProductsRow.VATAmount;
			
		EndDo;
		
		If AreDiscounts THEN
			
			NumberArea = Template.GetArea("TableWithVATWithDiscountFooter|LineNumber");
			CodesArea  = Template.GetArea("TableWithVATWithDiscountFooter|CodesColumn");
			AreaProduct  = Template.GetArea("TableWithVATWithDiscountFooter|ProductWithVATWithDiscount");
			DataArea = Template.GetArea("TableWithVATWithDiscountFooter|DataWithVATWithDiscount");
		ElsIf PrintInfo.ConsiderVAT Then
			
			NumberArea = Template.GetArea("TableWithVATFooter|LineNumber");
			CodesArea  = Template.GetArea("TableWIthVATFooter|CodesColumn");
			AreaProduct  = Template.GetArea("TableWithVATFooter|ProductWithVATOrWithDiscount");
			DataArea = Template.GetArea("TableWithVATFooter|DataWithVATOrWithDiscount");
		Else
			
			NumberArea = Template.GetArea("TableFooter|LineNumber");
			CodesArea  = Template.GetArea("TableFooter|CodesColumn");
			AreaProduct  = Template.GetArea("TableFooter|Product");
			DataArea = Template.GetArea("TableFooter|Data");
		EndIf;
		
		SpreadsheetDocument.Put(NumberArea);
		
		If OutputCodes Then
			SpreadsheetDocument.Join(CodesArea);
		EndIf;
		
		SpreadsheetDocument.Join(AreaProduct);
		
		DataArea.Parameters.Total = ElectronicDocumentsOverridable.AmountsFormat(Amount);
		
		If PrintInfo.ConsiderVAT AND AreDiscounts Then
			DataArea.Parameters.TotalVATAmount = ElectronicDocumentsOverridable.AmountsFormat(VATAmount);
		EndIf;
		
		If AreDiscounts Then
			DataArea.Parameters.TotalDiscounts = ElectronicDocumentsOverridable.AmountsFormat(TotalDiscounts);
			DataArea.Parameters.TotalWithoutDiscounts = ElectronicDocumentsOverridable.AmountsFormat(TotalWithoutDiscounts);
		EndIf;
		
		SpreadsheetDocument.Join(DataArea);
		
		// Display TotalVAT
		If PrintInfo.ConsiderVAT Then
			
			NumberArea = Template.GetArea("VATTableFooter|LineNumber");
			CodesArea  = Template.GetArea("VATTableFooter|CodesColumn");
			AreaProduct  = Template.GetArea("VATTableFooter|Product");
			DataArea = Template.GetArea("VATTableFooter|Data");
			
			TableProductsVAT = TableProducts.Copy( , "VATRate, VATAmount");
			TableProductsVAT.GroupBy("VATRate", "VATAmount");
			For Each CurVATRate IN TableProductsVAT Do
				AccordanceOfRatesVAT.Insert(CurVATRate.VATRate, CurVATRate.VATAmount);
				SpreadsheetDocument.Put(NumberArea);
				If OutputCodes Then
					SpreadsheetDocument.Join(CodesArea);
				EndIf;
				SpreadsheetDocument.Join(AreaProduct);
				DataArea.Parameters.VAT = ElectronicDocumentsOverridable.TextVATByRate(CurVATRate.VATRate,
					PrintInfo.Header.PriceIncludesVAT);
				DataArea.Parameters.TotalVAT = ElectronicDocumentsOverridable.AmountsFormat(CurVATRate.VATAmount);
				SpreadsheetDocument.Join(DataArea);
			EndDo;
			
			AreaTotalWithVAT = Template.GetArea("TotalWithVAT");
			
			If PrintInfo.Header.PriceIncludesVAT Then
				TotalWithVAT = ElectronicDocumentsOverridable.AmountsFormat(Amount);
			Else
				TotalWithVAT = ElectronicDocumentsOverridable.AmountsFormat(Amount + VATAmount);
			EndIf;
			
			AreaTotalWithVAT.Parameters.TotalWithVAT = TotalWithVAT;
			SpreadsheetDocument.Put(AreaTotalWithVAT)
			
		EndIf;
		
	EndIf;
	
	// Display sum in writing
	TemplateArea = Template.GetArea("AmountInWords");
	
	TemplateArea.Parameters.TotalRow = PrintInfo.Header.TotalsInWords;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	TablePaymentStages = PrintInfo.PaymentStages;
	If TablePaymentStages.Count() > 1 Then
		SpreadsheetDocument.Put(Template.GetArea("TableHeaderPaymentStages"));
		Area = Template.GetArea("TableRowPaymentStages");
		For Each CurStage IN TablePaymentStages Do
			Area.Parameters.Fill(CurStage);
			Area.Parameters.TextVAT = ElectronicDocumentsOverridable.GenerateTextVATPaymentStage(
				AccordanceOfRatesVAT, CurStage.PaymentPercent);
			SpreadsheetDocument.Put(Area);
		EndDo;
		SpreadsheetDocument.Put(Template.GetArea("TotalPaymentStages"));
	EndIf;
	
	FillFooterAttributesInvoiceOrder(PrintInfo, Template, SpreadsheetDocument, Type);
	
	DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument);
	
EndProcedure

// Procedure to fill in the details of account or order header.
//
// Parameters:
//  PrintInfo - QueryResultSelection - Document
//  header data Template - Template
//  AccountOrder TabularDocument - Spreadsheet document
//
Procedure FillHeaderAttributesInvoiceOrder(PrintInfo, Template, SpreadsheetDocument, TablePaymentStages, Type)
	
	InfoAboutVendor = PrintInfo.Header.InfoAboutVendor;
	InfoAboutRecipient = PrintInfo.Header.InfoAboutRecipient;
	
	If Type = "Account" Then
		
		TemplateArea = Template.GetArea("InvoiceHeader");
		
		If ValueIsFilled(PrintInfo.Header.PaymentDate) Then
			
			LabelValidityPeriod = NStr("en='Account is valid till %ValidityPeriod%.';ru='Счет действителен до %СрокДействия%.'");
			LabelValidityPeriod = StrReplace(LabelValidityPeriod, "%ValidityPeriod%",
				Format(PrintInfo.Header.PaymentDate, "DLF=D"));
			TemplateArea.Parameters.ValidityPeriod = LabelValidityPeriod;
			
		EndIf;
		
		TemplateArea.Parameters.TIN = InfoAboutVendor.TIN;
		
		If ValueIsFilled(PrintInfo.Header.CorrespondentBank) Then
			TemplateArea.Parameters.RecipientBankBIC               = PrintInfo.Header.BankBICCorrespondent;
			TemplateArea.Parameters.RecipientBankPresentation      = PrintInfo.Header.CorrespondentBank;
			TemplateArea.Parameters.RecipientBankAccountPresentation = PrintInfo.Header.CorrespondentBankAccount;
			TemplateArea.Parameters.RecipientAccountPresentation      = PrintInfo.Header.RecipientBankAccountPresentation;
		Else	
			TemplateArea.Parameters.RecipientBankBIC               = PrintInfo.Header.RecipientBankBIC;
			TemplateArea.Parameters.RecipientBankPresentation      = PrintInfo.Header.RecipientBankPresentation;
			TemplateArea.Parameters.RecipientBankAccountPresentation = PrintInfo.Header.RecipientBankAccountPresentation;
			TemplateArea.Parameters.RecipientAccountPresentation      = PrintInfo.Header.RecipientAccountPresentation;
		EndIf;
		
		TemplateArea.Parameters.VendorPresentationForPaymOrder = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
			InfoAboutVendor, "FullDescr,");
		SpreadsheetDocument.Put(TemplateArea);
		
	EndIf;
	
	TemplateArea = Template.GetArea("Title");
	
	If Type = "Account" Then
		HeaderText = NStr("en='Account for payment # %DocumentNumber% as of %DocumentDate%';ru='Счет на оплату № %НомерДокумента% от %ДатаДокумента% г.'");
	ElsIf Type = "Order" Then
		HeaderText = NStr("en='Client order # %DocumentNumber% as of %DocumentDate%';ru='Заказ клиента № %НомерДокумента% от %ДатаДокумента% г.'");
	EndIf;
	
	HeaderText = StrReplace(HeaderText, "%DocumentNumber%", PrintInfo.Header.Number);
	HeaderText = StrReplace(HeaderText, "%DocumentDate%",  Format(PrintInfo.Header.Date, "DF=dd MMMM yyyy'"));
	
	TemplateArea.Parameters.HeaderText = HeaderText;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Vendor");
	
	TemplateArea.Parameters.TextSupplier = ?(Type = "Account", NStr("en='Vendor:';ru='Поставщик:'"), NStr("en='Performer:';ru='Исполнитель:'"));
	TemplateArea.Parameters.VendorPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(InfoAboutVendor,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,");
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Customer");
	TemplateArea.Parameters.TextCustomer         = ?(Type = "Account", NStr("en='Customer:';ru='Покупатель:'"), NStr("en='Customer:';ru='Покупатель:'"));
	TemplateArea.Parameters.RecipientPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(InfoAboutRecipient,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,");
	SpreadsheetDocument.Put(TemplateArea);
	
	If Type = "Account" Then
		TemplateArea = Template.GetArea("PaymentDestination");
		TemplateArea.Parameters.PaymentDestination = PrintInfo.Header.PaymentDestination;
		SpreadsheetDocument.Put(TemplateArea);
	Else
		TemplateArea = Template.GetArea("ShippingAddress");
		TemplateArea.Parameters.ShippingAddress = PrintInfo.Header.ShippingAddress;
		SpreadsheetDocument.Put(TemplateArea);
	EndIf;
	
EndProcedure

// Procedure to fill the details of account or order footer.
//
// Parameters:
//  PrintInfo - QueryResultSelection - Data of
//  document header SumTotals - Structure - Structure of document
//  sum totals Template - Template
//  AccountOrder TabularDocument - Spreadsheet document
//
Procedure FillFooterAttributesInvoiceOrder(PrintInfo, Template, SpreadsheetDocument, Type)
	
	If ValueIsFilled(PrintInfo.Header.AdditionalInformation) Then
		Area = Template.GetArea("AdditionalInformation");
		Area.Parameters.AdditionalInformation = PrintInfo.Header.AdditionalInformation;
		SpreadsheetDocument.Put(Area);
	EndIf;
	
	If Type = "Account" Then
		TemplateArea = Template.GetArea("AccountFooter");
		TemplateArea.Parameters.HeadDescriptionFull = PrintInfo.Header.Head;
		TemplateArea.Parameters.AccountantDescriptionFull   = PrintInfo.Header.Accountant;
	Else
		TemplateArea = Template.GetArea("OrderFooter");
	EndIf;
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with ORDER TO SUPPLIER

Function GetSupplierOrderDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.FullDescr"));
	InformationAboutCompany.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.TIN"));
	InformationAboutCompany.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.LegalAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	EndIf;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.LegalAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
	EndIf;
	
	FillingDataHeader.Insert("Number",                    GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Number"));
	FillingDataHeader.Insert("Date",                     GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Date"));
	FillingDataHeader.Insert("CurrencyCode",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",       GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Currency.Description"));
	FillingDataHeader.Insert("VATAmount",                 GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "TaxAmountTotal"));
	FillingDataHeader.Insert("TotalsInWords",            GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "TotalsInWords"));
	FillingDataHeader.Insert("AdditionalInformation", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AdditionalInformation"));
	FillingDataHeader.Insert("PriceIncludesVAT",          GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PriceIncludesVAT"));
	FillingDataHeader.Insert("ShippingAddress",            GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "ShippingAddress"));
	
	VT = New ValueTable;
	VT.Columns.Add("Product");
	VT.Columns.Add("SupplierProductsAndServicesDescription");
	VT.Columns.Add("Code");
	VT.Columns.Add("SKU");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("Amount");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("SumWithVAT");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("DiscountAmount");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		If ObjectString.EDDirection = Enums.EDDirections.Incoming 
			or ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
			NewRow.Product = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Name");
			NewRow.SupplierProductsAndServicesDescription = NewRow.Product;
			NewRow.Code = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Code");
			NewRow.SKU = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.SKU");
		ElsIf ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
			NewRow.Product = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
				"SupplierProductsAndServices.Name");
			NewRow.SupplierProductsAndServicesDescription = NewRow.Product;
			ProductID = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SupplierProductsAndServices.Code");
			Pos = Find(ProductID, "#");
			If Pos > 0 Then
				ProductId = Mid(ProductID, 1, Pos - 1);
			EndIf;
			NewRow.Code = ProductID;
			NewRow.SKU = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
				"SupplierProductsAndServices.SKU");
		EndIf;
		Package = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "UOM.Name");
		BaseMeasurementUnit = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.BaseUnit.Description");
					
		NewRow.MeasurementUnit = ?(ValueIsFilled(Package), Package, BaseMeasurementUnit);
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PackingQuantity");
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.DiscountAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "DiscountAmount");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SumWithVAT");
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

// Procedure populates tabular document "Purchase order".
//
Procedure FillInTabularDocumentOrderToSupplier_ED(SpreadsheetDocument, PrintInfo)
	
	UseManualDiscounts = ElectronicDocumentsServiceCallServer.GetFunctionalOptionValue(
		"UseManualDiscountsInPurchases");
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_PurchaseOrder");
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_ED_PurchaseOrder";
	
	TableProducts = PrintInfo.Products;
	
	CodesColumn  = ElectronicDocumentsOverridable.AdditionalColumnName();
	OutputCodes  = ValueIsFilled(CodesColumn);
	PrintInfo.Insert("ConsiderVAT", TableProducts.Columns.Find("VATAmount") <> Undefined
		AND TableProducts.Total("VATAmount") > 0);
	
	AreDiscounts = ElectronicDocumentsOverridable.NeedToOutputDiscounts(TableProducts, UseManualDiscounts);
	
	If AreDiscounts Then
		AreaColumnProduct = Template.Area("ProductWithConditionOrWithDiscount");
	Else
		AreaColumnProduct = Template.Area("Product");
	EndIf;
	
	If Not OutputCodes Then
		AreaColumnProduct.ColumnWidth = AreaColumnProduct.ColumnWidth * 1.14;
	EndIf;
	
	If AreDiscounts THEN
		
		NumberArea = Template.GetArea("TableWithDiscountHeader|LineNumber");
		CodesArea  = Template.GetArea("TableWithDiscountHeader|CodesColumn");
		AreaProduct  = Template.GetArea("TableWithDiscountHeader|ProductWithConditionOrWithDiscount");
		DataArea = Template.GetArea("TableWithDiscountHeader|DataWithConditionOrWithDiscount");
	Else
		
		NumberArea = Template.GetArea("TableHeader|LineNumber");
		CodesArea  = Template.GetArea("TableHeader|CodesColumn");
		AreaProduct  = Template.GetArea("TableHeader|Product");
		DataArea = Template.GetArea("TableHeader|Data");
	EndIf;
	
	// Fill in header attributes
	TemplateArea = Template.GetArea("Title");
	
	HeaderText = NStr("en='Order to supplier # %DocumentNumber% as of %DocumentDate%.';ru='Заказ поставщику № %НомерДокумента% от %ДатаДокумента% г.'");
	HeaderText = StrReplace(HeaderText, "%DocumentNumber%", PrintInfo.Header.Number);
	HeaderText = StrReplace(HeaderText, "%DocumentDate%",  Format(PrintInfo.Header.Date, "DF=dd MMMM yyyy'"));
	
	TemplateArea.Parameters.HeaderText = HeaderText;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Vendor");
	
	TemplateArea.Parameters.VendorPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.Header.InfoAboutVendor, "FullDescr,TIN,LegalAddress,PhoneNumbers,");
	SpreadsheetDocument.Put(TemplateArea);
	TemplateArea = Template.GetArea("Customer");
	TemplateArea.Parameters.RecipientPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		PrintInfo.Header.InfoAboutCustomer, "FullDescr,TIN,LegalAddress,PhoneNumbers,");
	SpreadsheetDocument.Put(TemplateArea);
	
	AreaAddressDelivery = Template.GetArea("ShippingAddress");
	AreaAddressDelivery.Parameters.ShippingAddress = PrintInfo.Header.ShippingAddress;
	SpreadsheetDocument.Put(AreaAddressDelivery);
	
	SpreadsheetDocument.Put(NumberArea);
	
	If OutputCodes Then
		
		CodesArea.Parameters.CodesColumnName = CodesColumn;
		SpreadsheetDocument.Join(CodesArea);
		
	EndIf;
	
	AreaProduct.Parameters.Product = NStr("en='Goods (works, services)';ru='Товары (работы, услуги)'");
	SpreadsheetDocument.Join(AreaProduct);
	SpreadsheetDocument.Join(DataArea);
	
	AdditDataTableRows = AdditDataTable();
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		
		If AreDiscounts Then
			AreaTitleTablesDD = Template.GetArea("TableWithDiscountHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("TableWithDiscountRow|TableWithEDSAdditData");
			
		Else
			AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("TableRow|TableWithEDSAdditData");
			
		EndIf;
		
		SpreadsheetDocument.Join(AreaTitleTablesDD);
	EndIf;

	
	If AreDiscounts Then
		
		NumberArea = Template.GetArea("TableWithDiscountRow|LineNumber");
		CodesArea  = Template.GetArea("TableWithDiscountRow|CodesColumn");
		AreaProduct  = Template.GetArea("TableWithDiscountRow|ProductWithConditionOrWithDiscount");
		DataArea = Template.GetArea("TableWithDiscountRow|DataWithConditionOrWithDiscount");
	Else
		
		NumberArea = Template.GetArea("TableRow|LineNumber");
		CodesArea  = Template.GetArea("TableRow|CodesColumn");
		AreaProduct  = Template.GetArea("TableRow|Product");
		DataArea = Template.GetArea("TableRow|Data");
	EndIf;
	
	Amount          = 0;
	VATAmount       = 0;
	TotalDiscounts    = 0;
	TotalWithoutDiscounts = 0;
	LineNumber    = 0;
	
	For Each ProductsRow IN TableProducts Do
		
		LineNumber = LineNumber + 1;
		
		NumberArea.Parameters.LineNumber = LineNumber;
		SpreadsheetDocument.Put(NumberArea);
		
		If OutputCodes Then
			
			CodesArea.Parameters.SKU = ProductsRow.SKU;
			SpreadsheetDocument.Join(CodesArea);
		EndIf;
		
		AreaProduct.Parameters.Product = ProductsRow.SupplierProductsAndServicesDescription;
		
		SpreadsheetDocument.Join(AreaProduct);
		DataArea.Parameters.Fill(ProductsRow);
		DiscountAmount = ?(ValueIsFilled(ProductsRow.DiscountAmount), ProductsRow.DiscountAmount, 0);
		ProductVATAmount = ?(TypeOf(ProductsRow.VATAmount) = Type("Number"), ProductsRow.VATAmount, 0);
		If PrintInfo.Header.PriceIncludesVAT Then
			AmountByRow = ProductsRow.Amount + ProductVATAmount;
		Else
			AmountByRow = ProductsRow.Amount;
		EndIf;
		
		If AreDiscounts Then
			DataArea.Parameters.AmountWithoutDiscount = AmountByRow + DiscountAmount;
		EndIf;
		
		DataArea.Parameters.Amount = AmountByRow;
		
		SpreadsheetDocument.Join(DataArea);
		
		Amount     = Amount + AmountByRow;
		VATAmount  = VATAmount + ProductVATAmount;
		
		If AreDiscounts Then
			TotalDiscounts    = TotalDiscounts    + DiscountAmount;
			TotalWithoutDiscounts = TotalWithoutDiscounts + AmountByRow + DiscountAmount;
		EndIf;
		
		DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure, LineNumber, SpreadsheetDocument, AreaTemplateDD);
		
	EndDo;
	
	If AreDiscounts Then
		
		NumberArea = Template.GetArea("TableWithDiscountFooter|LineNumber");
		CodesArea  = Template.GetArea("TableWithDiscountsFooter|CodesColumn");
		AreaProduct  = Template.GetArea("TableWithDiscountFooter|ProductWithConditionOrWithDiscount");
		DataArea = Template.GetArea("TableWithDiscountFooter|DataWithConditionOrWithDiscount");
	Else
		
		NumberArea = Template.GetArea("TableFooter|LineNumber");
		CodesArea  = Template.GetArea("TableFooter|CodesColumn");
		AreaProduct  = Template.GetArea("TableFooter|Product");
		DataArea = Template.GetArea("TableFooter|Data");
	EndIf;
	
	SpreadsheetDocument.Put(NumberArea);
	
	If OutputCodes Then
		SpreadsheetDocument.Join(CodesArea);
	EndIf;
	
	SpreadsheetDocument.Join(AreaProduct);
	
	If AreDiscounts Then
		
		DataArea.Parameters.TotalDiscounts    = TotalDiscounts;
		DataArea.Parameters.TotalWithoutDiscounts = TotalWithoutDiscounts;
	EndIf;
	
	DataArea.Parameters.Total = ElectronicDocumentsOverridable.AmountsFormat(Amount);
	SpreadsheetDocument.Join(DataArea);
	
	// Display TotalVAT
	If PrintInfo.ConsiderVAT Then
		
		NumberArea = Template.GetArea("VATTableFooter|LineNumber");
		CodesArea  = Template.GetArea("VATTableFooter|CodesColumn");
		AreaProduct  = Template.GetArea("VATTableFooter|Product");
		DataArea = Template.GetArea("VATTableFooter|Data");
		
		SpreadsheetDocument.Put(NumberArea);
		
		If OutputCodes Then
			SpreadsheetDocument.Join(CodesArea);
		EndIf;
		
		SpreadsheetDocument.Join(AreaProduct);
		
		If PrintInfo.Header.PriceIncludesVAT Then
			DataArea.Parameters.VAT = NStr("en='Including VAT:';ru='Inclusive TVA:'");
		Else
			DataArea.Parameters.VAT = NStr("en='VAT Amount:';ru='Сумма НДС:'");
		EndIf;
		DataArea.Parameters.TotalVAT = PrintInfo.Header.VATAmount;
		SpreadsheetDocument.Join(DataArea);
		
	EndIf;
	
	// Display sum in writing
	TemplateArea = Template.GetArea("AmountInWords");
	TotalRow = PrintInfo.Header.TotalsInWords;
	
	TemplateArea.Parameters.TotalRow = TotalRow;
	SpreadsheetDocument.Put(TemplateArea);
	
	If ValueIsFilled(PrintInfo.Header.AdditionalInformation) Then
		Area = Template.GetArea("AdditionalInformation");
		Area.Parameters.AdditionalInformation = PrintInfo.Header.AdditionalInformation;
		SpreadsheetDocument.Put(Area);
	EndIf;
	
	// Export signatures
	TemplateArea = Template.GetArea("OrderFooter");
	SpreadsheetDocument.Put(TemplateArea);
	
	// Display additional data of the document
	
	DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Operation with the INVOICE

Function GetInvoiceDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	DocumentDate = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date");
	DocumentNumber = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number");
	
	FillingDataHeader.Insert("Number", NStr("en='Invoice #';ru='Счет-фактура №'") + DocumentNumber +" "+ NStr("en='dated';ru='от'")
		+" "+ Format(DocumentDate,"DLF=DD"));
	
	DateFixedLine = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfCorrection");
	CorrectionNumber = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CorrectionNumber");
	
	FillingDataHeader.Insert("CorrectionNumber", NStr("en='Fix #';ru='Исправление №'")
		+ ?(ValueIsFilled(CorrectionNumber), CorrectionNumber, "--") + " " + NStr("en='dated';ru='от'") + " "
		+ ?(ValueIsFilled(DateFixedLine), Format(DateFixedLine, "DLF=DD"), "--"));
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.ActualAddress_Presentation"));
	InfoAboutCounterparty.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.AccountNumber"));
	InfoAboutCounterparty.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Description"));
	InfoAboutCounterparty.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Code"));
	InfoAboutCounterparty.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	InfoAboutCounterparty.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.PhoneNumbers"));
	
	IssuedByPrincipal = (GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "IssuedByPrincipal") = True);
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
		CompanyAttrName = "Company";
		BankAccountName = "BankAccountOfTheCompany";
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
		CompanyAttrName = ?(IssuedByPrincipal, "Customer", "Company");
		BankAccountName = ?(IssuedByPrincipal, "CustomerBankAccount", "BankAccountOfTheCompany");
	EndIf;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".FullDescr"));
	InformationAboutCompany.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".TIN"));
	InformationAboutCompany.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".LegalAddress_Display"));
	InformationAboutCompany.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".ActualAddress_Display"));
	InformationAboutCompany.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName + ".AccountNo"));
	InformationAboutCompany.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName + ".Bank.Description"));
	InformationAboutCompany.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName + ".Bank.Code"));
	InformationAboutCompany.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName + ".Bank.CorrAccount"));
	InformationAboutCompany.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".PhoneNumbers"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	EndIf;
	
	InfoAboutShipper = New Structure;
	InfoAboutShipper.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor"));
	InfoAboutShipper.Insert("ActualAddress", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "ShipperAddress"));
	
	FillingDataHeader.Insert("InfoAboutShipper", InfoAboutShipper);
	
	InfoAboutConsignee = New Structure;
	InfoAboutConsignee.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignee"));
	InfoAboutConsignee.Insert("ActualAddress", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "ConsigneeAddress"));
	
	FillingDataHeader.Insert("InfoAboutConsignee", InfoAboutConsignee);
	
	FillingDataHeader.Insert("VendorPresentation", NStr("en='Seller:';ru='Продавец:'") + " " + FillingDataHeader.InfoAboutVendor.FullDescr);
	FillingDataHeader.Insert("VendorAddress", "Address: " + FillingDataHeader.InfoAboutVendor.LegalAddress);
	
	TIN = FillingDataHeader.InfoAboutVendor.TIN;
	FillingDataHeader.Insert("VendorTIN", NStr("en='TIN seller:';ru='TIN seller:'") + " " + TIN);
	
	If ValueIsFilled(InfoAboutShipper.FullDescr) Then
		FillingDataHeader.Insert("PresentationOfShipper", NStr("en='Consignor and its address:';ru='Грузоотправитель и его адрес:'") + " "
			+ InfoAboutShipper.FullDescr + ?(ValueIsFilled(InfoAboutShipper.ActualAddress), ", "
			+ InfoAboutShipper.ActualAddress, ""));
	Else
		FillingDataHeader.Insert("PresentationOfShipper", NStr("en='Consignor and their address: --';ru='Грузоотправитель и его адрес: --'")); 
	EndIf;
	
	If ValueIsFilled(InfoAboutConsignee.FullDescr) Then
		FillingDataHeader.Insert("PresentationOfConsignee", NStr("en='Consignee and its address:';ru='Грузополучатель и его адрес:'") + " "
			+ InfoAboutConsignee.FullDescr + ?(ValueIsFilled(InfoAboutConsignee.ActualAddress), ", "
			+ InfoAboutConsignee.ActualAddress, ""));
	Else
		FillingDataHeader.Insert("PresentationOfConsignee", NStr("en='Consignee and their address: --';ru='Грузополучатель и его адрес: --'")); 
	EndIf;
	
	FillingDataHeader.Insert("ByDocument", NStr("en='To payment and settlement document #';ru='К платежно-расчетному документу №'") + " "
		+ GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PaymentDocument"));
	FillingDataHeader.Insert("CustomerPresentation",NStr("en='Customer:';ru='Покупатель:'") + " " + FillingDataHeader.InfoAboutCustomer.FullDescr);
	FillingDataHeader.Insert("CustomerAddress", NStr("en='Address:';ru='Адрес:'") + " "+ FillingDataHeader.InfoAboutCustomer.LegalAddress);
	
	TIN = FillingDataHeader.InfoAboutCustomer.TIN;
	FillingDataHeader.Insert("TINOfHBuyer", NStr("en='TIN customer:';ru='TIN customer:'") + " "  + TIN);
	
	CurrencyCode = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CurCode");
	TextCurrency = StringFunctionsClientServer.SubstituteParametersInString(NStr("en='Currency: code %1';ru='Валюта: код %1'"), CurrencyCode);
	FillingDataHeader.Insert("Currency", TextCurrency);
	
	FillingDataHeader.Insert("TotalAmountWithoutVAT", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "StGoodsWithoutVAT"));
	FillingDataHeader.Insert("TotalVATAmount", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AmountVAT"));
	FillingDataHeader.Insert("SubtotalTotal", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "StGoodAcTax"));
	FillingDataHeader.Insert("HeadDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SignatoryLP"));
	FillingDataHeader.Insert("SNPPBOLP", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SignatoryIE"));
	FillingDataHeader.Insert("Certificate", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SignerPrStateRegIE"));
	
	VT = New ValueTable;
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("MeasurementUnitCode");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("AmountWithoutVAT");
	VT.Columns.Add("Excise");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("SumWithVAT");
	VT.Columns.Add("CountryOfOriginCode");
	VT.Columns.Add("CountryPresentation");
	VT.Columns.Add("CCDPresentation");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "DescProd");
		OKEI = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "OKEI_Tov");
		NewRow.MeasurementUnitCode = OKEI;

		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "QuantIt");
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PriceTov");
		NewRow.AmountWithoutVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsWithoutVAT");
		NewRow.Excise = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountExcise");
		VATRatePresentation = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "TaxValMag");
		NewRow.VATRate = ?(VATRatePresentation = "Without VAT", VATRatePresentation, VATRatePresentation + " %");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountVAT");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodAcTax");
		CountryOfOriginCode = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "CodeOrig");
		NewRow.CountryOfOriginCode = CountryOfOriginCode;

		NewRow.CCDPresentation = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "TDNumber");
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	Return DataForObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Work with CORRECTION INVOICE

Function GetCorrectiveInvoiceNoteDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	NumberStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number");
	FillingDataHeader.Insert("Number", ?(ValueIsFilled(NumberStr), NumberStr, "--"));
	DateStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date");
	FillingDataHeader.Insert("Date", ?(ValueIsFilled(DateStr), Format(DateStr,"DLF= DD"), "--"));
	
	NumberStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CorrectionNumber");
	FillingDataHeader.Insert("CorrectionNumber", ?(ValueIsFilled(NumberStr), NumberStr, "--"));
	DateStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfCorrection");
	FillingDataHeader.Insert("DateOfCorrection", ?(ValueIsFilled(DateStr), Format(DateStr,"DLF= DD"), "--"));
	
	NumberStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "InvoiceNumber");
	FillingDataHeader.Insert("InvoiceNumber", ?(ValueIsFilled(NumberStr), NumberStr, "--"));
	DateStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "InvoiceDate");
	FillingDataHeader.Insert("InvoiceDate", ?(ValueIsFilled(DateStr), Format(DateStr,"DLF= DD"), "--"));
	
	NumberStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "InvoiceCorrectionNumber");
	FillingDataHeader.Insert("InvoiceCorrectionNumber", ?(ValueIsFilled(NumberStr), NumberStr, "--"));
	DateStr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "InvoiceCorrectionDate");
	FillingDataHeader.Insert("InvoiceCorrectionDate", ?(ValueIsFilled(DateStr), Format(DateStr,"DLF= DD"), "--"));
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.ActualAddress_Presentation"));
	InfoAboutCounterparty.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.AccountNumber"));
	InfoAboutCounterparty.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Description"));
	InfoAboutCounterparty.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Code"));
	InfoAboutCounterparty.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	InfoAboutCounterparty.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.PhoneNumbers"));
	
	IssuedByPrincipal = (GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "IssuedByPrincipal") = True);
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
		CompanyAttrName = "Company";
		BankAccountName = "BankAccountOfTheCompany";
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
		CompanyAttrName = ?(IssuedByPrincipal, "Customer", "Company");
		BankAccountName = ?(IssuedByPrincipal, "CustomerBankAccount", "BankAccountOfTheCompany");
	EndIf;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".FullDescr"));
	InformationAboutCompany.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".TIN"));
	InformationAboutCompany.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".LegalAddress_Display"));
	InformationAboutCompany.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".ActualAddress_Display"));
	InformationAboutCompany.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName +".AccountNo"));
	InformationAboutCompany.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName +".Bank.Description"));
	InformationAboutCompany.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName +".Bank.Code"));
	InformationAboutCompany.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountName +".Bank.CorrAccount"));
	InformationAboutCompany.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, CompanyAttrName + ".PhoneNumbers"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	EndIf;
	
	FillingDataHeader.Insert("VendorPresentation", "Seller: " + FillingDataHeader.InfoAboutVendor.FullDescr);
	FillingDataHeader.Insert("VendorAddress", "Address: " + FillingDataHeader.InfoAboutVendor.LegalAddress);
		
	TIN = FillingDataHeader.InfoAboutVendor.TIN;
	FillingDataHeader.Insert("VendorTIN", "TIN seller: " + TIN);
	
	FillingDataHeader.Insert("CustomerPresentation","Customer: " + FillingDataHeader.InfoAboutCustomer.FullDescr);
	FillingDataHeader.Insert("CustomerAddress", "Address: " + FillingDataHeader.InfoAboutCustomer.LegalAddress);
		
	TIN = FillingDataHeader.InfoAboutCustomer.TIN;
	FillingDataHeader.Insert("TINOfHBuyer", "TIN customer: " + TIN);
	
	CurrencyCode = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CurCode");
	TextCurrency = StringFunctionsClientServer.SubstituteParametersInString("Currency: code %1", CurrencyCode);
	FillingDataHeader.Insert("Currency", TextCurrency);
	
	FillingDataHeader.Insert("TotalDifferenceWithoutVATIncreasing", GetParsedTreeStringAttributeValue(
		ParseTree, ObjectString, "StGoodsWithoutVATInc"));
	FillingDataHeader.Insert("TotalDifferenceVATIncreasing", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AmountVATIncr"));
	FillingDataHeader.Insert("TotalDifferenceWithVATIncreasing", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "StGoodsTaxTotalInc"));
	FillingDataHeader.Insert("TotalDifferenceWithoutVATDecreasing", GetParsedTreeStringAttributeValue(
		ParseTree, ObjectString, "StGoodsVATTotalDec"));
	FillingDataHeader.Insert("TotalDifferenceVATDecreasing", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "AmountVATDecr"));
	FillingDataHeader.Insert("TotalDifferenceWithVATDecreasing", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "StGoodsAcTaxTotalDec"));
	FillingDataHeader.Insert("HeadDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SignatoryLP"));
	FillingDataHeader.Insert("SNPPBOLP", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"SignatoryIE"));
	FillingDataHeader.Insert("Certificate", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SignerPrStateRegIE"));
	
	VT = New ValueTable;
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("MeasurementUnitBefore");
	VT.Columns.Add("MeasurementUnitCode");
	VT.Columns.Add("MeasurementUnitCodeBefore");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("QuantityBefore");
	VT.Columns.Add("Price");
	VT.Columns.Add("PriceBefore");
	VT.Columns.Add("AmountWithoutVAT");
	VT.Columns.Add("AmountNoVATBefore");
	VT.Columns.Add("Excise");
	VT.Columns.Add("ExciseTo");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("VATRateBefore");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("VATAmountBefore");
	VT.Columns.Add("SumWithVAT");
	VT.Columns.Add("VATAmountBefore");
	VT.Columns.Add("DifferenceWithoutVATIncreasing");
	VT.Columns.Add("DifferenceWithoutVATDecreasing");
	VT.Columns.Add("DifferenceVATIncreasing");
	VT.Columns.Add("DifferenceVATDecreasing");
	VT.Columns.Add("DifferenceWithVATIncreasing");
	VT.Columns.Add("DifferenceWithVATDecreasing");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		NewRow = VT.Add();
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "DescProd");
		
		RCUMBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "OKEI_GoodsBefore");
		OKEI = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "OKEI_ProdAfter");
		NewRow.MeasurementUnitCode = OKEI;
		
		NewRow.QuantityBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "QuantItBefore");
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "NumItAfter");
		NewRow.PriceBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PriceTovBef");
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PriceTovAfter");
		NewRow.AmountNoVATBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsVATBeforeChange");
		NewRow.AmountWithoutVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsWithoutVATAfterChange");
		NewRow.ExciseTo = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ExciseTo");
		NewRow.Excise = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ExciseAfter");
		VATRatePresentationBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "TaxValMagBefore");
		NewRow.VATRateBefore = ?(VATRatePresentationBefore = "Without VAT", VATRatePresentationBefore, VATRatePresentationBefore + " %");
		VATRatePresentationAfter = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "TaxValMagAfter");
		NewRow.VATRate = ?(VATRatePresentationAfter = "Without VAT",
			VATRatePresentationAfter,VATRatePresentationAfter + " %");
		NewRow.VATAmountBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountVATBefore");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountVATAfter");
		NewRow.VATAmountBefore = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoosAcTaxBeforeChange");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsAcTaxAfterChange");
		NewRow.DifferenceWithoutVATIncreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"StGoodsWithoutVATInc");
		NewRow.DifferenceVATIncreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountVATIncr");
		NewRow.DifferenceWithVATIncreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsAcTaxInc");
		NewRow.DifferenceWithoutVATDecreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsWithoutVATDec");
		NewRow.DifferenceVATDecreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountVATDecr");
		NewRow.DifferenceWithVATDecreasing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "StGoodsAcTaxDec");
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", 	FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	Return DataForObject;
	
EndFunction

// Procedure populates tabular document "Correction Invoice".
//
Procedure FillInTabularDocumentCorrectionInvoice_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_InvoiceCorrective1137");
	
	TableHeader = Template.GetArea("Header");
	TableHeader.Parameters.Fill(PrintInfo.Header);
	SpreadsheetDocument.Put(TableHeader);
	
	// Displaying table title
	TableTitle = Template.GetArea("TableTitle|TableMainData");
	SpreadsheetDocument.Put(TableTitle);
	RowData = StructureStringData(1);
	
	// Create array to check output
	OutputedAreasArray = New Array;
	
	// Displaying multiline part of the document
	TemplateArea  = Template.GetArea("Row|TableMainData");
	AreaTotalAmount   = Template.GetArea("Total");
	FooterArea = Template.GetArea("Footer");
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataTableRows = New ValueTable;
	AdditDataTableRows.Columns.Add("NumberStr");
	AdditDataTableRows.Columns.Add("DigitallySignedData");
	AdditDataTableRows.Columns.Add("UnDigitallySignedData");
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		AreaTitleTablesDD = Template.GetArea("TableHeader|TableAdditData");
		AreaTemplateDD           = Template.GetArea("Row|TableAdditData");
		AreaTableTitleDDSES = Template.GetArea("TableTitle|TableWithEDSAdditData");
		DDSESTemplateArea           = Template.GetArea("Row|TableWithEDSAdditData");
		AreaTableTitleDDBWithoutES = Template.GetArea("TableTitle|TableWithoutEDSAdditData");
		TemplateAreaDDWithoutES           = Template.GetArea("Row|TableWithoutEDSAdditData");
		If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
			SpreadsheetDocument.Join(AreaTitleTablesDD);
		Else
			If AdditDataExistanceStructure.AreDigitallySigned Then
				SpreadsheetDocument.Join(AreaTableTitleDDSES);
			EndIf;
			If AdditDataExistanceStructure.AreNotDigitallySigned Then
				SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
			EndIf;
		EndIf;
	EndIf;
	
	Products = PrintInfo.Products;
	LineCount = Products.Count();
	For Each ProductsRow IN Products Do
		
		RowData.Number = RowData.Number + 1;
		
		OutputedAreasArray.Clear();
		OutputedAreasArray.Add(TemplateArea);
		
		If RowData.Number = LineCount Then
			OutputedAreasArray.Add(AreaTotalAmount);
			OutputedAreasArray.Add(FooterArea);
		EndIf;
		
		If Not SpreadsheetDocumentFitsPage(SpreadsheetDocument,OutputedAreasArray) Then
			SpreadsheetDocument.PutHorizontalPageBreak();
			SpreadsheetDocument.Put(TableTitle);
			If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
				SpreadsheetDocument.Join(AreaTitleTablesDD);
			Else
				If AdditDataExistanceStructure.AreDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDSES);
				EndIf;
				If AdditDataExistanceStructure.AreNotDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
				EndIf;
			EndIf;
		EndIf;
		
		TemplateArea.Parameters.Fill(ProductsRow);
		PutDashesInRowEmptyFieldsInvoice(TemplateArea);
		SpreadsheetDocument.Put(TemplateArea);
		If AdditDataTableRows.Count() > 0 Then
			ADTableString = AdditDataTableRows.Find(String(RowData.Number), "NumberStr");
			If ADTableString <> Undefined Then
				If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
					AreaTemplateDD.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
					AreaTemplateDD.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
					SpreadsheetDocument.Join(AreaTemplateDD);
				Else
					If AdditDataExistanceStructure.AreDigitallySigned Then
						DDSESTemplateArea.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
						SpreadsheetDocument.Join(DDSESTemplateArea);
					EndIf;
					If AdditDataExistanceStructure.AreNotDigitallySigned Then
						TemplateAreaDDWithoutES.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
						SpreadsheetDocument.Join(TemplateAreaDDWithoutES);
					EndIf;
				EndIf;
			EndIf;
		EndIf;
		
	EndDo;
	
	AreaTotalAmount.Parameters.Fill(PrintInfo.Header);
	SpreadsheetDocument.Put(AreaTotalAmount);
	FooterArea.Parameters.Fill(PrintInfo.Header);
	SpreadsheetDocument.Put(FooterArea);
	
	FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with CORRECTION DOCUMENT

Function GetCorrectingDocumentDataToPrint(ObjectString, ParseTree)
	
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.ActualAddress_Presentation"));
	InfoAboutCounterparty.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.AccountNumber"));
	InfoAboutCounterparty.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Description"));
	InfoAboutCounterparty.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.Code"));
	InfoAboutCounterparty.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	InfoAboutCounterparty.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.PhoneNumbers"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing 
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
	EndIf;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.FullDescr"));
	InformationAboutCompany.Insert("TIN", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.TIN"));
	InformationAboutCompany.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.LegalAddress_Presentation"));
	InformationAboutCompany.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.ActualAddress_Presentation"));
	InformationAboutCompany.Insert("AccountNo",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CompanyBankAcc.AccountNumber"));
	InformationAboutCompany.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.Description"));
	InformationAboutCompany.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.Code"));
	InformationAboutCompany.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BankAccountOfTheCompany.Bank.CorrAccount"));
	InformationAboutCompany.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.PhoneNumbers"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing
		OR ObjectString.EDDirection = Enums.EDDirections.Intercompany Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	EndIf;
	
	InfoAboutShipper = New Structure;
	InfoAboutShipper.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.FullDescr"));
	InfoAboutShipper.Insert("TIN", 				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.TIN"));
	InfoAboutShipper.Insert("LegalAddress",	 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.LegalAddress_Presentation"));
	InfoAboutShipper.Insert("ActualAddress",	 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.ActualAddress_Presentation"));
	InfoAboutShipper.Insert("AccountNo",		 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsignorBankAccount.AccountNumber"));
	InfoAboutShipper.Insert("Bank",				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.Description"));
	InfoAboutShipper.Insert("BIN",				 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.Code"));
	InfoAboutShipper.Insert("CorrAccount",			 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShipperBankAccount.Bank.CorrAccount"));
	InfoAboutShipper.Insert("PhoneNumbers",			 GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.PhoneNumbers"));
	
	FillingDataHeader.Insert("InfoAboutShipper", InfoAboutShipper);
	
	InfoAboutConsignee = New Structure;
	InfoAboutConsignee.Insert("FullDescr",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.FullDescr"));
	InfoAboutConsignee.Insert("TIN", 			   	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.TIN"));
	InfoAboutConsignee.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.LegalAddress_Presentation"));
	InfoAboutConsignee.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignee.ActualAddress_Presentation"));
	InfoAboutConsignee.Insert("AccountNo",		 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.AccountNumber"));
	InfoAboutConsignee.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.Description"));
	InfoAboutConsignee.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.Code"));
	InfoAboutConsignee.Insert("CorrAccount",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ConsigneeBankAccount.Bank.CorrAccount"));
	InfoAboutConsignee.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "MeansPhoneNumbers"));
	
	FillingDataHeader.Insert("InfoAboutConsignee", InfoAboutConsignee);
	
	FillingDataHeader.Insert("DepartmentsPresentation", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Consignor.StructuralDepartment"));
	
	FillingDataHeader.Insert("VendorPresentation",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.Name"));
	FillingDataHeader.Insert("PayerPresentation",	"");

	FillingDataHeader.Insert("BasisNumber", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "NumberByCustomerData"));
	FillingDataHeader.Insert("BasisDate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateByCustomerData"));
	FillingDataHeader.Insert("BasisDescription", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BasisDescription"));
	
	FillingDataHeader.Insert("DocumentNumber",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number"));
	FillingDataHeader.Insert("DocumentDate",		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date"));
	FillingDataHeader.Insert("BasisNumber",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BasisDocumentNumber"));
	FillingDataHeader.Insert("BasisDate",		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BasisDocumentDate"));
	
	
	FillingDataHeader.Insert("OriginalDocumentPresentation",	GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString,	"OriginalDocumentPresentation"));
	
	FillingDataHeader.Insert("CorrectionNumber",				GetParsedTreeStringAttributeValue(ParseTree, 
																					ObjectString,	"CorrectionNumber"));
	
	FillingDataHeader.Insert("DateOfCorrection",				GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString,	"DateOfCorrection"));
	
	FillingDataHeader.Insert("SourceDocumentCorrectionNumber",	GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString, "SourceDocumentCorrectionNumber"));
																					
	FillingDataHeader.Insert("SourceDocumentCorrectionDate",		GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString, "SourceDocumentCorrectionDate"));
																					
	FillingDataHeader.Insert("InitialDocumentNumber",				GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString, "InitialDocumentNumber"));
																					
	FillingDataHeader.Insert("InitialDocumentDate",				GetParsedTreeStringAttributeValue(ParseTree,
																					ObjectString, "InitialDocumentDate"));


	
	FillingDataHeader.Insert("ExchangeRate", 				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ExchangeRate"));
	FillingDataHeader.Insert("CurrencyCode",         GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Description"));
	FillingDataHeader.Insert("PriceIncludesVAT", 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PriceIncludesVAT"));
	FillingDataHeader.Insert("ShippingAddress", 	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ShippingAddress"));
	
	FillingDataFooter = New Structure;
	FillingDataFooter.Insert("DateReleased", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DateReleased"));
	FillingDataFooter.Insert("HeadPost", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ManagerPosition"));
	FillingDataFooter.Insert("HeadDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Consignor.ManagerName"));
	
	VT = New ValueTable;
	
	VT.Columns.Add("ProductCode");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("PackagingKind");
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("BaseUnitCodeRCUM");
	VT.Columns.Add("BaseUnitDescription");
	VT.Columns.Add("PriceBeforeCorrection", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Price", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("AmountBeforeCorrection", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Amount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("VATAmountBeforeCorrection", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("VATAmount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("VATAmountBeforeAdjustments", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("SumWithVAT", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("QuantityBeforeCorrection", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("Quantity", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("NetWeightBeforeCorrection", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("NetWeight", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("GrossWeight", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("PlacesQuantity", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	VT.Columns.Add("QuantityInOnePlace", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	
	
	ProductsAndServicesName = "ProductsAndServices";
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		
		NewRow.ProductCode = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductCode");
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Name");
		
		NewRow.BaseUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.MeasurementUnit.Description");
		NewRow.BaseUnitCodeRCUM = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.MeasurementUnit.Code");
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
		NewRow.QuantityBeforeCorrection = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "QuantityBeforeCorrection");
		NewRow.QuantityInOnePlace = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "QuantityInOnePlace");
		
		NewRow.PlacesQuantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Places");
		NewRow.GrossWeight = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "GrossWeight");
		
		NewRow.NetWeightBeforeCorrection = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "NetWeightBeforeCorrection");
		NewRow.NetWeight = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "NetWeight");
		
		NewRow.PackagingKind = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Package");
		
		NewRow.PriceBeforeCorrection = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PriceBeforeCorrection");
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.AmountBeforeCorrection = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AmountBeforeCorrection");
		NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		NewRow.VATAmountBeforeCorrection = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmountBeforeCorrection");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.VATAmountBeforeAdjustments = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmountBeforeAdjustments");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SumWithVAT");
		NewRow.VATAmount = ?(ValueIsFilled(NewRow.VATAmount), NewRow.VATAmount, 0);
		If Not ValueIsFilled (NewRow.VATRate) Then
			NewRow.VATRate = NStr("en='Without VAT';ru='без НДС'");
		Else
			NewRow.VATRate = String(NewRow.VATRate);
		EndIf;
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", 	FillingDataHeader);
	DataForObject.Insert("Footer", FillingDataFooter);
	DataForObject.Insert("Products", VT);
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	Return DataForObject;
	
EndFunction

// Procedure populates tabular document "Correction Invoice".
//
Procedure FillInTabularDocumentCorrectionDocument_ED(SpreadsheetDocument, PrintInfo, BuyerData)
	
	SpreadsheetDocument.LeftMargin = 5;
	SpreadsheetDocument.RightMargin = 5;
	SpreadsheetDocument.HeaderSize = 0;
	SpreadsheetDocument.FooterSize = 0;
	SpreadsheetDocument.FitToPage = True;
	SpreadsheetDocument.PageOrientation = PageOrientation.Landscape;
	
	Template = Catalogs.EDAttachedFiles.GetTemplate(?(BuyerData.Count() > 0, "ED_AgreementAboutCostChangeRecipient", "ED_AgreementAboutCostChangeSender"));
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_ED_SidesAgreement";
	
	FillInHeaderAttributesCostCorrection(PrintInfo.Header, Template, SpreadsheetDocument);
	
	PageNumber = 1;
	TotalAmounts = StructureTotalAmounts();
	
	CoefficientConversion = 1;
	RowData = StructureStringData(CoefficientConversion);
	
	// Create array to check output
	OutputedAreasArray = New Array;
	
	// Displaying multiline part of the document
	AreaTitleTables = Template.GetArea("TabTitle|TableMainData");
	TemplateArea           = Template.GetArea("Row|TableMainData");
	TotalsAreaByPage = Template.GetArea("TotalByPage|TableMainData");
	AreaTotal            = Template.GetArea("Total|TableMainData");
	FooterArea          = Template.GetArea("Footer");
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataTableRows = New ValueTable;
	AdditDataTableRows.Columns.Add("NumberStr");
	AdditDataTableRows.Columns.Add("DigitallySignedData");
	AdditDataTableRows.Columns.Add("UnDigitallySignedData");
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		AreaTitleTablesDD = Template.GetArea("TabTitle|TableAdditData");
		AreaTemplateDD           = Template.GetArea("Row|TableAdditData");
		AreaTableTitleDDSES = Template.GetArea("TableTitle|TableWithEDSAdditData");
		DDSESTemplateArea           = Template.GetArea("Row|TableWithEDSAdditData");
		AreaTableTitleDDBWithoutES = Template.GetArea("TabTitle|TableWithoutEDSAdditData");
		TemplateAreaDDWithoutES           = Template.GetArea("Row|TableWithoutEDSAdditData");
	EndIf;
	
	// Display tabular section of the document
	TSProducts = PrintInfo.Products;
	
	LineCount = TSProducts.Count();
	
	For Each ProductsRow IN TSProducts Do
		
		RowData.Number = RowData.Number + 1;
		
		TemplateArea.Parameters.Fill(ProductsRow);
		
		RowData.Places = ProductsRow.PlacesQuantity;
		
		RowData.CoefficientConversion  = ?(ValueIsFilled(ProductsRow.QuantityInOnePlace), ProductsRow.QuantityInOnePlace, 1);
		
		RowData.QuantityBeforeCorrection  = ProductsRow.QuantityBeforeCorrection;
		RowData.Quantity  = ProductsRow.Quantity;
		RowData.NetWeightBeforeCorrection = ProductsRow.NetWeightBeforeCorrection;
		RowData.NetWeight = ProductsRow.NetWeight;
		
		RowData.AmountBeforeCorrection     = ProductsRow.AmountBeforeCorrection;
		RowData.Amount                    = ProductsRow.Amount;
		RowData.VATAmountBeforeCorrection  = ProductsRow.VATAmountBeforeCorrection;
		RowData.VATAmount                 = ProductsRow.VATAmount;
		RowData.VATAmountBeforeAdjustments = ProductsRow.VATAmountBeforeAdjustments;
		RowData.SumWithVAT                = ProductsRow.SumWithVAT;
		
		RowData.PriceBeforeCorrection = ProductsRow.PriceBeforeCorrection;
		RowData.Price = ProductsRow.Price;
		
		TemplateArea.Parameters.Fill(RowData);
		
		
		If RowData.Number = 1 Then // first string
			
			SpreadsheetDocument.Put(AreaTitleTables);
			If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
				SpreadsheetDocument.Join(AreaTitleTablesDD);
			Else
				If AdditDataExistanceStructure.AreDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDSES);
				EndIf;
				If AdditDataExistanceStructure.AreNotDigitallySigned Then
					SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
				EndIf;
			EndIf;
			
		Else
			
			OutputedAreasArray.Clear();
			OutputedAreasArray.Add(TemplateArea);
			OutputedAreasArray.Add(TotalsAreaByPage);
			
			If RowData.Number = LineCount Then
				
				OutputedAreasArray.Add(AreaTotal);
				OutputedAreasArray.Add(FooterArea);
				
			EndIf;
			
		EndIf;
		
		SpreadsheetDocument.Put(TemplateArea);
		CalculateTotalAmounts(TotalAmounts, RowData);
		If AdditDataTableRows.Count() > 0 Then
			ADTableString = AdditDataTableRows.Find(String(RowData.Number), "NumberStr");
			If ADTableString <> Undefined Then
				If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
					AreaTemplateDD.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
					AreaTemplateDD.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
					SpreadsheetDocument.Join(AreaTemplateDD);
				Else
					If AdditDataExistanceStructure.AreDigitallySigned Then
						DDSESTemplateArea.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
						SpreadsheetDocument.Join(DDSESTemplateArea);
					EndIf;
					If AdditDataExistanceStructure.AreNotDigitallySigned Then
						TemplateAreaDDWithoutES.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
						SpreadsheetDocument.Join(TemplateAreaDDWithoutES);
					EndIf;
				EndIf;
			EndIf;
		EndIf;
		
	EndDo;
	
	// Display totals on the last page
	TotalsAreaByPage = Template.GetArea("TotalByPage");
	TotalsAreaByPage.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TotalsAreaByPage);
	
	// Display totals on the full document
	TemplateArea = Template.GetArea("Total");
	TemplateArea.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TemplateArea);
	
	// Display the footer of the document
	FillFooterAttributesTORG12(PrintInfo.Footer, Template, SpreadsheetDocument, BuyerData, True);
	
	FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with PRICE LIST

Function GetPriceListDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutVendor = New Structure;
	InfoAboutVendor.Insert("Presentation",      GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.Name"));
	InfoAboutVendor.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	FillingDataHeader.Insert("InfoAboutVendor", InfoAboutVendor);
	FillingDataHeader.Insert("GeneratingDate", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "GeneratingDate"));
	
	VT = New ValueTable;
	VT.Columns.Add("SKU");
	VT.Columns.Add("Code");
	VT.Columns.Add("Product");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("Price");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.SKU          = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.SKU");
		NewRow.Code              = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Code");
		NewRow.Product            = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Name");
		NewRow.MeasurementUnit = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"Package.Name");
		NewRow.Price             = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Quantity       = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

Procedure FillInTabularDocumentPriceList_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_PriceList");
	
	HeaderArea = Template.GetArea("Title|Data");
	AreaHeader     = Template.GetArea("TableHeader|Data");
	AreaRow    = Template.GetArea("TableRow|Data");
	FooterArea    = Template.GetArea("TableFooter|Data");
	
	AdditDataTableRows = AdditDataTable();
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	AdditionalInformationExists = False;
	If AdditDataTableRows.Count() > 0 Then
		AdditionalInformationExists = True;
		
		AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
		AreaTemplateDD           = Template.GetArea("TableRow|TableWithEDSAdditData");
		
	EndIf;
	
	HeaderArea.Parameters.GeneratingDate = Format(PrintInfo.Header.GeneratingDate, "DLF= D");
	SpreadsheetDocument.Put(HeaderArea);
	
	AreaHeader.Parameters.Fill(PrintInfo.Header);
	
	InfoAboutVendor = PrintInfo.Header.InfoAboutVendor;
	AreaHeader.Parameters.VendorPresentation = ?(ValueIsFilled(InfoAboutVendor.FullDescr),
		InfoAboutVendor.FullDescr,
		InfoAboutVendor.Presentation);
	
	SpreadsheetDocument.Put(AreaHeader);
	
	If AdditionalInformationExists Then
		SpreadsheetDocument.Join(AreaTitleTablesDD);
	EndIf;
	
	TableProducts = PrintInfo.Products;
	LineNumber = 1;
	For Each String IN TableProducts Do
		
		AreaRow.Parameters.Fill(String);
		AreaRow.Parameters.LineNumber = LineNumber;
		SpreadsheetDocument.Put(AreaRow);
		
		
		DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure,
			LineNumber, SpreadsheetDocument, AreaTemplateDD);
		
		LineNumber = LineNumber + 1;

	EndDo;
	
	SpreadsheetDocument.Put(FooterArea);
	
	DisplayHeaderAdditDataForPrint(PrintInfo, Template,SpreadsheetDocument);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with ED read by CML2 scheme

Function DataStructureCounterparty(ObjectString, ParseTree, ParticipantType, BankAccountType)
	
	Structure = New Structure;
	Description = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + ".Description");
	FullDescr = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + ".FullDescr");
	Structure.Insert("Presentation", 	?(ValueIsFilled(Description), Description, FullDescr));
	Structure.Insert("FullDescr",?(ValueIsFilled(FullDescr), FullDescr, Description));
	Structure.Insert("TIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + ".TIN"));
	Structure.Insert("LegalAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + ".LegalAddress_Display"));
	Structure.Insert("ActualAddress",	GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + ".ActualAddress_Display"));
	Kind = ElectronicDocumentsOverridable.FindRefToObject("ContactInformationKinds","CounterpartyPhone");
	If ValueIsFilled(Kind) Then
		Structure.Insert("PhoneNumbers",			GetParsedTreeStringAttributeValue(ParseTree, ObjectString, ParticipantType + "." + Kind));
	EndIf;
	Structure.Insert("AccountNo",		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountType + ".AccountNo"));
	Structure.Insert("Bank",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountType + ".Bank.Description"));
	Structure.Insert("BIN",				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, BankAccountType + ".Bank.Code"));
	
	Return Structure;
	
EndFunction

Function ProductsTable(HeaderData, ObjectString, ParseTree, TableName)
	
	VT = New ValueTable;
	
	VT.Columns.Add("SKU");
	VT.Columns.Add("ProductCode");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("PackagingKind");
	VT.Columns.Add("VATIncludedInAmount");
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("BaseUnitCodeRCUM");
	VT.Columns.Add("BaseUnitDescription");
	VT.Columns.Add("Price", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Amount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("VATAmount", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("SumWithVAT", New TypeDescription("Number", New NumberQualifiers(15, 2)));
	VT.Columns.Add("Quantity", New TypeDescription("Number", New NumberQualifiers(15, 3)));
	
	VT.Columns.Add("SerialNumbers");
	
	AdditionalInformationDigitallySigned = New Structure;
	
	TableSerialNumbers = New ValueTable;
	TableSerialNumbers.Columns.Add("RowKey");
	TableSerialNumbers.Columns.Add("AttributeValue");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", TableName));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.SKU = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.SKU");
		NewRow.ProductCode = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.SKU");
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Name");
		
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.VATIncludedInAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATIncludedInAmount");
		NewRow.PackagingKind = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PackagingKind");
		
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		VATInAmount = ?(GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATIncludedInAmount") = True, True, False);
		VATAmount = ?(TypeOf(VATAmount) = Type("Number"), VATAmount, 0);
		
		NewRow.Amount = Amount - ?(VATInAmount, VATAmount, 0);
		NewRow.VATAmount = VATAmount;
		NewRow.SumWithVAT = Amount + ?(VATInAmount, 0, VATAmount);
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
		
		EI = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.BasicUnit");
		If ValueIsFilled(EI) Then
			NewRow.BaseUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.BaseUnit.Description");
			NewRow.BaseUnitCodeRCUM = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.BaseUnit.Code");
		Else
			NewRow.BaseUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.MeasurementUnit.Description");
			NewRow.BaseUnitCodeRCUM = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.MeasurementUnit.Code");
		EndIf;
		
		SerialNumbers = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SerialNumbers");
		If ValueIsFilled(SerialNumbers) Then
			
			If TypeOf(SerialNumbers) = Type("String") Then
				NumberArray = New Array;
				NumberArray.Add(SerialNumbers);
			Else
				NumberArray = SerialNumbers;
			EndIf;
			
			SerialNumbers = StringFunctionsClientServer.GetStringFromSubstringArray(NumberArray, ";");
			
			AttributesValuesNewRow = TableSerialNumbers.Add();
			AttributesValuesNewRow.RowKey = VT.IndexOf(NewRow);
			AttributesValuesNewRow.AttributeValue = "Serial numbers: "+ SerialNumbers;
			
		EndIf;
		
	EndDo;
	
	If TableSerialNumbers.Count() Then
		HeaderData.Insert("AttributeValues", TableSerialNumbers);
	EndIf;
	
	Return VT;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Work with the Act on the transfer of rights (CML2)

Function GetDataAssignmentDeedForPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = DataStructureCounterparty(ObjectString, ParseTree, "Counterparty", "CounterpartyBankAcc");
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutLicensee", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutLicensor", InfoAboutCounterparty);
	EndIf;
	
	InformationAboutCompany = DataStructureCounterparty(ObjectString, ParseTree, "Company", "BankAccountOfTheCompany");
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutLicensor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutLicensee", InformationAboutCompany);
	EndIf;
	
	BasisDocuments = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "BasisDocuments");
	If ValueIsFilled(BasisDocuments) Then
		Basis = "";
		If TypeOf(BasisDocuments) = Type("Array") Then
			For Each Item IN BasisDocuments Do
				Basis = ?(ValueIsFilled(Basis), "; ", "") + Item;
			EndDo;
		Else
			Basis = BasisDocuments;
		EndIf;
		FillingDataHeader.Insert("Basis", Basis);
	EndIf;
	
	InfoAboutPayer = DataStructureCounterparty(ObjectString, ParseTree, "Payer", "CounterpartyBankAcc");
	FillingDataHeader.Insert("InfoAboutPayer", InfoAboutPayer);
	
	FillingDataHeader.Insert("DocumentNumber", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number"));
	FillingDataHeader.Insert("DocumentDate", Date(GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date")));
	
	FillingDataHeader.Insert("CorrectionNumber", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CorrectionNumber"));
	FillingDataHeader.Insert("DateOfCorrection", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfCorrection"));
	
	FillingDataHeader.Insert("TransferConditions", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "TransferConditions"));
	FillingDataHeader.Insert("CodePartner", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CodePartner"));
	PaymentDelayDays = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PaymentDelayDays");
	FillingDataHeader.Insert("PaymentDelayDays", ?(ValueIsFilled(PaymentDelayDays), PaymentDelayDays, 45));
	PercentFineForDayOfDelay = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PercentFineForDayOfDelay");
	FillingDataHeader.Insert("PercentFineForDayOfDelay", ?(ValueIsFilled(PercentFineForDayOfDelay), PercentFineForDayOfDelay, 0.1));
	
	FillingDataHeader.Insert("GeneratingDate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "GeneratingDate"));
	
	DocumentAmount = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DocumentAmount");
	CurrencyCode = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Currency.Code");
	FillingDataHeader.Insert("AmountInWords", ElectronicDocumentsOverridable.AmountInWords(DocumentAmount, CurrencyCode));
	
	Products = ProductsTable(FillingDataHeader, ObjectString, ParseTree, "TSRow");
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", Products);
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document Acceptance certificate.
//
Procedure FillSpreadsheetDocumentDeedOfAssignment(SpreadsheetDocument, PrintInfo)
	
	SpreadsheetDocument.LeftMargin = 5;
	SpreadsheetDocument.RightMargin = 5;
	SpreadsheetDocument.HeaderSize = 0;
	SpreadsheetDocument.FooterSize = 0;
	SpreadsheetDocument.PageOrientation = PageOrientation.Landscape;
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;

	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_AcceptanceCertificate_Certificate";
	
	Header = PrintInfo.Header;
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_RightsDelegationAct");
	
	// Display act header
	TemplateArea = Template.GetArea("Header");
	TemplateArea.Parameters.Fill(Header);
	
	FillInCorrectionDateNumber(TemplateArea, Header.DateOfCorrection, Header.CorrectionNumber);
	
	If Not ValueIsFilled(Header.CodePartner) Then
		TemplateArea.Areas.Find("AreaCodePartner").Clear();
	EndIf;
	
	TemplateArea.Parameters.PresentationLicensor = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		Header.InfoAboutLicensor,
		"FullDescr,TIN,ActualAddress,PhoneNumbers,AccountNo,Bank,BIN,CorrAccount");
	
	TemplateArea.Parameters.PresentationLicensee = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		Header.InfoAboutLicensee,
		"FullDescr,TIN,ActualAddress,PhoneNumbers,AccountNo,Bank,BIN,CorrAccount");
	
	TemplateArea.Parameters.PayerPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		Header.InfoAboutPayer,
		"FullDescr,TIN,LegalAddress,PhoneNumbers,AccountNo,Bank,BIN");
		
	If ValueIsFilled(Header.TransferConditions) Then
		TemplateArea.Areas.TransferConditionsArea.Text = Header.TransferConditions;
	Else
		TemplateArea.Parameters.LicensorDescription = ?(ValueIsFilled(Header.InfoAboutLicensor.Presentation),
			Header.InfoAboutLicensor.Presentation, Header.InfoAboutLicensor.FullDescr);
		TemplateArea.Parameters.LicenseeDescription = ?(ValueIsFilled(Header.InfoAboutLicensee.Presentation),
			Header.InfoAboutLicensee.Presentation, Header.InfoAboutLicensee.FullDescr);
	EndIf;
	
	SpreadsheetDocument.Put(TemplateArea);
	PageNumber = 1;
	TotalAmounts = StructureTotalAmounts();
	
	CoefficientConversion = 1;
	RowData = StructureStringData(CoefficientConversion);
	
	// Create array to check output
	OutputedAreasArray = New Array;
	
	// Displaying multiline part of the document
	AreaTitleTables = Template.GetArea("TabTitle|TableMainData");
	TemplateArea           = Template.GetArea("Row|TableMainData");
	TotalsAreaByPage = Template.GetArea("TotalByPage|TableMainData");
	AreaTotal            = Template.GetArea("Total|TableMainData");
	FooterArea          = Template.GetArea("Footer");
		
	// Display tabular section of the document
	TSProducts = PrintInfo.Products;
	If TSProducts.Columns.Find("VATAmount") <> Undefined AND TSProducts.Total("VATAmount") > 0 Then
		IsVAT = True;
	Else
		IsVAT = False;
	EndIf;
	
	LineCount = TSProducts.Count();
	
	For Each ProductsRow IN TSProducts Do
		
		RowData.Number = RowData.Number + 1;
		
		TemplateArea.Parameters.Fill(ProductsRow);
		FillPropertyValues(RowData, ProductsRow);
		TemplateArea.Parameters.Fill(RowData);
		
		If RowData.Number = 1 Then // first string
			
			AreaTitleTables.Parameters.PageNumber = "Page " + PageNumber;
			SpreadsheetDocument.Put(AreaTitleTables);
			
		Else
			
			OutputedAreasArray.Clear();
			OutputedAreasArray.Add(TemplateArea);
			OutputedAreasArray.Add(TotalsAreaByPage);
			
			If RowData.Number = LineCount Then
				
				OutputedAreasArray.Add(AreaTotal);
				OutputedAreasArray.Add(FooterArea);
				
			EndIf;
			
			If RowData.Number <> 1 AND Not SpreadsheetDocumentFitsPage(SpreadsheetDocument,OutputedAreasArray) Then
				
				TotalsAreaByPage.Parameters.Fill(TotalAmounts);
				SpreadsheetDocument.Put(TotalsAreaByPage);
				
				// Clear results for a page.
				ResetTotalsByPage(TotalAmounts);
				
				PageNumber = PageNumber + 1;
				SpreadsheetDocument.PutHorizontalPageBreak();
				AreaTitleTables.Parameters.PageNumber = "Page " + PageNumber;
				SpreadsheetDocument.Put(AreaTitleTables);
				
			EndIf;
			
		EndIf;
		
		SpreadsheetDocument.Put(TemplateArea);
		CalculateTotalAmounts(TotalAmounts, RowData);
		
	EndDo;
	
	// Display totals on the last page
	TotalsAreaByPage = Template.GetArea("TotalByPage");
	TotalsAreaByPage.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TotalsAreaByPage);
	
	// Display totals on the full document
	TemplateArea = Template.GetArea("Total");
	TemplateArea.Parameters.Fill(TotalAmounts);
	
	SpreadsheetDocument.Put(TemplateArea);
	
	FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	
	TemplateArea = Template.GetArea("Footer");
	
	TemplateArea.Parameters.Fill(Header);
	
	FullDocumentDate = Format(Header.GeneratingDate, "DF=""dd MMMM yyyy """"year""""""");
	StringLength = StrLen(FullDocumentDate);
	FirstSeparator = Find(FullDocumentDate, " ");
	SecondSeparator = Find(Right(FullDocumentDate, StringLength - FirstSeparator), " ") + FirstSeparator;
	TemplateArea.Parameters.DocumentDateDay = """" + Left(FullDocumentDate, FirstSeparator -1 ) + """";
	TemplateArea.Parameters.DocumentDateMonth = Mid(FullDocumentDate, FirstSeparator + 1, SecondSeparator - FirstSeparator - 1);
	TemplateArea.Parameters.DocumentDateYear = Right(FullDocumentDate, StringLength - SecondSeparator);
	
	SpreadsheetDocument.Put(TemplateArea);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with catalog of files

Function GetGoodsListDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutVendor = New Structure;
	InfoAboutVendor.Insert("Presentation",      GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.Name"));
	InfoAboutVendor.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutVendor.Insert("OfficialName", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.OfficialName"));
	InfoAboutVendor.Insert("TIN", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Counterparty.TIN"));
	
	FillingDataHeader.Insert("InfoAboutVendor", InfoAboutVendor);
	FillingDataHeader.Insert("GeneratingDate", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "GeneratingDate"));
	
	VT = New ValueTable;
	VT.Columns.Add("SKU");
	VT.Columns.Add("Code");
	VT.Columns.Add("Product");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("MeasurementUnit");
	VT.Columns.Add("PropertyValues");
	VT.Columns.Add("Images");
	ThereAreProperties = False;
	ThereArePictures = False;
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.SKU = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.SKU");
		NewRow.Code     = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Code");
		NewRow.Product   = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Name");
			
		PropertyValues = GetParsedTreeStringAttributeValue(
								ParseTree,
								TSRow,
								"SupplierProductsAndServices.PropertyValues");
		If Not PropertyValues = Undefined Then
			NewRow.PropertyValues = PropertyValues;
			ThereAreProperties = True;
		EndIf;
		
		Images = GetParsedTreeStringAttributeValue(
								ParseTree,
								TSRow,
								"SupplierProductsAndServices.Images");
		If Not Images = Undefined Then
			NewRow.Images = Images;
			ThereArePictures = True;
		EndIf;
		
		Package = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "UOM.Name");
		MeasurementUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.MeasurementUnit.Description");
		If Not ValueIsFilled(MeasurementUnitDescription) Then
			MeasurementUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
				"SupplierProductsAndServices.MeasurementUnit.DescriptionFull");
		EndIf;
		
		NewRow.MeasurementUnit = MeasurementUnitDescription;
		
	EndDo;
	
	FillingDataHeader.Insert("ThereAreProperties", ThereAreProperties);
	FillingDataHeader.Insert("ThereArePictures", ThereArePictures);
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

Procedure FillInProductsCatalogTabularDocument_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_ProductsDirectory");
	
	HeaderArea     = Template.GetArea("Title|TableMainData");
	AreaHeader         = Template.GetArea("TableHeader|TableMainData");
	AreaHeaderProperties = Template.GetArea("TableHeader|Properties");
	AreaHeaderImages = Template.GetArea("TableHeader|Images");
	AreaRow        = Template.GetArea("TableRow|TableMainData");
	FooterArea        = Template.GetArea("TableFooter|TableMainData");
	PropertyArea      = Template.GetArea("TableRow|Properties");
	ImageArea      = Template.GetArea("TableRow|Images");
	
	HeaderArea.Parameters.GeneratingDate = Format(PrintInfo.Header.GeneratingDate, "DLF=D");
	SpreadsheetDocument.Put(HeaderArea);
	
	AreaHeader.Parameters.Fill(PrintInfo.Header);
	
	InfoAboutVendor = PrintInfo.Header.InfoAboutVendor;
	AreaHeader.Parameters.VendorPresentation = ?(ValueIsFilled(InfoAboutVendor.FullDescr),
		InfoAboutVendor.FullDescr, ?(ValueIsFilled(InfoAboutVendor.OfficialName),
		InfoAboutVendor.OfficialName, InfoAboutVendor.Presentation));
	AreaHeader.Parameters.Fill(InfoAboutVendor);
	
	SpreadsheetDocument.Put(AreaHeader);
	
	If PrintInfo.Header.ThereAreProperties Then
		SpreadsheetDocument.Join(AreaHeaderProperties);
	EndIf;
	
	If PrintInfo.Header.ThereArePictures Then
		SpreadsheetDocument.Join(AreaHeaderImages);
	EndIf;
	
	AdditDataTableRows = AdditDataTable();
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then

		
		AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
		AreaTemplateDD           = Template.GetArea("TableRow|TableWithEDSAdditData");
		
		SpreadsheetDocument.Join(AreaTitleTablesDD);
		
	EndIf;
	
	
	TableProducts = PrintInfo.Products;
	LineNumber = 1;
	For Each String IN TableProducts Do
		AreaRow.Parameters.Fill(String);
		AreaRow.Parameters.LineNumber = LineNumber;
		SpreadsheetDocument.Put(AreaRow);
		If PrintInfo.Header.ThereAreProperties Then
			PropertyString = "";
			If String.PropertyValues <> Undefined Then
				For Each Property IN String.PropertyValues Do
					PropertyString = PropertyString + "(" + Property.ID + ", " + Property.Description + ", [";
					For Each Value IN Property.Value Do
						PropertyString = PropertyString + Value + ",";
					EndDo;
					PropertyString = Mid(PropertyString, 1, StrLen(PropertyString) - 1);
					PropertyString = PropertyString + "]);" + Chars.LF;
				EndDo;
			EndIf;
			PropertyArea.Parameters.Properties = PropertyString;
			SpreadsheetDocument.Join(PropertyArea);
		EndIf;
		If PrintInfo.Header.ThereArePictures Then
			PicturesString = "";
			If String.Images <> Undefined Then
				For Each Picture IN String.Images Do
					PicturesString = PicturesString + Picture + Chars.LF;
				EndDo;
				PicturesString = Mid(PicturesString, 1, StrLen(PicturesString) - 1);
			EndIf;
			ImageArea.Parameters.Images = PicturesString;
			SpreadsheetDocument.Join(ImageArea);
		EndIf;
		
		DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure,
			LineNumber, SpreadsheetDocument, AreaTemplateDD);
		
		LineNumber = LineNumber + 1;
	EndDo;
	
	SpreadsheetDocument.Put(FooterArea);
	
	DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with ACT OF RENDERED SERVICES

Function GetAcceptanceCertificatesDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.TIN"));
	InfoAboutCounterparty.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutCounterparty.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.ActualAddress_Presentation"));
	InfoAboutCounterparty.Insert("BankAccount",      GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.AccountNumber"));
	InfoAboutCounterparty.Insert("BalancedAccount",            GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.CorrAccount"));
	InfoAboutCounterparty.Insert("Bank",               GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.Description"));
	InfoAboutCounterparty.Insert("BIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CounterpartyBankAcc.Bank.Code"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
	EndIf;
	
	InformationAboutCompany = New Structure;
	InformationAboutCompany.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.FullDescr"));
	InformationAboutCompany.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.TIN"));
	InformationAboutCompany.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.LegalAddress_Presentation"));
	InformationAboutCompany.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.ActualAddress_Presentation"));
	InformationAboutCompany.Insert("BankAccount",      GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"CompanyBankAcc.AccountNumber"));
	InformationAboutCompany.Insert("BalancedAccount",            GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"BankAccountOfTheCompany.Bank.CorrAccount"));
	InformationAboutCompany.Insert("Bank",               GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"BankAccountOfTheCompany.Bank.Description"));
	InformationAboutCompany.Insert("BIN",                GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"BankAccountOfTheCompany.Bank.Code"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	EndIf;
	
	FillingDataHeader.Insert("Number", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Number"));
	FillingDataHeader.Insert("Date", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Date"));
	FillingDataHeader.Insert("ExchangeRate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"ExchangeRate"));
	FillingDataHeader.Insert("CurrencyCode", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Description"));
	FillingDataHeader.Insert("HeaderText", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Title"));
	FillingDataHeader.Insert("PerformedWorksDescription", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PerformedWorksDescription"));
	FillingDataHeader.Insert("Claims", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Claims"));
	FillingDataHeader.Insert("TotalsInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "TotalsInWords"));
	FillingDataHeader.Insert("PriceIncludesVAT", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PriceIncludesVAT"));
	
	VT = New ValueTable;
	VT.Columns.Add("ProductCode");
	VT.Columns.Add("ProductDescription");
	VT.Columns.Add("BaseUnitDescription");
	VT.Columns.Add("BaseUnitCodeRCUM");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("Amount");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("DiscountAmount");
	VT.Columns.Add("Content");
	VT.Columns.Add("SumWithVAT");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.ProductCode = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Code");
		NewRow.ProductDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"SupplierProductsAndServices.Name");
		NewRow.Content = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Content");
		NewRow.BaseUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.MeasurementUnit.Description");
		NewRow.BaseUnitCodeRCUM = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.MeasurementUnit.Code");
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SumWithVAT");
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		NewRow.DiscountAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "DiscountAmount");
		NewRow.DiscountAmount = ?(NewRow.DiscountAmount = Undefined, 0, NewRow.DiscountAmount);
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document Acceptance certificate.
//
Procedure FillInTabularDocumentAcceptanceCertificate_ED(SpreadsheetDocument, PrintInfo)
	
	CodesColumn = ElectronicDocumentsOverridable.AdditionalColumnName();
	OutputCodes = ValueIsFilled(CodesColumn);
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_AcceptanceCertificate_Certificate";
	
	ServicesTable = PrintInfo.Products;
	AreDiscounts = ElectronicDocumentsOverridable.NeedToOutputDiscounts(ServicesTable, True);
	If ServicesTable.Total("VATAmount") > 0 Then
		IsVAT = true;
	Else	
		IsVAT = False;
	EndIf;
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Act");
	
	// Display act header
	TemplateArea = Template.GetArea("Title");
	
	HeaderText = NStr("en='Act # %DocumentNumber% dated %DocumentDate%';ru='Акт № %НомерДокумента% от %ДатаДокумента% г.'");
	HeaderText = StrReplace(HeaderText, "%DocumentNumber%", PrintInfo.Header.Number);
	HeaderText = StrReplace(HeaderText, "%DocumentDate%",  Format(PrintInfo.Header.Date, "DF=dd MMMM yyyy'"));
	
	TemplateArea.Parameters.HeaderText = HeaderText;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea  = Template.GetArea("HeaderText");
	TemplateArea.Parameters.HeaderText = PrintInfo.Header.HeaderText;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	// Display title of table Services
	AreaSuffix = ?(AreDiscounts, "WithDiscount", "") + ?(IsVAT, "WithVAT", "");
	TemplateArea = Template.GetArea("TableHeader" + AreaSuffix);
	RowArea = Template.GetArea("String" + AreaSuffix);
	
	SpreadsheetDocument.Put(TemplateArea);
	
	Amount       = 0;
	VATAmount    = 0;
	LineNumber = 0;
	
	// Display rows of the table Services
	For Each RowServices in ServicesTable Do
		
		LineNumber = LineNumber + 1;
		RowArea.Parameters.LineNumber = LineNumber;
		
		RowArea.Parameters.Fill(RowServices);
		RowArea.Parameters.MeasurementUnit = RowServices.BaseUnitDescription;
		
		If ValueIsFilled(RowServices.Content) Then
			RowArea.Parameters.Product = RowServices.Content;
		Else
			RowArea.Parameters.Product = RowServices.ProductDescription;
		EndIf;
		
		If PrintInfo.Header.PriceIncludesVAT Then
			AmountByRow = RowServices.Amount + RowServices.VATAmount;
		Else
			AmountByRow = RowServices.Amount;
		EndIf;
		
		RowArea.Parameters.Amount = AmountByRow;
		
		If AreDiscounts Then
			
			RowArea.Parameters.Discount         = RowServices.DiscountAmount;
			RowArea.Parameters.AmountWithoutDiscount = AmountsFormat(AmountByRow + RowServices.DiscountAmount);
			
		EndIf;
		
		Amount    = Amount    + AmountByRow;
		VATAmount = VATAmount + RowServices.VATAmount;
		
		SpreadsheetDocument.Put(RowArea);
		
	EndDo;
	
	TemplateArea = Template.GetArea("Total");
	TemplateArea.Parameters.Total = ElectronicDocumentsOverridable.AmountsFormat(Amount);
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("TotalVAT");
	TemplateArea.Parameters.TotalVAT = VATAmount;
	If IsVAT Then
		If PrintInfo.Header.PriceIncludesVAT Then
			TemplateArea.Parameters.VAT = NStr("en='Including VAT:';ru='Inclusive TVA:'");
		Else
			TemplateArea.Parameters.VAT = NStr("en='VAT amount';ru='Указывается сумма НДС'");
		EndIf;
	Else
		TemplateArea.Parameters.VAT = NStr("en='Without tax (VAT)';ru='Без налога (НДС)'");
	EndIf;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("AmountInWords");
	TemplateArea.Parameters.TotalRow = PrintInfo.Header.TotalsInWords;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("AdditionalInformation");
	TemplateArea.Parameters.AdditionalInformation = PrintInfo.Header.PerformedWorksDescription;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Signatures");
	TemplateArea.Parameters.Claims                = PrintInfo.Header.Claims;
	TemplateArea.Parameters.PerformerPresentation = PrintInfo.Header.InfoAboutVendor.FullDescr;
	TemplateArea.Parameters.PerformerLegAddress       = PrintInfo.Header.InfoAboutVendor.LegalAddress;
	TemplateArea.Parameters.PerformerTIN           = PrintInfo.Header.InfoAboutVendor.TIN;
	TemplateArea.Parameters.PerformerBankAccount = PrintInfo.Header.InfoAboutVendor.BankAccount;
	TemplateArea.Parameters.ExecutorBalancedAccount       = PrintInfo.Header.InfoAboutVendor.BalancedAccount;
	TemplateArea.Parameters.AssigneeBank          = PrintInfo.Header.InfoAboutVendor.Bank;
	TemplateArea.Parameters.PerformerBIC           = PrintInfo.Header.InfoAboutVendor.BIN;
	TemplateArea.Parameters.ConsumerPresentation   = PrintInfo.Header.InfoAboutCustomer.FullDescr;
	TemplateArea.Parameters.ConsumerLegAddress         = PrintInfo.Header.InfoAboutCustomer.LegalAddress;
	TemplateArea.Parameters.CustomerTIN             = PrintInfo.Header.InfoAboutCustomer.TIN;
	TemplateArea.Parameters.ConsumerBankAccount   = PrintInfo.Header.InfoAboutCustomer.BankAccount;
	TemplateArea.Parameters.ConsumerBalancedAccount         = PrintInfo.Header.InfoAboutCustomer.BalancedAccount;
	TemplateArea.Parameters.ConsumerBank            = PrintInfo.Header.InfoAboutCustomer.Bank;
	TemplateArea.Parameters.CustomerBIC             = PrintInfo.Header.InfoAboutCustomer.BIN;
	
	SpreadsheetDocument.Put(TemplateArea);
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

Function GetAct501DataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutCounterparty = New Structure;
	InfoAboutCounterparty.Insert("FullDescr", 
								  GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.FullDescr"));
	InfoAboutCounterparty.Insert("TIN",
								  GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.TIN"));
	LegalAddress = GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"Counterparty.LegalAddress_Presentation");
	InfoAboutCounterparty.Insert("LegalAddress", LegalAddress);
	
	InfoAboutCounterparty.Insert("BankAccount", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"CounterpartyBankAcc.AccountNumber"));
																	
	InfoAboutCounterparty.Insert("BIN", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"CounterpartyBankAcc.Bank.Code"));
																	
	InfoAboutCounterparty.Insert("Bank", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"CounterpartyBankAcc.Bank.Description"));

	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutCounterparty);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutCounterparty);
	EndIf;
	
	InformationAboutCompany = New Structure;
	FullDescr = GetParsedTreeStringAttributeValue(ParseTree,
																	  ObjectString,
																	  "Company.FullDescr");
	InformationAboutCompany.Insert("FullDescr", FullDescr);
	InformationAboutCompany.Insert("TIN",
								  GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Company.TIN"));
	LegalAddress = GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"Company.LegalAddress_Presentation");
	InformationAboutCompany.Insert("LegalAddress", LegalAddress);
	
	InformationAboutCompany.Insert("BankAccount", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"CompanyBankAcc.AccountNumber"));
																	
	InformationAboutCompany.Insert("BIN", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"BankAccountOfTheCompany.Bank.Code"));
																	
	InformationAboutCompany.Insert("Bank", GetParsedTreeStringAttributeValue(ParseTree,
																	ObjectString,
																	"BankAccountOfTheCompany.Bank.Description"));

	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InformationAboutCompany);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InformationAboutCompany);
	EndIf;
	
	FillingDataHeader.Insert("Number",
								   GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Number"));
	FillingDataHeader.Insert("Date",
								   GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Date"));
	FillingDataHeader.Insert("HeaderText",
								   GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Title"));
	FillingDataHeader.Insert("Claims",
									GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Claims"));
	FillingDataHeader.Insert("CompletionDate", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CompletionDate"));
	FillingDataHeader.Insert("DeliveredPosition", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DeliveredPosition"));
	FillingDataHeader.Insert("DeliveredDescriptionFull", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DeliveredDescriptionFull"));

	DateOfCorrection = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfCorrection");
	If ValueIsFilled(DateOfCorrection) Then
		FillingDataHeader.Insert("DateOfCorrection", Date(DateOfCorrection));
		FillingDataHeader.Insert("CorrectionNumber", 
				GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CorrectionNumber"));
	EndIf;
	
	WorksDescriptionVT = New ValueTable;
	WorksDescriptionVT.Columns.Add("WorksBegin");
	WorksDescriptionVT.Columns.Add("WorksEnd");
	WorksDescriptionVT.Columns.Add("Amount");
	WorksDescriptionVT.Columns.Add("VATAmount");
	WorksDescriptionVT.Columns.Add("SumWithVAT");
	WorksDescriptionVT.Columns.Add("Works");
	
	WorksDescriptionTSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "DescriptionsList"));
	For Each WorksDescriptionTSRow IN WorksDescriptionTSRows Do
		
		WorksDescriptionNewRow = WorksDescriptionVT.Add();
		WorksDescription = WorksDescriptionTSRow.AttributeValue;
		
		WorksDescriptionNewRow.WorksBegin = GetParsedTreeStringAttributeValue(ParseTree,
																							WorksDescription,
																							"WorkBeg");
		WorksDescriptionNewRow.WorksEnd = GetParsedTreeStringAttributeValue(ParseTree,
																						   WorksDescription,
																						   "WorkEnd");
		WorksDescriptionNewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree,
																						  WorksDescription,
																						  "Amount");
		WorksDescriptionNewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree,
																						 WorksDescription,
																						 "VATAmount");
		WorksDescriptionNewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, WorksDescription, "SumWithVAT");
		
		WorksVT = New ValueTable;
		WorksVT.Columns.Add("LineNumber");
		WorksVT.Columns.Add("DescriptionOfWorks");
		WorksVT.Columns.Add("MeasurementUnit");
		WorksVT.Columns.Add("Quantity");
		WorksVT.Columns.Add("Price");
		WorksVT.Columns.Add("Amount");
		WorksVT.Columns.Add("VATAmount");
		WorksVT.Columns.Add("SumWithVAT");
		WorksVT.Columns.Add("Definition");
		
		WorksTSRows = WorksDescription.Rows.FindRows(New Structure("Attribute", "Work"));
		For Each WorksTSRow IN WorksTSRows Do
			
			NewRow = WorksVT.Add();
			NewRow.LineNumber = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow,
			"Number");
			NewRow.DescriptionOfWorks = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow,
			"ProductsAndServices.Name");
			NewRow.Definition = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "Definition");
			NewRow.MeasurementUnit = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow,
			"MeasurementUnitDescription");
			NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "Quantity");
			NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "Price");
			NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "Amount");
			NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "VATAmount");
			NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, WorksTSRow, "SumWithVAT");
			
		EndDo;
		
		WorksDescriptionNewRow.Works = WorksVT;
	EndDo;
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("WorksDescriptions", WorksDescriptionVT);
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf;
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document Acceptance certificate.
//
Procedure FillTableDocumentAct501(SpreadsheetDocument, PrintInfo, ConsumerData)
	
	SpreadsheetDocument.LeftMargin = 5;
	SpreadsheetDocument.RightMargin = 5;
	SpreadsheetDocument.HeaderSize = 0;
	SpreadsheetDocument.FooterSize = 0;
	SpreadsheetDocument.PageOrientation = PageOrientation.Portrait;
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;

	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_AcceptanceCertificate_Certificate";
	
	WorksDescriptionTable = PrintInfo.WorksDescriptions;
	If WorksDescriptionTable.Total("VATAmount") > 0 Then
		IsVAT = True;
	Else
		IsVAT = False;
	EndIf;
	
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Act501");
	
	// Display act header
	TemplateArea = Template.GetArea("Header");
	
	CaptionPattern = NStr("en='Act # %1 dated %2 year';ru='Акт № %1 от %2 года'");
	HeaderText = StringFunctionsClientServer.SubstituteParametersInString(CaptionPattern, PrintInfo.Header.Number,
		Format(PrintInfo.Header.Date, "DF=dd MMMM yyyy'"));
	TemplateArea.Parameters.HeaderText = HeaderText;
	
	If PrintInfo.Header.Property("DateOfCorrection") Then
		
		CaptionPattern = NStr("en='Correction No %1 from %2';ru='Исправление № %1 от %2 г.'");
		FixText = StringFunctionsClientServer.SubstituteParametersInString(CaptionPattern, PrintInfo.Header.CorrectionNumber,
																		Format(PrintInfo.Header.DateOfCorrection, "DF=dd MMMM yyyy'"));
		TemplateArea.Parameters.Correction = FixText;

	EndIf;
	TemplateArea.Parameters.HeaderText = PrintInfo.Header.HeaderText;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	AdditDataTableRows = New ValueTable;
	AdditDataTableRows.Columns.Add("NumberStr");
	AdditDataTableRows.Columns.Add("DigitallySignedData");
	AdditDataTableRows.Columns.Add("UnDigitallySignedData");
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Services", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		AreaTitleTablesDD = Template.GetArea("WorksDescriptionTableHeader|TableAdditData");
		AreaTemplateDD = Template.GetArea("WorksRow|TableAdditData");
		AreaTableTitleDDSES = Template.GetArea("WorksDescriptionTableHeader|TableWithEDSAdditData");
		DDSESTemplateArea = Template.GetArea("JobsRow|TableWithEDSAdditData");
		AreaTableTitleDDBWithoutES = Template.GetArea("WorksDescriptionTableHeader|TableWithoutEDSAdditData");
		TemplateAreaDDWithoutES = Template.GetArea("JobsRow|TableWithoutEDSAdditData");
	EndIf;
	
	// Display title of table Services
	TemplateArea = Template.GetArea("WorksDescriptionTableHeader|TableMainData");
	
	NumberDescription = 0;
	For Each WorksDescriptionRow IN WorksDescriptionTable Do
		
		NumberDescription = NumberDescription + 1;
		TemplateArea.Parameters.Fill(WorksDescriptionRow);
		SpreadsheetDocument.Put(TemplateArea);
		If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
			SpreadsheetDocument.Join(AreaTitleTablesDD);
		Else
			If AdditDataExistanceStructure.AreDigitallySigned Then
				SpreadsheetDocument.Join(AreaTableTitleDDSES);
			EndIf;
			If AdditDataExistanceStructure.AreNotDigitallySigned Then
				SpreadsheetDocument.Join(AreaTableTitleDDBWithoutES);
			EndIf;
		EndIf;
		
		// Display rows of the table Services
		AreaWorkRow = Template.GetArea("JobsRow|TableMainData");
		For Each WorkRow IN WorksDescriptionRow.Works Do
			
			AreaWorkRow.Parameters.LineNumber = WorkRow.LineNumber;
			
			AreaWorkRow.Parameters.Fill(WorkRow);
			
			If ValueIsFilled(WorkRow.Definition) Then
				AreaWorkRow.Parameters.WorksDesc = WorkRow.Definition;
			Else
				AreaWorkRow.Parameters.WorksDesc = WorkRow.DescriptionOfWorks;
			EndIf;
			
			SpreadsheetDocument.Put(AreaWorkRow);
			If AdditDataTableRows.Count() > 0 Then
				ADTableString = AdditDataTableRows.Find(String(NumberDescription) + "." + WorkRow.LineNumber, "NumberStr");
				If ADTableString <> Undefined Then
					If AdditDataExistanceStructure.AreDigitallySigned AND AdditDataExistanceStructure.AreNotDigitallySigned Then
						AreaTemplateDD.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
						AreaTemplateDD.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
						SpreadsheetDocument.Join(AreaTemplateDD);
					Else
						If AdditDataExistanceStructure.AreDigitallySigned Then
							DDSESTemplateArea.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
							SpreadsheetDocument.Join(DDSESTemplateArea);
						EndIf;
						If AdditDataExistanceStructure.AreNotDigitallySigned Then
							TemplateAreaDDWithoutES.Parameters.Unsigned = ADTableString.UnDigitallySignedData;
							SpreadsheetDocument.Join(TemplateAreaDDWithoutES);
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
		EndDo;
		
		TemplateArea = Template.GetArea("Total");
		TemplateArea.Parameters.Total = ElectronicDocumentsOverridable.AmountsFormat(WorksDescriptionRow.SumWithVAT);
		SpreadsheetDocument.Put(TemplateArea);
		
		TemplateArea = Template.GetArea("TotalVAT");
		If IsVAT Then
			TemplateArea.Parameters.VAT = NStr("en='VAT amount';ru='Указывается сумма НДС'");
			TemplateArea.Parameters.TotalVAT = WorksDescriptionRow.VATAmount;
		Else
			TemplateArea.Parameters.VAT = NStr("en='Without tax (VAT)';ru='Без налога (НДС)'");
		EndIf;
		SpreadsheetDocument.Put(TemplateArea);
		
	EndDo;
	
	TemplateArea = Template.GetArea("Claims");
	Claims = ?(ConsumerData.Property("Claims"), ConsumerData.Claims, Undefined);
	TemplateArea.Parameters.Claims = Claims;
	SpreadsheetDocument.Put(TemplateArea);
	
	TempTabDoc = New SpreadsheetDocument;
	
	AreaTemplatePerformer = Template.GetArea("Signatures|Performer");
	AreaTemplatePerformer.Parameters.Fill(PrintInfo.Header);
	
	AreaTemplatePerformer.Parameters.PerformerPresentation = PrintInfo.Header.InfoAboutVendor.FullDescr;
	AreaTemplatePerformer.Parameters.PerformerLegAddress       = PrintInfo.Header.InfoAboutVendor.LegalAddress;
	AreaTemplatePerformer.Parameters.PerformerTIN           = PrintInfo.Header.InfoAboutVendor.TIN;
	AreaTemplatePerformer.Parameters.PerformerBankAccount = PrintInfo.Header.InfoAboutVendor.BankAccount;
	AreaTemplatePerformer.Parameters.AssigneeBank          = PrintInfo.Header.InfoAboutVendor.Bank;
	AreaTemplatePerformer.Parameters.PerformerBIC           = PrintInfo.Header.InfoAboutVendor.BIN;

	
	FullDocumentDate = Format(PrintInfo.Header.CompletionDate, "DF=""dd MMMM yyyy """"year""""""");
	StringLength = StrLen(FullDocumentDate);
	FirstSeparator = Find(FullDocumentDate, " ");
	SecondSeparator = Find(Right(FullDocumentDate, StringLength - FirstSeparator), " ") + FirstSeparator;
	AreaTemplatePerformer.Parameters.DocumentDateDay = """" + Left(FullDocumentDate, FirstSeparator -1 ) + """";
	AreaTemplatePerformer.Parameters.DocumentDateMonth = Mid(FullDocumentDate, FirstSeparator + 1, SecondSeparator - FirstSeparator - 1);
	AreaTemplatePerformer.Parameters.DocumentDateYear = Right(FullDocumentDate, StringLength - SecondSeparator);
	
	TempTabDoc.Put(AreaTemplatePerformer);
	
	TemplateArea = Template.GetArea("Signatures|Customer");
	TemplateArea.Parameters.Fill(ConsumerData);
	
	TemplateArea.Parameters.ConsumerPresentation   = PrintInfo.Header.InfoAboutCustomer.FullDescr;
	TemplateArea.Parameters.CustomerTIN             = PrintInfo.Header.InfoAboutCustomer.TIN;
	
	TemplateArea.Parameters.ConsumerBankAccount = PrintInfo.Header.InfoAboutCustomer.BankAccount;
	TemplateArea.Parameters.ConsumerBank          = PrintInfo.Header.InfoAboutCustomer.Bank;
	TemplateArea.Parameters.CustomerBIC           = PrintInfo.Header.InfoAboutCustomer.BIN;
	
	TempTabDoc.Join(TemplateArea);
	
	SpreadsheetDocument.Put(TempTabDoc);
		
	FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with REPORT ON COMMISSION GOODS SALES

Function GetReportDataAboutComissionGoodsSalesToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutPrincipal = New Structure;
	InfoAboutPrincipal.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.FullDescr"));
	InfoAboutPrincipal.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.TIN"));
	InfoAboutPrincipal.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.LegalAddress_Presentation"));
	InfoAboutPrincipal.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Company.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutPrincipal);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutPrincipal);
	EndIf;
	
	InfoAboutAgent = New Structure;
	InfoAboutAgent.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutAgent.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.TIN"));
	InfoAboutAgent.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutAgent.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutAgent);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutAgent);
	EndIf;
	
	FillingDataHeader.Insert("Number", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Number"));
	FillingDataHeader.Insert("Date", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Date"));
	FillingDataHeader.Insert("ExchangeRate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.ExchangeRate"));
	FillingDataHeader.Insert("CurrencyCode", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.CodeRCC"));
	FillingDataHeader.Insert("CurrencyDescription", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Description"));
	FillingDataHeader.Insert("DocumentAmount", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DocumentAmount"));
	FillingDataHeader.Insert("PrincipalAmount", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "PrincipalAmount"));
	FillingDataHeader.Insert("TotalsInWords", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "TotalsInWords"));
	FillingDataHeader.Insert("BrokerageAmount", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "BrokerageAmount"));
	
	VT = New ValueTable;
	VT.Columns.Add("Code");
	VT.Columns.Add("SKU");
	VT.Columns.Add("Description");
	VT.Columns.Add("MeasurementUnitDescription");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("Amount");
	VT.Columns.Add("VATAmount");
	VT.Columns.Add("SumWithVAT");
	VT.Columns.Add("BrokerageAmount");
	VT.Columns.Add("SalesAmount");
	VT.Columns.Add("SalePrice");
	VT.Columns.Add("VATRate");
	VT.Columns.Add("AdditionalAttributes");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.Code             = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Code");
		NewRow.SKU         = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.SKU");
		NewRow.Description    = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.Name");
		
		NewRow.MeasurementUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.MeasurementUnit.Description");
		NewRow.Quantity = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"Quantity");
		
		NewRow.Price = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.SalePrice = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SalePrice");
		NewRow.Amount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		NewRow.SalesAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SalesAmount");
		NewRow.BrokerageAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"BrokerageAmount");
		NewRow.VATAmount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATAmount");
		NewRow.SumWithVAT = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "SumWithVAT");
		NewRow.VATRate = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "VATRate");
		
		StructureAdditionalAttributes = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AdditionalAttributes");
		If ValueIsFilled(StructureAdditionalAttributes) Then
			AdditionalAttributes = ""; 
			For Each Item IN StructureAdditionalAttributes Do
				AdditionalAttributes = AdditionalAttributes + Item.Key + ":";
				AttributeValues = "";
				If TypeOf(Item.Value) = Type("Array") Then
					For Each ArrayElement IN Item.Value Do
						// For customer addresses parse address string to the structure of FTS address
						If Item.Key = "CustomerFactAddress" OR Item.Key = "CustomerLegAddress" Then
							ArrayElement = PrepareAdress(ArrayElement);
						EndIf;
						AttributeValues = AttributeValues + String(ArrayElement) + ", ";
					EndDo;
				Else
					ArrayElement = Item.Value;
					// For customer addresses parse address string to the structure of FTS address
					If Item.Key = "CustomerFactAddress" OR Item.Key = "CustomerLegAddress" Then
						ArrayElement = PrepareAdress(ArrayElement);
					EndIf;
					AttributeValues = AttributeValues + String(ArrayElement) + ", ";
				EndIf;
				AdditionalAttributes = AdditionalAttributes + AttributeValues;
			EndDo;
			NewRow.AdditionalAttributes = AdditionalAttributes;
		EndIf;
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document report on commission goods sales
//
Procedure FillInTabularDocumentCommissionGoodsSalesReport_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_CommisionReport");
	
	CodesColumn = ElectronicDocumentsOverridable.AdditionalColumnName();
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	// Display header general attributes.
	FillHeaderAttributesReportByComission(PrintInfo.Header, NStr("en='Report on the commission goods sales';ru='Отчет о продажах комиссионного товара'"), Template,
		SpreadsheetDocument);
	
	// Display table title.
	If ValueIsFilled(CodesColumn) Then
		TableTitle = Template.GetArea("TableHeaderWithCodes|Data");
		TableTitle.Parameters.CodesColumnName = CodesColumn;
	Else
		TableTitle = Template.GetArea("TableHeader|Data");
	EndIf;
	
	AdditDataTableRows = AdditDataTable();
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	AdditionalInformationExists = False;
	
	If AdditDataTableRows.Count() > 0 Then
		AdditionalInformationExists = True;
		
		If ValueIsFilled(CodesColumn) Then
			AreaTitleTablesDD = Template.GetArea("TableWithCodesHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("RowWithCodes|TableWithEDSAdditData");
			
		Else
			AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("Row|TableWithEDSAdditData");
			
		EndIf;
	EndIf;
	
	TableTitle.Parameters.Currency = PrintInfo.Header.CurrencyDescription;
	SpreadsheetDocument.Put(TableTitle);
	If AdditionalInformationExists Then
		SpreadsheetDocument.Join(AreaTitleTablesDD);
	EndIf;
	
	// Display multiline part of the document.
	If ValueIsFilled(CodesColumn) Then
		TemplateArea = Template.GetArea("RowWithCodes|Data");

	Else
		TemplateArea = Template.GetArea("String|Data");

	EndIf;
	
	LineNumber = 0;
	Products = PrintInfo.Products;
	For Each ProductsRow in Products Do
		
		LineNumber = LineNumber + 1;
		TemplateArea.Parameters.Fill(ProductsRow);
		If ValueIsFilled(CodesColumn) Then
			TemplateArea.Parameters.SKU = ProductsRow[CodesColumn];
		EndIf;
		
		TemplateArea.Parameters.LineNumber = LineNumber;
		TemplateArea.Parameters.ProductDescription = ProductsRow.Description;
		TemplateArea.Parameters.PrincipalPrice     = ProductsRow.Price;
		TemplateArea.Parameters.PrincipalAmount    = ProductsRow.Amount;
		SpreadsheetDocument.Put(TemplateArea);
		
		DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure, LineNumber, SpreadsheetDocument, AreaTemplateDD);
		
	EndDo;
	
	FillReportAboutComissionGoodsSalesFooterAttributes(PrintInfo.Header, Products, Template, SpreadsheetDocument);
	
	// Display document additional data.
	DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument);
	
EndProcedure

// Procedure to fill in the footer attributes of commission goods sales report.
//
// Parameters:
//  PrintInfo -  Document
//  header data Goods - Data of document
//  tabular section Template - Template
//  ReportOnCommission TabularDocument - Spreadsheet document
//
Procedure FillReportAboutComissionGoodsSalesFooterAttributes(PrintInfo, Products, Template, SpreadsheetDocument)
	
	SalesAmount = PrintInfo.DocumentAmount;
	
	TemplateArea = Template.GetArea("Footer|Data");
	
	TemplateArea.Parameters.PrincipalAmountGrandTotal      = PrintInfo.PrincipalAmount;
	TemplateArea.Parameters.SalesAmountGrandTotal        = SalesAmount;
	TemplateArea.Parameters.TotalAmountRemuneration = PrintInfo.BrokerageAmount;
	TemplateArea.Parameters.TotalRow           = PrintInfo.TotalsInWords;
	
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with REPORT ON COMMISSION GOODS WRITE-OFF

Function GetReportDataAboutComissionGoodsWriteOffToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	InfoAboutPrincipal = New Structure;
	InfoAboutPrincipal.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.FullDescr"));
	InfoAboutPrincipal.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.TIN"));
	InfoAboutPrincipal.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.LegalAddress_Presentation"));
	InfoAboutPrincipal.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Company.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutPrincipal);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutPrincipal);
	EndIf;
	
	InfoAboutAgent = New Structure;
	InfoAboutAgent.Insert("FullDescr", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.FullDescr"));
	InfoAboutAgent.Insert("TIN",                GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.TIN"));
	InfoAboutAgent.Insert("LegalAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.LegalAddress_Presentation"));
	InfoAboutAgent.Insert("ActualAddress",   GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Counterparty.ActualAddress_Presentation"));
	
	If ObjectString.EDDirection = Enums.EDDirections.Outgoing Then
		FillingDataHeader.Insert("InfoAboutVendor", InfoAboutAgent);
	ElsIf ObjectString.EDDirection = Enums.EDDirections.Incoming Then
		FillingDataHeader.Insert("InfoAboutCustomer", InfoAboutAgent);
	EndIf;
	
	FillingDataHeader.Insert("Number", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Number"));
	FillingDataHeader.Insert("Date",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Date"));
	FillingDataHeader.Insert("ExchangeRate",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.ExchangeRate"));
	FillingDataHeader.Insert("CurrencyCode", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Code"));
	FillingDataHeader.Insert("CurrencyDescription",GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Currency.Description"));
	FillingDataHeader.Insert("DocumentAmount", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"TotalByDocument"));
	FillingDataHeader.Insert("TotalsInWords", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"TotalsInWords"));
	
	VT = New ValueTable;
	
	VT.Columns.Add("Code");
	VT.Columns.Add("SKU");
	VT.Columns.Add("Description");
	VT.Columns.Add("MeasurementUnitDescription");
	VT.Columns.Add("Quantity");
	VT.Columns.Add("Price");
	VT.Columns.Add("Amount");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.Code                          = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "ProductsAndServices.Code");
		NewRow.SKU                      = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.SKU");
		NewRow.Description                 = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.Name");
		NewRow.MeasurementUnitDescription = GetParsedTreeStringAttributeValue(ParseTree, TSRow,
			"ProductsAndServices.MeasurementUnit.Description");
		NewRow.Quantity                   = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Quantity");
		NewRow.Price                         = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Price");
		NewRow.Amount                        = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
		
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header",  FillingDataHeader);
	DataForObject.Insert("Products", VT);
	
	AddAdditDataToDataForObject(DataForObject, ParseTree);
	
	Return DataForObject;
	
EndFunction

// Procedure populates the tabular document report on commission goods writeoff
//
Procedure FillInTabularDocumentComissionGoodsWriteOffReport_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_CommisionReportAboutWriteOff");
	
	Title = NStr("en='Report on the commission goods depreciation';ru='Отчет о списании комиссионного товара'");
	
	CodesColumn = ElectronicDocumentsOverridable.AdditionalColumnName();
	FirstLineNumber = SpreadsheetDocument.TableHeight + 1;
	
	// Displaying general header attributes
	FillHeaderAttributesReportByComission(PrintInfo.Header, Title, Template, SpreadsheetDocument);
	
	// Displaying table title
	If ValueIsFilled(CodesColumn) Then
		TableTitle = Template.GetArea("TableHeaderWithCodes|Data");
		TableTitle.Parameters.CodesColumnName = CodesColumn;
	Else
		TableTitle = Template.GetArea("TableHeader|Data");
	EndIf;
	
	TableTitle.Parameters.Currency = PrintInfo.Header.CurrencyDescription;
	SpreadsheetDocument.Put(TableTitle);
	
	AdditDataTableRows = AdditDataTable();
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) <> Type("ValueTree") Then
		AdditDataTree = Undefined;
	EndIf;
	
	AdditDataExistanceStructure = GenerateStringsAdditData(AdditDataTree, "Products", AdditDataTableRows);
	
	If AdditDataTableRows.Count() > 0 Then
		
		If ValueIsFilled(CodesColumn) Then
			AreaTitleTablesDD = Template.GetArea("TableWithCodesHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("RowWithCodes|TableWithEDSAdditData");
			
		Else
			AreaTitleTablesDD = Template.GetArea("TableHeader|TableWithEDSAdditData");
			AreaTemplateDD           = Template.GetArea("Row|TableWithEDSAdditData");
			
		EndIf;
		
		SpreadsheetDocument.Join(AreaTitleTablesDD);
		
	EndIf;
	
	// Displaying multiline part of the document
	If ValueIsFilled(CodesColumn) Then
		TemplateArea = Template.GetArea("RowWithCodes|Data");
	Else
		TemplateArea = Template.GetArea("String|Data");
	EndIf;
	
	LineNumber = 0;
	
	For Each ProductsRow in PrintInfo.Products Do
		
		LineNumber = LineNumber + 1;
		
		TemplateArea.Parameters.Fill(ProductsRow);
		
		If ValueIsFilled(CodesColumn) Then
			TemplateArea.Parameters.SKU = ProductsRow[CodesColumn];
		EndIf;
		
		TemplateArea.Parameters.LineNumber = LineNumber;
		TemplateArea.Parameters.ProductDescription = ProductsRow.Description;
		
		SpreadsheetDocument.Put(TemplateArea);
		
		DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataExistanceStructure, LineNumber, SpreadsheetDocument, AreaTemplateDD);
		
	EndDo;
	
	FillReportByComissionAboutWriteOff(PrintInfo.Header, PrintInfo.Products, Template, SpreadsheetDocument);
	
	// Display document additional data.
	DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument);
	
EndProcedure

// Procedure to fill in the details of the header of the report on commission
//
// Parameters:
//  PrintInfo - QueryResultSelection - Document
//  header data Template - Report
//  template TabularDocument - Spreadsheet document
//
Procedure FillHeaderAttributesReportByComission(PrintInfo, Title, Template, SpreadsheetDocument)
	
	// Displaying general header attributes
	InfoAboutPrincipal = PrintInfo.InfoAboutVendor;
	InfoAboutAgent = PrintInfo.InfoAboutCustomer;
	
	TemplateArea = Template.GetArea("Header|Data");
	HeaderText = NStr("en='" + Title + " No %1 from %2'");
	HeaderText = StringFunctionsClientServer.SubstituteParametersInString(HeaderText, PrintInfo.Number,
		Format(PrintInfo.Date, "DF=dd MMMM yyyy'"));

	TemplateArea.Parameters.HeaderText = HeaderText;
	TemplateArea.Parameters.PrincipalPresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		InfoAboutPrincipal, "FullDescr,");
	TemplateArea.Parameters.ComissionarePresentation = ElectronicDocumentsOverridable.CompaniesDescriptionFull(
		InfoAboutAgent, "FullDescr,");
	
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

// Procedure to fill in footer attributes of report on writeoff commission.
//
// Parameters:
//  PrintInfo - QueryResultSelection - Data of
//  SelectionByDocuments document header - QueryResultSelection - Data of document
//  tabular section Template - Template
//  ReportToAgent TabularDocument - Spreadsheet document
//
Procedure FillReportByComissionAboutWriteOff(PrintInfo, Products, Template, SpreadsheetDocument)
	
	TemplateArea = Template.GetArea("Footer|Data");
	AmountTotal = PrintInfo.DocumentAmount;
	
	TemplateArea.Parameters.AmountTotal = AmountTotal;
	TemplateArea.Parameters.TotalRow = PrintInfo.TotalsInWords;
	
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure


////////////////////////////////////////////////////////////////////////////////
// Work with COMPANY ATTRIBUTES

Function GetCompanyDetailsForPrinting(ObjectString, ParseTree)
	
	CompanyAttributes = New Structure;
	
	TIN = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "TIN");
	CompanyAttributes.Insert("TIN", TIN);

	OfficialName = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "OfficialName");
	CompanyAttributes.Insert("OfficialName", OfficialName);
	
	OKPO = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "OKPO");
	CompanyAttributes.Insert("OKPO", OKPO);
	
	LegalEntityIndividual = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.LegalEntityIndividual");
		
	LegalAddress = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Counterparty.ActualAddress_Presentation");
	CompanyAttributes.Insert("LegalAddress", LegalAddress);//ActualAddress_Presentation
	
	ActualAddress = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ActualAddress_Presentation");
	CompanyAttributes.Insert("ActualAddress", ActualAddress);
	
	Phone = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Phone");
	CompanyAttributes.Insert("Phone", Phone);
	
	
	VT = New ValueTable;
	
	VT.Columns.Add("AccountNo");
	VT.Columns.Add("Bank");
	VT.Columns.Add("Bin");
	VT.Columns.Add("SWIFT");
	VT.Columns.Add("CorrespondentBank");
	VT.Columns.Add("BINCor");
	VT.Columns.Add("SWIFTCor");
	
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		
		NewRow = VT.Add();
		NewRow.AccountNo				= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AccountNo");
		NewRow.Bank					= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankBasicUnitName");
		NewRow.Bin						= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankBIN");
		NewRow.SWIFT					= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankSWIFT");
		NewRow.CorrespondentBank		= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankCorpBasicUnitName");
		NewRow.BINCor					= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankBINCorr");
		NewRow.SWIFTCor				= GetParsedTreeStringAttributeValue(ParseTree, TSRow, "BankSWIFTCorr");
		
	EndDo;
	
	
	FillingData = New Structure;
	FillingData.Insert("CompanyAttributes", CompanyAttributes);
	FillingData.Insert("BankAccounts", VT);
	
	Return FillingData;
	
EndFunction

Procedure FillInTabularDocumentCompanyDetails_ED(SpreadsheetDocument, EDDataToPrint)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_CounterpartyAttributes");
	Title = NStr("en='Company attributes';ru='Реквизиты организации'");
	
	CompanyAttributes = EDDataToPrint.CompanyAttributes;
	
	TemplateArea = Template.GetArea("Attributes");
	TemplateArea.Parameters.Fill(CompanyAttributes);
	SpreadsheetDocument.Put(TemplateArea);
	
	If Not EDDataToPrint.Property("BankAccounts") Then
		Return;
	EndIf;
	
	TemplateArea = Template.GetArea("BankAccount");
	BankAccounts = EDDataToPrint.BankAccounts;
	For Each Account IN BankAccounts Do
		
		TemplateArea.Parameters.Fill(Account);
		SpreadsheetDocument.Put(TemplateArea);
		
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with printed forms

// Function to generate the storage structure of amount totals.
//
// Returns:
//  Structure - Structure of sum total storage
//
Function StructureTotalAmounts()
	
	Structure = New Structure;
	
	// Initialization of totals for the page.
	Structure.Insert("TotalGrossWeightOnPage", 0);
	Structure.Insert("TotalPlacesOnPage", 0);
	Structure.Insert("TotalQuantityOnPage", 0);
	Structure.Insert("TotalAmountOnPage", 0);
	Structure.Insert("TotalVATAmountOnPage", 0);
	Structure.Insert("TotalAmountOfWithVATOnPage", 0);
	Structure.Insert("TotalGrossWeightOnPage", 0);
	Structure.Insert("TotalNetWeightOnPage", 0);
	
	// Initialization of results by the document
	Structure.Insert("TotalGrossWeight", 0);
	Structure.Insert("TotalPlaces", 0);
	Structure.Insert("TotalQuantity", 0);
	Structure.Insert("TotalAmount", 0);
	Structure.Insert("TotalVATAmount", 0);
	Structure.Insert("TotalAmountWithVAT", 0);
	Structure.Insert("TotalGrossWeight", 0);
	Structure.Insert("TotalNetWeight", 0);
	Structure.Insert("RecordsSequenceNumbersQuantityInWords", 0);
	Structure.Insert("AmountInWords", "");
	
	Structure.Insert("TotalAmountBeforeCorrection", 0);
	Structure.Insert("TotalVATAmountBeforeCorrection", 0);
	Structure.Insert("TotalVATAmountBeforeCorrection", 0);
	
	Return Structure;
	
EndFunction

// Function of generation of row data storage structure.
//
// Parameters:
//  CoefficientConversion - Number - Conversion rate for currency of regulatory accounting accounting
//
// Returns:
//  Structure - Structure of goods row data
//
Function StructureStringData(CoefficientConversion)
	
	Structure = New Structure;
	Structure.Insert("Number", 0);
	Structure.Insert("Places", 0);
	Structure.Insert("QuantityBeforeCorrection", 0);
	Structure.Insert("Quantity", 0);
	Structure.Insert("PriceBeforeCorrection", 0);
	Structure.Insert("Price", 0);
	Structure.Insert("AmountBeforeCorrection", 0);
	Structure.Insert("Amount", 0);
	Structure.Insert("VATAmountBeforeCorrection", 0);
	Structure.Insert("VATAmount", 0);
	Structure.Insert("VATAmountBeforeAdjustments", 0);
	Structure.Insert("SumWithVAT", 0);
	Structure.Insert("CoefficientConversion", CoefficientConversion);
	Structure.Insert("GrossWeight", 0);
	Structure.Insert("NetWeightBeforeCorrection", 0);
	Structure.Insert("NetWeight", 0);
	
	Return Structure;
	
EndFunction

// Procedure of setting sum totals to zero by the page.
//
Procedure ResetTotalsByPage(TotalAmounts)
	
	TotalAmounts.TotalGrossWeightOnPage = 0;
	TotalAmounts.TotalNetWeightOnPage  = 0;
	TotalAmounts.TotalPlacesOnPage        = 0;
	TotalAmounts.TotalQuantityOnPage  = 0;
	TotalAmounts.TotalAmountOnPage       = 0;
	TotalAmounts.TotalVATAmountOnPage    = 0;
	TotalAmounts.TotalAmountOfWithVATOnPage   = 0;
	
EndProcedure

// Procedure calculates the total amounts with account of products row.
//
// Parameters:
//  TotalAmounts - Structure - Structure of
//  document sum totals RowData - Structure - Structure of goods row data
//
Procedure CalculateTotalAmounts(TotalAmounts, RowData)
	
	// Increase total by page.
	TotalAmounts.TotalPlacesOnPage        = TotalAmounts.TotalPlacesOnPage + RowData.Places;
	TotalAmounts.TotalQuantityOnPage  = TotalAmounts.TotalQuantityOnPage + RowData.Quantity;
	TotalAmounts.TotalAmountOnPage       = TotalAmounts.TotalAmountOnPage + RowData.Amount;
	TotalAmounts.TotalVATAmountOnPage    = TotalAmounts.TotalVATAmountOnPage + RowData.VATAmount;
	TotalAmounts.TotalAmountOfWithVATOnPage   = TotalAmounts.TotalAmountOfWithVATOnPage + RowData.SumWithVAT;
	TotalAmounts.TotalGrossWeightOnPage = TotalAmounts.TotalGrossWeightOnPage + RowData.GrossWeight;
	TotalAmounts.TotalNetWeightOnPage  = TotalAmounts.TotalNetWeightOnPage + RowData.NetWeight;
	
	// Increase total by document.
	TotalAmounts.TotalPlaces        = TotalAmounts.TotalPlaces + RowData.Places;
	TotalAmounts.TotalQuantity  = TotalAmounts.TotalQuantity + RowData.Quantity;
	TotalAmounts.TotalAmount       = TotalAmounts.TotalAmount + RowData.Amount;
	TotalAmounts.TotalVATAmount    = TotalAmounts.TotalVATAmount + RowData.VATAmount;
	TotalAmounts.TotalAmountWithVAT   = TotalAmounts.TotalAmountWithVAT + RowData.SumWithVAT;
	TotalAmounts.TotalGrossWeight = TotalAmounts.TotalGrossWeight + RowData.GrossWeight;
	TotalAmounts.TotalNetWeight  = TotalAmounts.TotalNetWeight + RowData.NetWeight;
	
	TotalAmounts.TotalAmountBeforeCorrection     = TotalAmounts.TotalAmountBeforeCorrection + RowData.AmountBeforeCorrection;
	TotalAmounts.TotalVATAmountBeforeCorrection  = TotalAmounts.TotalVATAmountBeforeCorrection + RowData.VATAmountBeforeCorrection;
	TotalAmounts.TotalVATAmountBeforeCorrection = TotalAmounts.TotalVATAmountBeforeCorrection + RowData.VATAmountBeforeAdjustments;
	
EndProcedure

// Function for sums formatting
//
// Parameters:
//  Amount  - number that we want
// to format, Currency - reference to the item of currencies catalog if set, then
//           NZ currency presentation will
//  be added to the resulting string     - String that represents the
//  zero value of the number, NGS    - character-separator of groups of number integral part.
//
// Returns:
//  Properly formatted string representation of the amount.
//
Function AmountsFormat(Val Amount, Currency = Undefined, NZ = "", NGS = "")
	
	Amount = ?(Amount < 0, -Amount, Amount);
	FormatString = "ND=15;NFD=2" + ?(NOT ValueIsFilled(NZ), "", ";" + "NZ=" + NZ)
		+ ?(NOT ValueIsFilled(NGS),"", ";" + "NGS=" + NGS);
	ResultString = TrimL(Format(Amount, FormatString));
	
	If ValueIsFilled(Currency) Then
		ResultString = ResultString + " " + TrimR(Currency);
	EndIf;
	
	Return ResultString;
	
EndFunction

// Function changes VAT amount to the required format if it is in numeric presentation.
//
// Parameters:
// VATAmount - String, VAT amount (without VAT, -, number).
//
// Returns:
// ReturnedAmount - If incoming parameter - presentation of number, then return value - number.
//
Function VATAmountSFBringToRequiredFormat(VATAmount)
	
	If Find(VATAmount, ".") > 0 OR Find(VATAmount, ",") > 0 OR Find(VATAmount, "-") > 0 Then
		ReturnedAmount = Number(VATAmount);
	Else
		ReturnedAmount = VATAmount;
	EndIf;
	
	Return ReturnedAmount;
	
EndFunction

// Puts dashes in unfilled fields of invoice form for printing
//
Procedure PutDashesInRowEmptyFieldsInvoice(TemplateArea)
	
	For t = 0 To TemplateArea.Parameters.Count() - 1 Do
		
		CurParameter = TemplateArea.Parameters.Get(t);
		
		If Not ValueIsFilled(CurParameter) Then
			TemplateArea.Parameters.Set(t, "--");
		EndIf;
		
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Preparation for service ED viewing

Function GetEDExchangeParticipantData(ExchangeParticipant)
	
	ReturnValue = Undefined;
	
	If ExchangeParticipant.Properties().Get("SenLP") <> Undefined Then
		
		ReturnValue = ExchangeParticipant.SenLP.DescEnt + ", " + ExchangeParticipant.SenLP.TINLP;
	ElsIf ExchangeParticipant.Properties().Get("RecLP") <> Undefined Then
		
		ReturnValue = ExchangeParticipant.RecLP.DescEnt + ", " + ExchangeParticipant.RecLP.TINLP;
	ElsIf ExchangeParticipant.Properties().Get("SenIP") <> Undefined Then
		
		ReturnValue = TrimAll(ExchangeParticipant.SenIP.Initials.Surname + " " + ExchangeParticipant.SenIP.Initials.Name + " "
			+ ExchangeParticipant.SenIP.Initials.Patronymic) + ", " + ExchangeParticipant.SenIP.TINInd;
		ElsIf ExchangeParticipant.Properties().Get("LegalEntity") <> Undefined AND ExchangeParticipant.LegalEntity <> Undefined Then
		
		ReturnValue = ExchangeParticipant.LegalEntity.DescEnt + ", " + ExchangeParticipant.LegalEntity.TINLP;
	ElsIf ExchangeParticipant.Properties().Get("CO") <> Undefined AND ExchangeParticipant.CO <> Undefined Then
		
		ReturnValue = TrimAll(ExchangeParticipant.CO.Initials.Surname + " " + ExchangeParticipant.CO.Initials.Name + " "
			+ ExchangeParticipant.CO.Initials.Patronymic) + ", " + ExchangeParticipant.CO.TINInd;
	ElsIf ExchangeParticipant.Properties().Get("OperEDF") <> Undefined Then
		
		ReturnValue = ExchangeParticipant.OperEDF.DescEnt + ", " + ExchangeParticipant.OperEDF.TINLP;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Work with confirmation

// EIRDC, SDANAREIC
Procedure ReadReceivingDataConfirmationXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.Confirmation;
	
	AddObjectHeaderAttribute(NewED, "FileName",                 ED.Document.InfoConf.InfoSenFile.PostFileName);
	AddObjectHeaderAttribute(NewED, "Sender",              GetEDExchangeParticipantData(ED.Document.SenDoc));
	AddObjectHeaderAttribute(NewED, "SenderID", ED.Document.SenDoc.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "Recipient",               GetEDExchangeParticipantData(ED.Document.RecDoc));
	AddObjectHeaderAttribute(NewED, "RecipientIdentifier",  ED.Document.RecDoc.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "SendingDate",             ED.Document.InfoConf.SenDate);
	AddObjectHeaderAttribute(NewED, "SendingTime",            ED.Document.InfoConf.SenTime);
	AddObjectHeaderAttribute(NewED, "CTDForms",                 ED.Document.CTD);
	If ED.Document.CTD = "1115112" Then
		TitleParameter = "get";
		SentReceived = "IsReceived";
	Else
		TitleParameter = "sending";
		SentReceived = "sent";
	EndIf;
	AddObjectHeaderAttribute(NewED, "TitleParameter",  TitleParameter);
	AddObjectHeaderAttribute(NewED, "Sent_Received",  SentReceived);
	AddObjectHeaderAttribute(NewED, "OperatorEDO", """" + ED.Document.OperEDF.DescEnt + """ (TIN "
		+ ED.Document.OperEDF.TINLP + ", code " + ED.Document.OperEDF.IdOperEDF + ")");
	
EndProcedure

// EISDC
Procedure ReadSendingDataConfirmationXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.Confirmation;
	
	AddObjectHeaderAttribute(NewED, "FileName",                 ED.Document.InfoConf.InfoSenFile.PostFileName);
	AddObjectHeaderAttribute(NewED, "Sender",              GetEDExchangeParticipantData(ED.Document.PrSendDoc));
	AddObjectHeaderAttribute(NewED, "SenderID", ED.Document.PrSendDoc.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "Recipient",               GetEDExchangeParticipantData(ED.Document.PrRecDoc));
	AddObjectHeaderAttribute(NewED, "RecipientIdentifier",  ED.Document.PrRecDoc.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "SendingDate",             ED.Document.InfoConf.SenDate);
	AddObjectHeaderAttribute(NewED, "SendingTime",            ED.Document.InfoConf.SenTime);
	AddObjectHeaderAttribute(NewED, "CTDForms",                 ED.Document.CTD);
	AddObjectHeaderAttribute(NewED, "TitleParameter",        "sending");
	AddObjectHeaderAttribute(NewED, "Sent_Received",        "sent");
	AddObjectHeaderAttribute(NewED, "OperatorEDO", """" + ED.Document.OperEDF.DescEnt + """ (TIN "
		+ ED.Document.OperEDF.TINLP + ", code " + ED.Document.OperEDF.IdOperEDF + ")");
	
EndProcedure

// SDC
Procedure ReadConfirmationXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.Confirmation;
	
	AddObjectHeaderAttribute(NewED, "FileName",      ED.Document.InfoConf.PostFileName);
	AddObjectHeaderAttribute(NewED, "Sender",   GetEDExchangeParticipantData(ED.Document.PrSen));
	AddObjectHeaderAttribute(NewED, "Recipient",    GetEDExchangeParticipantData(ED.Document.RecDoc));
	AddObjectHeaderAttribute(NewED, "SendingDate",  ED.Document.InfoConf.DocDate);
	AddObjectHeaderAttribute(NewED, "SendingTime", ED.Document.InfoConf.TimeDoc);
	AddObjectHeaderAttribute(NewED, "CTDForms",      ED.Document.CTD);
	If ED.Document.CTD = "1167002" Then
		TitleParameter = "get";
		SentReceived = "IsReceived";
	Else
		TitleParameter = "sending";
		SentReceived = "sent";
	EndIf;
	AddObjectHeaderAttribute(NewED, "TitleParameter",  TitleParameter);
	AddObjectHeaderAttribute(NewED, "Sent_Received",  SentReceived);
	AddObjectHeaderAttribute(NewED, "OperatorEDO", """" + ED.Document.OperEDF.DescEnt + """ (TIN "
		+ ED.Document.OperEDF.TINLP + ", code " + ED.Document.OperEDF.IdOperEDF + ")");
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	
EndProcedure

// Procedure populates tabular document Confirmation (PDO, RDC, PDOIP).
//
Procedure FillTableDocumentConfirmation(SpreadsheetDocument, PrintInfo)
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_Confirmation";
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Confirmation");
	
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, PrintInfo.Header);
	SpreadsheetDocument.Put(TemplateArea);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

Function GetConfirmationDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	
	FillingDataHeader.Insert("OperatorEDO", NStr("en='Operator of electronic document flow';ru='Оператор электронного документооборота'") + " "
		+ GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "OperatorEDO"));
	
	FillingDataHeader.Insert("Sender", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Sender"));
	FillingDataHeader.Insert("SenderID", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SenderID"));
	
	FillingDataHeader.Insert("Recipient",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Recipient"));
	FillingDataHeader.Insert("RecipientIdentifier", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "RecipientIdentifier"));
	
	FillingDataHeader.Insert("SendingDate", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"SendingDate"));
	FillingDataHeader.Insert("SendingTime",GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"SendingTime"));
	
	FillingDataHeader.Insert("FileName", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"FileName"));
	FillingDataHeader.Insert("TitleParameter", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "TitleParameter"));
	FillingDataHeader.Insert("CTDForms", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"CTDForms"));
	FillingDataHeader.Insert("Sent_Received", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "Sent_Received"));
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", 	FillingDataHeader);
	
	Return DataForObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// View notifications

// Procedure populates the tabular document Notification.
//
Procedure FillTableDocumentNumbertification(SpreadsheetDocument, PrintInfo)
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_Notification";
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Notification");
	
	TemplateArea = Template.GetArea("Title");
	HeaderText = NStr("en='Notification on the electronic document receiving';ru='Извещение о получении электронного документа'");
	TemplateArea.Parameters.HeaderText = HeaderText;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, PrintInfo.Header);
	SpreadsheetDocument.Put(TemplateArea);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

Procedure ReadNotificationXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.NotificationAboutReception;
	
	AddObjectHeaderAttribute(NewED, "FileName",                ED.Document.PrNotifRec.InfRecFile.PostFileName);
	AddObjectHeaderAttribute(NewED, "Sender",             GetEDExchangeParticipantData(ED.Document.SenDoc));
	AddObjectHeaderAttribute(NewED, "SenderID",
		?(ED.Document.SenDoc.OperEDF <> Undefined, ED.Document.SenDoc.OperEDF.IdOperEDF,
		ED.Document.SenDoc.IdParticEDF));
	AddObjectHeaderAttribute(NewED, "Recipient",              GetEDExchangeParticipantData(ED.Document.ParticEDO));
	AddObjectHeaderAttribute(NewED, "RecipientIdentifier", ED.Document.ParticEDO.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "DateReceived",           ED.Document.PrNotifRec.DateGender);
	AddObjectHeaderAttribute(NewED, "ReceivingTime",          ED.Document.PrNotifRec.RecTime);
	AddObjectHeaderAttribute(NewED, "TitleParameter",       "");
	AddObjectHeaderAttribute(NewED, "DocumentID",  ED.IdFile);
EndProcedure

Function GetNotificationDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;
	FillingDataHeader.Insert("Sender", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Sender"));
	FillingDataHeader.Insert("SenderID", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SenderID"));
	
	FillingDataHeader.Insert("Recipient",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Recipient"));
	FillingDataHeader.Insert("RecipientIdentifier", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "RecipientIdentifier"));
	
	FillingDataHeader.Insert("DateReceived",	GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DateReceived"));
	FillingDataHeader.Insert("ReceivingTime",GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "ReceivingTime"));
	
	FillingDataHeader.Insert("FileName", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"FileName"));
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", 	FillingDataHeader);
	
	Return DataForObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Generation of notifications

Procedure GenerateDataByEDFParticipant(EDFParticipant, Tree, ParticipantKindOfEDO, ErrorText, TargetNamespace, FormatVersion)
	
	Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO);
	If Attribute <> True Then
		Return;
	EndIf;
	
	Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".EDFParticipantId");
	FillXDTOProperty(EDFParticipant, "IdParticEDF", Attribute, True, ErrorText);
	
	Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType");
	// Filling of attributes
	If Attribute = "OperatorEDO" Then
		OperatorAttributes = GetCMLObjectType(XDTOFactory.Type(TargetNamespace, "OperEDF"), FormatVersion);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.OperatorEDO.CompanyDescription");
		FillXDTOProperty(OperatorAttributes, "DescEnt", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.OperatorEDO.TIN");
		FillXDTOProperty(OperatorAttributes, "TINLP", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.OperatorEDO.OperatorIdentifier");
		FillXDTOProperty(OperatorAttributes, "IdOperEDF", Attribute, True, ErrorText);
		FillXDTOProperty(EDFParticipant, "OperEDF", OperatorAttributes, True, ErrorText);
	ElsIf Attribute = "CO" Then
		CounterpartyAttributes = GetCMLObjectType(XDTOFactory.Type(TargetNamespace, "INDType"), FormatVersion);
		SNPAttributes = GetCMLObjectType(XDTOFactory.Type(TargetNamespace, "NameAndSurnameOfType"), FormatVersion);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.CO.TIN");
		FillXDTOProperty(CounterpartyAttributes, "TINInd", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.CO.Surname");
		FillXDTOProperty(SNPAttributes, "Surname", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.CO.Name");
		FillXDTOProperty(SNPAttributes, "Name", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.CO.Patronymic");
		FillXDTOProperty(SNPAttributes, "Patronymic", Attribute, , ErrorText);
		FillXDTOProperty(CounterpartyAttributes, "Initials", SNPAttributes, True, ErrorText);
		FillXDTOProperty(EDFParticipant, "CO", CounterpartyAttributes, True, ErrorText);
	Else
		CounterpartyAttributes = GetCMLObjectType(XDTOFactory.Type(TargetNamespace, "LEType"), FormatVersion);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.LegalEntity.CompanyDescription");
		FillXDTOProperty(CounterpartyAttributes, "DescEnt", Attribute, True, ErrorText);
		Attribute = TreeAttributeValue(Tree, ParticipantKindOfEDO + ".ParticipantType.LegalEntity.TIN");
		FillXDTOProperty(CounterpartyAttributes, "TINLP", Attribute, True, ErrorText);
		FillXDTOProperty(EDFParticipant, "LegalEntity", CounterpartyAttributes, True, ErrorText);
	EndIf;
	
EndProcedure

Function ReceivedFileES(ObjectReference)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	EDAttachedFilesDigitalSignatures.Signature
	|FROM
	|	Catalog.EDAttachedFiles.DigitalSignatures AS EDAttachedFilesDigitalSignatures
	|WHERE
	|	EDAttachedFilesDigitalSignatures.Ref = &ObjectReference";
	Query.SetParameter("ObjectReference", ObjectReference);
	
	Selection = Query.Execute().Select();
	ESArray = New Array;
	While Selection.Next() Do
		ESArray.Add(Base64String(Selection.Signature.Get()));
	EndDo;
	
	Return ESArray;
	
EndFunction

Function FillInServiceDocumentFile(Tree, EDKind)
	
	ErrorText = "";
	If EDKind = Enums.EDKinds.NotificationAboutReception Then
		TargetNamespace      = "DP_IZVPOL";
		ItemGeneralInformation  = "PrNotifRec";
		ItemFileInformation = "InfRecFile";
		AttributeFileName       = "PostFileName";
		FileEDSList        = "EDSRecFile";
		ItemRecipient     = "SenDoc";
	ElsIf EDKind = Enums.EDKinds.NotificationAboutClarification Then
		TargetNamespace      = "DP_UVUTOCH";
		ItemGeneralInformation  = "PrAdjNot";
		ItemFileInformation = "InfRecFile";
		AttributeFileName       = "PostFileName";
		FileEDSList        = "EDSRecFile";
		ItemClarifyingText = "TextNotifCor";
		ItemRecipient     = "SenDoc";
	Else
		TargetNamespace      = "DP_PRANNUL";
		ItemGeneralInformation  = "PrelimAnalysisInfo";
		ItemFileInformation = "InfoAnFile";
		AttributeFileName       = "AnFileName";
		FileEDSList        = "EDSAnFile";
		ItemClarifyingText = "TextAnnOffer";
		ItemRecipient     = "AnOfferSent";
	EndIf;
	
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("FileID", TreeAttributeValue(Tree,"FileID"));
	
	Try
		File = GetCMLObjectType("File", TargetNamespace);
		
		// 
		FillXDTOProperty(File, "IdFile", ParametersStructure.FileID, True, ErrorText);
		FillXDTOProperty(File, "VersProg", TreeAttributeValue(Tree, "ApplicationVersion"), True, ErrorText);
		FormatVersion = TreeAttributeValue(Tree, "FormatVersion");
		FillXDTOProperty(File, "VersForm", FormatVersion, True, ErrorText);
		
		Document = GetCMLObjectType("File.Document", TargetNamespace);
		If EDKind <> Enums.EDKinds.CancellationOffer Then
			FillXDTOProperty(Document, "CTD", TreeAttributeValue(Tree,"CodeCTD"), True, ErrorText);
		EndIf;
		
		// Sender
		Sender = GetCMLObjectType("File.Document.ParticEDO", TargetNamespace);
		
		GenerateDataByEDFParticipant(Sender, Tree, "Sender", ErrorText, TargetNamespace, FormatVersion);
		FillXDTOProperty(Document, "ParticEDO", Sender, True, ErrorText);
		
		// General information about document
		GeneralInformation = GetCMLObjectType("File.Document." + ItemGeneralInformation, TargetNamespace);
		If EDKind <> Enums.EDKinds.CancellationOffer Then
			Attribute = DateDD_MM_YYYY(TreeAttributeValue(Tree, "DocumentData.ReceiptDate"));
			FillXDTOProperty(GeneralInformation, "DateGender", Attribute, True, ErrorText);
			FillXDTOProperty(GeneralInformation, "RecTime",
				TreeAttributeValue(Tree, "DocumentData.ReceivingTime"), True, ErrorText);
		EndIf;
		
		// Data on received file
		ReceivedED = GetCMLObjectType("File.Document." + ItemGeneralInformation + "." + ItemFileInformation,
			TargetNamespace);
		Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedFileName");
		FillXDTOProperty(ReceivedED, AttributeFileName, Attribute, True, ErrorText);
		
		// EDS of received file in Base64 encoding
		ESArray = TreeAttributeValue(Tree, "DocumentData.InfRecFile.RecievedDS");
		If TypeOf(ESArray) = Type("Array") Then
			For Each DS IN ESArray Do
				ReceivedED[FileEDSList].Add(DS);
			EndDo;
		EndIf;
		
		If EDKind <> Enums.EDKinds.NotificationAboutReception Then
			Attribute = TreeAttributeValue(Tree, "DocumentData.CorrectionText");
			FillXDTOProperty(GeneralInformation, ItemClarifyingText, Attribute, True, ErrorText);
		EndIf;
		
		If EDKind <> Enums.EDKinds.CancellationOffer Then
			Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData");
			If Attribute = True Then
				DataDoc = GetCMLObjectType("File.Document." + ItemGeneralInformation + ".InfRecFile.DatReceDoc", TargetNamespace);
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DocumentDesc");
				FillXDTOProperty(DataDoc, "DocDesc", Attribute, True, ErrorText);
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DocumentNumber");
				FillXDTOProperty(DataDoc, "DocNum", Attribute, True, ErrorText);
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DocumentDate");
				Attribute = DateDD_MM_YYYY(Attribute);
				FillXDTOProperty(DataDoc, "DocDate", Attribute, True, ErrorText);
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.NumCrinSF");
				If ValueIsFilled(Attribute) Then
					FillXDTOProperty(DataDoc, "NumCrinSF", Attribute, , ErrorText);
				EndIf;
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DateCrinSF");
				If ValueIsFilled(Attribute) Then
					Attribute = DateDD_MM_YYYY(Attribute);
					FillXDTOProperty(DataDoc, "DateCrinSF", Attribute, , ErrorText);
				EndIf;
				If EDKind = Enums.EDKinds.NotificationAboutReception Then
					Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.NumCSF");
					If ValueIsFilled(Attribute) Then
						FillXDTOProperty(DataDoc, "NumCSF", Attribute, , ErrorText);
					EndIf;
					Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DateCSF");
					If ValueIsFilled(Attribute) Then
						Attribute = DateDD_MM_YYYY(Attribute);
						FillXDTOProperty(DataDoc, "DateCSF", Attribute, , ErrorText);
					EndIf;
				EndIf;
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.NumCrinCSF");
				If ValueIsFilled(Attribute) Then
					FillXDTOProperty(DataDoc, "NumCrinCSF", Attribute, , ErrorText);
				EndIf;
				Attribute = TreeAttributeValue(Tree, "DocumentData.InfRecFile.ReceivedDocumentData.DateCrinCSF");
				If ValueIsFilled(Attribute) Then
					Attribute = DateDD_MM_YYYY(Attribute);
					FillXDTOProperty(DataDoc, "DateCrinCSF", Attribute, , ErrorText);
				EndIf;
				FillXDTOProperty(ReceivedED, "DatReceDoc", DataDoc, , ErrorText);
			EndIf;
		EndIf;
		
		FillXDTOProperty(GeneralInformation, ItemFileInformation, ReceivedED, True, ErrorText);
		FillXDTOProperty(Document, ItemGeneralInformation, GeneralInformation, True, ErrorText);
		
		// Recipient
		Recipient = GetCMLObjectType("File.Document." + ItemRecipient, TargetNamespace);
		
		GenerateDataByEDFParticipant(Recipient, Tree, "Recipient", ErrorText, TargetNamespace, FormatVersion);
		FillXDTOProperty(Document, ItemRecipient, Recipient, True, ErrorText);
		
		// Signer
		Signer = GetCMLObjectType("File.Document.Signer", TargetNamespace);
		FillXDTOProperty(Signer, "Position", "---", True, ErrorText);
		
		SignerSNP = GetCMLObjectType(XDTOFactory.Type(TargetNamespace, "NameAndSurnameOfType"));
		FillXDTOProperty(SignerSNP, "Surname", "---", True, ErrorText);
		FillXDTOProperty(SignerSNP, "Name", "---", True, ErrorText);
		
		FillXDTOProperty(Signer, "Initials", SignerSNP, True, ErrorText);
		FillXDTOProperty(Document, "Signer", Signer, True, ErrorText);
		
		FillXDTOProperty(File, "Document", Document, True, ErrorText);
		
		File.Validate();
		InsertValueIntoTree(Tree, "FullFileName", ElectronicDocumentsService.TemporaryFileCurrentName("xml"));
		ExportEDtoFile(File, TreeAttributeValue(Tree, "FullFileName"), False, "windows-1251");
		
		Return True;
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		
		Return False;
	EndTry;
	
EndFunction

Function PrepareDataByServiceDocument(ObjectReference, EDStructure, Tree)
	
	CommonUseED.FillTreeAttributeValue(Tree, "FileID", EDStructure.FileID);
	CommonUseED.FillTreeAttributeValue(Tree, "ApplicationVersion", NStr("en='1C:Enterprise 8';ru='1C:Enterprise 8'"));
	CommonUseED.FillTreeAttributeValue(Tree, "Sender.EDFParticipantId", EDStructure.SenderID);
	CommonUseED.FillTreeAttributeValue(Tree, "Recipient.EDFParticipantId", EDStructure.RecipientID);
	If EDStructure.EDKind = Enums.EDKinds.CancellationOffer Then
		CommonUseED.FillTreeAttributeValue(Tree, "FormatVersion", "1.01");
		CommonUseED.FillTreeAttributeValue(Tree, "CodeCTD", "");
	Else
		CommonUseED.FillTreeAttributeValue(Tree, "FormatVersion", "1.02");
		CommonUseED.FillTreeAttributeValue(Tree, "CodeCTD",
			?(EDStructure.EDKind = Enums.EDKinds.NotificationAboutReception, "1115110", "1115113"));
	EndIf;
	
	Try
		// Recipient
		If EDStructure.Property("OperatorEDO") Then
			If Mid(EDStructure.OperatorEDO.TIN, 6, 2) = "16" Then
				EDStructure.OperatorEDO.TIN = Left(EDStructure.OperatorEDO.TIN, 5) + "61" + Mid(EDStructure.OperatorEDO.TIN, 8);
			EndIf;
			Path = "Recipient.ParticipantType.OperatorEDO";
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".TIN", EDStructure.OperatorEDO.TIN);
			CommonUseED.FillTreeAttributeValue(Tree,
				Path + ".CompanyName", EDStructure.OperatorEDO.Description);
			CommonUseED.FillTreeAttributeValue(Tree,
				Path + ".OperatorIdentifier", EDStructure.OperatorEDO.OperatorIdentifier);
		Else
			ThisIsInd = ElectronicDocumentsOverridable.ThisIsInd(EDStructure.Recipient);
			DataLegalIndividual = ElectronicDocumentsOverridable.GetDataLegalIndividual(EDStructure.Recipient);
			FullDescrName = ?(ThisIsInd, "FullDescr", "OfficialName");
			FullDescr = "";
			DataLegalIndividual.Property(FullDescrName, FullDescr);
			If Not ValueIsFilled(FullDescr) Then
				FullDescr = ?(ValueIsFilled(DataLegalIndividual.FullDescr), DataLegalIndividual.FullDescr,
					DataLegalIndividual.Presentation);
			EndIf;
			If ThisIsInd Then
				Path = "Recipient.ParticipantType.CO";
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".TIN", DataLegalIndividual.TIN);
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".Surname", DataLegalIndividual.Surname);
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".Name", DataLegalIndividual.Name);
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".Patronymic", DataLegalIndividual.Patronymic);
			Else
				Path = "Recipient.ParticipantType.LegalEntity";
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".TIN", DataLegalIndividual.TIN);
				CommonUseED.FillTreeAttributeValue(Tree, Path + ".CompanyName", FullDescr);
			EndIf;
		EndIf;
		
		// Sender
		ThisIsInd = ElectronicDocumentsOverridable.ThisIsInd(EDStructure.Sender);
		DataLegalIndividual = ElectronicDocumentsOverridable.GetDataLegalIndividual(EDStructure.Sender);
		FullDescrName = ?(ThisIsInd, "FullDescr", "OfficialName");
		FullDescr = "";
		DataLegalIndividual.Property(FullDescrName, FullDescr);
		If Not ValueIsFilled(FullDescr) Then
			FullDescr = ?(ValueIsFilled(DataLegalIndividual.FullDescr), DataLegalIndividual.FullDescr,
				DataLegalIndividual.Presentation);
		EndIf;
		If ThisIsInd Then
			Path = "Sender.ParticipantType.CO";
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".TIN", DataLegalIndividual.TIN);
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".Surname", DataLegalIndividual.Surname);
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".Name", DataLegalIndividual.Name);
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".Patronymic", DataLegalIndividual.Patronymic);
		Else
			Path = "Sender.ParticipantType.LegalEntity";
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".TIN", DataLegalIndividual.TIN);
			CommonUseED.FillTreeAttributeValue(Tree, Path + ".CompanyName", FullDescr);
		EndIf;
		
		// Document
		If Not EDStructure.EDKind = Enums.EDKinds.CancellationOffer Then
			Attribute = ReturnDateESF(EDStructure.DateReceivedTime);
			CommonUseED.FillTreeAttributeValue(Tree, "DocumentData.ReceiptDate", Attribute);
			Attribute = ReturnESFTime(EDStructure.DateReceivedTime);
			CommonUseED.FillTreeAttributeValue(Tree, "DocumentData.ReceivingTime", Attribute);
		EndIf;
		Path = "DocumentData.InfRecFile.";
		Attribute = EDStructure.ReceivedFileDescriptionWithoutExtension;
		CommonUseED.FillTreeAttributeValue(Tree, Path + "ReceivedFileName", Attribute);
		
		Attribute = ReceivedFileES(ObjectReference);
		If Not ValueIsFilled(Attribute) Then
			Attribute.Add("---");
		EndIf;
		CommonUseED.FillTreeAttributeValue(Tree, Path + "RecievedDS", Attribute);
		
		If EDStructure.EDKind <> Enums.EDKinds.NotificationAboutReception Then
			Attribute = ReturnDateESF(EDStructure.CorrectionText);
			CommonUseED.FillTreeAttributeValue(Tree, "DocumentData.CorrectionText", Attribute);
		EndIf;
		
		TreeIsFilled = True;
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
			DetailErrorDescription(ErrorInfo()), MessageText);
		TreeIsFilled = False;
	EndTry;
	
	ErrorText = "";
	CheckFillObligatoryAttributesRecursively(Tree, ErrorText);
	If TreeIsFilled AND ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
		TreeIsFilled = False;
	EndIf;
	
	Return TreeIsFilled;
	
EndFunction

Function DetermineEDFileId(EDStructure)
	
	IdText = "";
	If EDStructure.EDKind = Enums.EDKinds.NotificationAboutReception Then
		
		// Format of the name by ESF: DP_IZVPOL_RecipientId_SenderId_YYYYMMDD_GUID.
		IdText = NStr("en='DP_IZVPOL_%1_%2_%3_%4';ru='DP_IZVPOL_%1_%2_%3_%4'");
		If EDStructure.Property("OperatorEDO") AND EDStructure.OperatorEDO.Property("OperatorIdentifier") Then
			RecipientID = EDStructure.OperatorEDO.OperatorIdentifier;
		Else
			RecipientID = EDStructure.RecipientID;
		EndIf;
		IdText = StringFunctionsClientServer.SubstituteParametersInString(IdText, RecipientID, EDStructure.SenderId,
			ReturnDateAsStringForID(CurrentSessionDate()), EDStructure.EDNumber);
	ElsIf EDStructure.EDKind = Enums.EDKinds.NotificationAboutClarification Then
		
		// Format of the name by ESF: DP_UVUTOCH_RecipientId_SenderId_YYYYMMDD_GUID.
		IdText = NStr("en='DP_UVUTOCH_%1_%2_%3_%4';ru='DP_UVUTOCH_%1_%2_%3_%4'");
		IdText = StringFunctionsClientServer.SubstituteParametersInString(IdText, EDStructure.RecipientID,
			EDStructure.SenderId, ReturnDateAsStringForID(CurrentSessionDate()), EDStructure.EDNumber);
	ElsIf EDStructure.EDKind = Enums.EDKinds.CancellationOffer Then
		
		// Format of name by ESF: DP_PRANNUL_RecipientId_SenderId_YYYYMMDD_GUID.
		IdText = NStr("en='DP_PRANNUL_%1_%2_%3_%4';ru='DP_PRANNUL_%1_%2_%3_%4'");
		IdText = StringFunctionsClientServer.SubstituteParametersInString(IdText, EDStructure.RecipientID,
			EDStructure.SenderId, ReturnDateAsStringForID(CurrentSessionDate()), EDStructure.EDNumber);
	EndIf;
	
	EDFileId = ElectronicDocumentsService.CorrectFileName(IdText);
	
	Return EDFileId;
	
EndFunction

Function ReturnDateAsStringForID(DateTime)
	
	Return Format(DateTime, "DF=yyyyMMdd");
	
EndFunction

Function ReturnDateESF(DateTime)
	
	ESFDate = Format(DateTime, "DF=dd.MM.yyyy");
	Return ESFDate;
	
EndFunction

Function ReturnESFTime(DateTime)
	
	TimeESF = Format(Hour(DateTime), "ND=2; NZ=; NLZ=") + ".";
	TimeESF = TimeESF+Format(Minute(DateTime), "ND=2; NZ=; NLZ=") + ".";
	TimeESF = TimeESF+Format(Minute(DateTime), "ND=2; NZ=; NLZ=");
	
	Return TimeESF;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Viewing of notifications of corrections

// Procedure populates the tabular document Notification of clarification.
//
Procedure FillTableDocumentCorrection(SpreadsheetDocument, PrintInfo)
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_Correction";
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Clarification");
	
	TemplateArea = Template.GetArea("Title");
	HeaderText = NStr("en='Notification about clarification';ru='Уведомление об уточнении'");
	TemplateArea.Parameters.HeaderText = HeaderText;
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, PrintInfo.Header);
	SpreadsheetDocument.Put(TemplateArea);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

Procedure ReadRefinementXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.NotificationAboutClarification;
	
	AddObjectHeaderAttribute(NewED, "FileName",          ED.Document.PrAdjNot.InfRecFile.PostFileName);
	AddObjectHeaderAttribute(NewED, "Sender",       GetEDExchangeParticipantData(ED.Document.SenDoc));
	AddObjectHeaderAttribute(NewED, "Recipient",        GetEDExchangeParticipantData(ED.Document.ParticEDO));
	AddObjectHeaderAttribute(NewED, "DateReceived",     ED.Document.PrAdjNot.DateGender);
	AddObjectHeaderAttribute(NewED, "ReceivingTime",    ED.Document.PrAdjNot.RecTime);
	AddObjectHeaderAttribute(NewED, "CorrectionText",    ED.Document.PrAdjNot.TextNotifCor);
	AddObjectHeaderAttribute(NewED, "TitleParameter", "");
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.IdFile);
	
EndProcedure

Function GetCorrectionDataToPrint(ObjectString, ParseTree, ID)
	
	FillingDataHeader = New Structure;
	
	FillingDataHeader.Insert("Sender", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Sender"));
	FillingDataHeader.Insert("SenderID", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SenderID"));
	FillingDataHeader.Insert("Recipient",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Recipient"));
	FillingDataHeader.Insert("RecipientIdentifier", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "RecipientIdentifier"));
	FillingDataHeader.Insert("DateReceived", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "DateReceived"));
	FillingDataHeader.Insert("ReceivingTime", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "ReceivingTime"));
	FillingDataHeader.Insert("CorrectionText", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CorrectionText"));
	FillingDataHeader.Insert("FileName", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"FileName"));
	
	EDClarification = Catalogs.EDAttachedFiles.GetRef(ID);
	
	If EDClarification.EDDirection = Enums.EDDirections.Incoming Then
		VersionPointTypeED = Enums.EDVersionElementTypes.EIRDC;
	Else
		VersionPointTypeED = Enums.EDVersionElementTypes.EISDC;
	EndIf;
	
	SearchParametersStructure = New Structure;
	SearchParametersStructure.Insert("UniqueId",        EDClarification.UniqueId);
	SearchParametersStructure.Insert("EDDirection",       Enums.EDDirections.Incoming);
	SearchParametersStructure.Insert("EDKind",               Enums.EDKinds.Confirmation);
	SearchParametersStructure.Insert("VersionPointTypeED", VersionPointTypeED);
	EDDateConfirmation = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
	
	If EDDateConfirmation <> Undefined Then
		AdditInformationAboutED = ElectronicDocumentsService.GetFileData(EDDateConfirmation, , True);
		If AdditInformationAboutED.Property("FileBinaryDataRef")
			AND ValueIsFilled(AdditInformationAboutED.FileBinaryDataRef) Then
			
			EDData = GetFromTempStorage(AdditInformationAboutED.FileBinaryDataRef);
			If ValueIsFilled(AdditInformationAboutED.Extension) Then
				FileName = ElectronicDocumentsService.TemporaryFileCurrentName(AdditInformationAboutED.Extension);
			Else
				FileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
			EndIf;
			
			If FileName <> Undefined Then
				
				EDData.Write(FileName);
				
				ConfirmationStructure = GenerateParseTree(FileName, EDDateConfirmation.EDDirection);
				DeleteFiles(FileName);
				If ConfirmationStructure <> Undefined AND ConfirmationStructure.Count() > 0 Then
					FillingDataHeader.Insert("PostDating", GetParsedTreeStringAttributeValue(
						ConfirmationStructure.ParseTree, ConfirmationStructure.ObjectString, "SendingDate"));
					FillingDataHeader.Insert("SendingTime", GetParsedTreeStringAttributeValue(
						ConfirmationStructure.ParseTree, ConfirmationStructure.ObjectString, "SendingTime"));
					FillingDataHeader.Insert("OperatorEDO", NStr("en='operator of electronic document flow';ru='оператора электронного документооборота'") + " "
						+ GetParsedTreeStringAttributeValue(ConfirmationStructure.ParseTree,
						ConfirmationStructure.ObjectString, "OperatorEDO"));
				EndIf;
				
			EndIf;
		EndIf;
	EndIf;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", FillingDataHeader);
	
	Return DataForObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// EDF operator

Procedure FillEDFOperatorAttributes(ParametersStructure)
	
	AttributesStructure = EDFOperatorSettingsStructure();
	Description = "";
	TIN = "";
	OperatorIdentifier = "";
	AttributesStructure.Property("Description", Description);
	AttributesStructure.Property("TIN", TIN);
	AttributesStructure.Property("OperatorIdentifier", OperatorIdentifier);
	ParametersStructure.Insert("DescEnt", Description);
	ParametersStructure.Insert("TINLP", TIN);
	ParametersStructure.Insert("IdEDF", OperatorIdentifier);
	
EndProcedure

Procedure FillEDFBlankOperatorAttributes(ParametersStructure, DataByCompany)
	
	Description = NStr("en='without EDO Operator';ru='Без оператора ЭДО'");
	TIN = "1111111117"; // First TIN which fulfills the format requirements
	
	DataLegalIndividual = ElectronicDocumentsOverridable.GetDataLegalIndividual(DataByCompany);
	If ValueIsFilled(DataLegalIndividual.FullDescr) Then
		Description = DataLegalIndividual.FullDescr;
	EndIf;
	If ValueIsFilled(DataLegalIndividual.TIN) Then
		TIN = DataLegalIndividual.TIN;
	EndIf;
	ParametersStructure.Insert("DescEnt", Description);
	ParametersStructure.Insert("TINLP", Left(TIN, 10));
	ParametersStructure.Insert("IdEDF", "---");
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Exchange with banks

Procedure FillInStatementTabularDocument_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_BankStatement");
	For Each Record IN PrintInfo.TurnoversOnAccounts Do
		HeaderData = PrintInfo.Header;
		AreaHeader = Template.GetArea("Header");
		AreaHeader.Parameters.Fill(HeaderData);
		AreaHeader.Parameters.Fill(Record.Value);
		AreaHeader.Parameters.AccountNo = Record.Key;
		SpreadsheetDocument.Put(AreaHeader);
		Turnovers = Record.Value.Turnovers;
		For Each Payment IN Turnovers Do
			AreaRow = Template.GetArea("String");
			AreaRow.Parameters.Fill(Payment);
			SpreadsheetDocument.Put(AreaRow);
		EndDo;
		FooterArea = Template.GetArea("Footer");
		FooterArea.Parameters.Fill(Record.Value);
		FooterArea.Parameters.Fill(HeaderData);
		SpreadsheetDocument.Put(FooterArea);
		
		If PrintInfo.Property("Stamp") Then
			StampArea = Template.GetArea("Stamp");
			StampArea.Parameters.Fill(PrintInfo.Stamp);
			SpreadsheetDocument.Put(StampArea);
		EndIf;
		
		SpreadsheetDocument.PutHorizontalPageBreak();
	EndDo;
	
EndProcedure

Procedure FillInTabularDocumentQueryOnStatement_ED(SpreadsheetDocument, PrintInfo)
		
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_QueryStatement");

	HeaderArea = Template.GetArea("Title");
	HeaderData = PrintInfo.Header;
	
	HeaderArea.Parameters.PeriodOpenDate    = Format(HeaderData.StartDate, "DLF=D");
	HeaderArea.Parameters.EndDateOfPeriod = Format(HeaderData.EndDate,  "DLF=D");
	SpreadsheetDocument.Put(HeaderArea);
	
	BankAccounts = PrintInfo.BankAccounts;
	
	AreaRowBankAccount = Template.GetArea("TSRow");
	
	For Each TSRow in BankAccounts Do
		AreaRowBankAccount.Parameters.Fill(TSRow);
		SpreadsheetDocument.Put(AreaRowBankAccount);
	EndDo;
	
	SpreadsheetDocument.PageOrientation = PageOrientation.Portrait;
	
EndProcedure

Procedure FillInTabularDocumentPaymentOrderOutgoing_ED(SpreadsheetDocument, Attributes, ID)

	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_PaymentOrder");

	TemplateArea = Template.GetArea("TableTitle");
	
	FillPropertyValues(TemplateArea.Parameters, Attributes);
	
	TemplateArea.Parameters.DescriptionNumber = NStr("en='PAYMENT ORDER No';ru='ПЛАТЕЖНОЕ ПОРУЧЕНИЕ №'") + " " + Attributes.Number;
	TemplateArea.Parameters.DocumentDate = Format(Attributes.Date, "DLF=D");
	
	TextPattern = NStr("en='%1
		|R/c %2 in %3 %4';ru='%1
		|Р/c %2 в %3 %4'");
	If Attributes.PayerIndirectPayments Then
		TemplateArea.Parameters.PayerBankDescription = TrimAll("" + Attributes.PayerBankForSettlementsName
																		+ " " + Attributes.PayerBankForSettlementsCity);
		TemplateArea.Parameters.PayerBankCorrAccount = Attributes.PayerBankForSettlementsCorrAccount;
		TemplateArea.Parameters.PayerDescription = StringFunctionsClientServer.SubstituteParametersInString(
			TextPattern, Attributes.PayerDescription, Attributes.PayerBankAcc, Attributes.PayerBankName,
			Attributes.PayerBankCity);
		TemplateArea.Parameters.PayerBankAcc = Attributes.PayerBankForSettlementsCorrAccount;
	Else
		TemplateArea.Parameters.PayerBankDescription = TrimAll("" + Attributes.PayerBankName + " "
																		+ Attributes.PayerBankCity);
	EndIf;
	
	If Attributes.RecipientIndirectSettlements Then
		TemplateArea.Parameters.RecipientBankCorrAccount = Attributes.RecipientBankForSettlementsBalancedAccount;
		TemplateArea.Parameters.PayeeBankDescription = TrimAll("" + Attributes.RecipientBankNameForSettlements
																		+ " " + Attributes.RecipientBankForSettlementsCity);
		TemplateArea.Parameters.RecipientDescription = StringFunctionsClientServer.SubstituteParametersInString(
			TextPattern, Attributes.RecipientDescription, Attributes.PayeeBankAcc,
			Attributes.RecipientBankName, Attributes.PayeeBankCity);
		TemplateArea.Parameters.PayeeBankAcc = Attributes.RecipientBankForSettlementsBalancedAccount;
	Else
		TemplateArea.Parameters.PayeeBankDescription = TrimAll("" + Attributes.RecipientBankName + " "
																		+ Attributes.PayeeBankCity);
	EndIf;

	SpreadsheetDocument.PageOrientation = PageOrientation.Portrait;
	
	If ValueIsFilled(ID) Then
		LinkToED = Catalogs.EDAttachedFiles.GetRef(ID);
		STATEMENT = SubordinateDocument(LinkToED, Enums.EDKinds.STATEMENT);
		If ValueIsFilled(STATEMENT) Then
			FileData = ElectronicDocumentsService.GetFileData(STATEMENT);
			EDData = GetFromTempStorage(FileData.FileBinaryDataRef);
			TempFile = GetTempFileName("xml");
			If Not TempFile = Undefined Then
				EDData.Write(TempFile);
				Result = GenerateParseTree(TempFile, Enums.EDDirections.Incoming);
				DeleteFiles(TempFile);
				If Not Result = Undefined Then
					ParseTree = Result.ParseTree;
					ObjectString = Result.ObjectString;
					ReceiptDate = GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
						"ReceiptDateInPayersBank");
					DateWriteOff = GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
						"DateWriteOffAccountOfPayer");
					TemplateArea.Parameters.ReceiptDate = Format(ReceiptDate, "DLF=D");
					TemplateArea.Parameters.DateWriteOff = Format(DateWriteOff, "DLF=D");
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
	SpreadsheetDocument.Put(TemplateArea);
	
	If ValueIsFilled(ID) Then
		UniqueId = New UUID(ID);
		LinkToED = Catalogs.EDAttachedFiles.GetRef(UniqueId);
		AdditionalAttributes = CommonUse.ObjectAttributeValue(LinkToED, "AdditionalAttributes");
		If ValueIsFilled(AdditionalAttributes) Then
			AttributeValues = AdditionalAttributes.Get();
			If ValueIsFilled(AttributeValues) AND AttributeValues.Property("StampData") Then
				StampArea = Template.GetArea("Stamp");
				StampArea.Parameters.Fill(AttributeValues.StampData);
				SpreadsheetDocument.Put(StampArea);
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

Procedure FillInTabularDocumentReciept_ED(SpreadsheetDocument, PrintInfo)
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Receipt");

	HeaderArea = Template.GetArea("Title");
	
	SpreadsheetDocument.Put(HeaderArea);
	
	AreaTicketSBBOL = Template.GetArea("TicketSBBOL");
	AreaTicketSBBOL.Parameters.TicketSBBOL = PrintInfo.TicketSBBOL;
	SpreadsheetDocument.Put(AreaTicketSBBOL);
	
	If ValueIsFilled(PrintInfo.CreationDateKvitka) Then
		AreaTicketCreationDate = Template.GetArea("CreationDateKvitka");
		AreaTicketCreationDate.Parameters.CreationDateKvitka = PrintInfo.CreationDateKvitka;
		SpreadsheetDocument.Put(AreaTicketCreationDate);
	EndIf;
	
	If ValueIsFilled(PrintInfo.CodeDocumentStatus) Then
		AreaDocumentStateCode = Template.GetArea("CodeDocumentStatus");
		AreaDocumentStateCode.Parameters.CodeDocumentStatus = PrintInfo.CodeDocumentStatus;
		SpreadsheetDocument.Put(AreaDocumentStateCode);
	EndIf;

	If ValueIsFilled(PrintInfo.CompanyID) Then
		AreaCompanyIdentifier = Template.GetArea("CompanyID");
		AreaCompanyIdentifier.Parameters.CompanyID = PrintInfo.CompanyID;
		SpreadsheetDocument.Put(AreaCompanyIdentifier);
	EndIf;
	
	If ValueIsFilled(PrintInfo.DocumentID) Then
		AreaDocumentID = Template.GetArea("DocumentID");
		AreaDocumentID.Parameters.DocumentID = PrintInfo.DocumentID;
		SpreadsheetDocument.Put(AreaDocumentID);
	EndIf;
	
	If ValueIsFilled(PrintInfo.DateWriteOffAccountOfPayer) 
		OR ValueIsFilled(PrintInfo.DateOfFiling) 
		OR ValueIsFilled(PrintInfo.ReceiptDateInPayersBank) 
		OR ValueIsFilled(PrintInfo.DatePaymentEnums) 
		OR ValueIsFilled(PrintInfo.PayersBankStampDate) 
		OR ValueIsFilled(PrintInfo.DateStampOfBeneficiarysBank) Then
			AreaBankingDates = Template.GetArea("BankDates");
			SpreadsheetDocument.Put(AreaBankingDates);
	EndIf;
	
	If ValueIsFilled(PrintInfo.DateWriteOffAccountOfPayer) Then
		AreaWriteOffDateFromPaymentAccount = Template.GetArea("DateWriteOffAccountOfPayer");
		AreaWriteOffDateFromPaymentAccount.Parameters.DateWriteOffAccountOfPayer = PrintInfo.DateWriteOffAccountOfPayer;
		SpreadsheetDocument.Put(AreaWriteOffDateFromPaymentAccount);
	EndIf;

	If ValueIsFilled(PrintInfo.DateOfFiling) Then
		AreaSettingToCardIndexDate = Template.GetArea("DateOfFiling");
		AreaSettingToCardIndexDate.Parameters.DateOfFiling = PrintInfo.DateOfFiling;
		SpreadsheetDocument.Put(AreaSettingToCardIndexDate);
	EndIf;
	
	If ValueIsFilled(PrintInfo.PayersBankStampDate) Then
		AreaMarkDateByPayerBank = Template.GetArea("PayersBankStampDate");
		AreaMarkDateByPayerBank.Parameters.PayersBankStampDate = PrintInfo.PayersBankStampDate;
		SpreadsheetDocument.Put(AreaMarkDateByPayerBank);
	EndIf;
	
	If ValueIsFilled(PrintInfo.ReceiptDateInPayersBank) Then
		AreaReceiptDateInPayerBank = Template.GetArea("ReceiptDateInPayersBank");
		AreaReceiptDateInPayerBank.Parameters.ReceiptDateInPayersBank = PrintInfo.ReceiptDateInPayersBank;
		SpreadsheetDocument.Put(AreaReceiptDateInPayerBank);
	EndIf;
	
	If ValueIsFilled(PrintInfo.DatePaymentEnums) Then
		AreaPaymentTransferDate = Template.GetArea("DatePaymentEnums");
		AreaPaymentTransferDate.Parameters.DatePaymentEnums = PrintInfo.DatePaymentEnums;
		SpreadsheetDocument.Put(AreaPaymentTransferDate);
	EndIf;
	
	If ValueIsFilled(PrintInfo.DateStampOfBeneficiarysBank) Then
		AreaReceiverBankMarkDate = Template.GetArea("DateStampOfBeneficiarysBank");
		AreaReceiverBankMarkDate.Parameters.DateStampOfBeneficiarysBank = PrintInfo.DateStampOfBeneficiarysBank;
		SpreadsheetDocument.Put(AreaReceiverBankMarkDate);
	EndIf;

	If ValueIsFilled(PrintInfo.AuthorOfMessage) OR ValueIsFilled(PrintInfo.MessageFromBank) Then
		AreaMessageFromBank = Template.GetArea("MessageFromBank");
		SpreadsheetDocument.Put(AreaMessageFromBank);
	EndIf;
	
	If ValueIsFilled(PrintInfo.AuthorOfMessage) Then
		AreaMessageAuthor = Template.GetArea("AuthorOfMessage");
		AreaMessageAuthor.Parameters.AuthorOfMessage = PrintInfo.AuthorOfMessage;
		SpreadsheetDocument.Put(AreaMessageAuthor);
	EndIf;
	
	If ValueIsFilled(PrintInfo.MessageFromBank) Then
		AreaMessageText = Template.GetArea("MessageText");
		AreaMessageText.Parameters.MessageFromBank = PrintInfo.MessageFromBank;
		SpreadsheetDocument.Put(AreaMessageText);
	EndIf;

EndProcedure

Function GetStatementDataToPrint(ObjectString, ParseTree)
	
	DataForObject = New Structure;
	
	FillingDataHeader = New Structure;
	
	FilterStructure = New Structure("Attribute", "BankAccountsOfTheCompany");
	BankAccountsOfTheCompany = ObjectString.Rows.FindRows(FilterStructure);
	
	AccordanceAccountsAndData = New Map;
	For Each StringBankAccount IN BankAccountsOfTheCompany Do
		AccountNo = GetParsedTreeStringAttributeValue(
			ParseTree, StringBankAccount, "BankAcc.SettlemAccount");
		DataStructure = New Structure;
		OpeningBalance = GetParsedTreeStringAttributeValue(
			ParseTree, StringBankAccount, "BankAccount.OpeningBalance");
		DataStructure.Insert("InBalance", ?(OpeningBalance = Undefined, 0, OpeningBalance));
		DebitedTotal = GetParsedTreeStringAttributeValue(
			ParseTree, StringBankAccount, "BankAccount.TotalReceived");
		DataStructure.Insert("Credit", ?(DebitedTotal = Undefined, 0, DebitedTotal));
		CreditedTotal = GetParsedTreeStringAttributeValue(
			ParseTree, StringBankAccount, "BankAccount.TotalDebited");
		DataStructure.Insert("Debit", ?(CreditedTotal = Undefined, 0, CreditedTotal));
		ClosingBalance = GetParsedTreeStringAttributeValue(
			ParseTree, StringBankAccount, "BankAccount.ClosingBalance");
		DataStructure.Insert("OutgBalance", ?(ClosingBalance = Undefined, 0, ClosingBalance));
		AccordanceAccountsAndData.Insert(AccountNo, DataStructure);
	EndDo;
	
	StatementCompletionDate = GetParsedTreeStringAttributeValue(
							ParseTree, ObjectString, "GeneratingDate");
	
	If Not ValueIsFilled(StatementCompletionDate) Then
		CompilationDate =  GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CreationDate");
		CompilationTime = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CreationTime");
		StatementCompletionDate = Format(CompilationDate, "DF=dd.MM.yyyy") + " " + Format(CompilationTime, "DLF=T");
	EndIf;
		
	FillingDataHeader.Insert("StatementCompletionDate", StatementCompletionDate);
	StartDate = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "StartDate");
	FillingDataHeader.Insert("StartDate", Format(StartDate,"DF=dd.MM.yyyy"));
	EndDate = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "EndDate");
	FillingDataHeader.Insert("EndDate", Format(EndDate, "DF=dd.MM.yyyy"));
	
	StatementData = New Array;
	
	VT = New ValueTable;
	VT.Columns.Add("OperationDate");
	VT.Columns.Add("FB");
	VT.Columns.Add("DocumentNumber");
	VT.Columns.Add("Debit");
	VT.Columns.Add("Credit");
	VT.Columns.Add("BIN");
	VT.Columns.Add("Description");
	VT.Columns.Add("OperationBasis");
	
	For Each Record IN AccordanceAccountsAndData Do
		VT.Clear();
		TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	
		For Each TSRow IN TSRows Do
			PayerAccount = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayerAccount");
			RecipientAccount  = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayeeAccount");
			If PayerAccount = AccountNo OR RecipientAccount = AccountNo Then
				NewRow = VT.Add();
				NewRow.OperationDate   = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Date");
				NewRow.FB             = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayKind");
				NewRow.DocumentNumber = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Number");
				PaymentOutgoing = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PaymentOutgoing");
				If PaymentOutgoing = Undefined Then
					PaymentOutgoing = (PayerAccount = AccountNo);
				EndIf;
				If PaymentOutgoing Then
					NewRow.Debit  = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
					NewRow.BIN    = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayeeBankBIC");
					CorrespondentTIN  = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayeeTIN");
					CorrespondentAccount = RecipientAccount;
					CorrespondentBank = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "RecipientBankName");
					CorrespondentDescription = GetParsedTreeStringAttributeValue(
											ParseTree, TSRow, "RecipientDescription");
				Else
					NewRow.Credit = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "Amount");
					NewRow.BIN    = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayerBankBIC");
					CorrespondentTIN  = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayerTIN");
					CorrespondentAccount = RecipientAccount;
					CorrespondentBank = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "PayerBankName");
					CorrespondentDescription = GetParsedTreeStringAttributeValue(
											ParseTree, TSRow, "PayerDescription");
				EndIf;
				NewRow.Description = "" + CorrespondentDescription + Chars.LF + "TIN " + CorrespondentTIN + Chars.LF
											+ CorrespondentAccount + Chars.LF + CorrespondentBank;
				NewRow.OperationBasis = GetParsedTreeStringAttributeValue(
					ParseTree, TSRow, "PaymentDestination");
			EndIf;
		EndDo;
		Record.Value.Insert("Turnovers", VT);
	EndDo;
	
	Stamp = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Stamp");
	
	If ValueIsFilled(Stamp) Then
		StampData = New Structure();
		BankDescription = GetParsedTreeStringAttributeValue(
						ParseTree, ObjectString, "Stamp.NameOfBank");
		StampData.Insert("BankDescription", BankDescription);
		BIN = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Stamp.BIN");
		StampData.Insert("BIN", BIN);
		BankCity = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Stamp.BankCity");
		StampData.Insert("BankCity", BankCity);
		BankCorrAccount = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Stamp.BankCorrAccount");
		StampData.Insert("BankCorrAccount", BankCorrAccount);
		Department = GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "Stamp.BankBranch");
		StampData.Insert("Department", Department);
		DataForObject.Insert("Stamp", StampData);
	EndIf;
	
	DataForObject.Insert("Header", FillingDataHeader);
	DataForObject.Insert("TurnoversOnAccounts", AccordanceAccountsAndData);
	
	Return DataForObject;
	
EndFunction

Function GetStatementInquiryDataToPrint(ObjectString, ParseTree)
	
	FillingDataHeader = New Structure;

	FillingDataHeader.Insert("StartDate", 
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "StartDate"));
	FillingDataHeader.Insert("EndDate",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "EndDate"));
		
	VT = New ValueTable;
	VT.Columns.Add("AccountNo");
			
	TSRows = ObjectString.Rows.FindRows(New Structure("Attribute", "TSRow"));
	For Each TSRow IN TSRows Do
		NewRow = VT.Add();
		NewRow.AccountNo = GetParsedTreeStringAttributeValue(ParseTree, TSRow, "AccountNo");
	EndDo;
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", FillingDataHeader);
	DataForObject.Insert("BankAccounts", VT);
		
	Return DataForObject;

	
EndFunction

Function GetReceiptDataForPrinting(ObjectString, ParseTree)
	
	FillingData = New Structure;

	FillingData.Insert("TicketSBBOL",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "TicketSBBOL"));
	FillingData.Insert("CreationDateKvitka",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CreationDateKvitka"));
	FillingData.Insert("CodeDocumentStatus",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CodeDocumentStatus"));
	FillingData.Insert("CompanyID",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "CompanyID"));
	FillingData.Insert("DocumentID",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DocumentID"));
	FillingData.Insert("DateWriteOffAccountOfPayer",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateWriteOffAccountOfPayer"));
	FillingData.Insert("PayersBankStampDate",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "PayersBankStampDate"));
	FillingData.Insert("DateOfFiling",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateOfFiling"));
	FillingData.Insert("ReceiptDateInPayersBank",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "ReceiptDateInPayersBank"));
	FillingData.Insert("DatePaymentEnums",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DatePaymentEnums"));
	FillingData.Insert("DateStampOfBeneficiarysBank",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "DateStampOfBeneficiarysBank"));
	FillingData.Insert("AuthorOfMessage",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "AuthorOfMessage"));
	FillingData.Insert("MessageFromBank",
		GetParsedTreeStringAttributeValue(ParseTree, ObjectString, "MessageFromBank"));
		
	Return FillingData;
	
EndFunction

Procedure ReadStatementXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.BankStatement;
	AddObjectHeaderAttribute(NewED, "Sender",   ED.Sender);
	AddObjectHeaderAttribute(NewED, "Recipient",    ED.Recipient);
	AddObjectHeaderAttribute(NewED, "CreationDate",  ED.CreationDate);
	AddObjectHeaderAttribute(NewED, "CreationTime", ED.CreationTime);
	If Not ED.SectionBankAcc = Undefined Then
		AddObjectHeaderAttribute(NewED, "StartDate", ED.SectionBankAcc.StartDate);
		AddObjectHeaderAttribute(NewED, "EndDate",  ED.SectionBankAcc.EndDate);
		If ED.SectionBankAcc.BankAccs.Count()>0 Then
			
			For Each BankAccAttributes IN ED.SectionBankAcc.BankAccs Do
				ListTS = New ValueList;
				AccountParameters = New Structure;
				AccountParameters.Insert("BankAcc",         BankAccAttributes.BankAcc);
				AccountParameters.Insert("OpeningBalance", BankAccAttributes.OpeningBalance);
				AccountParameters.Insert("DebitedTotal",   BankAccAttributes.DebitedTotal);
				AccountParameters.Insert("CreditedTotal",     BankAccAttributes.CreditedTotal);
				AccountParameters.Insert("ClosingBalance",  BankAccAttributes.ClosingBalance);
				FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BankAccount");
				BankAccount = ElectronicDocumentsOverridable.FindRefToObject(
								"BankAccountsOfTheCompany", BankAccAttributes.BankAcc);
				FoundString = FindCreateStringInParsedTree(
					FoundTypeInTree, BankAccAttributes.BankAcc, , BankAccount, AccountParameters, ParseTree, Error);
				ListTS.Add(FoundString.RowIndex, "BankAccount");
				AddObjectTSAttributes(NewED, "BankAccountsOfTheCompany", ListTS);
			EndDo;
		EndIf;
	EndIf;
	
	If Not ED.FilterConditions = Undefined Then
		AddObjectHeaderAttribute(NewED, "StartDate", ED.FilterConditions.StartDate);
		AddObjectHeaderAttribute(NewED, "EndDate",  ED.FilterConditions.EndDate);
	EndIf;
	
	For Each PaymentItem in ED.PaymentDocumentSection Do
		PaymentAttributes = New ValueList;
		PaymentAttributes.Add(PaymentItem.SectionDocument, "SectionDocument");
		PaymentAttributes.Add(PaymentItem.Number, "Number");
		PaymentAttributes.Add(PaymentItem.Date,  "Date");
		PaymentAttributes.Add(PaymentItem.Amount, "Amount");
		If Not PaymentItem.STATEMENT = Undefined Then
			PaymentAttributes.Add(PaymentItem.STATEMENT.StatementDate,       "StatementDate");
			PaymentAttributes.Add(PaymentItem.STATEMENT.StatementTime,      "StatementTime");
			PaymentAttributes.Add(PaymentItem.STATEMENT.StatementContent, "StatementContent");
		EndIf;
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerAccount, "PayerAccount");
		If Not PaymentItem.PayerAttributes.DateCredited = Undefined Then
			PaymentAttributes.Add(PaymentItem.PayerAttributes.DateCredited.__content, "DateCredited");
			PaymentAttributes.Add(PaymentItem.PayerAttributes.DateCredited.PaymentId, "PaymentId");
		EndIf;
		If ValueIsFilled(PaymentItem.PayerAttributes.Payer1) Then
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer1, "PayerDescription");
		Else
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer, "PayerDescription");
		EndIf;
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerBankAcc, "PayerBankAcc");
		If ValueIsFilled(PaymentItem.PayerAttributes.Payer1) Then
			PaymentAttributes.Add(True, "PayerIndirectPayments");
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer1, "PayerNameIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer2, "PayerAccountIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer3, "PayerBankNameIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.PayerAttributes.Payer4, "PayerBankCityIndirectSettlements");
		Else
			PaymentAttributes.Add(False, "PayerIndirectPayments");
		EndIf;
		
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerTIN, "PayerTIN");
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerBank1, "PayerBankName");
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerBank2, "PayerBankCity");
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerBIC, "PayerBankBIC");
		PaymentAttributes.Add(PaymentItem.PayerAttributes.PayerBalancedAccount, "PayerBankBalancedAccount");
		
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeAccount, "PayeeAccount");
		
		
		If Not PaymentItem.RecipientAttributes.Date_Received = Undefined Then
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Date_Received.__content, "Date_Received");
		EndIf;
		If ValueIsFilled(PaymentItem.RecipientAttributes.Payee1) Then
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Payee1, "RecipientDescription");
		Else
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Recipient, "RecipientDescription");
		EndIf;

		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeBankAcc, "PayeeBankAcc");
		If ValueIsFilled(PaymentItem.RecipientAttributes.Payee1) Then
			PaymentAttributes.Add(True, "RecipientIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Payee1, "RecipientNameIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Payee2, "RecipientAccountIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Payee3, "RecipientBankNameIndirectSettlements");
			PaymentAttributes.Add(PaymentItem.RecipientAttributes.Payee4, "RecipientBankCityIndirectSettlements");
		Else
			PaymentAttributes.Add(False, "RecipientIndirectSettlements");
		EndIf;
		
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeTIN, "PayeeTIN");
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeBank1, "RecipientBankName");
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeBank2, "PayeeBankCity");
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeBIK, "PayeeBankBIC");
		PaymentAttributes.Add(PaymentItem.RecipientAttributes.PayeeBalancedAccount, "RecipientBankBalancedAccount");
		
		If Not PaymentItem.PaymentAttributes = Undefined Then
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentKind,         "PaymentKind");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PayKind,          "PayKind");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.OrderOfPriority,        "OrderOfPriority");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.Code,                "Code");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination,  "PaymentDestination");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination1, "PaymentDestination1");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination2, "PaymentDestination2");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination3, "PaymentDestination3");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination4, "PaymentDestination4");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination5, "PaymentDestination5");
			PaymentAttributes.Add(PaymentItem.PaymentAttributes.PaymentDestination6, "PaymentDestination6");
		EndIf;
		
		If Not PaymentItem.PaymentsToBudget = Undefined Then
			PaymentAttributes.Add(True, "IsPaymentsToBudget");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.AuthorStatus,   "AuthorStatus");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.KBKIndicator,       "KBKIndicator");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.OKATO,               "OKTMO");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.BasisIndicator, "BasisIndicator");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.PeriodIndicator,   "PeriodIndicator");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.NumberIndicator,    "NumberIndicator");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.DateIndicator,      "DateIndicator");
			PaymentAttributes.Add(PaymentItem.PaymentsToBudget.TypeIndicator,      "TypeIndicator");
		Else
			PaymentAttributes.Add(False, "IsPaymentsToBudget");
		EndIf;
		
		If Not PaymentItem.AdditionalAttributes = Undefined Then
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.AcceptanceTerm,          "AcceptanceTerm");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.LetterOfCreditType,       "LetterOfCreditType");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.PaymentDueDate,          "PaymentDueDate");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.PaymentCondition,        "PaymentCondition");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.PaymentByRepr,       "PaymentByRepr");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.AdditionalConditions,        "AdditionalConditions");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.NumberVendorAccount, "NumberVendorAccount");
			PaymentAttributes.Add(PaymentItem.AdditionalAttributes.DocSendingDate,       "DocSendingDate");
		EndIf;
		
		AddObjectTSAttributes(NewED, "TSRow", PaymentAttributes);
	EndDo;
	
EndProcedure

Procedure ReadStatementRequestXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.QueryStatement;
	
	QueryStatement = ED.FilterConditions;
	AddObjectHeaderAttribute(NewED, "StartDate", QueryStatement.StartDate);
	AddObjectHeaderAttribute(NewED, "EndDate",  QueryStatement.EndDate);
	For Each Item in QueryStatement.BankAcc Do
		AccountAttributes = New ValueList;
		AccountAttributes.Add(Item, "AccountNo");
		AddObjectTSAttributes(NewED, "TSRow", AccountAttributes);
	EndDo;

EndProcedure

Procedure ReadPaymentOrderXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.PaymentOrder;
	
	PaymentDocument = ED.PaymentDocumentSection[0];
	
	AddObjectHeaderAttribute(NewED, "Number",          PaymentDocument.Number);
	AddObjectHeaderAttribute(NewED, "Date",           PaymentDocument.Date);
	AddObjectHeaderAttribute(NewED, "SectionDocument", PaymentDocument.SectionDocument);
	AddObjectHeaderAttribute(NewED, "Amount",          PaymentDocument.Amount);
	AddObjectHeaderAttribute(NewED, "DocumentAmount", PaymentDocument.Amount);
	AddObjectHeaderAttribute(NewED, "DocumentID", PaymentDocument.DocumentId);
	If Not PaymentDocument.PaymentsToBudget = Undefined Then
		AddObjectHeaderAttribute(NewED, "IsTaxPayment",  True);
		AddObjectHeaderAttribute(NewED, "AuthorStatus",   PaymentDocument.PaymentsToBudget.AuthorStatus);
		AddObjectHeaderAttribute(NewED, "KBKIndicator",       PaymentDocument.PaymentsToBudget.KBKIndicator);
		AddObjectHeaderAttribute(NewED, "OKTMO",               PaymentDocument.PaymentsToBudget.OKATO);
		AddObjectHeaderAttribute(NewED, "BasisIndicator", PaymentDocument.PaymentsToBudget.BasisIndicator);
		AddObjectHeaderAttribute(NewED, "PeriodIndicator",   PaymentDocument.PaymentsToBudget.PeriodIndicator);
		AddObjectHeaderAttribute(NewED, "NumberIndicator",    PaymentDocument.PaymentsToBudget.NumberIndicator);
		AddObjectHeaderAttribute(NewED, "DateIndicator",      PaymentDocument.PaymentsToBudget.DateIndicator);
		AddObjectHeaderAttribute(NewED, "TypeIndicator",      PaymentDocument.PaymentsToBudget.TypeIndicator);
	Else
		AddObjectHeaderAttribute(NewED, "IsTaxPayment",  False);
	EndIf;
	AddObjectHeaderAttribute(NewED, "PayKind",          PaymentDocument.PaymentAttributes.PayKind);
	AddObjectHeaderAttribute(NewED, "PaymentKind",         PaymentDocument.PaymentAttributes.PaymentKind);
	AddObjectHeaderAttribute(NewED, "Code",                PaymentDocument.PaymentAttributes.Code);
	AddObjectHeaderAttribute(NewED, "PaymentDestination",  PaymentDocument.PaymentAttributes.PaymentDestination);
	AddObjectHeaderAttribute(NewED, "PaymentDestination1", PaymentDocument.PaymentAttributes.PaymentDestination1);
	AddObjectHeaderAttribute(NewED, "PaymentDestination2", PaymentDocument.PaymentAttributes.PaymentDestination2);
	AddObjectHeaderAttribute(NewED, "PaymentDestination3", PaymentDocument.PaymentAttributes.PaymentDestination3);
	AddObjectHeaderAttribute(NewED, "PaymentDestination4", PaymentDocument.PaymentAttributes.PaymentDestination4);
	AddObjectHeaderAttribute(NewED, "PaymentDestination5", PaymentDocument.PaymentAttributes.PaymentDestination5);
	AddObjectHeaderAttribute(NewED, "PaymentDestination6", PaymentDocument.PaymentAttributes.PaymentDestination6);
	AddObjectHeaderAttribute(NewED, "OrderOfPriority",        PaymentDocument.PaymentAttributes.OrderOfPriority);
	PayerAttributes = PaymentDocument.PayerAttributes;
	AddObjectHeaderAttribute(NewED, "DateCredited", PayerAttributes.DateCredited);
	AddObjectHeaderAttribute(NewED, "PayerDescription", PayerAttributes.Payer1);
	If Not ValueIsFilled(PaymentDocument.PayerAttributes.Payer1) Then
		AddObjectHeaderAttribute(NewED, "PayerDescription", PayerAttributes.Payer);
	EndIf;
	AddObjectHeaderAttribute(NewED, "PayerBankBIC", PayerAttributes.PayerBIC);
	AddObjectHeaderAttribute(NewED, "PayerBankName", PayerAttributes.PayerBank1);
	AddObjectHeaderAttribute(NewED, "PayerBankCity", PayerAttributes.PayerBank2);
	AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsCity", PayerAttributes.Payer4);
	If ValueIsFilled(PaymentDocument.PayerAttributes.Payer3) Then
		AddObjectHeaderAttribute(NewED, "PayerIndirectPayments", True);
		AddObjectHeaderAttribute(NewED, "PayerBankCorrAccount",     PayerAttributes.Payer2);
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsCorrAccount", PayerAttributes.PayerBalancedAccount);
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsName", PayerAttributes.Payer3);
	Else
		AddObjectHeaderAttribute(NewED, "PayerIndirectPayments", False);
		AddObjectHeaderAttribute(NewED, "PayerBankCorrAccount",     PayerAttributes.PayerBankAcc);
	EndIf;
	AddObjectHeaderAttribute(NewED, "PayerTIN",      PayerAttributes.PayerTIN);
	AddObjectHeaderAttribute(NewED, "PayerBalancedAccount",  PayerAttributes.PayerBalancedAccount);
	AddObjectHeaderAttribute(NewED, "PayerBankAcc",     PayerAttributes.PayerAccount);
	
	RecipientAttributes = PaymentDocument.RecipientAttributes;
	AddObjectHeaderAttribute(NewED, "Date_Received", RecipientAttributes.Date_Received);
	AddObjectHeaderAttribute(NewED, "RecipientDescription", RecipientAttributes.Payee1);
	If Not ValueIsFilled(PaymentDocument.RecipientAttributes.Payee1) Then
		AddObjectHeaderAttribute(NewED, "RecipientDescription", RecipientAttributes.Recipient);
	EndIf;
	AddObjectHeaderAttribute(NewED, "PayeeBankBIC", RecipientAttributes.PayeeBIK);
	AddObjectHeaderAttribute(NewED, "RecipientBankName", RecipientAttributes.PayeeBank1);
	AddObjectHeaderAttribute(NewED, "PayeeBankCity", RecipientAttributes.PayeeBank2);
	AddObjectHeaderAttribute(NewED, "RecipientBankForSettlementsCity", RecipientAttributes.Payee4);
	If ValueIsFilled(PaymentDocument.RecipientAttributes.Payee3) Then
		AddObjectHeaderAttribute(NewED, "RecipientIndirectSettlements", True);
		AddObjectHeaderAttribute(NewED, "RecipientBankCorrAccount", RecipientAttributes.Payee2);
		AddObjectHeaderAttribute(NewED, "RecipientBankNameForSettlements", RecipientAttributes.Payee3);
		AddObjectHeaderAttribute(NewED, "RecipientBankForSettlementsBalancedAccount", RecipientAttributes.PayeeBalancedAccount);
	Else
		AddObjectHeaderAttribute(NewED, "RecipientIndirectSettlements", False);
		AddObjectHeaderAttribute(NewED, "RecipientBankCorrAccount", RecipientAttributes.PayeeBankAcc);
	EndIf;
	AddObjectHeaderAttribute(NewED, "PayeeTIN", RecipientAttributes.PayeeTIN);
	AddObjectHeaderAttribute(NewED, "PayeeBalancedAccount", RecipientAttributes.PayeeBalancedAccount);
	AddObjectHeaderAttribute(NewED, "PayeeBankAcc", RecipientAttributes.PayeeAccount);

EndProcedure

// Returns the result of successful generation of ED file Tranfer order.
//
// Parameters
//  ParametersStructure - parameters structure for generation,
//
// Returns:
//   Boolean - flag of successful generation
//
Function GeneratePaymentOrderCML(DataTree)
	
	SchemaVersion = "urn:1C.ru:ClientBankExchange";
	
	ErrorText = "";
	Try 
		
		ClientBankExchange = GetCMLObjectType("ClientBankExchange", SchemaVersion);
		FillXDTOProperty(ClientBankExchange, "FormatVersion", "1.07", True, ErrorText);
		PayerBankName = TreeAttributeValue(DataTree, "PayerAttributes.Bank.Description");
		FillXDTOProperty(ClientBankExchange, "Recipient", PayerBankName, True, ErrorText);
		FillXDTOProperty(ClientBankExchange, "Sender", "1C: Enterprise", True, ErrorText);
		FillXDTOProperty(ClientBankExchange, "CreationDate", CurrentSessionDate(), , ErrorText);
		FillXDTOProperty(ClientBankExchange, "CreationTime", CurrentSessionDate(), , ErrorText);
		
		PaymentOrderEO = GetCMLObjectType("PaymentDocument", SchemaVersion);
		DocumentId = TreeAttributeValue(DataTree, "DocumentId");
		FillXDTOProperty(PaymentOrderEO, "DocumentId", DocumentId, , ErrorText);
		
		FillXDTOProperty(PaymentOrderEO, "SectionDocument", "Payment order", True, ErrorText);
		Number = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(PaymentOrderEO, "Number", Number, True, ErrorText);
		Date = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(PaymentOrderEO, "Date", Date, True, ErrorText);
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(PaymentOrderEO, "Amount", Amount, True, ErrorText);
		
		PayerAttributes = GetCMLObjectType("PayerAttributes", SchemaVersion);
		PayerBankAcc = TreeAttributeValue(DataTree, "PayerDetails.BankAcc");
		FillXDTOProperty(PayerAttributes, "PayerAccount", PayerBankAcc, True, ErrorText);
		
		PaymentToBudget = TreeAttributeValue(DataTree, "PaymentsToBudget") = True;
		
		If PaymentToBudget Then
			FillXDTOProperty(PayerAttributes, PaymentToBudget, ErrorText);
		EndIf;
		
		PayerTIN = TreeAttributeValue(DataTree, "PayerDetails.TIN");
		FillXDTOProperty(PayerAttributes, "PayerTIN", PayerTIN, , ErrorText);
		
		PayerBank = TreeAttributeValue(DataTree, "PayerAttributes.Bank.Description");
		FillXDTOProperty(PayerAttributes, "PayerBank1", PayerBank, , ErrorText);
		PayerBankCity = TreeAttributeValue(DataTree, "PayerAttributes.Bank.City");
		FillXDTOProperty(PayerAttributes, "PayerBank2", PayerBankCity, , ErrorText);
		PayerBankBIC = TreeAttributeValue(DataTree, "PayerAttributes.Bank.BIN");
		FillXDTOProperty(PayerAttributes, "PayerBIC", PayerBankBIC, , ErrorText);
		PayerBalancedAccount = TreeAttributeValue(DataTree, "PayerAttributes.Bank.CorrAccount");
		FillXDTOProperty(PayerAttributes, "PayerBankAcc", PayerBalancedAccount, , ErrorText);
		
		PayerDesc = TreeAttributeValue(DataTree, "PayerDetails.Name");
		
		PayerIndirectPayments = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments") = True;
		
		FillXDTOProperty(PayerAttributes, "Payer1", PayerDesc, , ErrorText);
		
		If PayerIndirectPayments Then
			FillXDTOProperty(PayerAttributes, "Payer2", PayerBankAcc, , ErrorText);
			PayerBankForSettlements = TreeAttributeValue(
				DataTree, "PayerBankForIndirectSettlements.Name");
			FillXDTOProperty(PayerAttributes, "Payer3", PayerBankForSettlements, , ErrorText);
			PayerRCBankCity = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments.City");
			FillXDTOProperty(PayerAttributes, "Payer4", PayerRCBankCity, , ErrorText);
			PayerBalancedAccountRCBank = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments.CorrAccount");
			FillXDTOProperty(PayerAttributes, "PayerBalancedAccount", PayerBalancedAccountRCBank, , ErrorText);
		EndIf;
		
		FillXDTOProperty(PayerAttributes, "Payer", PayerDesc, , ErrorText);
			
		RecipientAttributes = GetCMLObjectType("RecipientAttributes", SchemaVersion);

		PayeeBankAcc = TreeAttributeValue(DataTree, "RecipientDetails.BankAcc");
		FillXDTOProperty(RecipientAttributes, "PayeeAccount", PayeeBankAcc, True, ErrorText);
		
		PayeeTIN = TreeAttributeValue(DataTree, "RecipientAttributes.TIN");
		FillXDTOProperty(RecipientAttributes, "PayeeTIN", PayeeTIN, , ErrorText);
		
		PayeeBank = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.Description");
		FillXDTOProperty(RecipientAttributes, "PayeeBank1", PayeeBank, , ErrorText);
		PayeeBankCity = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.City");
		FillXDTOProperty(RecipientAttributes, "PayeeBank2", PayeeBankCity, , ErrorText);
		PayeeBankBIC = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.BIN");
		FillXDTOProperty(RecipientAttributes, "PayeeBIK", PayeeBankBIC, , ErrorText);
		PayeeBalancedAccount = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.CorrAccount");
		FillXDTOProperty(RecipientAttributes, "PayeeBankAcc", PayeeBalancedAccount, , ErrorText);
		
		RecipientDesc = TreeAttributeValue(DataTree, "RecipientDetails.Name");
			
		RecipientIndirectSettlements = TreeAttributeValue(DataTree, "RecipientBankForIndirectCalculations") = True;
		FillXDTOProperty(RecipientAttributes, "Payee1", RecipientDesc, , ErrorText);
		
		If RecipientIndirectSettlements Then
			FillXDTOProperty(RecipientAttributes, "Payee2", PayeeBankAcc, , ErrorText);
			PayeeBankForSettlements = TreeAttributeValue(
				DataTree, "RecipientBankForIndirectSettlements.Name");
			FillXDTOProperty(RecipientAttributes, "Payee3", PayeeBankForSettlements, , ErrorText);
			PayeeRCBankCity = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.City");
			FillXDTOProperty(RecipientAttributes, "Payee4", PayeeRCBankCity, , ErrorText);
			PayeeRCBankCorrAccount = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.CorrAccount");
			FillXDTOProperty(RecipientAttributes, "PayeeBalancedAccount", PayeeRCBankCorrAccount, , ErrorText);
		EndIf;
		
		FillXDTOProperty(RecipientAttributes, "Recipient", RecipientDesc, , ErrorText);

		If PaymentToBudget Then
			
			PaymentsToBudgetCML = GetCMLObjectType("PaymentsToBudget", SchemaVersion);
			
			AuthorStatus = TreeAttributeValue(DataTree, "PaymentsToBudget.ComposerStatus");
			FillXDTOProperty(PaymentsToBudgetCML, "AuthorStatus", AuthorStatus, True, ErrorText);
			
			KBKIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.KBKIndicator");
			FillXDTOProperty(PaymentsToBudgetCML, "KBKIndicator", KBKIndicator, True, ErrorText);
			
			OKTMO = TrimAll(TreeAttributeValue(DataTree, "PaymentsToBudget.OKTMO"));
			If Not ValueIsFilled(OKTMO) OR IsBlankString(OKTMO) Then
				OKTMO = "0";
			EndIf;
			
			FillXDTOProperty(PaymentsToBudgetCML, "OKATO", OKTMO, True, ErrorText);
			
			BasisIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.BasisIndicator");
			If Not ValueIsFilled(BasisIndicator) OR IsBlankString(BasisIndicator) Then
				BasisIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "BasisIndicator", BasisIndicator, True, ErrorText);
			
			PeriodIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.PeriodIndicator");
			If Not ValueIsFilled(PeriodIndicator) OR IsBlankString(PeriodIndicator)
				OR PeriodIndicator = "  . .    " Then
				PeriodIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "PeriodIndicator", PeriodIndicator, True, ErrorText);
			
			NumberIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.NumberIndicator");
			If Not ValueIsFilled(NumberIndicator) OR IsBlankString(NumberIndicator) Then
				NumberIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "NumberIndicator", NumberIndicator, True, ErrorText);
			
			DateIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.DateIndicator");
			If Not ValueIsFilled(DateIndicator) Then
				DateIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "DateIndicator", DateIndicator, True, ErrorText);
			
			TypeIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.TypeIndicator");
			If Not ValueIsFilled(TypeIndicator) OR IsBlankString(TypeIndicator) Then
				TypeIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "TypeIndicator", TypeIndicator, True, ErrorText);
			
		EndIf;
		
		FillXDTOProperty(PaymentOrderEO, "PayerAttributes", PayerAttributes, True, ErrorText);
		FillXDTOProperty(PaymentOrderEO, "RecipientAttributes", RecipientAttributes, True, ErrorText);
		
		PaymentAttributes = GetCMLObjectType("PaymentAttributes", SchemaVersion);
		PaymentKind = TreeAttributeValue(DataTree, "PaymentDetails.PaymentKind");
		FillXDTOProperty(PaymentAttributes, "PaymentKind", PaymentKind, , ErrorText);
		PayKind = TreeAttributeValue(DataTree, "PaymentDetails.PaymentMethod");
		FillXDTOProperty(PaymentAttributes, "PayKind", PayKind, , ErrorText);
		OrderOfPriority = TreeAttributeValue(DataTree, "PaymentDetails.Sequence");
		FillXDTOProperty(PaymentAttributes, "OrderOfPriority", OrderOfPriority, , ErrorText);
		Code = TreeAttributeValue(DataTree, "PaymentAttributes.Code");
		FillXDTOProperty(PaymentAttributes, "Code", Code, , ErrorText);
		
		If PaymentToBudget AND Not ValueIsFilled(Code) Then
			FillXDTOProperty(PaymentAttributes, "Code", "0", , ErrorText);
		EndIf;
		
		PaymentDestination = TreeAttributeValue(DataTree, "PaymentDetails.PaymentDestination");
		FillXDTOProperty(PaymentAttributes, "PaymentDestination", PaymentDestination, , ErrorText);
		
		PaymentDestinationFormatted = PaymentDestinationFormatted(PaymentDestination);
		
		RowsCountNP = min(StrLineCount(PaymentDestinationFormatted), 6);
		
		For Ct = 1 To RowsCountNP Do
			CurRow = StrGetLine(PaymentDestinationFormatted, Ct);
			FillXDTOProperty(PaymentAttributes, "PaymentDestination" + Ct, CurRow, , ErrorText);
		EndDo;
			
		FillXDTOProperty(PaymentOrderEO, "PaymentAttributes", PaymentAttributes, True, ErrorText);
		
		If PaymentToBudget Then
			FillXDTOProperty(PaymentOrderEO, "PaymentsToBudget", PaymentsToBudgetCML, True, ErrorText);
		EndIf;
		
		ClientBankExchange.PaymentDocumentSection.Add(PaymentOrderEO);
		
		ClientBankExchange.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			FullFileName = TreeAttributeValue(DataTree, "FullFileName");
			ExportEDtoFile(ClientBankExchange, FullFileName, , "UTF-8");
			FileIsFormed = True;
		EndIf;

	Except
		
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		BriefErrorDescription = BriefErrorDescription(ErrorInfo());
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(
			MessagePattern, ?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription));
		Operation = NStr("en='ED formation';ru='Формирование ЭД'");
		DetailErrorDescription = DetailErrorDescription(ErrorInfo());
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
			Operation, DetailErrorDescription, MessageText, 1);
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

// To send additional data to a print form, it is required:
// 1. in the function of data preparation (within the override module) create a structure, where key - name
//  of transferred additional parameter, and value - Thus the value of additional parameter and
//  send to interface function "ElectronicDocuments.AddDataToAdditDataTree" (description of parameters in the comments to it).
// 2. in the function of data preparation for printing "GetData...ForPrinting"
//  write reading of transferred additional data by name (under which the parameter was placed to the structure at step 1) and assignment of the template to required attribute.
//
Function AdditDataTree()
	
	DataTree = New ValueTree;
	
	TypeArray = New Array;
	TypeArray.Add(Type("Structure"));
	TypeArray.Add(Type("Array"));
	TypeArray.Add(Type("String"));
	TypeStructureArrayString = New TypeDescription(TypeArray);
	
	DataTree.Columns.Add("AttributeName", New TypeDescription("String"));
	DataTree.Columns.Add("AttributeValue", TypeStructureArrayString);
	DataTree.Columns.Add("LegallyMeaningful", New TypeDescription("Boolean"));
	DataTree.Columns.Add("CWT", New TypeDescription("Boolean"));
	
	Return DataTree;
	
EndFunction

// ESF parameters structure

Function CorrESFInformationTableAboutProducts()
	
		ProductsTable = New ValueTable;
		ProductsTable.Columns.Add("LineNumber"); // Number of table row
		ProductsTable.Columns.Add("ProductsAndServicesDescription"); // Name of a product (description of works completed, services rendered), propertry right (Column 1)
		ProductsTable.Columns.Add("MeasurementUnitCodeBefore"); // (optional) Unit of measure code, before change (Column 2, row A)
		ProductsTable.Columns.Add("MeasurementUnitCode"); // (optional) Unit of measure code, after change (Column 2, row B)
		ProductsTable.Columns.Add("QuantityBefore"); //(optional) Quantity (volume), before change (Column 3, row A)
		ProductsTable.Columns.Add("Quantity"); // (optional) Quantity (volume), after change (Column 3, row B)
		ProductsTable.Columns.Add("PriceBefore"); // (optional) Quantity (volume) for UOM, before change (Column 4, row A)
		ProductsTable.Columns.Add("Price"); // (optional) Quantity (volume) for UOM, after change (Column 4, row B)
		
		//(optional) Cost of products (works, services), property rights without tax - total (Column 5)
		ProductsTable.Columns.Add("AmountNoVATBefore"); //  Amount before change (Row A)
		ProductsTable.Columns.Add("AmountWithoutVAT"); // Amount after change (Row B)
		ProductsTable.Columns.Add("AmountWithoutVATReducing"); //(optional) Cost -  increase (Row C)
		ProductsTable.Columns.Add("AmountWithoutVATIncrease"); //(optional) Cost - decrease (Row G)
		
		// Including the amount of excise duty, before change (Column 6, row A)
		ProductsTable.Columns.Add("ExciseUntil");
		ProductsTable.Columns.Add("Excise");
		
		// Tax rate, before change (Column 7, string A)
		ProductsTable.Columns.Add("VATRateBefore"); // Tax Rate - value: (row: 0, 10, 18, 20, 10/110, 18/118, without VAT)
		ProductsTable.Columns.Add("VATRateTypeBefore"); // Type of tax rate (percentage, fraction, text)
		
		// Tax rate, after change (column 7, row B)
		ProductsTable.Columns.Add("VATRate"); // Tax Rate - value: (row: 0, 10, 18, 20, 10/110, 18/118, without VAT)
		ProductsTable.Columns.Add("VATRateType"); // Type of tax rate (percentage, fraction, text)
		
		
		ProductsTable.Columns.Add("VATAmountBefore"); // VAT amount presented to the buyer, before change (Column 8)
		ProductsTable.Columns.Add("VATAmount"); // VAT amount presented to the buyer, before change (Column 8)
		
		// Tax amount, increase (decrease) (Column 8, rows C,D)
		ProductsTable.Columns.Add("VATAmountReduction");
		ProductsTable.Columns.Add("VATAmountIncrease");
		
		//Cost of products (works, services), property rights with tax - total (Column 9)
		ProductsTable.Columns.Add("AmountBefore");
		ProductsTable.Columns.Add("Amount");
		ProductsTable.Columns.Add("AmountOfReduction");
		ProductsTable.Columns.Add("AmountOfIncrease");
	
	Return ProductsTable;
	
EndFunction

Function ESFInformationTableAboutProduct()
	
	ProductsTable = New ValueTable;
	
	// Information about product (job, service)
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("LineNumber"); // Number of table row
	ProductsTable.Columns.Add("ProductsAndServicesDescription"); // Name of a product (description of works completed, services rendered), propertry right (Column 1)
	ProductsTable.Columns.Add("MeasurementUnitCode"); // (optional) Unit of measure code (Column 2)
	ProductsTable.Columns.Add("Quantity"); // (optional) Quantity (volume) (Column 3)
	ProductsTable.Columns.Add("Price"); // (optional) Price (tariff) for UOM (Column 4)
	ProductsTable.Columns.Add("AmountWithoutVAT"); // (optional) Cost of products (works, services), property rights without tax - total (Column 5)
	ProductsTable.Columns.Add("Amount"); // Cost of products (works, services), property rights with tax - total (Column 9)
	ProductsTable.Columns.Add("Excise"); // Including excise duty amount (Column 6)
	ProductsTable.Columns.Add("VATRate"); // Tax Rate - quantity
	ProductsTable.Columns.Add("VATRateType"); // Type of tax rate
	ProductsTable.Columns.Add("VATAmount"); // VAT amount shown to customer (Column 8)
	ProductsTable.Columns.Add("CountryOfOriginCode"); // (optional) Digital code of country of origin (Column 10)
	ProductsTable.Columns.Add("CustomsDeclarationNumber"); // (optional) Customs declaration number (Column 11)
	
	Return ProductsTable;
	
EndFunction

// For an internal use.
Function GetXDTOschemaFieldProperty(TargetNamespaceSchema, ObjectName, PropertyName, FacetKind) Export
	
	ReturnValue = Undefined;
	
	ObjectCML = GetCMLObjectType(ObjectName, TargetNamespaceSchema);
	
	If ObjectCML <> Undefined AND TypeOf(FacetKind) = Type("XDTOFacetType") Then
		PropertiesOfObject = ObjectCML.Properties();
		RequiredProperty = PropertiesOfObject.Get(PropertyName);
		If RequiredProperty <> Undefined Then
			Facet = RequiredProperty.Type.Facets.Get(FacetKind);
			ReturnValue = Facet.Value;
		EndIf;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Filling of parsing objects tree and tree of object matches

Procedure GenerateVTByXDTODataSet(VT, DataSet, ED, XMLObject, AdditDataTree = Undefined,
	IsPropertyIdFile = False, TSName = Undefined, LineNumber = Undefined, AdditColumnsNames = "")
	
	KS80 = New StringQualifiers(110);
	CS255 = New StringQualifiers(255);
	CS3000 = New StringQualifiers(3000);
	ArrayString = New Array;
	ArrayString.Add(Type("String"));
	TypeDescriptionWith80 = New TypeDescription(ArrayString, , KS80);
	TypeDescriptionWith255 = New TypeDescription(ArrayString, , CS255);
	TypeDescriptionWith3000 = New TypeDescription(ArrayString, , CS3000);
	ArrayEDType = New Array;
	ArrayEDType.Add(Type("CatalogRef.EDAttachedFiles"));
	ArrayEDType.Add(Type("Structure"));
	EDTypeDescription = New TypeDescription(ArrayEDType);
	
	VT = New ValueTable();
	VT.Columns.Add("ID", TypeDescriptionWith80);
	VT.Columns.Add("Description", TypeDescriptionWith255);
	VT.Columns.Add("CharacteristicDescription", TypeDescriptionWith255);
	VT.Columns.Add("ProductCode", TypeDescriptionWith255);
	VT.Columns.Add("SKU", TypeDescriptionWith255);
	VT.Columns.Add("BaseUnitCode", TypeDescriptionWith255);
	VT.Columns.Add("BaseUnitDescription", TypeDescriptionWith255);
	VT.Columns.Add("BaseUnitDescriptionFull", TypeDescriptionWith255);
	VT.Columns.Add("BaseUnitInternationalAbbreviation", TypeDescriptionWith255);
	VT.Columns.Add("Definition", TypeDescriptionWith3000);
	VT.Columns.Add("ED", EDTypeDescription);
	
	For Each CurItem IN DataSet Do
		NewRecord = VT.Add();
		NewRecord.ED = ED;
		
		Item = CurItem;
		
		If IsPropertyIdFile
			AND (ValueIsFilled(CurItem.InfFullStr) OR Not AdditDataTree = Undefined) Then
			
			If Find(CurItem.InfFullStr, "xml") = 0 Then
				CurItemProperties = CurItem.Properties();
				If CurItemProperties.Get("ItemNum") <> Undefined Then
					NumRow = String(CurItem.ItemNum);
				ElsIf CurItemProperties.Get("NumRow") <> Undefined Then
					NumRow = String(CurItem.NumRow);
				ElsIf CurItemProperties.Get("Number") <> Undefined Then
					NumRow = String(LineNumber) + "." + CurItem.Number;
				Else
					Continue;
				EndIf;
				
				// Read TS string parameters from additional data.
				ReadInfPol(CurItem.InfFullStr, AdditDataTree, TSName, NumRow);
				If AdditDataTree <> Undefined AND AdditDataTree.Rows.Count() > 0 Then
					SearchStructure = New Structure("AttributeName, AttributeValue", "List", TSName);
					TreeRows = AdditDataTree.Rows.FindRows(SearchStructure, True);
					If TreeRows.Count() > 0 Then
						SearchStructure = New Structure("AttributeName, AttributeValue", "NPP", NumRow);
						TreeRows = TreeRows[0].Rows.FindRows(SearchStructure);
						If TreeRows.Count() > 0 Then
							RowOwner = TreeRows[0];
							RowID = RowOwner.Rows.Find("ID", "AttributeName");
							StringBUDescriptionFull = RowOwner.Rows.Find("BaseUnitDescriptionFull", "AttributeName");
							RowBMUAbbr = RowOwner.Rows.Find("BaseUnitInternationalAbbreviation", "AttributeName");
							StringBUDescription = RowOwner.Rows.Find("BaseUnitDescription", "AttributeName");
							RowBUCode = RowOwner.Rows.Find("BaseUnitCode", "AttributeName");
							If RowID <> Undefined Then
								NewRecord.ID = RowID.AttributeValue;
							EndIf;
							If StringBUDescriptionFull <> Undefined Then
								NewRecord.BaseUnitDescriptionFull = StringBUDescriptionFull.AttributeValue;
							EndIf;
							If RowBMUAbbr <> Undefined Then
								NewRecord.BaseUnitInternationalAbbreviation = RowBMUAbbr.AttributeValue;
							EndIf;
							If StringBUDescription <> Undefined Then
								NewRecord.BaseUnitDescription = StringBUDescription.AttributeValue;
							EndIf;
							If RowBUCode <> Undefined Then
								NewRecord.BaseUnitCode = RowBUCode.AttributeValue;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
				
			Else
				XMLObject.SetString(CurItem.InfFullStr);
				Item = XDTOFactory.ReadXML(XMLObject);
			EndIf;
		EndIf;
		
		If Not Item.Properties().Get("ID") = Undefined Then
			NewRecord.ID = Item.ID;
		EndIf;
		If Not Item.Properties().Get("Description") = Undefined Then
			NewRecord.Description = Item.Description;
		EndIf;
		If Not CurItem.Properties().Get("WorksDesc") = Undefined Then
			NewRecord.Description = CurItem.WorksDesc;
		EndIf;
		If Not CurItem.Properties().Get("DescProd") = Undefined Then
			NewRecord.Description = CurItem.DescProd;
		EndIf;
		If Not CurItem.Properties().Get("CodeProd") = Undefined Then
			NewRecord.ProductCode = CurItem.CodeProd;
		EndIf;
		If Not CurItem.Properties().Get("CharacterTov") = Undefined Then
			NewRecord.CharacteristicDescription = CurItem.CharacterTov;
		EndIf;
		If Not CurItem.Properties().Get("OKEI_Tov") = Undefined Then
			NewRecord.BaseUnitCode = CurItem.OKEI_Tov;
		EndIf;
		If Not CurItem.Properties().Get("OKEI") = Undefined Then
			NewRecord.BaseUnitCode = CurItem.OKEI;
		EndIf;
		If Not CurItem.Properties().Get("DescUnOfMeas") = Undefined Then
			NewRecord.BaseUnitDescription = CurItem.DescUnOfMeas;
		EndIf;
		If Not Item.Properties().Get("BaseUnit") = Undefined Then
			If Not Item.BaseUnit.Properties().Get("Code") = Undefined Then
				NewRecord.BaseUnitCode = Item.BaseUnit.Code;
			EndIf;
			If Not Item.BaseUnit.Properties().Get("Description") = Undefined Then
				NewRecord.BaseUnitDescription = Item.BaseUnit.Description;
			EndIf;
			If Not Item.BaseUnit.Properties().Get("DescriptionFull") = Undefined Then
				NewRecord.BaseUnitDescriptionFull = Item.BaseUnit.DescriptionFull;
			EndIf;
			If Not Item.BaseUnit.Properties().Get("InternationalAbbreviation") = Undefined Then
				NewRecord.BaseUnitInternationalAbbreviation = Item.BaseUnit.InternationalAbbreviation;
			EndIf;
		EndIf;
		If Not Item.Properties().Get("SKU") = Undefined Then
			NewRecord.SKU = Item.SKU;
		EndIf;
		If Not Item.Properties().Get("GoodsSKU") = Undefined Then
			NewRecord.SKU = Item.GoodsSKU;
		EndIf;
		If Not Item.Properties().Get("Definition") = Undefined Then
			NewRecord.Definition = Item.Definition;
		EndIf;
		If Not Item.Properties().Get("AdditionalAttributes") = Undefined Then
			For Each DataItem in Item.AdditionalAttributes Do
				If VT.Columns.Find("add_" + DataItem.Description) = Undefined Then
					VT.Columns.Add("add_" + DataItem.Description, TypeDescriptionWith255);
					AdditColumnsNames = AdditColumnsNames + ", "+ "add_" + DataItem.Description;
				EndIf;
				For Each ValueItem in DataItem.Value Do
					NewRecord["add_" + DataItem.Description] = ValueItem;
				EndDo;
			EndDo;
		EndIf;
		
		// If empty ID arrived, then use product name instead of it.
		// Relevant for the incoming ED from accounting systems, other than 1C.
		If Not ValueIsFilled(NewRecord.ID) Then
			NewRecord.ID = Upper(StrReplace(NewRecord.Description, " ", ""))
				+ "#" + Upper(StrReplace(NewRecord.CharacteristicDescription, " ", ""))
				+ "#" + Upper(StrReplace(NewRecord.ProductCode, " ", ""))
				+ "#" + Upper(StrReplace(NewRecord.SKU, " ", ""));
		EndIf;
	EndDo;
	
EndProcedure

Procedure GenerateStructureByAdditData(Tree, AdditDataStructure)
	
	For Each TreeRow IN Tree.Rows Do
		If TreeRow.AttributeName = "Set" Then
			Structure = New Structure;
			GenerateStructureByAdditData(TreeRow, Structure);
			AdditDataStructure.Insert(TreeRow.AttributeValue, Structure);
		ElsIf TreeRow.AttributeName = "Array" Then
			AdditDataStructure.Insert(TreeRow.AttributeValue, TreeRow.Rows.UnloadColumn("AttributeValue"));
		Else
			AdditDataStructure.Insert(TreeRow.AttributeName, TreeRow.AttributeValue);
		EndIf;
	EndDo;
	
EndProcedure

// Procedure "restores" the data set in values table. If during ED generation the
// values table was placed in additional data, then at ED parsing the data set (from additional data) is converted to the values table.
//
// Parameters:
//   Tree - ValueTree - set of additional data read from ED.
//   VT - ValueTable - values table generated from data of the values tree.
//
Procedure GenerateValuesTableByAdditData(Tree, VT)
	
	For Each VTRowInTree IN Tree.Rows Do
		VTRow = Undefined;
		For Each VTCellValue IN VTRowInTree.Rows Do
			If VTRowInTree.AttributeValue = "0" Then // Row 0 of VT in the tree
				VT.Columns.Add(VTCellValue.AttributeName);
			EndIf;
			If VTRow = Undefined Then
				VTRow = VT.Add();
			EndIf;
			VTRow[VTCellValue.AttributeName] = VTCellValue.AttributeValue;
		EndDo;
	EndDo;
	
EndProcedure

Function FillHeaderByAdditData(AdditDataTree, NewED, Error)
	
	ReturnValue = False;
	
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FilterStructure = New Structure("AttributeName", "Set");
		RowsAdditData = AdditDataTree.Rows.FindRows(FilterStructure);
		For Each RowOptionalData IN RowsAdditData Do
			For Each TreeRow IN RowOptionalData.Rows Do
				If TreeRow.AttributeName = "Set" Then
					Structure = New Structure;
					GenerateStructureByAdditData(TreeRow, Structure);
					AddObjectHeaderAttribute(NewED, TreeRow.AttributeValue, Structure);
				ElsIf TreeRow.AttributeName = "Array" Then
					NewRow = Undefined;
					For Each String IN TreeRow.Rows Do
						If String.AttributeValue = "Structure" Then
							If NewRow = Undefined Then
								NewRow                   = NewED.Rows.Add();
								NewRow.Attribute          = TreeRow.AttributeValue;
								NewRow.AttributeValue = TreeRow.AttributeName;
							EndIf;
							Structure = New Structure;
							GenerateStructureByAdditData(String, Structure);
							AddObjectHeaderAttribute(NewRow, String.AttributeName, Structure);
						Else
							AddObjectHeaderAttribute(NewED, String.AttributeValue, String.Rows.UnloadColumn("AttributeValue"));
							Break;
						EndIf;
					EndDo;
				ElsIf RowOptionalData.AttributeValue = "Header" AND TreeRow.AttributeName = "List" Then
					VT = New ValueTable;
					GenerateValuesTableByAdditData(TreeRow, VT);
					AddObjectHeaderAttribute(NewED, TreeRow.AttributeValue, VT);
				Else
					AddObjectHeaderAttribute(NewED, TreeRow.AttributeName, TreeRow.AttributeValue);
				EndIf;
			EndDo;
			ReturnValue = True;
		EndDo;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function FillTSRowByAdditData(AdditDataTree, ListTS, LineNumber, TSName, Error)
	
	ReturnValue = False;
	
	If TypeOf(AdditDataTree) = Type("ValueTree") Then
		FilterStructure = New Structure("AttributeName, AttributeValue", "List", TSName);
		HeaderRowsAdditData = AdditDataTree.Rows.FindRows(FilterStructure);
		If HeaderRowsAdditData.Count() > 0 Then
			FilterStructure = New Structure("AttributeName, AttributeValue", "NPP", String(LineNumber));
			TSRowsAdditData = HeaderRowsAdditData[0].Rows.FindRows(FilterStructure);
			If TSRowsAdditData.Count() > 0 Then
				For Each TreeRow IN TSRowsAdditData[0].Rows Do
					If TreeRow.AttributeName = "Set" Then
						Structure = New Structure;
						GenerateStructureByAdditData(TreeRow, Structure);
						ListTS.Add(Structure, TreeRow.AttributeValue);
					ElsIf TreeRow.AttributeName = "Array" Then
						ListTS.Add(TreeRow.Rows.UnloadColumn("AttributeValue"), TreeRow.AttributeValue);
					ElsIf Upper(TreeRow.AttributeName) = Upper("CodeOKEI") Then
						ListTS.Add(TreeRow.AttributeValue, "OKEI_Tov");
					ElsIf Upper(TreeRow.AttributeName) = Upper("CodeOKEIBefore") Then
						ListTS.Add(TreeRow.AttributeValue, "OKEI_GoodsBefore");
					ElsIf Upper(TreeRow.AttributeName) = Upper("CodeOKEIAfter") Then
						ListTS.Add(TreeRow.AttributeValue, "OKEI_ProdAfter");	
					Else
						ListTS.Add(TreeRow.AttributeValue, TreeRow.AttributeName);
					EndIf;
				EndDo;
				ReturnValue = True;
			EndIf;
		EndIf;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function CertificateInNewFormat(FileName)
	
	XMLReader = New XMLReader;
	XMLReader.OpenFile(FileName);
	While XMLReader.Read() Do
		If XMLReader.NodeType = XMLNodeType.StartElement AND XMLReader.LocalName = "Document" Then
			While XMLReader.NextAttribute() Do
				If XMLReader.LocalName = "TempDoc" Then
					If StrLen(XMLReader.Value) = 8 Then   // for example, 12.45.55
						XMLReader.Close();
						Return False;
					EndIf;
				EndIf;
			EndDo;
		EndIf
	EndDo;
	
	XMLReader.Close();
	
	Return True;
	
EndFunction

// Parsing of xml-file/row

Function RecursivelyParseAdditFile(ParsedObject, AdditDataTree, LegallyMeaningful = False)
	
	For Each Attribute IN ParsedObject.Attribute Do
		FilterStructure = New Structure("AttributeName, AttributeValue", Attribute.Name, Attribute.Value);
		VTRows = AdditDataTree.Rows.FindRows(FilterStructure, True);
		If VTRows.Count() <> 0 Then
			StrTree = VTRows[0];
		Else
			StrTree = AdditDataTree.Rows.Add();
			StrTree.AttributeName = Attribute.Name;
			StrTree.AttributeValue = Attribute.Value;
			StrTree.LegallyMeaningful = LegallyMeaningful;
		EndIf;
		If Attribute.Attribute <> Undefined Then
			RecursivelyParseAdditFile(Attribute, StrTree, LegallyMeaningful);
		EndIf;
	EndDo;
	
EndFunction

// Universal additional file is a tree with unlimited level of attachments. Each tree item
// has attributes (Name, Value) and subordinate items (branches) with the same content as in the current item.
//
// Parameters:
//  AdditFile - String - full path to the file.
//
// Returns - Undefined or ValuesTree.
//
Function ParseUniversalAdditFile(AdditFile)
	
	AdditDataTree = AdditDataTree();
	XMLObject = New XMLReader;
		
	Try
		XMLObject.OpenFile(AdditFile);
		ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("AdditFile", "AdditFileUniversal"));
		XMLObject.Close();
		If ED.Data <> Undefined Then
			RecursivelyParseAdditFile(ED.Data, AdditDataTree);
		EndIf;
	Except
		AdditDataTree = Undefined;
		XMLObject.Close();
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			AdditFile, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
	Return AdditDataTree;
	
EndFunction

Procedure ReadInfPol(Val XMLString, AdditDataTree, DataSetName, LineNumber = Undefined)
	
	// Tag <Data> - mandatory for xml string in the format of universal additional file.
	If Find(XMLString, "<Data>") > 0 Then
		XMLString = "<AdditFile FileID=""1"" AdditFileId=""1"" FormatVersion=""1"" GeneratingDate=""2000-01-01T00:00:00"" xmlns=""AdditFileUniversal"">"
			+ XMLString + "</AdditFile>";
			
		TreeCreatedEarlier = True;
		If TypeOf(AdditDataTree) <> Type("ValueTree") Then
			AdditDataTree = AdditDataTree();
			TreeCreatedEarlier = False;
		EndIf;
		XMLObject = New XMLReader;
		
		Try
			XMLObject.SetString(XMLString);
			ED = XDTOFactory.ReadXML(XMLObject, GetCMLValueType("AdditFile", "AdditFileUniversal"));
			XMLObject.Close();
			If ED.Data <> Undefined Then
				VTRow = AdditDataTree.Rows.Find(DataSetName, "AttributeValue");
				If VTRow = Undefined Then
					VTRow = AdditDataTree.Rows.Add();
					VTRow.AttributeValue = DataSetName;
					If LineNumber = Undefined Then
						VTRow.AttributeName = "Set";
					Else
						VTRow.AttributeName = "List";
					EndIf;
				EndIf;
				If LineNumber <> Undefined Then
					VTRows = VTRow.Rows.FindRows(New Structure("AttributeName, AttributeValue", "NPP", String(LineNumber)));
					If VTRows.Count() > 0 Then
						VTRow = VTRows[0];
					Else
						VTRow = VTRow.Rows.Add();
						VTRow.AttributeName = "NPP";
						VTRow.AttributeValue = String(LineNumber);
					EndIf;
				EndIf;
				RecursivelyParseAdditFile(ED.Data, VTRow, True);
			EndIf;
		Except
			If Not TreeCreatedEarlier Then
				AdditDataTree = Undefined;
			EndIf;
			XMLObject.Close();
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(
				NStr("en='Error occurred when reading the data from additional data string. (%1)';ru='Возникла ошибка при чтении данных из строки доп.данных. (%1)'"), ErrorDescription());
			CommonUseClientServer.MessageToUser(MessageText);
		EndTry;
	EndIf;
	
EndProcedure

// Parsing of additional data tree for print forms

Function GenerateStringsAdditData(AdditDataTree, ReadTableName, ReturnTable)
	
	ReturnStructure = New Structure("ThereAreSigned, ThereAreUnsigned", False, False);
	
	If AdditDataTree <> Undefined Then
		SearchStructure = New Structure("AttributeName, AttributeValue", "List", ReadTableName);
		ListRows = AdditDataTree.Rows.FindRows(SearchStructure, True);
		If ListRows.Count() > 0 Then
			
			AdditDataTable = New ValueTable;
			AdditDataTable.Columns.Add("NPP");
			AdditDataTable.Columns.Add("AttributeName");
			AdditDataTable.Columns.Add("AttributeValue");
			AdditDataTable.Columns.Add("LegallyMeaningful");
			
			For Each ListRow IN ListRows[0].Rows Do
				AdditDataTable.Clear();
				ReadTreeRowsRecursively(ListRow.Rows, AdditDataTable);
				
				If AdditDataTable.Count() > 0 Then
					For Each VTRow IN AdditDataTable Do
						VTRow.NPP = AdditDataTable.IndexOf(VTRow) + 1;
					EndDo;
					AdditDataTable.Sort("LegallyValid, NPP");
					StringVTReturn = ReturnTable.Add();
					StringVTReturn.NumberStr = ListRow.AttributeValue;
					For Each VTRow IN AdditDataTable Do
						If VTRow.LegallyMeaningful Then
							ReturnStructure.AreDigitallySigned = True;
							StringVTReturn.DigitallySignedData = ?(ValueIsFilled(StringVTReturn.DigitallySignedData),
								StringVTReturn.DigitallySignedData + Chars.LF, "") + VTRow.AttributeName + " = " + VTRow.AttributeValue;
						Else
							ReturnStructure.AreNotDigitallySigned = True;
							StringVTReturn.UnDigitallySignedData = ?(ValueIsFilled(StringVTReturn.UnDigitallySignedData),
								StringVTReturn.UnDigitallySignedData + Chars.LF, "") + VTRow.AttributeName + " = " + VTRow.AttributeValue;
						EndIf;
					EndDo;
				EndIf;
			EndDo;
		EndIf;
	EndIf;
	
	Return ReturnStructure;
	
EndFunction

Procedure ReadTreeRowsRecursively(TreeRows, AdditDataTable, ParentName = "")
	
	For Each TreeRow IN TreeRows Do
		If TreeRow.AttributeName = "Set" OR TreeRow.AttributeName = "Array" 
			OR TreeRow.AttributeName = "List" OR TreeRow.AttributeName = "NPP"
			OR TreeRow.AttributeValue = "Structure" Then
			
			ParentName = ParentName + TreeRow.AttributeValue;
			ReadTreeRowsRecursively(TreeRow.Rows, AdditDataTable, ParentName);
		Else
			VTRow = AdditDataTable.Add();
			FillPropertyValues(VTRow, TreeRow);
		EndIf;
	EndDo;
	
EndProcedure

Procedure FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument)
	
	If AdditDataTree <> Undefined Then
		SearchStructure = New Structure("AttributeName, AttributeValue", "Set", "Header");
		HeaderRows = AdditDataTree.Rows.FindRows(SearchStructure, True);
		If HeaderRows.Count() > 0 Then
			
			AdditDataTable = New ValueTable;
			AdditDataTable.Columns.Add("AttributeName");
			AdditDataTable.Columns.Add("AttributeValue");
			AdditDataTable.Columns.Add("LegallyMeaningful");
			
			ReadTreeRowsRecursively(HeaderRows, AdditDataTable);
			
			If AdditDataTable.Count() > 0 Then
				TemplateArea = Template.GetArea("AdditionalHeaderData_Header");
				SpreadsheetDocument.Put(TemplateArea);
				
				TemplateAreaWithES = Template.GetArea("HeaderAdditData_Row");
				TemplateAreaWithoutES = Template.GetArea("HeaderAdditData_RowWithoutEDS");
				AdditDataTable.Columns.Add("NPP");
				For Each VTRow IN AdditDataTable Do
					VTRow.NPP = AdditDataTable.IndexOf(VTRow) + 1;
				EndDo;
				AdditDataTable.Sort("LegallyValid, NPP");
				For Each VTRow IN AdditDataTable Do
					TemplateArea = ?(VTRow.LegallyMeaningful, TemplateAreaWithES, TemplateAreaWithoutES);
					TemplateArea.Parameters.Fill(VTRow);
					SpreadsheetDocument.Put(TemplateArea);
				EndDo;
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Work with documents bases

// For internal use only
Function GetBasisDocument(FileDescription, AddSearchParameters)
	
	BasisDocument = Undefined;
	
	If Not ValueIsFilled(FileDescription) Then
		Return Undefined;
	EndIf;
	
	Query = New Query;
	
	Text =
	"SELECT ALLOWED TOP 1
	|	EDAttachedFiles.FileOwner AS Ref
	|FROM
	|	Catalog.EDAttachedFiles AS EDAttachedFiles
	|WHERE
	|	EDAttachedFiles.FileDescription LIKE &Description
	|
	|SELECT ALLOWED TOP 1
	|	EDAttachedFiles.FileOwner AS Ref
	|FROM
	|	Catalog.EDAttachedFiles AS EDAttachedFiles
	|WHERE
	|	EDAttachedFiles.FileDescription LIKE &Description
	|
	|";
	Query.SetParameter("Description", FileDescription + "%");
	For Each Item IN AddSearchParameters Do
		Text = Text + StrReplace("	And EDAttachedFiles.%1 = &%1", "%1", Item.Key);
		Query.SetParameter(Item.Key,  Item.Value);
	EndDo;
	Query.Text = Text;
	
	Result = Query.Execute();
	If Not Result.IsEmpty() Then
		Selection = Result.Select();
		Selection.Next();
		BasisDocument = Selection.Ref;
	EndIf;
	
	Return BasisDocument;
	
EndFunction

// For internal use only
Function GetBasisDocumentsParameters(BasisDocuments)
	
	BasisDocumentsParametersTable = New ValueTable;
	
	Query = New Query;
	Query.Text =
	"SELECT ALLOWED
	|	CASE
	|		WHEN Not EDAttachedFiles.ElectronicDocumentOwner = VALUE(Catalog.EDAttachedFiles.EmptyRef)
	|			THEN EDAttachedFiles.ElectronicDocumentOwner.FileDescription
	|		ELSE EDAttachedFiles.FileDescription
	|	END AS Description,
	|	CASE
	|		WHEN Not EDAttachedFiles.ElectronicDocumentOwner = VALUE(Catalog.EDAttachedFiles.EmptyRef)
	|			THEN EDAttachedFiles.ElectronicDocumentOwner.EDKind
	|		ELSE EDAttachedFiles.EDKind
	|	END AS EDKind,
	|	CASE
	|		WHEN Not EDAttachedFiles.ElectronicDocumentOwner = VALUE(Catalog.EDAttachedFiles.EmptyRef)
	|			THEN EDAttachedFiles.ElectronicDocumentOwner.SenderDocumentNumber
	|		ELSE EDAttachedFiles.SenderDocumentNumber
	|	END AS SenderDocumentNumber,
	|	CASE
	|		WHEN Not EDAttachedFiles.ElectronicDocumentOwner = VALUE(Catalog.EDAttachedFiles.EmptyRef)
	|			THEN EDAttachedFiles.ElectronicDocumentOwner.SenderDocumentDate
	|		ELSE EDAttachedFiles.SenderDocumentDate
	|	END AS SenderDocumentDate
	|FROM
	|	InformationRegister.EDStates AS EDStates
	|		LEFT JOIN Catalog.EDAttachedFiles AS EDAttachedFiles
	|		ON EDStates.ElectronicDocument = EDAttachedFiles.Ref
	|WHERE
	|	EDAttachedFiles.FileOwner IN(&FileOwner)
	|	AND (EDAttachedFiles.VersionPointTypeED = VALUE(Enum.EDVersionElementTypes.PrimaryED)
	|			OR EDAttachedFiles.VersionPointTypeED = VALUE(Enum.EDVersionElementTypes.ESF))";
	
	Query.SetParameter("FileOwner", BasisDocuments);
	
	Result = Query.Execute();
	If Not Result.IsEmpty() Then
		BasisDocumentsParametersTable = Result.Unload();
	EndIf;
	
	Return BasisDocumentsParametersTable;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Types of objects

// Receives the name of catalog owner SupplierProductsAndServices.
//
// Returns:
//  CatalogName - String name of owner.
//
Function GetSupplierProductsAndServicesOwnerAttributeName()
	
	OwnerAttributeName = Undefined;
	ElectronicDocumentsOverridable.DetermineSuppliersProductsAndServicesOwnerAttributeName(OwnerAttributeName);
	
	If OwnerAttributeName = Undefined Then // match is not specified
		MessageText = NStr("en='In the applied solution code it is necessary to specify the attribute name for the owner of the suppliers items.';ru='В коде прикладного решения необходимо указать имя реквизита для владельца номенклатуры поставщиков.'");
		ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText,
			2, EventLogLevel.Warning);
		OwnerAttributeName = "";
	EndIf;
	
	Return OwnerAttributeName;
	
EndFunction

// Determines whether the Parameter is a reference to ProductsAndServices
//
// Parameters:
//  ObjectReference - any object.
//
// Returns:
//  Boolean - True if this is a reference to catalog item Products And Services OR SuppliersProductsAndServices
//
Function IsProductsAndServices(ObjectReference)
	
	Result = False;
	
	Result = TypeOf(ObjectReference) = Type(DetermineObjectType("ProductsAndServices"));
	If Not Result AND DetermineObjectType("SuppliersProductsAndServices") <> Undefined Then
		Result = TypeOf(ObjectReference) = Type(DetermineObjectType("SuppliersProductsAndServices"));
	EndIf;
	
	Return Result;
	
EndFunction

// Specifies the type of an object by text view.
//
// Parameters:
//  ObjectTypeDescription - String, textual representation of object type.
//
Function DetermineObjectType(ObjectTypeDescription)
	
	ObjectType = Undefined;
	
	AppliedCatalogName = ElectronicDocumentsReUse.GetAppliedCatalogName(ObjectTypeDescription);
	If ValueIsFilled(AppliedCatalogName) Then
		ObjectType = "CatalogRef." + AppliedCatalogName;
	EndIf;
	
	Return ObjectType;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Sberbank

Procedure ReadExtractSberbankXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.BankStatement;
		
	AddObjectHeaderAttribute(NewED, "CompanyDescription",                     ED.orgName);
	AddObjectHeaderAttribute(NewED, "StatementCompletionDate",                      ED.stmtDateTime);
	AddObjectHeaderAttribute(NewED, "BIN",                                         ED.bic);
	AddObjectHeaderAttribute(NewED, "DateOfLastOperations",                       ED.lastMovetDate);
	AddObjectHeaderAttribute(NewED, "BankAcc",                                    ED.Acc);
	AddObjectHeaderAttribute(NewED, "OpeningBalance",                            ED.enterBal);
	AddObjectHeaderAttribute(NewED, "ClosingBalance",                             ED.outBal);
	AddObjectHeaderAttribute(NewED, "StartDate",                                  ED.beginDate);
	AddObjectHeaderAttribute(NewED, "EndDate",                                   ED.endDate);
	AddObjectHeaderAttribute(NewED, "CreditedTotal",                                ED.debetSum);
	AddObjectHeaderAttribute(NewED, "DebitedTotal",                              ED.creditSum);
	AddObjectHeaderAttribute(NewED, "DateOfPreviousOperations",                      ED.DatePLast);
	AddObjectHeaderAttribute(NewED, "RateAtBeginningOfPeriod",                         ED.rateIn);
	AddObjectHeaderAttribute(NewED, "RateAtEndOfPeriod",                          ED.rateOut);
	AddObjectHeaderAttribute(NewED, "AnIncomingBalanceInNationalCurrency",          ED.enterBalNat);
	AddObjectHeaderAttribute(NewED, "OutgoingBalanceInNationalCurrency",         ED.outBalNat);
	AddObjectHeaderAttribute(NewED, "PlannedOutgoingBalance",                    ED.planOutBal);
	AddObjectHeaderAttribute(NewED, "WellPlannedOutgoingBalanceInNationalCurrency", ED.planOutBalNat);
	AddObjectHeaderAttribute(NewED, "TypeQueryStatements",                           ED.stmtType);
	AddObjectHeaderAttribute(NewED, "DocumentNumber",                              ED.docNum);
	AddObjectHeaderAttribute(NewED, "UserAccount",                               ED.accountName);
	AddObjectHeaderAttribute(NewED, "DebitInNationalCurrency",                    ED.debetSumNat);
	AddObjectHeaderAttribute(NewED, "CreditInNationalCurrency",                   ED.creditSumNat);
	AddObjectHeaderAttribute(NewED, "Performer",                                 ED.author);
	AddObjectHeaderAttribute(NewED, "AddInformation",                               ED.docComment);
	AddObjectHeaderAttribute(NewED, "ExtractsStatements",                        ED.docId);
	
	ListTS = New ValueList;
	AccountParameters = New Structure;
	AccountParameters.Insert("BankAcc", ED.Acc);
	AccountParameters.Insert("OpeningBalance", ED.enterBal);
	AccountParameters.Insert("DebitedTotal",   ED.creditSum);
	AccountParameters.Insert("CreditedTotal",     ED.debetSum);
	AccountParameters.Insert("ClosingBalance",  ED.outBal);
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BankAccount");
	BankAccount = ElectronicDocumentsOverridable.FindRefToObject(
										"BankAccountsOfTheCompany", ED.Acc);
	FoundString = FindCreateStringInParsedTree(
		FoundTypeInTree, ED.Acc, , BankAccount, AccountParameters, ParseTree, Error);
	ListTS.Add(FoundString.RowIndex, "BankAccount");
	AddObjectTSAttributes(NewED, "BankAccountsOfTheCompany", ListTS);
	
	If Not ED.Docs = Undefined Then
		For Each Document in ED.Docs.TransInfo Do
			DocumentAttributes = New ValueList;
			DocumentAttributes.Add(Document.chargeOffDate,    "DateWriteOff");
			DocumentAttributes.Add(Document.dpp,              "DateEnums");
			DocumentAttributes.Add(Document.fileDate,         "DateOfFiling");
			DocumentAttributes.Add(Document.recDate,          "DateStampOfBeneficiarysBank");
			DocumentAttributes.Add(Document.receiptDate,      "ReceiptDateInPayersBank");
			DocumentAttributes.Add(Document.signDate,         "PayersBankStampDate");
			DocumentAttributes.Add(Document.bankNumDoc,       "Number");
			DocumentAttributes.Add(Document.branchCode,       "DepartmentCode");
			DocumentAttributes.Add(Document.carryDate,        "DateCredited");
			DocumentAttributes.Add(Document.dc,               "ApplicationSign");
			DocumentAttributes.Add(Document.docCurr,          "PaymentCurrency");
			DocumentAttributes.Add(Document.docDate,          "Date");
			DocumentAttributes.Add(Document.docNum,           "NumberOfAccountsDocument");
			DocumentAttributes.Add(Document.docSum,           "Amount");
			DocumentAttributes.Add(Document.docSumNat,        "DocumentAmountInNationalCurrency");
			DocumentAttributes.Add(Document.paymentOrder,     "OrderOfPriority");
			DocumentAttributes.Add(Document.paytKind,         "PaymentKind");
			DocumentAttributes.Add(Document.purpose,          "PaymentDestination");
			DocumentAttributes.Add(Document.transKind,        "PayKind");
			DocumentAttributes.Add(Document.urgentSBRF,       "AddService");
			DocumentAttributes.Add(Document.docId,            "DocumentID");
			DocumentAttributes.Add(Document.payeeName,        "Recipient");
			DocumentAttributes.Add(Document.payeeAcc,         "PayeeAccount");
			DocumentAttributes.Add(Document.payeeTIN,         "PayeeTIN");
			DocumentAttributes.Add(Document.payeeBankBic,     "PayeeBankBIC");
			DocumentAttributes.Add(Document.payeeBankCorrAcc, "PayeeBankAcc");
			DocumentAttributes.Add(Document.payeeBankName,    "RecipientBankName");
			DocumentAttributes.Add(Document.payerName,        "PayerDescription");

			DocumentAttributes.Add(Document.payerAcc,         "PayerAccount");
			DocumentAttributes.Add(Document.payerTIN,         "PayerTIN");
			DocumentAttributes.Add(Document.payerBankBic,     "PayerBankBIC");
			DocumentAttributes.Add(Document.payerBankCorrAcc, "PayerBankAcc");
			DocumentAttributes.Add(Document.payerBankName,    "PayerBankName");
			DocumentAttributes.Add(Document.s_TI,             "Revaluation");
			DocumentAttributes.Add(Document.Info,             "AdditionalInformation");

			If Not Document.DepartmentalInfo = Undefined Then
				DocumentAttributes.Add(True, "IsTaxPayment");
				DocumentAttributes.Add(Document.DepartmentalInfo.cbc,          "KBKIndicator");
				DocumentAttributes.Add(Document.DepartmentalInfo.docDate,      "DateIndicator");
				DocumentAttributes.Add(Document.DepartmentalInfo.docNo,        "NumberIndicator");
				DocumentAttributes.Add(Document.DepartmentalInfo.drawerStatus, "AuthorStatus");
				DocumentAttributes.Add(Document.DepartmentalInfo.paytReason,   "BasisIndicator");
				DocumentAttributes.Add(Document.DepartmentalInfo.taxPaytKind,  "TypeIndicator");
				DocumentAttributes.Add(Document.DepartmentalInfo.taxPeriod,    "PeriodIndicator");
			Else
				DocumentAttributes.Add(False, "IsTaxPayment");
			EndIf;
			If Not Document.DiffDoc = Undefined Then
				DocumentAttributes.Add(True, "IsFileCabinet");
				DocumentAttributes.Add(Document.DiffDoc.docDateCard,              "DocSendingDate");
				DocumentAttributes.Add(Document.DiffDoc.docNumberCard,            "NumberDocumentFile");
				DocumentAttributes.Add(Document.DiffDoc.docShifr,                 "CodeDocumentFileCabinet");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditAcceptDate, "AcceptanceTerm");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditAddCond,    "AdditionalConditions");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditDemandDocs, "PaymentByRepr");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditPayAcc,     "NumberVendorAccount");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditPaymCond,   "Condition1");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditPeriodVal,  "PaymentDueDate");
				DocumentAttributes.Add(Document.DiffDoc.letterOfCreditType,       "LetterOfCreditType");
				DocumentAttributes.Add(Document.DiffDoc.NumPaymentCard,           "NumberOfPayment");
				DocumentAttributes.Add(Document.DiffDoc.OperContent,              "ContentOperations");
				DocumentAttributes.Add(Document.DiffDoc.PayingCondition,          "PaymentCondition");
				DocumentAttributes.Add(Document.DiffDoc.SumRestCard,              "AmountOfBalanceOfPayment");
			Else
				DocumentAttributes.Add(False, "IsFileCabinet");
			EndIf;
			AddObjectTSAttributes(NewED, "TSRow", DocumentAttributes);
		EndDo
	EndIf;
	
	If Not ED.InfoForStamp = Undefined Then
		AddObjectHeaderAttribute(NewED, "NameOfBank", ED.InfoForStamp.BankName);
		AddObjectHeaderAttribute(NewED, "Department",     ED.InfoForStamp.BranchName);
		AddObjectHeaderAttribute(NewED, "Office",          ED.InfoForStamp.SubBranchName);
		AddObjectHeaderAttribute(NewED, "Branch",        ED.InfoForStamp.SubBranchNum);
	EndIf;
		
EndProcedure

Procedure ReadPaymentOrderSberbankXDTO(ED, ParseTree, NewED, Error)
	
		NewED.EDKind = Enums.EDKinds.PaymentOrder;
		NewED.DescriptionOfType = "Sberbank";
		
		AddObjectHeaderAttribute(NewED, "Number", ED.AccDoc.AccDocNo);
		AddObjectHeaderAttribute(NewED, "Date", ED.AccDoc.docDate);
		AddObjectHeaderAttribute(NewED, "PaymentKind",            ED.AccDoc.paytKind);
		AddObjectHeaderAttribute(NewED, "DateOfDocumentCreation", ED.AccDoc.docDate);
		AddObjectHeaderAttribute(NewED, "OperationKind",           ED.AccDoc.TransKind);
		AddObjectHeaderAttribute(NewED, "AdditionalService",  ED.AccDoc.urgentSBRF);
		
		If Not ED.Credit = Undefined Then
			AddObjectHeaderAttribute(NewED, "TargetAssignment",                ED.Credit.flagTargetAssignment);
			AddObjectHeaderAttribute(NewED, "UseYourOwnTools", ED.Credit.flagUseOwnMeans);
			If Not ED.Credit.Properties().Get("CredConNum") = Undefined Then
				AddObjectHeaderAttribute(NewED, "NumberOfCreditAgreement",     ED.Credit.CredConNum);
			EndIf;
		EndIf;
		
		If Not ED.AccDoc.Properties().Get("CodeVO") = Undefined Then
			AddObjectHeaderAttribute(NewED, "CodeTypeOfCurrencyOperations", ED.AccDoc.CodeVO);
		EndIf;
		
		If Not ED.DepartmentalInfo = Undefined Then
			AddObjectHeaderAttribute(NewED, "PaymentsToBudget", True);
			AddObjectHeaderAttribute(NewED, "AuthorStatus", ED.DepartmentalInfo.drawerStatus);
			AddObjectHeaderAttribute(NewED, "KBKIndicator", ED.DepartmentalInfo.cbc);
			AddObjectHeaderAttribute(NewED, "OKTMO", ED.DepartmentalInfo.okato);
			AddObjectHeaderAttribute(NewED, "BasisIndicator", ED.DepartmentalInfo.paytReason);
			AddObjectHeaderAttribute(NewED, "PeriodIndicator", ED.DepartmentalInfo.taxPeriod);
			AddObjectHeaderAttribute(NewED, "NumberIndicator", ED.DepartmentalInfo.docNo);
			AddObjectHeaderAttribute(NewED, "DateIndicator", ED.DepartmentalInfo.docDate);
			AddObjectHeaderAttribute(NewED, "TypeIndicator", ED.DepartmentalInfo.taxPaytKind);
		EndIf;
		
		AddObjectHeaderAttribute(NewED, "PayerIndirectPayments", False);
		AddObjectHeaderAttribute(NewED, "PayerTIN", ED.Payer.tin);
		AddObjectHeaderAttribute(NewED, "Amount", ED.AccDoc.docSum);
		AddObjectHeaderAttribute(NewED, "PayerDescription", ED.Payer.Name);
		AddObjectHeaderAttribute(NewED, "PayerBankAcc", ED.Payer.PersonalAcc);
		AddObjectHeaderAttribute(NewED, "PayerBankName", ED.Payer.Bank.Name);
		SettlementPayerBank = "";
		If Not ED.Payer.Bank.Properties().Get("BankCity")=Undefined Then
			SettlementPayerBank = ED.Payer.Bank.BankCity;
			AddObjectHeaderAttribute(NewED, "SettlementPayerBank", SettlementPayerBank);
		EndIf;
		TypeLocalityOfBankOfPayer = "";
		If Not ED.Payer.Bank.Properties().Get("SettlementType")=Undefined Then
			TypeLocalityOfBankOfPayer = ED.Payer.Bank.SettlementType;
			AddObjectHeaderAttribute(NewED, "TypeLocalityOfBankOfPayer", TypeLocalityOfBankOfPayer);
		EndIf;
		AddObjectHeaderAttribute(
			NewED, "PayerBankCity", TypeLocalityOfBankOfPayer + " " + SettlementPayerBank);
		AddObjectHeaderAttribute(NewED, "PayerBankBIC", ED.Payer.Bank.bic);
		AddObjectHeaderAttribute(NewED, "PayerBankCorrAccount", ED.Payer.Bank.correspAcc);
		If Not ED.Payer.Properties().Get("Filial") = Undefined Then
			AddObjectHeaderAttribute(NewED, "PayersBankBranch", ED.Payer.Filial);
		EndIf;
		AddObjectHeaderAttribute(NewED, "RecipientBankName", ED.Payee.Bank.Name);
		SettlementRecipientBank = "";
		If Not ED.Payee.Bank.Properties().Get("BankCity") = Undefined Then
			SettlementRecipientBank = ED.Payee.Bank.BankCity;
			AddObjectHeaderAttribute(NewED, "SettlementRecipientBank", SettlementRecipientBank);
		EndIf;
		TypeLocalityOfBeneficiarysBank = "";
		If Not ED.Payee.Bank.Properties().Get("SettlementType") = Undefined Then
			TypeLocalityOfBeneficiarysBank = ED.Payee.Bank.SettlementType;
			AddObjectHeaderAttribute(NewED, "TypeLocalityOfBeneficiarysBank", TypeLocalityOfBeneficiarysBank);
		EndIf;
		AddObjectHeaderAttribute(
			NewED, "PayeeBankCity", TypeLocalityOfBeneficiarysBank + " " + SettlementRecipientBank);
			
		If Not ED.Payee.Properties().Get("Filial") = Undefined Then
			AddObjectHeaderAttribute(NewED, "BranchOfBankOfBeneficiary", ED.Payee.Filial);
		EndIf;
		
		AddObjectHeaderAttribute(NewED, "RecipientIndirectSettlements", False);
		AddObjectHeaderAttribute(NewED, "PayeeBankBIC", ED.Payee.Bank.bic);
		AddObjectHeaderAttribute(NewED, "RecipientBankCorrAccount", ED.Payee.Bank.correspAcc);
		AddObjectHeaderAttribute(NewED, "PayeeTIN", ED.Payee.tin);
		AddObjectHeaderAttribute(NewED, "PayeeBankAcc", ED.Payee.PersonalAcc);
		AddObjectHeaderAttribute(NewED, "RecipientDescription", ED.Payee.Name);
		AddObjectHeaderAttribute(NewED, "OrderOfPriority", ED.AccDoc.priority);
		AddObjectHeaderAttribute(NewED, "PaymentDestination", ED.AccDoc.purpose);
		AddObjectHeaderAttribute(NewED, "DocumentID", ED.docExtId);
		
EndProcedure

Procedure ReadQueryStatementSberbankXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.QueryStatement;
	
	AddObjectHeaderAttribute(NewED, "DocumentID",           ED.docExtId);
	AddObjectHeaderAttribute(NewED, "DateOfQueryCreation",              ED.createTime);
	AddObjectHeaderAttribute(NewED, "StartDate",                       ED.beginDate);
	AddObjectHeaderAttribute(NewED, "EndDate",                        ED.endDate);
	AddObjectHeaderAttribute(NewED, "TypeQuery",                       ED.stmtType);
	AddObjectHeaderAttribute(NewED, "DescriptionCompanyForPayment", ED.orgName);
	For Each Item in ED.Accounts.Account Do
		AccountAttributes = New ValueList;
		AccountAttributes.Add(Item.bic,       "BIN");
		AccountAttributes.Add(Item.__content, "AccountNo");
		AddObjectTSAttributes(NewED, "TSRow", AccountAttributes);
	EndDo;
			
EndProcedure

Function InformationAboutBankLocation(ParsingString)

	ReturnStructure = New Structure("SettlementType, SettlementName");
	SpacePos = Find(ParsingString, " ");
	If SpacePos > 0 Then
		ReturnStructure.TypeLocality = StrReplace(Mid(ParsingString, 1, SpacePos - 1), ".", "");
		If SpacePos < StrLen(ParsingString) Then
			ReturnStructure.SettlementName = Mid(ParsingString, SpacePos + 1);
		EndIf
	EndIf;
	Return ReturnStructure;
	
EndFunction

Function GeneratePaymentOrderSberbankCML(DataTree)
		
	TargetNamespace = "http://www.bssys.com/en/";
	ErrorText = "";
	
	Try

		FullFileName = TreeAttributeValue(DataTree, "FullFileName");
		FileOnDrive = New File(FullFileName);
		PayDocRu = GetCMLObjectType("PayDocRu",TargetNamespace);
		DocumentID = TreeAttributeValue(DataTree, "DocumentId");
		FillXDTOProperty(PayDocRu, "docExtId", DocumentID, True, ErrorText);
		AccDoc = GetCMLObjectType("PayDocRu.AccDoc",TargetNamespace);

		PaymentDestination = TreeAttributeValue(DataTree, "PaymentDetails.PaymentDestination");
		FillXDTOProperty(AccDoc, "purpose", PaymentDestination, True, ErrorText);
		Number = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(AccDoc, "accDocNo", Number, True, ErrorText);
		Date = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(AccDoc, "docDate", Date, True, ErrorText);
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(AccDoc, "docSum", Amount, True, ErrorText);
		FillXDTOProperty(AccDoc, "transKind", "01", True, ErrorText);
		PaymentKind = TreeAttributeValue(DataTree, "PaymentDetails.PaymentKind");
		PaymentKind = ?(ValueIsFilled(PaymentKind), Lower(PaymentKind), "0");
		FillXDTOProperty(AccDoc, "paytKind", PaymentKind, True, ErrorText);
		OrderOfPriority = TreeAttributeValue(DataTree, "PaymentDetails.Sequence");
		FillXDTOProperty(AccDoc, "priority", OrderOfPriority, True, ErrorText);
		FillXDTOProperty(PayDocRu, "AccDoc", AccDoc, True, ErrorText);
		
		Payer = GetCMLObjectType("Payer",TargetNamespace);
		PayerDescription = TreeAttributeValue(DataTree, "PayerDetails.Name");
		FillXDTOProperty(Payer, "Name", PayerDescription, True, ErrorText);
		PayerTIN = TreeAttributeValue(DataTree, "PayerDetails.TIN");
		FillXDTOProperty(Payer, "tin", PayerTIN, True, ErrorText);
		PayerBankAcc = TreeAttributeValue(DataTree, "PayerDetails.BankAcc");
		FillXDTOProperty(Payer, "personalAcc", PayerBankAcc, True, ErrorText);

		Bank = GetCMLObjectType("Bank",TargetNamespace);
		PayerBankBIC = TreeAttributeValue(DataTree, "PayerAttributes.Bank.BIN");
		FillXDTOProperty(Bank, "bic", PayerBankBIC, True, ErrorText);
		PayerBank = TreeAttributeValue(DataTree, "PayerAttributes.Bank.Description");
		FillXDTOProperty(Bank, "Name", PayerBank, True, ErrorText);
		PayerBalancedAccount = TreeAttributeValue(DataTree, "PayerAttributes.Bank.CorrAccount");
		FillXDTOProperty(Bank, "correspAcc", TrimAll(PayerBalancedAccount), , ErrorText);
		
		PayerBankCity = TreeAttributeValue(DataTree, "PayerAttributes.Bank.City");
		InformationAboutBankLocation = InformationAboutBankLocation(PayerBankCity);
		FillXDTOProperty(Bank, "BankCity", InformationAboutBankLocation.SettlementName, True, ErrorText);
		FillXDTOProperty(
			Bank, "SettlementType", InformationAboutBankLocation.TypeLocality, True, ErrorText);
		
		FillXDTOProperty(Payer, "Bank", Bank, True, ErrorText);
		
		FillXDTOProperty(PayDocRu, "Payer", Payer, True, ErrorText);
		
		Payee = GetCMLObjectType("Payee",TargetNamespace);
		RecipientDescription = TreeAttributeValue(DataTree, "RecipientDetails.Name");
		FillXDTOProperty(Payee, "Name", RecipientDescription, True, ErrorText);
		PayeeTIN = TreeAttributeValue(DataTree, "RecipientAttributes.TIN");
		FillXDTOProperty(Payee, "tin", PayeeTIN, True, ErrorText);
		PayeeBankAcc = TreeAttributeValue(DataTree, "RecipientDetails.BankAcc");
		FillXDTOProperty(Payee, "personalAcc", PayeeBankAcc, True, ErrorText);
		
		Bank = GetCMLObjectType("Bank",TargetNamespace);
		PayeeBankBIC = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.BIN");
		FillXDTOProperty(Bank, "bic", PayeeBankBIC, True, ErrorText);
		PayeeBank = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.Description");
		FillXDTOProperty(Bank, "Name", PayeeBank, True, ErrorText);
		PayeeBalancedAccount = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.CorrAccount");
		FillXDTOProperty(Bank, "correspAcc", TrimAll(PayeeBalancedAccount), , ErrorText);
		
		PayeeBankCity = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.City");
		InformationAboutBankLocation = InformationAboutBankLocation(PayeeBankCity);
		FillXDTOProperty(Bank, "BankCity", InformationAboutBankLocation.SettlementName, True, ErrorText);
		FillXDTOProperty(Bank, "SettlementType", InformationAboutBankLocation.TypeLocality, True, ErrorText);
		
		FillXDTOProperty(Payee, "Bank", Bank, True, ErrorText);
		
		FillXDTOProperty(PayDocRu, "Payee", Payee, True, ErrorText);

		PaymentToBudget = TreeAttributeValue(DataTree, "PaymentsToBudget");
		If PaymentToBudget = True Then
			DepartmentalInfo =  GetCMLObjectType("PayDocRu.DepartmentalInfo",TargetNamespace);
			AuthorStatus = TreeAttributeValue(DataTree, "PaymentsToBudget.ComposerStatus");
			FillXDTOProperty(DepartmentalInfo, "drawerStatus", AuthorStatus, True, ErrorText);
			BasisIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.BasisIndicator");
			BasisIndicator = ?(ValueIsFilled(BasisIndicator), BasisIndicator, "0");
			FillXDTOProperty(DepartmentalInfo, "paytReason", BasisIndicator, True, ErrorText);
			PeriodIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.PeriodIndicator");
			PeriodIndicator = ?(ValueIsFilled(PeriodIndicator), PeriodIndicator, "0");
			FillXDTOProperty(DepartmentalInfo, "taxPeriod", PeriodIndicator, True, ErrorText);
			NumberIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.NumberIndicator");
			NumberIndicator = ?(ValueIsFilled(NumberIndicator), NumberIndicator, "0");
			FillXDTOProperty(DepartmentalInfo, "docNo", NumberIndicator, True, ErrorText);
			DateIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.DateIndicator");
			DateIndicator = ?(ValueIsFilled(DateIndicator), DateIndicator, "0");
			FillXDTOProperty(DepartmentalInfo, "docDate", DateIndicator, True, ErrorText);
			TypeIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.TypeIndicator");
			TypeIndicator = ?(ValueIsFilled(TypeIndicator), TypeIndicator, "0");
			FillXDTOProperty(DepartmentalInfo, "taxPaytKind", TypeIndicator, True, ErrorText);
			FillXDTOProperty(PayDocRu, "DepartmentalInfo", DepartmentalInfo, , ErrorText);
		EndIf;
		
		PayDocRu.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(PayDocRu, FullFileName, , "UTF-8");
			FileIsFormed = True;
		EndIf;
		
	Except
		
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		BriefErrorDescription = BriefErrorDescription(ErrorInfo());
		
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(
			MessagePattern, ?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription));
		Operation = NStr("en='ED formation';ru='Формирование ЭД'");
		DetailErrorDescription = DetailErrorDescription(ErrorInfo());
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
							Operation, DetailErrorDescription, MessageText, 1);
		FileIsFormed = False;
		
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Other

// Defines the name of electronic document file.
//
// Parameters:
//  EDKind - Kind of electronic document, enumeration.
//
Function DetermineEDFileName(EDKind, ObjectReference, Val EDVersion = Undefined)
	
	If EDKind = Enums.EDKinds.TORG12
		OR EDKind = Enums.EDKinds.TORG12Seller
		OR EDKind = Enums.EDKinds.TORG12Customer
		OR EDKind = Enums.EDKinds.AcceptanceCertificate
		OR EDKind = Enums.EDKinds.ActPerformer
		OR EDKind = Enums.EDKinds.ActCustomer
		OR EDKind = Enums.EDKinds.RightsDelegationAct
		OR EDKind = Enums.EDKinds.AgreementAboutCostChangeSender
		OR EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient
		OR EDKind = Enums.EDKinds.InvoiceForPayment
		OR EDKind = Enums.EDKinds.ProductOrder
		OR EDKind = Enums.EDKinds.ResponseToOrder
		OR EDKind = Enums.EDKinds.PriceList
		OR EDKind = Enums.EDKinds.ProductsDirectory
		OR EDKind = Enums.EDKinds.ComissionGoodsSalesReport
		OR EDKind = Enums.EDKinds.ComissionGoodsWriteOffReport
		OR EDKind = Enums.EDKinds.GoodsTransferBetweenCompanies
		OR EDKind = Enums.EDKinds.ProductsReturnBetweenCompanies
		OR EDKind = Enums.EDKinds.PaymentOrder
		OR EDKind = Enums.EDKinds.BankStatement
		OR EDKind = Enums.EDKinds.NotificationOnStatusOfED
		OR EDKind = Enums.EDKinds.QueryProbe
		OR EDKind = Enums.EDKinds.QueryStatement Then
		
		EDDisplayTemplate = NStr("en='%1 %2 %3%4.xml';ru='%1 %2 %3%4.xml'");
		
		// Get the version of ED and its row view.
		EDVersion = ?(EDVersion = Undefined, ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference), EDVersion);
		If TypeOf(EDVersion) = Type("Date") Then
			EDVersion = Format(EDVersion, "DLF=DT; DE=-");
		EndIf;
		
		ViewVersion = "";
		If EDKind <> Enums.EDKinds.NotificationAboutReception
			AND EDKind <> Enums.EDKinds.Confirmation AND EDKind <> Enums.EDKinds.NotificationAboutClarification
			AND EDKind <> Enums.EDKinds.PaymentOrder AND EDKind <> Enums.EDKinds.STATEMENT
			AND EDKind <> Enums.EDKinds.QueryStatement AND EDKind <> Enums.EDKinds.BankStatement
			AND EDKind <> Enums.EDKinds.NotificationOnStatusOfED AND EDKind <> Enums.EDKinds.QueryProbe
			AND ValueIsFilled(EDVersion) Then
			
			TemplateVersionDisplay = NStr("en=' (ver. %1)';ru=' (ver. %1)'");
			ViewVersion = StringFunctionsClientServer.SubstituteParametersInString(TemplateVersionDisplay, EDVersion);
		EndIf;
		
		If EDKind = Enums.EDKinds.ProductsDirectory Then
			FileNameRow = StringFunctionsClientServer.SubstituteParametersInString(EDDisplayTemplate,
				EDKind, ObjectReference.Company, ObjectReference.Counterparty, ViewVersion);
		Else
			FileNameRow = StringFunctionsClientServer.SubstituteParametersInString(EDDisplayTemplate,
				EDKind, ObjectReference.Number, Format(ObjectReference.Date, "DF=dd.MM.yyyy; DLF=D"), ViewVersion);
		EndIf;
		
		FileNameRow = StringFunctionsClientServer.StringInLatin(FileNameRow);
	Else
		FileNameRow = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
	EndIf;
	FileNameRow = ElectronicDocumentsService.CorrectFileName(FileNameRow, True);
	
	Return FileNameRow;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ElectonicDocuments1CTaxcomService: mechanism of electronic documents exchange.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROGRAMMING INTERFACE

////////////////////////////////////////////////////////////////////////////////
// EDF operator Taxcom

// For internal use only
Function TakskomSettingsStructure() Export
	
	SettingsStructure = New Structure;
	
	SettingsStructure.Insert("Description", "Taxcom LLC");
	SettingsStructure.Insert("WebServiceAddress", "");
	SettingsStructure.Insert("TIN", "7704211201");
	SettingsStructure.Insert("OperatorIdentifier", "2AL");
	
	Return SettingsStructure;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Generation of container

// For internal use only
Function GenerateEDTakskomPackageAttachedFile(Envelop, AddressDataEncryptedAtClient = Undefined) Export
	
	ContainerGenerated = False;
	
	PreparedDocuments = Envelop.ElectronicDocuments.UnloadColumn("ElectronicDocument");
	If PreparedDocuments.Count() = 1 Then
		
		ErrorText = "";
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(
							"Send",
							PreparedDocuments[0].UUID());
		
		For Each DocumentToSend IN PreparedDocuments Do
			
			// Save main file and additional file with signatures.
			StructureFilesED = New Structure;
			StructureFilesED.Insert("MainFile");
			StructureFilesED.Insert("AdditionalFile");
			
			//Create signatures table for import to the tree of transport information taxcom
			SignaturesTable = New ValueTable;
			SignaturesTable.Columns.Add("Name");
			SignaturesTable.Columns.Add("Path");
			
			StructureFilesED.Insert("MainFileSignatures", SignaturesTable);
			StructureFilesED.Insert("AdditionalFileSignatures", SignaturesTable);
			
			FileData = ElectronicDocumentsService.GetFileData(DocumentToSend);
			
			// ED encryption
			If Envelop.DataEncrypted Then
				If AddressDataEncryptedAtClient <> Undefined Then // Encryption is completed on client
					FileData.FileBinaryDataRef = AddressDataEncryptedAtClient;
				Else
					EncryptionParameters = ElectronicDocumentsService.GetEncryptionCertificatesAdressesArray(DocumentToSend);
					If EncryptionParameters <> Undefined Then
						Cancel = False;
						CryptoManager = ElectronicDocumentsServiceCallServer.GetCryptoManager(Cancel);
						If Cancel Then
							MessageText = ElectronicDocumentsServiceCallServer.GetMessageAboutError("110");
							CommonUseClientServer.MessageToUser(MessageText);
							
							DeleteFiles(DirectoryAddress, "*");
							Return ContainerGenerated;
						EndIf;
						
						CertificatesArray = New Array;
						For Each StringCertificate IN EncryptionParameters Do
							
							CertificateBinaryData = GetFromTempStorage(StringCertificate);
							Certificate = New CryptoCertificate(CertificateBinaryData);
							CertificatesArray.Add(Certificate);
						EndDo;
						
						FileBinaryData = GetFromTempStorage(FileData.FileBinaryDataRef);
						EncryptedData = CryptoManager.Encrypt(FileBinaryData, CertificatesArray);
						FileData.FileBinaryDataRef = PutToTempStorage(EncryptedData);
					EndIf;
				EndIf;
			EndIf;
			
			If DocumentToSend.EDDirection = Enums.EDDirections.Incoming  Then
				ElectronicDocumentsService.SaveWithLatestES(DocumentToSend, FileData, DirectoryAddress,
					StructureFilesED);
			Else
				ElectronicDocumentsService.SaveWithDS(DocumentToSend, FileData, DirectoryAddress, StructureFilesED);
			EndIf;
			ElectronicDocumentsService.SaveEDAdditDataFiles(DocumentToSend, DirectoryAddress, StructureFilesED);
			
			// Form meta.xml.
			GenerateEDTransportInformationTakskom(DocumentToSend, StructureFilesED, DirectoryAddress, ErrorText);
			
			// Form card.xml
			GenerateEDCardTakskom(DocumentToSend, DirectoryAddress, ErrorText, Envelop.DataEncrypted);
			
		EndDo;
		
		If Not ValueIsFilled(ErrorText) Then
			
			// Generate ED package through the creation of zip-container.
			ZipContainer = New ZipFileWriter();
			FileName = "EDI_" + Envelop.UUID();
			FileName = CommonUseClientServer.ReplaceProhibitedCharsInFileName(FileName);
			ZipContainer.Open(DirectoryAddress + FileName + ".zip");
			
			AddingObjectsInArchive = DirectoryAddress + "*";
			ZipContainer.Add(AddingObjectsInArchive, ZIPStorePathMode.StoreRelativePath,
			ZIPSubDirProcessingMode.ProcessRecursively);
			
			Try
				ZipContainer.Write();
				// Save the ZIP container in the files attached to the envelope.
				ElectronicDocumentsService.PlaceEDPackageIntoEnvelop(Envelop, DirectoryAddress + FileName + ".zip");
				ContainerGenerated = True;
			Except
				MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
				MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
					?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED package formation';ru='Формирование пакета ЭД'"),
					DetailErrorDescription(ErrorInfo()), MessageText);
			EndTry;
		Else
			MessagePattern = NStr("en='During the generation of the
		|package the following errors occurred: %2';ru='При формировании
		|пакета возникли следующие ошибки: %2'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, ErrorText);
			CommonUseClientServer.MessageToUser(MessageText);
		EndIf;
		
		DeleteFiles(DirectoryAddress);
	Else
		MessagePattern = NStr("en='Error occurred when processing ED package %1!
		|For transfer through Taxcom operator ED package should contain 1 electronic document!
		|It is required to regenerate the electronic document.';ru='Ошибка при обработке пакета ЭД %1!
		|Для передачи через оператора Такском, пакет ЭД должен содержать 1 электронный документ!
		|Необхомидо повторно сформировать электронный документ.'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, Envelop.Description);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ContainerGenerated;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Exchange with taxcom

// For internal use only
Procedure DetermineSiteParameters(Val SiteAddress, SecureConnection, Address, Protocol) Export
	
	SiteAddress = TrimAll(SiteAddress); 
	
	SiteAddress = StrReplace(SiteAddress, "\", "/");
	SiteAddress = StrReplace(SiteAddress, " ", "");
	
	If Lower(Left(SiteAddress, 7)) = "http://" Then
		Protocol = "http";
		Address = Mid(SiteAddress,8);
		SecureConnection = FALSE;
	ElsIf Lower(Left(SiteAddress, 8)) = "https://" Then
		Protocol =  "https";
		Address = Mid(SiteAddress,9);
		SecureConnection = true;
	EndIf;
	
EndProcedure 

// Returns marker
//
// Parameters:
//  TokenRequestParametersStructure - Structure, contains the parameters of marker query;
//  Join - HTTPConnection, connection
//  with the Taxcom service Decrypt - Boolean, indication specifying whether to decrypt the marker.
//                   Used if decoding will be executed on the client
//
// Returns:
//  BinaryData - marker binary data
//
Function GetMarkerEEDF(TokenRequestParametersStructure, Join, Decrypt = True) Export
	
	Marker = Undefined;
	SignatureCertificate = Undefined;
	TokenRequestParametersStructure.Property("SignatureCertificate", SignatureCertificate);
	If Not Decrypt OR ValueIsFilled(SignatureCertificate) Then
		PasswordToCertificate = Undefined;
		TokenRequestParametersStructure.Property("UserPassword", PasswordToCertificate);
		If PasswordToCertificate <> Undefined OR Not Decrypt Then
			ResourceAddress = "CertificateLogin";
			
			CertificateData = Undefined;
			If Not TokenRequestParametersStructure.Property("CertificateData", CertificateData) Then
				CertificateData = CommonUse.ObjectAttributeValue(SignatureCertificate, "CertificateData");
			EndIf;
			If ValueIsFilled(CertificateData) Then
				ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("txt");
				DDCertificateFile = ElectronicDocumentsService.TemporaryFileCurrentName("cer");
				If TypeOf(CertificateData) = Type("BinaryData") Then
					CertificateBinaryData = CertificateData;
				Else
					CertificateBinaryData = CertificateData.Get();
				EndIf;
				CertificateBinaryData.Write(DDCertificateFile);
				
				Headers = "";
				AddParameterToTitle(Headers, "Integrator-Id", "1C_22BFE9D5-E77D-424A-BC6D-D8A3496C05FE");
				
				Try
					Join.Post(DDCertificateFile, ResourceAddress, ResultFileName, Headers);
				Except
					MessageText = NStr("en='Authorization error on the server of electronic document management operator Taxcom!
		|(see details in Event log monitor).';ru='Ошибка авторизации на сервере оператора электронного документооборота Такском!
		|(подробности см. в Журнале регистрации).'");
					ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
																NStr("en='Authentication on EDF operator server';ru='Аутентификация на сервере оператора ЭДО'"),
																DetailErrorDescription(ErrorInfo()),
																MessageText);
					DeleteFiles(ResultFileName);
					DeleteFiles(DDCertificateFile);
					Return Undefined;
				EndTry;
				
				If Decrypt Then
					ElectronicDocumentsServiceCallServer.ValidateCertificateValidityPeriod(SignatureCertificate);
					Marker = DecryptMarker(ResultFileName, PasswordToCertificate);
					TokenRequestParametersStructure.Insert("MarkerTranscribed", Marker);
				Else
					Marker = New BinaryData(ResultFileName);
					TokenRequestParametersStructure.Insert("MarkerEncrypted", Marker);
				EndIf;
				
				DeleteFiles(ResultFileName);
				DeleteFiles(DDCertificateFile);
			Else
				DetailErrorDescription = NStr("en='Failed to receive the data of cryptography certificate %1.';ru='Не удалось получить данные сертификата криптографии %1.'");
				DetailErrorDescription = StrReplace(DetailErrorDescription, "%1", SignatureCertificate);
				MessageText = NStr("en='Authorization error on the server of electronic document management operator Taxcom!
		|(see details in Event log monitor).';ru='Ошибка авторизации на сервере оператора электронного документооборота Такском!
		|(подробности см. в Журнале регистрации).'");
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
															NStr("en='Authentication on EDF operator server';ru='Аутентификация на сервере оператора ЭДО'"),
															DetailErrorDescription,
															MessageText);
			EndIf;
		EndIf;
	Else
		MessageText = NStr("en='Authentication certificate is not specified on the server of electronic document flow operator.';ru='Не указан сертификат аутентификации на сервере оператора электронного документооборота.'");
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return Marker;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED sending

// Function sends the files from the directory "SendingDirectoryAddress".
//
// Parameters:
//  Marker                - binary data or string - transcribed marker;
//  SendingDirectoryAddress - String, full path to the directory with transferred files;
//  ResourceAddress          - String, web service address;
//  EDFProfileSettings    - CatalogRef.EDFProfileSettings - EDF profile settings on which the sending happens;
//  DebuggingFlag - Boolean.
//
// Returns:
//  SendingResult - Number (number of sent documents)
//
Function SendThroughTakskom(Marker, SendingDirectoryAddress, ResourceAddress, EDFProfileSettings) Export
	
	SendingResult = 0;
	
	Join = GetConnection();
	
	If ValueIsFilled(Marker) Then
		If TypeOf(Marker) <> Type("String") Then
			Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(Marker);
		EndIf;
		FilesOfSending = FindFiles(SendingDirectoryAddress, "*");
		For Each File IN FilesOfSending Do
			InterimResult = TransferEDFOperatorEDFPackage(
													File,
													Marker,
													Join,
													ResourceAddress,
													EDFProfileSettings);
			SendingResult = SendingResult + InterimResult;
		EndDo;
	EndIf;
	
	DeleteFiles(SendingDirectoryAddress);
	
	Return SendingResult;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED receiving

// Get new electronic documents from Taxcom
//
// Parameters:
//  ReturnStructure - structure with fields: "UnpackingParameters,
//  ReturnArray, CallAlert" PasswordsCorrespondenceForEDF - structure - suitability
//  of passwords for EDF GetAllList - get ED list without restriction of the
//  selection by date Readmission - Boolean - indication that receipt was recalled due to marker is invalid
//
Procedure GetNewEDTakskomOperator(ReturnStructure,
										 AccAgreementsAndStructuresOfCertificates,
										 GetAllList,
										 Readmission = False)
	
	If Not ValueIsFilled(AccAgreementsAndStructuresOfCertificates) Then
		Map = Undefined;
		If Not ElectronicDocumentsServiceCallServer.ParametersAvailableForAuthorizationOnOperatorServer(, Map) Then
			Return;
		EndIf;
		AccAgreementsAndStructuresOfCertificates = New Map;
		For Each Item IN Map Do
			EDFProfileSettings = Item.Key;
			For Each Item1 IN Item.Value Do
				AccAgreementsAndStructuresOfCertificates.Insert(EDFProfileSettings, Item1.Value);
				Break;
			EndDo;
		EndDo;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	EDFProfileSettingsThroughOEDF.Ref AS EDFProfileSettings,
	|	EDExchangeStatesThroughEDFOperators.EDDateReceived AS EDDateReceived
	|FROM
	|	Catalog.EDFProfileSettings AS EDFProfileSettingsThroughOEDF
	|		LEFT JOIN InformationRegister.EDExchangeStatesThroughEDFOperators AS EDExchangeStatesThroughEDFOperators
	|		ON (EDExchangeStatesThroughEDFOperators.EDFProfileSettings = EDFProfileSettingsThroughOEDF.Ref)
	|WHERE
	|	EDFProfileSettingsThroughOEDF.EDExchangeMethod = VALUE(Enum.EDExchangeMethods.ThroughEDFOperatorTaxcom)
	|	AND EDExchangeStatesThroughEDFOperators.DeleteAgreementAboutEDUsage = VALUE(Catalog.EDUsageAgreements.EmptyRef)
	|	AND Not EDFProfileSettingsThroughOEDF.DeletionMark";
	
	EDReceiptDatesTable = Query.Execute().Unload();
	
	For Each Item IN AccAgreementsAndStructuresOfCertificates Do
		
		EDFProfileSettings = Item.Key;
		CertificateStructure = Item.Value;
		
		MarkerTranscribed = Undefined;
		MarkerEncrypted = Undefined;
		PasswordToCertificate = Undefined;
		If TypeOf(CertificateStructure) = Type("Structure")
			AND (CertificateStructure.Property("MarkerTranscribed", MarkerTranscribed)
			OR CertificateStructure.Property("MarkerEncrypted", MarkerEncrypted))
			AND (ValueIsFilled(MarkerTranscribed) OR ValueIsFilled(MarkerEncrypted)) Then
			CertificateStructure.Property("UserPassword", PasswordToCertificate);
			If Not ValueIsFilled(MarkerTranscribed) AND PasswordToCertificate = Undefined
				OR Not ElectronicDocumentsServiceCallServer.DecryptMarkerFromStructureOfCertificateAtServer(CertificateStructure) Then
				Continue;
			Else
				MarkerTranscribed = CertificateStructure.MarkerTranscribed;
			EndIf;
			TableRow = EDReceiptDatesTable.Find(EDFProfileSettings);
			QueryDateTime = Undefined;
			If TableRow <> Undefined Then
				QueryDateTime = TableRow.EDDateReceived;
			EndIf;
		Else
			Continue;
		EndIf;
		
		Join = GetConnection();

		Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(MarkerTranscribed);
		
		MoveDate = True;
		ReceivedAllDocuments = False;
		While Not ReceivedAllDocuments Do
			
			QueryDateTime = Format(QueryDateTime, "DF='yyyy-MM-dd HH:mm:ss'");
			ResourceAddress = "GetMessageList" + ?(ValueIsFilled(QueryDateTime), "?date=" + QueryDateTime, "");
			EDList_XML = GetEDFOperatorEDList(Marker, Join, Item.Value, ResourceAddress, Readmission);
			
			If Readmission Then
				Return;
			EndIf;
			
			DocumentsIDList = "";
			QueryDateTime   = ParseEDListText(EDList_XML, DocumentsIDList);
			DeleteFiles(EDList_XML);
			
			If DocumentsIDList.Count() = 0 Then
				ReceivedAllDocuments = True;
				Break;
			EndIf;
					
			For Each Str IN DocumentsIDList Do
				
				If Not EDPackageAlreadyImported(Str.DocumentID) Then
					
					EDFile = GetEdOperatorsEED(Marker, Join, Item.Value, Str.DocumentID, Readmission);
					
					If Readmission Then
						Return;
					EndIf;
					
					If EDFile <> Undefined Then
						ItemBinaryData = New BinaryData(EDFile);
						
						ParametersStructure = GetIncomingEDData(ItemBinaryData,
																		Str.TransactionCode,
																		Str.DocumentFlowID,
																		Str.DocumentID);
						If ValueIsFilled(ParametersStructure) Then
							EDPackage = ElectronicDocumentsService.GenerateNewEDPackage(ParametersStructure);
							
							If ValueIsFilled(EDPackage.Ref) Then
								FileName = "EDI_" + ParametersStructure.ExternalUID;
								AddressInStorage = PutToTempStorage(ItemBinaryData);
								
								AttachedFile = AttachedFiles.AddFile(EDPackage.Ref,
																					  FileName,
																					  "zip",
																					  CurrentSessionDate(),
																					  CurrentSessionDate(),
																					  AddressInStorage,
																					  ,
																					  ,
																					  Catalogs.EDAttachedFiles.GetRef());
								
								ReturnStructure.ReturnArray.Add(AttachedFile);
								UnpackPackage = Not ParametersStructure.Encrypted;
								UnpackingStructure = New Structure("Unpack, EDPackage", UnpackPackage, EDPackage.Ref);
								If UnpackPackage Then
									UnpackingData = ElectronicDocumentsServiceCallServer.ReturnArrayBinaryDataPackage(EDPackage.Ref);
									UnpackingStructure.Insert("UnpackingData", UnpackingData);
								EndIf;
								ReturnStructure.UnpackingParameters.Add(UnpackingStructure);
							EndIf;
						ElsIf Str.TransactionCode = "PostDateConfirmation"
							OR Str.TransactionCode = "SendConfirmation" 
							OR Str.TransactionCode = "ReceiveNoticePostDateConfirmation" Then
							MoveDate = False;
						Else
							SaveUnknownPackage(ItemBinaryData, EDFProfileSettings, Str.DocumentID);
						EndIf;
						DeleteFiles(EDFile);
					EndIf;
				EndIf;
			EndDo;
			
			If MoveDate AND ValueIsFilled(QueryDateTime) AND DocumentsIDList.Count() > 0 Then
				
				Record = InformationRegisters.EDExchangeStatesThroughEDFOperators.CreateRecordManager();
				Record.EDFProfileSettings = EDFProfileSettings;
				Record.Read();
				Record.EDDateReceived = Date(StrReplace(StrReplace(StrReplace(Mid(QueryDateTime, 0,
					Find(QueryDateTime, ".") - 1), "-", ""), " ", ""), ":", ""));
				Record.Write();
			EndIf;
			
		EndDo;
	
	EndDo;
	
EndProcedure

// Get new electronic documents from Taxcom
//
// Parameters:
//  ResourceAddress - String - address
//  of resource LatestQueryDate - Date - date of
//  last query Marker - binary data or string - transcribed marker;
//
// Returns:
//  ListED_XML - list of electronic documents
//
Function GetThroughTakskom(Val ResourceAddress, LastQueryDate, Marker) Export
	
	Join = GetConnection();
	
	Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(Marker);
	
	ResourceAddress = ResourceAddress + ?(ValueIsFilled(LastQueryDate), "?date=" + LastQueryDate, "");
	
	EDList_XML = GetEDFOperatorEDList(Marker, Join, , ResourceAddress);
	
	Return EDList_XML;
	
EndFunction

// Sends information about acceptance or rejection of an invitation to taxcom
Function AcceptRejectContactThroughTakskom(ID, InvitationAccepted, Marker) Export
	
	ConnectionAddress = "";
	SecureConnection = False;
	ProtocolConnection = "";
	
	DetermineSiteParameters("https://1" + Char(67) + "-"
		+ Char(97) + Char(112) + Char(105) + "."
		+ Char(116) + Char(97) + Char(120) + Char(99) + Char(111) + Char(109) + "."
		+ Char(114) + Char(117) + "/v1.2/" + Char(65) + Char(80) + Char(73) + "/",
		SecureConnection, ConnectionAddress, ProtocolConnection);
	Proxy = ElectronicDocumentsService.GenerateProxy(ProtocolConnection);
	Join = New HTTPConnection(ConnectionAddress, , , , Proxy, SecureConnection);
	
	Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(Marker);
	
	OperationExecuted = False;
	If ValueIsFilled(Marker) Then
		If InvitationAccepted Then
			ResourceAddress = "AcceptContact?id=" + ID;
		Else
			ResourceAddress = "RejectContact?id=" + ID;
		EndIf;
		
		Headers = "";
		AddparameterToTitle(Headers, "Assistant-Key", Marker);
		ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		Try
			Join.Get(ResourceAddress, ResultFileName, Headers);
			OperationExecuted = True;
		Except
			TextDocument = New TextDocument;
			TextDocument.Read(ResultFileName, "UTF-8");
			TextString = TextDocument.GetText();
			If Find(TextString, "Contact status ") * Find(TextString, ", was expected") > 0 Then
				// If the row of the following kind arrived: "Status of
				// the contact is Accepted, Incoming was expected" or similar, then this is not an error but an operational aspect of the service.
				StatusStartPos = Find(TextString, "Contact status") + StrLen("Contact status ");
				StatusEndPos = Find(TextString, ", was expected");
				CurrentStatusOfContact = TrimAll(Mid(TextString, StatusStartPos, StatusEndPos - StatusStartPos));
				CurrentStatusOfContact = ConvertTextStatus(CurrentStatusOfContact);
				If CurrentStatusOfContact = "Connected" Then
					OperationExecuted = True;
				Else
					MessageText = NStr("en='Current status of the Contact in the agreement does
		|not correspond to the actual status %1 on Taxcom server! It is required to execute the command ""Update statuses from the server"".';ru='Текущий статус Контакта в соглашении не
		|соответствует действительному статусу %1, на сервере Такском! Необходимо выполнить команду ""Обновить статусы с сервера"".'");
					MessageText = StrReplace(MessageText, "%1", CurrentStatusOfContact);
					CommonUseClientServer.MessageToUser(MessageText);
					OperationExecuted = False;
				EndIf;
			Else
				MessagePattern = NStr("en='Error occurred when processing %1 invitation on the Taxcom server!
		|(see details in Event log monitor).';ru='Ошибка обработки %1 приглашения на сервере Такском!
		|(подробности см. в Журнале регистрации).'");
				CurParameterString = ?(InvitationAccepted, NStr("en='Adoption';ru='принятия'"), NStr("en='rejections';ru='отклонения'"));
				MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, CurParameterString);
				DetailErrorDescription = DetailErrorDescription(ErrorInfo());
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Receiving ED.';ru='Получение ЭД.'"),
																							DetailErrorDescription,
																							MessageText);
				OperationExecuted = False;
			EndIf;
			DeleteFiles(ResultFileName);
		EndTry;
	EndIf;
	
	Return OperationExecuted;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Unpacking electronic documents packages

// Returns an array of binary data of electronic documents package contents.
//
// Parameters:
// EDPackage             - DocumentRef.EDPackage - package of electronic documents under study,
//
// Returns:
//  ReturnStructure - array of binary data.
//
Function ReturnTakskomPackageBinaryDataArray(EDPackage) Export
	
	FileOfArchive = "";
	EncryptedArchiveFile = "";
	
	SetPrivilegedMode(True);
	
	Try
		// Verify that the setting specified in the package is still valid.
		EDFSetup = EDPackage.EDFSetup;
		If EDFSetup.IsEmpty() OR EDFSetup.ConnectionStatus <> Enums.EDExchangeMemberStatuses.Connected Then
			ExceptionMessage = NStr("en='There is no current EDF setup for this package of electronic documents.
		|Unpacking is impossible.';ru='По данному пакету электронных документов нет действующей настройки ЭДО.
		|Распаковка невозможна.'");
			Raise(ExceptionMessage);
		EndIf;
		
		// It is required to get the package archive from the files attached to the document.
		AttachedFilesSelection = ElectronicDocumentsService.GetEDSelectionByFilter(New Structure("FileOwner", EDPackage));
		If Not ValueIsFilled(AttachedFilesSelection) OR Not AttachedFilesSelection.Next() Then
			Return Undefined;
		EndIf;
		
		// For each package it is required to define a file with data.
		DataParameters = ElectronicDocumentsService.GetFileData(AttachedFilesSelection.Ref);
		FileBinaryData = GetFromTempStorage(DataParameters.FileBinaryDataRef);
		FileOfArchive = ElectronicDocumentsService.TemporaryFileCurrentName("zip");
		FileBinaryData.Write(FileOfArchive);
		
		ZIPReading = New ZipFileReader(FileOfArchive);
		FolderForUnpacking = ElectronicDocumentsService.WorkingDirectory("Ext", EDPackage.Ref.UUID());
		
		Try
			ZipReading.ExtractAll(FolderForUnpacking, ZIPRestoreFilePathsMode.DontRestore);
		Except
			ErrorText = BriefErrorDescription(ErrorInfo());
			If Not ElectronicDocumentsService.PossibleToExtractFiles(ZIPReading, FolderForUnpacking) Then
				MessageText = ElectronicDocumentsReUse.GetMessageAboutError("006");
			EndIf;
			ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
				ErrorText, MessageText);
			DeleteFiles(FolderForUnpacking);
			DeleteFiles(FileOfArchive);
			Return Undefined;
		EndTry;
		
		ZIPReading.Close();
		DeleteFiles(FileOfArchive);
	
		// Decrypt file with data
		InformationArrayFile = FindFiles(FolderForUnpacking, "meta*.xml", True);
		
		If InformationArrayFile.Count() > 0 Then
			InformationFile = InformationArrayFile[0];
		Else
			DeleteFiles(FolderForUnpacking);
			Return Undefined;
		EndIf;
		
		CardArrayFile = FindFiles(FolderForUnpacking, "card*.xml", True);
		
		If CardArrayFile.Count() > 0 Then
			CardFile = CardArrayFile[0];
		Else
			DeleteFiles(FolderForUnpacking);
			Return Undefined;
		EndIf;
		
		MapFileParameters = GetCorrespondingFileParameters(InformationFile, CardFile);
		
		If MapFileParameters.Count() = 0 Then
			DeleteFiles(FolderForUnpacking);
			Return Undefined;
		EndIf;
		
		NotificationFilesArray = FindFiles(FolderForUnpacking, "*NotificationAboutReceivingDocument*.xml", True);
		DataFileArray = New Array;
		
		IsArbitraryED = False;
		
		For Each MapItem IN MapFileParameters Do
			DataType = DetermineDataTypeByTransactionCode(MapItem.Value.TransactionCode);
			If DataType <> "Signature" Then
				FilesArraySource = FindFiles(FolderForUnpacking, MapItem.Key, True);
				AddSourceArrayItemsInArrayReceiver(DataFileArray, FilesArraySource);
				ArbitraryEDText = "";
				IsArbitraryED = MapItem.Value.RandomED;
				MapItem.Value.AddData.Property("CommentED", ArbitraryEDText);
			EndIf;
		EndDo;
		
		If IsArbitraryED Then
			MapFileParameters.Insert("Text", ArbitraryEDText);
			MapFileParameters.Insert("IsArbitraryED", True);
		EndIf;
		
		ReturnStructure = New Structure;
		ReturnStructure.Insert("DataType", DataType);
		ReturnStructure.Insert("MapFileParameters", MapFileParameters);
		ReturnStructure.Insert("StructureOfBinaryData", ConvertFilesArrayIntoBinaryData(DataFileArray));
		ReturnStructure.Insert("StructureOfBinaryDataAnnouncements",
								   ConvertFilesArrayIntoBinaryData(NotificationFilesArray));
		AllFilesArray = FindFiles(FolderForUnpacking, "*.*", True);
		DataFiles = New Map;
		For Each File IN AllFilesArray Do
			FileBinaryData = New BinaryData(File.FullName);
			RefToFileData = PutToTempStorage(FileBinaryData, New UUID);
			DataFiles.Insert(File.Name, RefToFileData);
		EndDo;
		DeleteFiles(FolderForUnpacking);
		ReturnStructure.Insert("PackageFiles", DataFiles);
		Return ReturnStructure;
		
	Except
		MessageText = BriefErrorDescription(ErrorInfo())
			+ NStr("en=' (see details in Event log monitor).';ru=' (подробности см. в Журнале регистрации).'");
		ErrorText = DetailErrorDescription(ErrorInfo());
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
																					ErrorText,
																					MessageText);
		If ValueIsFilled(FolderForUnpacking) Then
			DeleteFiles(FolderForUnpacking);
		EndIf;
	EndTry;
	
EndFunction

Function HandleBinaryDataPackageTakskom(EDPackage, UnpackingData, IsCryptofacilityOnClient, AccordanceOfEdAndSignatures, ReturnStructure)
	
	ProcessedDocumentsCount = 0;
	
	AddedFilesReturnArray             = New Array;
	AddedFilesForNotificationsReturnArray = New Array;
	
	BinaryDataArray = UnpackingData.StructureOfBinaryData;
	NotificationsBinaryDataArray = UnpackingData.StructureOfBinaryDataAnnouncements;
	
	IsUnpackingError = False;
	
	For Each DataStructure IN BinaryDataArray Do
		
		SignsStructuresArray = ElectronicDocumentsServiceCallServer.GetSignaturesDataCorrespondence(
																			DataStructure.FileName,
																			UnpackingData.PackageFiles,
																			DataStructure.BinaryData,
																			UnpackingData.MapFileParameters,
																			True);
		AddedFilesArrayForNotifications = New Array;
		AddedFilesArray = AddDataByEDPackage(
											EDPackage,
											SignsStructuresArray,
											DataStructure,
											UnpackingData.MapFileParameters,
											UnpackingData.PackageFiles,
											IsUnpackingError,
											IsCryptofacilityOnClient,
											True,
											AddedFilesArrayForNotifications,
											AccordanceOfEdAndSignatures);
		
		If Not IsUnpackingError AND TypeOf(AddedFilesArray) = Type("Array") Then
			ProcessedDocumentsCount = ProcessedDocumentsCount + AddedFilesArray.Count();
		EndIf;
		
		If TypeOf(AddedFilesArray) = Type("Array") Then
			CommonUse.FillArrayWithUniqueValues(AddedFilesReturnArray, AddedFilesArray);
		EndIf;
		
		CommonUse.FillArrayWithUniqueValues(
								AddedFilesForNotificationsReturnArray,
								AddedFilesArrayForNotifications);
		
	EndDo;
	
	If Not IsUnpackingError Then
		
		ElectronicDocumentsServiceCallServer.SetPackageStatus(
													EDPackage,
													PredefinedValue("Enum.EDPackagesStatuses.Unpacked"));
	Else
		ProcessedDocumentsCount = 0;
	EndIf;
	
	ReturnStructure.Insert("AddedFilesArray",             AddedFilesArray);
	ReturnStructure.Insert("AddedFilesArrayForNotifications", AddedFilesArrayForNotifications);
	ReturnStructure.Insert("ArrayOfOwners",                    ArrayOfOwners(AddedFilesArray));
	
	Return ProcessedDocumentsCount;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Invitations to exchange

// For internal use only
Function OutgoingInvitationRequestTakskom(TableDataProcessors, AdditParametersStructure) Export
	
	ErrorText = "";
	PathToDescription = "{http://api-invoice.taxcom.en/contacts}.Contacts";
	Try
		Contacts = GetCMLObjectType(PathToDescription);
		FillXDTOProperty(Contacts, "Asof", CurrentSessionDate(), , ErrorText);
		For Each CurRow IN TableDataProcessors Do
			Contact = GetCMLObjectType(PathToDescription + ".Contact");
			FillXDTOProperty(Contact, "Name",              CurRow.Description, , ErrorText);
			FillXDTOProperty(Contact, "Inn",               CurRow.TIN, True, ErrorText);
			FillXDTOProperty(Contact, "Email",             CurRow.EMail_Address, True, ErrorText);
			FillXDTOProperty(Contact, "Comment",           CurRow.InvitationText, , ErrorText);
			FillXDTOProperty(Contact, "ExternalContactId", CurRow.ExternalCode, , ErrorText);
			Contacts.Contact.Add(Contact);
		EndDo;
		Contacts.Validate();
		If ValueIsFilled(ErrorText) Then
			Raise ErrorText;
		EndIf;
		
		FileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		ExportEDtoFile(Contacts, FileName, False);
		
		Return FileName;
	Except
		
		MessageText = ErrorText + NStr("en=' (see details in Event log monitor).';ru=' (подробности см. в Журнале регистрации).'");
		ErrorText = DetailErrorDescription(ErrorInfo());
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Generation of invitations for the exchange';ru='Формирование приглашения к обмену'"),
																					ErrorText,
																					MessageText);
			
		Return "";
	EndTry;
	
EndFunction

// For internal use only
Function GetConnection() Export
	
	Address = "";
	SecureConnection = False;
	Protocol = "";
	
	OperatorSettings = TakskomSettingsStructure();
	DetermineSiteParameters(OperatorSettings.WebServiceAddress, SecureConnection, Address, Protocol);
	Proxy = ElectronicDocumentsService.GenerateProxy(Protocol);
	
	Join = New HTTPConnection(Address, , , , Proxy, SecureConnection);
	
	Return Join;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROCEDURES AND FUNCTIONS

Procedure AddParameterToTitle(QueryTitle, Name, Value)

	QueryTitle = QueryTitle + Name + ": "+ Value + Chars.CR + Chars.LF;

EndProcedure

Procedure ReadContact(Contact, ContactsTable, EDFProfileSettings)
	
	String = ContactsTable.Add();
	String.EDFProfileSettings  = EDFProfileSettings;
	String.TIN                 = ?(TypeOf(Contact.Inn) = Type("XDTODataObject"), "", Contact.Inn);
	
	String.Changed             = Date(StrReplace(StrReplace(StrReplace(StrReplace(Mid(Contact.State.Changed, 0,
		Find(Contact.State.Changed, ".") - 1), "-", ""), " ", ""), ":", ""),"T",""));
		
	If Contact.Properties().Get("ExternalContactId") <> Undefined
		AND TypeOf(Contact.ExternalContactId) = Type("String") Then
		
		String.ExternalID = Contact.ExternalContactId;
	EndIf;
	
	If Contact.Properties().Get("Name") <> Undefined AND TypeOf(Contact.Name) = Type("String") Then
		String.Description    = Contact.Name;
	EndIf;
	
	If Contact.Properties().Get("Comment") <> Undefined AND TypeOf(Contact.Name) = Type("String") Then
		String.InvitationText = Contact.Comment;
	EndIf;
	
	String.State = ConvertTextStatus(Contact.State.Code);
	If Contact.State.Code = "Error" Then
		String.ErrorDescription  = ConvertTextStatus(Contact.State.ErrorCode);
	EndIf;
	
	If Contact.Properties().Get("EDXClientId") <> Undefined Then
		String.ID  = Contact.EDXClientId;
	EndIf;
	
EndProcedure

Function ConvertTextStatus(StatusCode)
	
	If StatusCode = "Incoming" Then
		ReturnValue = Enums.EDExchangeMemberStatuses.ApprovalRequired; //"Incoming request";
	ElsIf StatusCode = "Rejected" Then
		ReturnValue = Enums.EDExchangeMemberStatuses.Disconnected; //"Disconnected"
	ElsIf StatusCode = "Accepted" Then
		ReturnValue = Enums.EDExchangeMemberStatuses.Connected; //"Connected"
	ElsIf StatusCode = "Sent" Then
		ReturnValue = Enums.EDExchangeMemberStatuses.AgreementExpectation; //"Wait for consent"
	ElsIf StatusCode = "Error" Then
		ReturnValue = Enums.EDExchangeMemberStatuses.Error; // "Error"
	
	ElsIf StatusCode = "InvalidTIN" Then
		ReturnValue = "Wrong TIN";
	ElsIf StatusCode = "InvalidEmail" Then
		ReturnValue = "Invalid email address";
	Else
		ReturnValue = StatusCode;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function IsNumber(String)
	
	ReturnValue = True;
	Try
		Number = Number(String);
	Except
		ReturnValue = False;
	EndTry;
	
	Return ReturnValue;
	
EndFunction

Function GetTransactionCode(ElectronicDocument, RegulationsCode, SignatureSign = False)
	
	TransactionCode = Undefined;
	
	EDParameters = CommonUse.ObjectAttributesValues(ElectronicDocument,
		"EDVersionPointType, EDKind, ElectronicDocumentOwner");
		
	If EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.ATA Then
		If SignatureSign Then
			TransactionCode = "CancellationOfferResign";
		ElsIf EDParameters.EDKind = Enums.EDKinds.NotificationAboutClarification Then
			TransactionCode = "CancellationOfferReject";
		Else
			TransactionCode = "CancellationOffer";
		EndIf;
	ElsIf EDParameters.EDKind = Enums.EDKinds.NotificationAboutClarification Then
		If RegulationsCode = "Invoice" Then
			TransactionCode = "CorrectionNotice";
		Else
			OwnerEDKind = CommonUse.ObjectAttributeValue(EDParameters.ElectronicDocumentOwner, "EDKind");
			If OwnerEDKind = Enums.EDKinds.CancellationOffer Then
				TransactionCode = "CancellationOfferReject";
			Else
				TransactionCode = "MainDocumentReject";
			EndIf;
		EndIf;
	ElsIf RegulationsCode = "Invoice" Then
		
		If EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDDEI Then
			TransactionCode = "SendConfirmationReceiveNotice";
		ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDREI Then
			TransactionCode = "PostDateConfirmationReceiveNotice";
		ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.NAREI Then
			TransactionCode = "ReceiveNotice";
		ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDDNREI Then
			TransactionCode = "ReceiveNoticePostDateConfirmationReceiveNotice";
		ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.NRNCEI Then
			TransactionCode = "CorrectionNoticeReceiveNotice";
		ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.ESF Then
			TransactionCode = "Invoice";
		EndIf;
		
	ElsIf RegulationsCode = "Formalized" Then
		If EDParameters.EDKind = Enums.EDKinds.TORG12Seller
			OR EDParameters.EDKind = Enums.EDKinds.ActPerformer
			OR EDParameters.EDKind = Enums.EDKinds.AgreementAboutCostChangeSender Then
			
			TransactionCode = "VendorTitle";
		ElsIf EDParameters.EDKind = Enums.EDKinds.TORG12Customer
			OR EDParameters.EDKind = Enums.EDKinds.ActCustomer
			OR EDParameters.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
			
			TransactionCode = "CustomerTitle";
		EndIf;
		
		If EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.RN Then
			TransactionCode = "ReceiveNotice";
		EndIf;
		
	ElsIf RegulationsCode = "Nonformalized" Then
		TransactionCode = "MainDocument";
		If EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.RN Then
			TransactionCode = "ReceiveNotice";
		EndIf;
		
		If SignatureSign Then
			TransactionCode = "MainDocumentResign";
		EndIf;
		
	EndIf;
	
	Return TransactionCode;
	
EndFunction

Function GetRegulationCode(ElectronicDocument)
	
	EDParameters = CommonUse.ObjectAttributesValues(ElectronicDocument,
		"EDFScheduleVersion, EDVersionPointType, EDKind, ElectronicDocumentOwner");
	
	// Change the code of regulations if you use the version 20 of the regulations.
	If ElectronicDocumentsServiceCallServer.ThisIsServiceDocument(ElectronicDocument)
		AND ValueIsFilled(EDParameters.ElectronicDocumentOwner) Then
		RegulationsCode = GetRegulationCode(EDParameters.ElectronicDocumentOwner);
	ElsIf EDParameters.VersionPointTypeED = Enums.EDVersionElementTypes.ESF Then
		RegulationsCode = "Invoice";
	ElsIf EDParameters.EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20
		AND (EDParameters.EDKind = Enums.EDKinds.TORG12Seller
			OR EDParameters.EDKind = Enums.EDKinds.TORG12Customer
			OR EDParameters.EDKind = Enums.EDKinds.ActPerformer
			OR EDParameters.EDKind = Enums.EDKinds.ActCustomer
			OR EDParameters.EDKind = Enums.EDKinds.AgreementAboutCostChangeSender
			OR EDParameters.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient) Then
			RegulationsCode = "Formalized";
	Else
		RegulationsCode = "Nonformalized";
	EndIf;
	
	Return RegulationsCode;
	
EndFunction

Function DocumentTypeByTakscomLine(DocumentType)
	
	FormattedString = Lower(TrimAll(DocumentType));
	If FormattedString = "account" Then
		ReturnValue = Enums.EDTypes.InvoiceForPayment;
	ElsIf FormattedString = "statement" Then
		ReturnValue = Enums.EDTypes.AcceptanceCertificate;
	ElsIf FormattedString = "consignment" Then
		ReturnValue = Enums.EDTypes.GoodsSale;
	ElsIf FormattedString = "paymentorder" Then
		ReturnValue = Enums.EDTypes.PaymentOrder;
	ElsIf FormattedString = "contract" Then
		ReturnValue = Enums.EDTypes.Contract;
	ElsIf FormattedString = "statementappendix" Then
		ReturnValue = Enums.EDTypes.ApplicationOfAct;
	ElsIf FormattedString = "guaranteeletter" Then
		ReturnValue = Enums.EDTypes.WarrantyLetter;
	ElsIf FormattedString = "formalizedstatementcustomer"
		  OR FormattedString = "formalizedstatementvendor"
		  OR FormattedString = "formalizedconsignmentcustomer"
		  OR FormattedString = "formalizedconsignmentvendor"
		  OR FormattedString = "invoice"
		  OR FormattedString = "correctiveinvoice"
		  OR FormattedString = "receivenotification"
		  OR FormattedString = "specificationnotice"
		  OR FormattedString = "sendingtimeconfirmation"
		  OR FormattedString = "other"
		Then
		ReturnValue = Enums.EDTypes.Other;
	Else
		RecordInLog = NStr("en='Not set the mapping of document type from the
		|card of ED package ""%1"" with listing of the configuration ""ED types""';ru='Не задано сопоставление типа документа
		|из карточки пакета ЭД ""%1"", с перечислением конфигурации ""Типы ЭД""'");
		RecordInLog = StrReplace(RecordInLog, "%1", DocumentType);
		OperationKind = NStr("en='Reading of ED package card';ru='Чтение карточки пакета ЭД'");
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(OperationKind, RecordInLog);
		ReturnValue = Enums.EDTypes.Other;
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function DocumentTypeRowTakskomByEnumeration(EDType)
	
	If EDType = Enums.EDTypes.InvoiceForPayment Then
		ReturnValue = "Account";
	ElsIf EDType = Enums.EDTypes.AcceptanceCertificate Then
		ReturnValue = "Statement";
	ElsIf EDType = Enums.EDTypes.GoodsSale Then
		ReturnValue = "Consignment";
	ElsIf EDType = Enums.EDTypes.PaymentOrder Then
		ReturnValue = "PaymentOrder";
	ElsIf EDType = Enums.EDTypes.Contract Then
		ReturnValue = "Contract";
	ElsIf EDType = Enums.EDTypes.ApplicationOfAct Then
		ReturnValue = "StatementAppendix";
	ElsIf EDType = Enums.EDTypes.WarrantyLetter Then
		ReturnValue = "GuaranteeLetter";
	ElsIf EDType = Enums.EDTypes.Other Then
		ReturnValue = "Other";
	Else
		ReturnValue = "Other";
	EndIf;
	
	Return ReturnValue;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Exchange with taxcom

Function DecryptMarker(ResultFileName, PasswordToOperatorCertificate)
	
	Cancel = False;
	CryptoManager = ElectronicDocumentsServiceCallServer.GetCryptoManager(Cancel);
	If Cancel Then
		MessageText = ElectronicDocumentsServiceCallServer.GetMessageAboutError("110");
		CommonUseClientServer.MessageToUser(MessageText);
		Return Undefined;
	EndIf;
	
	If ValueIsFilled(PasswordToOperatorCertificate) Then
		CryptoManager.PrivateKeyAccessPassword = PasswordToOperatorCertificate;
	EndIf;
	Try
		DecryptedBinaryData = CryptoManager.Decrypt(ResultFileName);
	Except
		MessageText = ElectronicDocumentsServiceCallServer.GetMessageAboutError("113");
		CommonUseClientServer.MessageToUser(MessageText);
		Return Undefined;
	EndTry;
		
	Return DecryptedBinaryData;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED sending

Function TransferEDFOperatorEDFPackage(File, Marker, Join, Val ResourceAddress, EDFProfileSettings)
	
	ReturnParameter = 0;
	If ValueIsFilled(Marker) Then
		Headers = "";
		AddparameterToTitle(Headers, "Assistant-Key", Marker);
		ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("txt");
		
		ResourceAddress = ResourceAddress + ?(ResourceAddress = "SendMessage", "/" + StrReplace(File.Name, "-", ""), "");
		
		Try
			Join.Post(File.FullName, ResourceAddress, ResultFileName, Headers);
			ReturnParameter = 1;
		Except
			ReturnParameter = 0;
			
			ResultFile = New TextDocument;
			ResultFile.Read(ResultFileName, TextEncoding.UTF8);
			Result = ResultFile.GetText();
			
			If ValueIsFilled(Result) Then
				Result = StrReplace(Result, """", "");
				Result = StrReplace(Result, ":", ",");
				ErrorParametersArray = StringFunctionsClientServer.DecomposeStringIntoSubstringsArray(Result, ",");
				
				ErrorTemplate = NStr("en='%1: %2.';ru='%1: %2.'");
				TakskomOperatorErrorText = StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate,
					ErrorParametersArray[7], ErrorParametersArray[1]);
					
				ErrorCode = ErrorParametersArray[5];
				MessagePattern = NStr("en='Sending of package on EDF profile settings: %1, exchange method: %2';ru='Отправка пакета по профилю настроек ЭДО: %1, способ обмена: %2'");
				
				MessageTitleText = StringFunctionsClientServer.SubstituteParametersInString(
											MessagePattern,
											EDFProfileSettings,
											Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom);
				ErrorText = ElectronicDocumentsServiceCallServer.GetMessageAboutError(
																		ErrorCode,
																		TakskomOperatorErrorText);
				
				MessageText = MessageTitleText + Chars.LF + ErrorText;
				
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(MessageTitleText,
																							Result,
																							MessageText);
			EndIf;
			
		EndTry;
		
		DeleteFiles(ResultFileName);
	EndIf;
	
	Return ReturnParameter;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED receiving

Function GetEDFOperatorEDList(Marker, Join, TokenRequestParametersStructure, ResourceAddress, Recursion = False)
	
	ResultFileName = Undefined;
	If ValueIsFilled(Marker) Then
		Headers = "";
		AddParameterToTitle(Headers, "Assistant-Key", Marker);
		ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		Try
			Join.Get(ResourceAddress, ResultFileName, Headers);
			Recursion = False;
		Except
			DeleteFiles(ResultFileName);
			ResultFileName = Undefined;
			If Not Recursion AND ElectronicDocumentsServiceCallServer.ServerAuthorizationPerform()
					AND Not TokenRequestParametersStructure = Undefined Then
				Marker = GetMarkerEEDF(TokenRequestParametersStructure, Join, True);
				Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(Marker);
				ResultFileName = GetEDFOperatorEDList(
															Marker,
															Join,
															TokenRequestParametersStructure,
															ResourceAddress,
															True);
			Else
				Recursion = Not Recursion;
			EndIf;
			
			If Not Recursion Then
				ErrorText = DetailErrorDescription(ErrorInfo());
				MessageText = NStr("en='Receipt of the incoming electronic documents on Taxcom server failed!
		|(see details in Event log monitor).';ru='Ошибка получения входящих электронных документов на сервере Такском!
		|(подробности см. в Журнале регистрации).'");
				Operation = NStr("en='ED receiving';ru='Получение ЭД'");
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(Operation, ErrorText, MessageText);
			EndIf;
		EndTry;
	EndIf;
	
	Return ResultFileName;
	
EndFunction

Function ParseEDListText(EDList_XML, VT)
	
	VT = New ValueTable;
	VT.Columns.Add("DocumentFlowID");
	VT.Columns.Add("TransactionCode");
	VT.Columns.Add("DocumentID");
	VT.Columns.Add("Priority");
	
	QueryDateTime = Undefined;
	
	If ValueIsFilled(EDList_XML) Then
		
		XMLReader = New XMLReader;
		XMLReader.OpenFile(EDList_XML);
		
		DocumentFlowID = Undefined;
		TransactionCode      = Undefined;
		While XMLReader.Read() Do
			
			If XMLReader.NodeType = XMLNodeType.StartElement AND XMLReader.LocalName = "ContainerDescription" Then
				QueryDateTime = XMLReader.GetAttribute("LastRecordDateTime");
				Continue;
			EndIf;
			
			If XMLReader.NodeType = XMLNodeType.StartElement AND XMLReader.LocalName = "DocFlow" Then
				DocumentFlowID = XMLReader.GetAttribute("Id");
				Continue;
			EndIf;
			
			If XMLReader.NodeType = XMLNodeType.StartElement AND XMLReader.LocalName = "Document" Then
				TransactionCode      = XMLReader.GetAttribute("TransactionCode");
				Continue;
			EndIf;
			
			If XMLReader.NodeType = XMLNodeType.StartElement AND XMLReader.LocalName = "Identifiers" Then
				StrVT = VT.Add();
				StrVT.DocumentFlowID = DocumentFlowID;
				StrVT.TransactionCode      = TransactionCode;
				
				If TransactionCode = "MainDocument" Then
					
					StrVT.Priority = 0;

				ElsIf TransactionCode = "VendorTitle" OR TransactionCode = "CustomerTitle" Then
					
					StrVT.Priority = 1;
				ElsIf TransactionCode = "Invoice" Then
					
					StrVT.Priority = 2;
				ElsIf TransactionCode = "PostDateConfirmation"
					OR TransactionCode = "SendConfirmation"
					OR TransactionCode = "ReceiveNoticePostDateConfirmation" Then
					
					StrVT.Priority = 3;
				ElsIf TransactionCode = "ReceiveNotice" Then
					
					StrVT.Priority = 4;
				ElsIf TransactionCode = "MainDocumentReject" Then
					
					StrVT.Priority = 5;
				Else
					
					StrVT.Priority = 6;
				EndIf;
				
				StrVT.DocumentID = XMLReader.GetAttribute("InternalId");
				Continue;
			EndIf;
		EndDo;
		
		VT.Sort("Priority");
	EndIf;
	
	Return QueryDateTime;
	
EndFunction

Function GetEdOperatorsEED(Marker, Join, TokenRequestParametersStructure, DocumentID, Recursion = False)
	
	ResultFileName = Undefined;
	If ValueIsFilled(Marker) Then
		ResourceAddress = "GetMessage/" + DocumentID;
		Headers = "";
		
		AddParameterToTitle(Headers, "Assistant-Key", Marker);
		ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("zip");
		Try
			Join.Get(ResourceAddress, ResultFileName, Headers);
			Recursion = False;
		Except
			// If an error occurred due to the
			// expiration of marker, try to get a new marker and then ED again.
			DeleteFiles(ResultFileName);
			ErrorText = ErrorDescription();
			ResultFileName = Undefined;
			If Not Recursion AND ElectronicDocumentsServiceCallServer.ServerAuthorizationPerform() Then
				Marker = GetMarkerEEDF(TokenRequestParametersStructure, Join, True);
				Marker = ElectronicDocumentsServiceCallServer.AStringOfBinaryData(Marker);
				ResultFileName = GetEdOperatorsEED(Marker,
															Join,
															TokenRequestParametersStructure,
															DocumentID,
															True);
			Else
				Recursion = Not Recursion;
			EndIf;
		EndTry;
	EndIf;
	
	Return ResultFileName;
	
EndFunction

Function EDPackageAlreadyImported(DocumentID)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	EDPackage.Ref
	|FROM
	|	Document.EDPackage AS EDPackage
	|WHERE
	|	EDPackage.ExternalUID = &ExternalUID
	|	AND EDPackage.Direction = &Direction";
	Query.SetParameter("Direction", Enums.EDDirections.Incoming);
	Query.SetParameter("ExternalUID",  DocumentID);
	
	ResultIsEmpty = Query.Execute().IsEmpty();
	
	Return Not ResultIsEmpty;
	
EndFunction

Function GetIncomingEDData(BinaryData, TransactionCode, DocumentFlowID, DocumentID)
	
	SetPrivilegedMode(True);
	
	ParametersStructure = Undefined;
	AgreementSettings = Undefined;
	
	
	If TransactionCode = "PostDateConfirmation"
		OR TransactionCode = "SendConfirmation" 
		OR TransactionCode = "ReceiveNoticePostDateConfirmation"
		OR TransactionCode = "ErrorMessage" Then
		
		If TransactionCode = "PostDateConfirmation" Then
			EDRef = Catalogs.EDAttachedFiles.GetRef(New UUID(DocumentFlowID));
			EDFound = (EDRef.GetObject() <> Undefined);
			
		Else
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("UniqueId", DocumentFlowID);
			If TransactionCode <> "ErrorMessage" Then
				SearchParametersStructure.Insert("EDDirection",       Enums.EDDirections.Incoming);
				SearchParametersStructure.Insert("VersionPointTypeED", Enums.EDVersionElementTypes.ESF);
			EndIf;
			EDRef = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
			EDFound = (EDRef <> Undefined);
		EndIf;
		
		If EDFound Then
			EDParameters = CommonUse.ObjectAttributesValues(EDRef, "EDFProfileSettings,
				|EDAgreement, Company, Counterparty, EDSender, EDRecipient");
				
			AgreementSettings = New Structure;
			AgreementSettings.Insert("EDFProfileSettings", EDParameters.EDFProfileSettings);
			AgreementSettings.Insert("EDFSetup",       EDParameters.EDAgreement);
			AgreementSettings.Insert("EDExchangeMethod",     Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom);
			AgreementSettings.Insert("Company",        EDParameters.Company);
			AgreementSettings.Insert("Counterparty",         EDParameters.Counterparty);
			AgreementSettings.Insert("SenderAddress",   "");
			AgreementSettings.Insert("RecipientAddress",    "");
			SenderID = EDParameters.EDFrom;
			RecipientID  = EDParameters.EDRecipient;
		EndIf;
	Else
		
		TemporaryZIPFileName = ElectronicDocumentsService.TemporaryFileCurrentName("zip");
		BinaryData.Write(TemporaryZIPFileName);
		
		ZIPReading = New ZipFileReader(TemporaryZIPFileName);
		UniqueKey = New UUID();
		FolderForUnpacking = ElectronicDocumentsService.WorkingDirectory("Input", UniqueKey);
		UnpackingError = False;
		Try
			ZipReading.ExtractAll(FolderForUnpacking, ZIPRestoreFilePathsMode.DontRestore);
		Except
			UnpackingError = True;
			ErrorText = BriefErrorDescription(ErrorInfo());
			
			If Not ElectronicDocumentsService.PossibleToExtractFiles(ZIPReading, FolderForUnpacking) Then
				MessageText = ElectronicDocumentsReUse.GetMessageAboutError("006");
			EndIf;
			ElectronicDocuments.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
																   ErrorText,
																   MessageText);
			ZipReading.Close();
		EndTry;
		
		If Not UnpackingError Then
			
			CardMassFile  = FindFiles(FolderForUnpacking, "card*.xml", True);
			
			If CardMassFile.Count() > 0 Then
				CardFile = CardMassFile[0];
			Else
				CardFile = Undefined;
			EndIf;
			
			RecipientID  = Undefined;
			SenderID = Undefined;
			If CardFile <> Undefined Then
				
				XMLObject = New XMLReader;
				ValuesStructure = New Structure;
				
				Try
					XMLObject.OpenFile(CardFile.FullName);
					ED = XDTOFactory.ReadXML(XMLObject);
					XMLObject.Close();
					SenderID = ED.Sender.Abonent.ID;
					RecipientID  = ED.Receiver.Abonent.ID;
					AgreementSettings = ElectronicDocumentsService.GetEDExchangeSettingsByID(RecipientID, SenderID);
				Except
					XMLObject.Close();
					
					MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
					MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
						CardFile.FullName, BriefErrorDescription(ErrorInfo()));
					ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																								DetailErrorDescription(ErrorInfo()),
																								MessageText);
					AgreementSettings = Undefined;
					
				EndTry;
			EndIf;
			
		EndIf;
		DeleteFiles(TemporaryZIPFileName);
		DeleteFiles(FolderForUnpacking);
	EndIf;
	
	
	If AgreementSettings <> Undefined Then
		
		ParametersStructure = New Structure;
		ParametersStructure.Insert("EDFProfileSettings",  AgreementSettings.EDFProfileSettings);
		ParametersStructure.Insert("EDExchangeMethod",      AgreementSettings.EDExchangeMethod);
		ParametersStructure.Insert("EDFSetup",        AgreementSettings.EDFSetup);
		ParametersStructure.Insert("Recipient",          RecipientID);
		ParametersStructure.Insert("Sender",         SenderID);
		ParametersStructure.Insert("SenderAddress",    AgreementSettings.SenderAddress);
		ParametersStructure.Insert("RecipientAddress",     AgreementSettings.RecipientAddress);
		ParametersStructure.Insert("Company",         AgreementSettings.Company);
		ParametersStructure.Insert("Counterparty",          AgreementSettings.Counterparty);
		ParametersStructure.Insert("Encrypted",          False); // Data encryption through Operator is not supported.
		ParametersStructure.Insert("CompanyCertificateForDetails", Undefined);
		ParametersStructure.Insert("PackageFormatVersion", Enums.EDPackageFormatVersions.Version30);
		ParametersStructure.Insert("ExternalUID",          DocumentID);
		ParametersStructure.Insert("PackageStatus",        Enums.EDPackagesStatuses.ToUnpacking);
		ParametersStructure.Insert("EDDirections",       Enums.EDDirections.Incoming);
		
	EndIf;
	
	Return ParametersStructure;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Unpacking electronic documents packages

Procedure ReadServiceHeaderFileCMXDTOLpo(FileName, RegulationsCode, TransactionCode, EDFileStructure)
	
	XMLObject = New XMLReader;
	IDED                      = Undefined;
	EDKind                     = Undefined;
	EDDirection             = Undefined;
	SenderDocumentNumber = Undefined;
	SenderDocumentDate  = Undefined;
	VersionPointTypeED       = Undefined;
	EDOwnerStatus         = Undefined;
	MessageText            = Undefined;
	ErrorDescription            = Undefined;
	AdditionalInformation      = New Structure;
	CorrectionText            = Undefined;
	
	ParticipantsStructure = New Structure;
	
	Try
		XMLObject.OpenFile(FileName);
		ED = XDTOFactory.ReadXML(XMLObject);
		XMLObject.Close();
		
		If TransactionCode = "ErrorMessage" Then
			ErrorDescription      = ElectronicDocumentsServiceCallServer.GetMessageAboutError(ED.ErrorCode, ED.Definition);
			EDKind               = Enums.EDKinds.Error;
			VersionPointTypeED = Enums.EDVersionElementTypes.Error;
			EDOwnerStatus   = Enums.EDStatuses.TransferError;
		Else
			IDED = ED.IdFile;
			EDVersionNumber = 0;
			
			If RegulationsCode = "Nonformalized" OR RegulationsCode = "Formalized" Then
				
				If TransactionCode = "PostDateConfirmation" Then
					EDKind               = Enums.EDKinds.Confirmation;
					If ED.Document.CTD = "1115112" Then
						VersionPointTypeED = Enums.EDVersionElementTypes.RDC;
					Else
						VersionPointTypeED = Enums.EDVersionElementTypes.SDC;
					EndIf;
					EDOwnerStatus   = Enums.EDStatuses.Sent;
					SenderDocumentDate  = Date(ParseDateString(ED.Document.InfoConf.SenDate)
						+ StrReplace(ED.Document.InfoConf.SenTime, ".", ""));
				ElsIf TransactionCode = "CorrectionNotice"
					OR TransactionCode = "MainDocumentReject"
					OR TransactionCode = "CancellationOfferReject" Then
					EDKind               = Enums.EDKinds.NotificationAboutClarification;
					VersionPointTypeED = Enums.EDVersionElementTypes.NAC;
					EDOwnerStatus   = Enums.EDStatuses.RejectedByReceiver;
					SenderDocumentDate  = Date(ParseDateString(ED.Document.PrAdjNot.DateGender)
						+ StrReplace(ED.Document.PrAdjNot.RecTime, ".", ""));
					CorrectionText      = ED.Document.PrAdjNot.TextNotifCor;
				ElsIf TransactionCode = "ReceiveNotice" Then
					EDKind               = Enums.EDKinds.NotificationAboutReception;
					VersionPointTypeED = Enums.EDVersionElementTypes.RN;
					EDOwnerStatus   = Enums.EDStatuses.Delivered;
					SenderDocumentDate  = Date(ParseDateString(ED.Document.PrNotifRec.DateGender)
						+ StrReplace(ED.Document.PrNotifRec.RecTime, ".", ""));
				ElsIf TransactionCode = "CancellationOffer" Then
					EDKind               = Enums.EDKinds.CancellationOffer;
					VersionPointTypeED = Enums.EDVersionElementTypes.ATA;
					EDOwnerStatus   = Enums.EDStatuses.CancellationOfferReceived;
					SenderDocumentDate  = Date(1, 1, 1);
					CorrectionText      = ED.Document.PrelimAnalysisInfo.TextAnnOffer;
					AdditionalInformation.Insert("OwnerName", TrimAll(ED.Document.PrelimAnalysisInfo.InfoAnFile.AnFileName));
				Else
					MessageText = NStr("en='This kind of electronic document ""%1""  is not supported in the current version of the application.
		|It is required to update the configuration to a recent version (see details in Event log monitor).';ru='Данный вид электронного документа ""%1"" не поддерживается в текущей версии программы.
		|Необходимо обновить конфигурацию до актуальной версии (подробности см. в Журнале регистрации).'");
					MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessageText, TransactionCode);
					ErrorText = NStr("en='When reading the data from the file ""%1"" an error occurred: unknown code of transaction ""%2"".';ru='При чтении данных из файла ""%1"" возникла ошибка: неизвестный код транзакции ""%2"".'");
					ErrorText = StringFunctionsClientServer.SubstituteParametersInString(ErrorText, FileName, TransactionCode);
					ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
						ErrorText, MessageText);
				EndIf;
			Else
				If TransactionCode = "PostDateConfirmation" Then
					EDKind                    = Enums.EDKinds.Confirmation;
					VersionPointTypeED      = Enums.EDVersionElementTypes.EIRDC;
					EDOwnerStatus        = Enums.EDStatuses.Sent;
					SenderDocumentDate = Date(ParseDateString(ED.Document.InfoConf.SenDate)
						+ StrReplace(ED.Document.InfoConf.SenTime, ".", ""));
				ElsIf TransactionCode = "SendConfirmation" Then
					EDKind                    = Enums.EDKinds.Confirmation;
					VersionPointTypeED      = Enums.EDVersionElementTypes.EISDC;
					EDOwnerStatus        = Enums.EDStatuses.Received;
					SenderDocumentDate = Date(ParseDateString(ED.Document.InfoConf.SenDate)
						+ StrReplace(ED.Document.InfoConf.SenTime, ".", ""));
				ElsIf TransactionCode = "ReceiveNoticePostDateConfirmation" Then
					EDKind                    = Enums.EDKinds.Confirmation;
					VersionPointTypeED      = Enums.EDVersionElementTypes.SDANAREIC;
					EDOwnerStatus        = Enums.EDStatuses.Received;
					SenderDocumentDate = Date(ParseDateString(ED.Document.InfoConf.SenDate)
						+ StrReplace(ED.Document.InfoConf.SenTime, ".", ""));
				ElsIf TransactionCode = "ReceiveNotice" Then
					EDKind                    = Enums.EDKinds.NotificationAboutReception;
					VersionPointTypeED      = Enums.EDVersionElementTypes.NAREI;
					EDOwnerStatus        = Enums.EDStatuses.Delivered;
					SenderDocumentDate = Date(ParseDateString(ED.Document.PrNotifRec.DateGender)
						+ StrReplace(ED.Document.PrNotifRec.RecTime, ".", ""));
				ElsIf TransactionCode = "CorrectionNotice" Then
					EDKind                    = Enums.EDKinds.NotificationAboutClarification;
					VersionPointTypeED      = Enums.EDVersionElementTypes.NAEIC;
					EDOwnerStatus        = Enums.EDStatuses.RejectedByReceiver;
					SenderDocumentDate = Date(ParseDateString(ED.Document.PrAdjNot.DateGender)
						+ StrReplace(ED.Document.PrAdjNot.RecTime, ".", ""));
					CorrectionText           = ED.Document.PrAdjNot.TextNotifCor;
				ElsIf TransactionCode = "CorrectionNoticeReceiveNotice" Then
					EDKind                    = Enums.EDKinds.NotificationAboutReception;
					VersionPointTypeED      = Enums.EDVersionElementTypes.NRNCEI;
					EDOwnerStatus        = Enums.EDStatuses.Rejected;
					SenderDocumentDate = Date(ParseDateString(ED.Document.PrNotifRec.DateGender)
						+ StrReplace(ED.Document.PrNotifRec.RecTime, ".", ""));
				ElsIf TransactionCode = "CancellationOffer" Then
					EDKind                    = Enums.EDKinds.CancellationOffer;
					VersionPointTypeED      = Enums.EDVersionElementTypes.ATA;
					EDOwnerStatus        = Enums.EDStatuses.CancellationOfferReceived;
					SenderDocumentDate = Date(1, 1, 1);
					CorrectionText           = ED.Document.PrelimAnalysisInfo.TextAnnOffer;
					AdditionalInformation.Insert("OwnerName", TrimAll(ED.Document.PrelimAnalysisInfo.InfoAnFile.AnFileName));
				Else
					MessageText = NStr("en='This kind of electronic document ""%1""  is not supported in the current version of the application.
		|It is required to update the configuration to a recent version (see details in Event log monitor).';ru='Данный вид электронного документа ""%1"" не поддерживается в текущей версии программы.
		|Необходимо обновить конфигурацию до актуальной версии (подробности см. в Журнале регистрации).'");
					MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessageText, TransactionCode);
					ErrorText = NStr("en='When reading the data from the file ""%1"" an error occurred: unknown code of transaction ""%2"".';ru='При чтении данных из файла ""%1"" возникла ошибка: неизвестный код транзакции ""%2"".'");
					ErrorText = StringFunctionsClientServer.SubstituteParametersInString(ErrorText, FileName, TransactionCode);
					ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
						ErrorText, MessageText);
				EndIf;
				
			EndIf;
		EndIf;
		
		If ValueIsFilled(MessageText) Then
			Raise(MessageText);
		EndIf;
		
		Try
			EDVersionNumber = Number(EDVersionNumber);
		Except
		EndTry;
		
		EDFileStructure.EDVersionNumber             = EDVersionNumber;
		EDFileStructure.EdKind                     = EDKind;
		EDFileStructure.EDNumber                   = IDED;
		EDFileStructure.EDDirection             = EDDirection;
		EDFileStructure.EDOwnerStatus         = EDOwnerStatus;
		EDFileStructure.VersionPointTypeED       = VersionPointTypeED;
		EDFileStructure.SenderDocumentNumber = SenderDocumentNumber;
		EDFileStructure.SenderDocumentDate  = SenderDocumentDate;
		EDFileStructure.ErrorDescription            = ErrorDescription;
		EDFileStructure.CorrectionText            = CorrectionText;
		EDFileStructure.AdditionalInformation      = AdditionalInformation;
	Except
		XMLObject.Close();
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			FileName, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
EndProcedure

Procedure AddSourceArrayItemsInArrayReceiver(ArrayReceiver, ArraySource)
	
	For Each ArrayElement IN ArraySource Do
		
		ArrayReceiver.Add(ArrayElement);
		
	EndDo;
	
EndProcedure

Procedure AddDataToMap(ConformityOfReturn, DocumentPresentation, NestedStructure)
	
	ConformityOfReturn.Insert(DocumentPresentation, NestedStructure);
	DocumentPresentation = "";
	
EndProcedure

// IN this function incoming service documents are processed:
// PDO, IOP, UOU - T.e. documents received in response to the previously sent ED.
//
// Parameters:
// AddedFilesArrayForNotifications - Added ED based on which receipt notes shall be generated
//
Function AddDataByEDPackage(EDPackage,
								SignaturesDataStructure,
								DataStructure,
								MapFileParameters,
								PackageFiles,
								ErrorFlag = False,
								IsCryptofacilityOnClient = False,
								IsXML = False,
								AddedFilesArrayForNotifications,
								AccordanceOfEdAndSignatures = Undefined)
								
	SetPrivilegedMode(True);
								
	If Find(DataStructure.FileName, "NotificationAboutReceivingDocument") > 0 Then
		Return Undefined;
	EndIf;
	
	EDPackageAttributes = CommonUse.ObjectAttributesValues(EDPackage, "EDFProfileSettings,
	|EDFSetup, EDExchangeMethod, Sender, Recipient");
	
	HasCryptoToolAtServer = EDPackageAttributes.EDExchangeMethod = Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom
			 					  AND ElectronicDocumentsServiceCallServer.ServerAuthorizationPerform();
	
	AddedFilesArray = New Array;
	If ElectronicDocumentsServiceCallServer.PerformCryptoOperationsAtServer()
		OR HasCryptoToolAtServer Then
		
		CryptoManager = ElectronicDocumentsServiceCallServer.GetCryptoManager();
	Else
		CryptoManager = Undefined;
	EndIf;
	
	If Not IsCryptofacilityOnClient AND SignaturesDataStructure.Count() > 0
		AND CryptoManager = Undefined Then
		
		MessagePattern = NStr("en='Package unpacking
		|failed:
		|%1 Package contains electronic digital signatures. The cryptofacility is required to be on the computer to unpack';ru='Ошибка
		|распаковки
		|пакета: %1 Пакет содержит электронные цифровые подписи. Для распаковки требуется наличие криптосредства на компьютере.'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, EDPackage);
		
		// If unpacking on the client, then display a message
		ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText,
			2, EventLogLevel.Information);

		ErrorFlag = True;
		
		Return Undefined;
	EndIf;
	
	Try
		PackageEDObject = EDPackage.GetObject();
		
		DataFile = DataStructure.BinaryData;
		EncryptedArchiveFile = ElectronicDocumentsService.TemporaryFileCurrentName(?(IsXML, "xml", "zip"));
		DataFile.Write(EncryptedArchiveFile);
		
		EncryptedDataFile = New File(EncryptedArchiveFile);
		
		EDFileStructure = GenerateEDFileStructure();
		
		FolderForDetails = ElectronicDocumentsService.WorkingDirectory("Dec");
		ElectronicDocumentsService.DeleteUnnecessarySlashInPath(FolderForDetails);
		DeleteFiles(FolderForDetails, "*");
		
		If IsXML Then
			FileCopy(EncryptedDataFile.FullName, FolderForDetails + DataStructure.FileName);
			DeleteFiles(EncryptedArchiveFile);
		Else
			ZIPReading = New ZipFileReader(EncryptedDataFile.FullName);
			Try
				ZIPReading.ExtractAll(FolderForDetails);
			Except
				ErrorText = BriefErrorDescription(ErrorInfo());
				If Not ElectronicDocumentsService.PossibleToExtractFiles(ZIPReading, FolderForDetails) Then
					MessageText = ElectronicDocumentsReUse.GetMessageAboutError("006");
				EndIf;
				ElectronicDocuments.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
																	   ErrorText,
																	   MessageText);
				DeleteFiles(FolderForDetails);
				ZIPReading.Close();
				DeleteFiles(EncryptedArchiveFile);
				Return Undefined;
			EndTry;
			ZIPReading.Close();
			DeleteFiles(EncryptedArchiveFile)
		EndIf;
		
		EncryptionFiles = FindFiles(FolderForDetails, "*.xml");
		If EncryptionFiles.Count() = 0 Then
			DeleteFiles(FolderForDetails);
			Return Undefined;
		Else
			FileWithData = EncryptionFiles[0];
			
			ServiceDataStructure = MapFileParameters.Get(FileWithData.Name);
			RegulationsCode = ServiceDataStructure.RegulationsCode;
			TransactionCode = ServiceDataStructure.TransactionCode;
			Try
				ReadServiceHeaderFileCMXDTOLpo(
						FileWithData.FullName,
						RegulationsCode,
						TransactionCode,
						EDFileStructure);
				EDFileStructure.EDDirection = Enums.EDDirections.Incoming;
				EDFileStructure.EDAgreement  = EDPackageAttributes.EDFSetup;
				EDFileStructure.Company   = PackageEDObject.Company;
				EDFileStructure.Counterparty    = PackageEDObject.Counterparty;
			Except
				DeleteFiles(FolderForDetails);
				Return Undefined;
			EndTry;
		EndIf;
		
		// For service documents DocFlow is placed to EDNumber.ID
		// UID of primary ED in sender IB, same as UniqueId in recipient IB.
		PrimaryEDGUID = ServiceDataStructure.UniqueId;
		
		ElectronicDocumentOwner = Undefined;
		
		// For an unstructured document flow, official documents come only to sender IB
		
		If TransactionCode = "CancellationOfferReject" Then
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("UniqueId",        PrimaryEDGUID);
			SearchParametersStructure.Insert("EDKind",               Enums.EDKinds.CancellationOffer);
			SearchParametersStructure.Insert("Company",         EDFileStructure.Company);
			SearchParametersStructure.Insert("Counterparty",          EDFileStructure.Counterparty);
			PrimaryED = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
			PrimaryEDFound = (PrimaryED <> Undefined);
			ElectronicDocumentOwner = PrimaryED;
		ElsIf EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.ATA Then
			OwnerName = EDFileStructure.AdditionalInformation.OwnerName;
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("Description",        OwnerName);
			SearchParametersStructure.Insert("Company",         EDFileStructure.Company);
			SearchParametersStructure.Insert("Counterparty",          EDFileStructure.Counterparty);
			PrimaryED = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
			PrimaryEDFound = (PrimaryED <> Undefined);
			ElectronicDocumentOwner = PrimaryED;
		ElsIf RegulationsCode = "Nonformalized" OR RegulationsCode = "Formalized"
			OR EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.Error
			OR EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.EIRDC
			OR EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.NAREI
			OR EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.NAEIC Then
			
			PrimaryED = Catalogs.EDAttachedFiles.GetRef(New UUID(PrimaryEDGUID));
			ElectronicDocumentOwner = PrimaryED;
			PrimaryEDFound = (PrimaryED.GetObject() <> Undefined);
			
		Else
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("UniqueId",        PrimaryEDGUID);
			SearchParametersStructure.Insert("EDDirection",       Enums.EDDirections.Incoming);
			SearchParametersStructure.Insert("VersionPointTypeED", Enums.EDVersionElementTypes.ESF);
			PrimaryED = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
			PrimaryEDFound = PrimaryED <> Undefined;
			
			If EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.EISDC Then
				ElectronicDocumentOwner = PrimaryED;
			EndIf;
			
		EndIf;
		
		If Not PrimaryEDFound Then
			DeleteFiles(FolderForDetails);
			Return Undefined;
		EndIf;
		
		If ElectronicDocumentOwner = Undefined Then
			
			Parameters = New Structure;
			Parameters.Insert("EDDirection", Enums.EDDirections.Outgoing);
			
			If EDFileStructure.VersionPointTypeED = Enums.EDVersionElementTypes.SDANAREIC Then
				
				Parameters.Insert("EDKind", Enums.EDKinds.NotificationAboutReception);
				Parameters.Insert("VersionPointTypeED", Enums.EDVersionElementTypes.NAREI);
			Else
				
				Parameters.Insert("EDKind", Enums.EDKinds.NotificationAboutClarification);
				Parameters.Insert("VersionPointTypeED", Enums.EDVersionElementTypes.NAEIC);
			EndIf;
			
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("UniqueId",        PrimaryEDGUID);
			SearchParametersStructure.Insert("EDDirection",       Parameters.EDDirection);
			SearchParametersStructure.Insert("EDKind",               Parameters.EDKind);
			SearchParametersStructure.Insert("VersionPointTypeED", Parameters.VersionPointTypeED);
			ElectronicDocumentOwner = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
		EndIf;
		
		If ElectronicDocumentOwner = Undefined Then
			DeleteFiles(FolderForDetails);
			Return Undefined;
		EndIf;
		
		EDOwner = PrimaryED.FileOwner;
		
		If EDFileStructure.EDKind = Enums.EDKinds.Error Then
			
			MessagePattern = NStr("en='An error occurred when sending the electronic document %1, the recipient %2.
		|(see details in Event log monitor).';ru='Возникла ошибка при передаче электронного документа %1, получатель %2.
		|(подробности см. в Журнале регистрации).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, PrimaryED,
				PrimaryED.Counterparty);
			
			DetailedErrorTemplate = NStr("en='During transfer of the electronic document %1, an error occurred: %2.
		|Information base document (electronic document 
		|owner) - %3; Agreement on electronic documents exchange - %4.';ru='При передаче электронного документа %1, возникла ошибка: %2.
		|Документ информационной базы (владелец электронного документа) - %3;
		|Соглашение об обмене электронными документами - %4.'");
			DetailErrorText = StringFunctionsClientServer.SubstituteParametersInString(DetailedErrorTemplate, PrimaryED,
				EDFileStructure.ErrorDescription, EDOwner, PrimaryED.EDAgreement);

			ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Electronic document transfer';ru='Передача электронного документа'"),
																						DetailErrorText,
																						MessageText);
			
			ParametersUpdateStructure = New Structure;
			ParametersUpdateStructure.Insert("EDOwner",     EDOwner);
			ParametersUpdateStructure.Insert("EDKind",          PrimaryED.EDKind);
			ParametersUpdateStructure.Insert("EDDirection",  PrimaryED.EDDirection);
			ParametersUpdateStructure.Insert("Counterparty",     PrimaryED.Counterparty);
			ParametersUpdateStructure.Insert("EDAgreement",   PrimaryED.EDAgreement);
			ParametersUpdateStructure.Insert("CorrectionText", EDFileStructure.ErrorDescription);
			ParametersUpdateStructure.Insert("EDStatus", ElectronicDocumentsService.GetAdmissibleEDStatus(
				EDFileStructure.EDOwnerStatus, PrimaryED));
			
			ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(PrimaryED, ParametersUpdateStructure);
			
		Else
			
			// Put the data file in the files attached to DB document.
			SearchParametersStructure = New Structure;
			SearchParametersStructure.Insert("UniqueId",        PrimaryEDGUID);
			SearchParametersStructure.Insert("EDDirection",       EDFileStructure.EDDirection);
			SearchParametersStructure.Insert("EDKind",               EDFileStructure.EDKind);
			SearchParametersStructure.Insert("VersionPointTypeED", EDFileStructure.VersionPointTypeED);
			AddedFile = ElectronicDocumentsService.DetermineElectronicDocument(SearchParametersStructure);
			
			If Not ValueIsFilled(AddedFile) Then
				
				AddressInTemporaryStorage = PutToTempStorage(DataFile);
				DataFileSignatures  = MapFileParameters.Get(FileWithData.Name).Signatures;
				
				AddedFile = AttachedFiles.AddFile(EDOwner, FileWithData.BaseName,
					StrReplace(EncryptedDataFile.Extension, ".", ""), CurrentSessionDate(), CurrentSessionDate(),
					AddressInTemporaryStorage, Undefined, , Catalogs.EDAttachedFiles.GetRef());
				
				Responsible = ElectronicDocumentsOverridable.GetResponsibleByED(EDPackage.Counterparty,
					EDPackageAttributes.EDFSetup);
				
				If ValueIsFilled(AddedFile) Then
					
					ParametersUpdateStructure = New Structure;
					ParametersUpdateStructure.Insert("EDOwner",                  EDOwner);
					ParametersUpdateStructure.Insert("EDKind",                       EDFileStructure.EDKind);
					ParametersUpdateStructure.Insert("EDDirection",               Enums.EDDirections.Incoming);
					ParametersUpdateStructure.Insert("EDNumber",                     ElectronicDocumentOwner.EDNumber);
					ParametersUpdateStructure.Insert("Company",                 EDFileStructure.Company);
					ParametersUpdateStructure.Insert("Counterparty",                  EDFileStructure.Counterparty);
					ParametersUpdateStructure.Insert("EDVersionNumber",               EDFileStructure.EDVersionNumber);
					ParametersUpdateStructure.Insert("SenderDocumentNumber",   EDFileStructure.SenderDocumentNumber);
					ParametersUpdateStructure.Insert("SenderDocumentDate",    EDFileStructure.SenderDocumentDate);
					ParametersUpdateStructure.Insert("Responsible",               Responsible);
					ParametersUpdateStructure.Insert("Sender",                 EDPackageAttributes.Sender);
					ParametersUpdateStructure.Insert("Recipient",                  EDPackageAttributes.Recipient);
					ParametersUpdateStructure.Insert("EDAgreement",                EDPackageAttributes.EDFSetup);
					ParametersUpdateStructure.Insert("EDFProfileSettings",          EDPackageAttributes.EDFProfileSettings);
					ParametersUpdateStructure.Insert("UniqueId",                PrimaryEDGUID);
					ParametersUpdateStructure.Insert("ElectronicDocumentOwner", ElectronicDocumentOwner);
					ParametersUpdateStructure.Insert("EDFScheduleVersion",         ElectronicDocumentOwner.EDFScheduleVersion);
					ParametersUpdateStructure.Insert("VersionPointTypeED",         EDFileStructure.VersionPointTypeED);
					ParametersUpdateStructure.Insert("FileDescription",           FileWithData.BaseName);
					ParametersUpdateStructure.Insert("EDStatus", ElectronicDocumentsService.GetAdmissibleEDStatus(
						Enums.EDStatuses.Received, AddedFile));
					
					ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(AddedFile, ParametersUpdateStructure, False);
					
					ParametersUpdateStructure = New Structure;
					ParametersUpdateStructure.Insert("EDStatus",
						ElectronicDocumentsService.GetAdmissibleEDStatus(EDFileStructure.EDOwnerStatus, PrimaryED));
					
					If ValueIsFilled(EDFileStructure.CorrectionText) Then
						ParametersUpdateStructure.Insert("CorrectionText", EDFileStructure.CorrectionText);
					EndIf;
					
					ElectronicDocumentsServiceCallServer.ChangeByRefAttachedFile(PrimaryED, ParametersUpdateStructure, False);
					
					If RegulationsCode = "Invoice" Then
						
						If TransactionCode <> "ReceiveNotice" AND TransactionCode <> "CorrectionNoticeReceiveNotice" Then
							
							AddedFilesArrayForNotifications.Add(AddedFile);
							
						EndIf;
						
						If TransactionCode = "PostDateConfirmation" OR TransactionCode = "SendConfirmation"
							OR TransactionCode = "ReceiveNotice" OR TransactionCode = "ReceiveNoticePostDateConfirmation" Then
							
							ElectronicDocumentsOverridable.FillESFAttributes(EDOwner, AddedFile);
						EndIf;
						
						If TransactionCode = "ReceiveNotice" Then
							
							If ElectronicDocumentsServiceCallServer.ThisIsCorrectionDocument(AddedFile) Then
								ChangeGroundsIRState(PrimaryED, Enums.EDDirections.Outgoing);
							EndIf;
						EndIf;
						
					EndIf;
					
				EndIf;
				
				// Add information about signatures
				If ValueIsFilled(DataFileSignatures) Then
					ArrayDataSignatures = New Array;
					AccordanceOfEdAndSignatures = New Map;
					For Each SignatureFileName IN DataFileSignatures Do
						
						BinaryDataSignatures = GetFromTempStorage(PackageFiles.Get(SignatureFileName));
							
						If ElectronicDocumentsServiceCallServer.PerformCryptoOperationsAtServer()
								OR HasCryptoToolAtServer Then
							// Define cryptography certificates from signature
							SignatureCertificates = CryptoManager.GetCertificatesFromSignature(BinaryDataSignatures);
							If SignatureCertificates.Count() <> 0 Then
								Certificate = SignatureCertificates[0];
								SignatureInstallationDate = ElectronicDocumentsService.SignatureInstallationDate(BinaryDataSignatures);
								SignatureInstallationDate = ?(ValueIsFilled(SignatureInstallationDate), SignatureInstallationDate, CurrentSessionDate());
								UserPresentation = DigitalSignatureClientServer.SubjectPresentation(Certificate);
								PrintBase64 = Base64String(Certificate.Imprint);
								ElectronicDocumentsServiceCallServer.AddInformationAboutSignature(
																AddedFile,
																BinaryDataSignatures,
																PrintBase64,
																SignatureInstallationDate,
																"",
																SignatureFileName,
																UserPresentation,
																Certificate.Unload());
									
							EndIf;
						Else
							ArrayDataSignatures.Add(BinaryDataSignatures);
						EndIf;
					EndDo;
					If ElectronicDocumentsServiceCallServer.PerformCryptoOperationsAtServer()
							OR HasCryptoToolAtServer Then
						ElectronicDocumentsServiceCallServer.DetermineSignaturesStatuses(AddedFile);
					Else
						AccordanceOfEdAndSignatures.Insert(AddedFile, ArrayDataSignatures);
					EndIf;
				EndIf;
				AddedFilesArray.Add(AddedFile);
				
			EndIf;
			
		EndIf;
		
		DeleteFiles(FolderForDetails);
		
		// Add information about the attached file to the document of electronic documents package.
		For Each AddedFile IN AddedFilesArray Do
			NewElectronicDocument = PackageEDObject.ElectronicDocuments.Add();
			NewElectronicDocument.ElectronicDocument = AddedFile;
			NewElectronicDocument.OwnerObject = AddedFile.FileOwner;
		EndDo;
		
		If CryptoManager <> Undefined Then
			ConfirmedDocuments = ElectronicDocumentsService.ProcessDocumentConfirmations(
												PackageFiles, MapFileParameters, PackageEDObject);
			For Each ConfirmedDocument IN ConfirmedDocuments Do
				AddedFilesArray.Add("Confirmation " + String(ConfirmedDocument));
			EndDo;
		EndIf;
		
		PackageEDObject.Write();
		
		Return AddedFilesArray;
	Except
		ErrorFlag = True;
		
		DeleteFiles(EncryptedArchiveFile);
		DeleteFiles(FolderForDetails);
		
		MessageText = BriefErrorDescription(ErrorInfo())
			+ NStr("en=' (see details in Event log monitor).';ru=' (подробности см. в Журнале регистрации).'");
		ErrorText = DetailErrorDescription(ErrorInfo());
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED package Unpacking';ru='распаковка пакета ЭД'"),
																					ErrorText,
																					MessageText);
		
		Return Undefined;
	EndTry;
	
EndFunction

Function ReturnSignaturesPresentationsArray(PresentationArray)
	
	ReturnArray = New Array;
	For Each Item IN PresentationArray Do
		ReturnArray.Add(Item);
	EndDo;
	
	Return ReturnArray;
	
EndFunction

Function GetDataFileName(PathString)
	
	PositionSlash = Find(PathString, "/");
	While PositionSlash > 0 Do
		PathString = Mid(PathString, PositionSlash + 1);
		PositionSlash = Find(PathString, "/");
	EndDo;
	Return PathString;
	
EndFunction

// For internal use only
Function GetCorrespondingFileParameters(FileTransportInfo, CardFile) Export
	
	PathsToSignaturesArray = New Array;
	AdditDataSignatures = New Array;
	ConformityOfReturn  = New Map;
	StructureAttachments = New Structure("Signatures, UUID, EDNumber, TransactionCode, ScheduleCode,
		|AdditData, ConfirmationRequired, EDTINumber, DocumentType, RandomED");
	TransactionCode = "";
	RegulationsCode = "";
	EDCardType = Enums.EDTypes.Other;
	EDCardNumber = String(New UUID);
	EDNumber = "";
	AdditDataStructure = New Structure;
	ConfirmationRequired = True;
	RandomED = False;
	
	XMLObject = New XMLReader;
	ValuesStructure = New Structure;
	
	Try
		XMLObject.OpenFile(CardFile.FullName);
		ED = XDTOFactory.ReadXML(XMLObject,
			GetCMLValueType("Card", ""));
		XMLObject.Close();
		If ED.Identifiers.ExternalIdentifier <> Undefined Then
			EDCardNumber = ED.Identifiers.ExternalIdentifier;
		EndIf;
		If ED.Description <> Undefined Then
			If ED.Description.AdditionalInformation <> Undefined AND ED.Description.AdditionalInformation.AdditionalParameter <> Undefined Then
				AdditParametersStructure = New Structure;
				For Each Property IN ED.Description.AdditionalInformation.AdditionalParameter Do
					AdditParametersStructure.Insert(Property.Name, Property.Value);
				EndDo;
				If AdditParametersStructure.Count() > 0 Then
					AdditDataStructure.Insert("AdditParameters", AdditParametersStructure);
				EndIf;
			EndIf;
			// Define the title of arbitrary ED.
			RandomED = True;
			If ED.Description.Properties().Get("Title") <> Undefined Then
				RandomED = (ED.Description.Title = String(Enums.EDKinds.RandomED));
			EndIf;
				
			CommentED = ED.Description.Comment;
		EndIf;
		If ED.Type <> Undefined Then
			EDCardType = DocumentTypeByTakscomLine(ED.Type.Name);
			If ED.Type.ResignRequired <> Undefined Then
				ConfirmationRequired = Boolean(ED.Type.ResignRequired);
			EndIf;
		EndIf;
	Except
		XMLObject.Close();
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			CardFile.FullName, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
	Try
		XMLObject.OpenFile(FileTransportInfo.FullName);
		ED = XDTOFactory.ReadXML(XMLObject,
			GetCMLValueType("ContainerDescription", ""));
		XMLObject.Close();
		For Each DocFlow IN ED.DocFlow Do
			EDTINumber = DocFlow.Id;
			For Each Document IN DocFlow.Documents.Document Do
				TransactionCode = Document.TransactionCode;
				RegulationsCode = Document.ReglamentCode;
				EDNumber = ?(Find(TransactionCode, "Resign") > 0, EDCardNumber, EDTINumber);
				
				// Define arbitrary document by ED type in the card and the transaction code in meta.
				If TransactionCode = "MainDocument" AND RandomED Then
					AdditDataStructure.Insert("CommentED", CommentED);
				EndIf;
				
				PathToDocument = "";
				If Document.Files.MainImage <> Undefined Then
					PathToDocument = GetDataFileName(Document.Files.MainImage.Path);
				EndIf;
				If Document.Files.MainImageSignature <> Undefined Then
					PathsToSignaturesArray.Clear();
					For Each Signature IN Document.Files.MainImageSignature Do
						SignaturePresentation = GetDataFileName(Signature.Path);
						If Not ValueIsFilled(PathToDocument) Then
							// If MainImage - empty, hence a container with confirmation (signature) has arrived.
							StructureAttachments = New Structure();
							StructureAttachments.Insert("Signatures",       ReturnSignaturesPresentationsArray(PathsToSignaturesArray));
							StructureAttachments.Insert("UniqueId",  EDNumber);
							StructureAttachments.Insert("EDNumber",       EDCardNumber);
							StructureAttachments.Insert("TransactionCode", TransactionCode);
							StructureAttachments.Insert("RegulationsCode", RegulationsCode);
							StructureAttachments.Insert("AddData",     AdditDataStructure);
							StructureAttachments.Insert("EDTINumber",     EDTINumber);
							StructureAttachments.Insert("DocumentType",  EDCardType);
							StructureAttachments.Insert("RandomED",RandomED);
							AddDataToMap(ConformityOfReturn, SignaturePresentation, StructureAttachments);
						Else
							PathsToSignaturesArray.Add(SignaturePresentation);
						EndIf;
					EndDo;
				EndIf;
				
				If Document.Files.DataImage <> Undefined Then
					AdditDataSignatures.Clear();
					If Document.Files.DataImageSignature <> Undefined Then
						For Each Signature IN Document.Files.DataImageSignature Do
							AdditDataSignatures.Add(GetDataFileName(Signature.Path));
						EndDo;
					EndIf;
					AdditDataStructure.Insert("AdditDataFile", GetDataFileName(Document.Files.DataImage.Path));
					AdditDataStructure.Insert("AdditDataSignatures", AdditDataSignatures);
				EndIf;
				If ValueIsFilled(PathToDocument) Then
					AddDataToMap(ConformityOfReturn, PathToDocument,
						New Structure("Signatures, UniqueId, EDNumber, TransactionCode, ScheduleCode,
										|AdditData, ConfirmationRequired, DocumentType, RandomED",
										ReturnSignaturesPresentationsArray(PathsToSignaturesArray), EDNumber, EDCardNumber, TransactionCode,
											RegulationsCode, AdditDataStructure, ConfirmationRequired, EDCardType, RandomED));
				EndIf;
			EndDo;
		EndDo;
	Except
		XMLObject.Close();
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			FileTransportInfo.FullName, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		ConformityOfReturn.Clear();
	EndTry;
	
	Return ConformityOfReturn;
	
EndFunction

Function ConvertFilesArrayIntoBinaryData(FilesArray)
	
	ReturnArray = New Array;
	For Each DataFile IN FilesArray Do
		
		ArrayStructure = New Structure;
		ArrayStructure.Insert("BinaryData",        New BinaryData(DataFile.FullName));
		ArrayStructure.Insert("FileDescriptionWithoutExtension", DataFile.BaseName);
		ArrayStructure.Insert("FileName",              DataFile.Name);
		ReturnArray.Add(ArrayStructure);
	EndDo;
	
	Return ReturnArray;
	
EndFunction

Function DetermineDataTypeByTransactionCode(TransactionCode)
	
	// Kinds of incoming ED and corresponding transaction codes:
	// ED       MainDocument
	// Signature  MainDocumentResign
	// ED(ESF)  Invoice
	// PDPESF  PostDateConfirmation
	// IPESF  ReceiveNotice  UUESF
	// CorrectionNotice  IPUUESF  CorrectionNoticeReceiveNotice
	// PDOESF  SendConfirmation
	// PDOIPESF  ReceiveNoticePostDateConfirmation
	// POA
	// CancellationOffer
	
	If TransactionCode = "MainDocument" OR TransactionCode = "Invoice"
		OR TransactionCode = "VendorTitle" OR TransactionCode = "CustomerTitle" Then
		
		ReturnValue = "ED";
	ElsIf Find(TransactionCode, "Resign") > 0 Then
		ReturnValue = "Signature";
	ElsIf TransactionCode = "CancellationOffer" Then
		ReturnValue = "CancellationOffer";
	Else
		ReturnValue = "ServiceED";
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Function ParseDateString(ParseParameter)
	
	Return Mid(ParseParameter, 7, 4) + Mid(ParseParameter, 4, 2) + Mid(ParseParameter, 1, 2);
	
EndFunction

Function GenerateEDFileStructure()
	
	EDFileStructure = New Structure();
	EDFileStructure.Insert("EDOwner");
	EDFileStructure.Insert("Counterparty");
	EDFileStructure.Insert("EDKind");
	EDFileStructure.Insert("EDDirection");
	
	EDFileStructure.Insert("EDAgreement");
	EDFileStructure.Insert("Company");
	EDFileStructure.Insert("EDNumber");
	EDFileStructure.Insert("EDVersionNumber");
	EDFileStructure.Insert("VersionPointTypeED");
	EDFileStructure.Insert("SenderDocumentNumber");
	EDFileStructure.Insert("SenderDocumentDate");
	
	If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
		EDFileStructure.Insert("Partner");
	EndIf;
	EDFileStructure.Insert("EDOwnerStatus");
	EDFileStructure.Insert("ErrorDescription");
	EDFileStructure.Insert("CorrectionText");
	EDFileStructure.Insert("AdditionalInformation");
	
	// Mandatory parameters for filling.
	EDFileStructure.Insert("MandatoryParameters","EDOwner, Counterparty, EDKind, EDDirection");
	
	Return EDFileStructure;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Exchange format

Function GenerateCardTakskomCML(DataTree, ErrorText)
	
	PathToDescription = "{http://api-invoice.taxcom.en/card}.Card";
	Try
		Card = GetCMLObjectType(PathToDescription);
		
		SubscriberSender = GetCMLObjectType(PathToDescription + ".Sender.Abonent");
		FillXDTOProperty(SubscriberSender, "Id", TreeAttributeValue(DataTree, "Sender.ID"), , ErrorText);
		FillXDTOProperty(SubscriberSender, "Name",
			TreeAttributeValue(DataTree, "Sender.Name"), , ErrorText);
		FillXDTOProperty(SubscriberSender, "Inn", TreeAttributeValue(DataTree, "Sender.TIN"), , ErrorText);
		FillXDTOProperty(SubscriberSender, "ContractNumber",
			TreeAttributeValue(DataTree, "Sender.ContractNumber"), , ErrorText);
		
		Sender = GetCMLObjectType(PathToDescription + ".Sender");
		FillXDTOProperty(Sender, "Abonent", SubscriberSender, , ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "Recipient.Type")) Then
			SubscriberReceiver  = GetCMLObjectType(PathToDescription + ".Receiver.Organization");
			
			FillXDTOProperty(SubscriberReceiver, "Name",
				TreeAttributeValue(DataTree, "Recipient.Name"), , ErrorText);
			FillXDTOProperty(SubscriberReceiver, "Type",
				TreeAttributeValue(DataTree, "Recipient.Type"), , ErrorText);
			PropertyName = "Organization";
		Else
			SubscriberReceiver  = GetCMLObjectType(PathToDescription + ".Receiver.Abonent");
			
			FillXDTOProperty(SubscriberReceiver, "Id", TreeAttributeValue(DataTree, "Recipient.ID"), , ErrorText);
			FillXDTOProperty(SubscriberReceiver, "Name",
				TreeAttributeValue(DataTree, "Recipient.Name"), , ErrorText);
			FillXDTOProperty(SubscriberReceiver, "Inn", TreeAttributeValue(DataTree, "Recipient.TIN"), , ErrorText);
			FillXDTOProperty(SubscriberReceiver, "ContractNumber",
				TreeAttributeValue(DataTree, "Recipient.ContractNumber"), , ErrorText);
			PropertyName = "Abonent";
		EndIf;
		
		Recipient  = GetCMLObjectType(PathToDescription + ".Receiver");
		FillXDTOProperty(Recipient, PropertyName, SubscriberReceiver, , ErrorText);
		
		FillXDTOProperty(Card, "Sender", Sender, , ErrorText);
		FillXDTOProperty(Card, "Receiver", Recipient, , ErrorText);
		
		IDs = GetCMLObjectType(PathToDescription + ".Identifiers");
		FillXDTOProperty(IDs, "ExternalIdentifier",
			TreeAttributeValue(DataTree, "Definition.ExternalIdentifier"), , ErrorText);
		FillXDTOProperty(Card, "Identifiers", IDs, , ErrorText);
		
		Type = GetCMLObjectType(PathToDescription + ".Type");
		FillXDTOProperty(Type, "Name", TreeAttributeValue(DataTree, "Definition.Name"), , ErrorText);
		FillXDTOProperty(Type, "ResignRequired",
			TreeAttributeValue(DataTree, "Definition.ItIsRequiredToSignAgain"), , ErrorText);
			
		Definition = GetCMLObjectType(PathToDescription + ".Description");
		FillXDTOProperty(Definition, "Title", TreeAttributeValue(DataTree, "Definition.Title"), , ErrorText);
		FillXDTOProperty(Definition, "Date", TreeAttributeValue(DataTree, "Definition.Date"), , ErrorText);
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "Definition.Comment")) Then
			FillXDTOProperty(Definition, "Comment", TreeAttributeValue(DataTree, "Definition.Comment"), , ErrorText);
		EndIf;
		
		TableRowAdditionalInformation = DataTree.Rows.Find("Description.AdditionalData", "FullPath", True);
		If ValueIsFilled(TableRowAdditionalInformation.Value) Then
			DescriptionAdditData = GetCMLObjectType(PathToDescription + ".Description.AdditionalInformation");
			For Each RowOptionalData IN TableRowAdditionalInformation.Rows Do
				AddData = GetCMLObjectType(PathToDescription + ".Description.AdditionalInformation.AdditionalParameter");
				
				FillXDTOProperty(AddData, "Name",
					TreeAttributeValue(RowOptionalData, "Definition.AdditionalInformation.LineNumber.Name"), , ErrorText);
				FillXDTOProperty(AddData, "Value",
					TreeAttributeValue(RowOptionalData, "Definition.AdditionalInformation.LineNumber.Value"), , ErrorText);
				DescriptionAdditData.AdditionalParameter.Add(AddData);
			EndDo;
			
			FillXDTOProperty(Definition, "AdditionalInformation", DescriptionAdditData, , ErrorText);
		EndIf;
		
		FillXDTOProperty(Card, "Type", Type, , ErrorText);
		FillXDTOProperty(Card, "Description", Definition, , ErrorText);
		
		Card.Validate();
		
		FileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		ExportEDtoFile(Card, FileName, False);
		
		Return FileName;
	Except
		
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Takskom card generation';ru='Формирование карточки такском'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		Return "";
	EndTry;
	
EndFunction

Function GenerateTransportInformationTakskomCML(DataTree, ErrorText)
	
	PathToDescription = "{http://api-invoice.taxcom.en/meta}.ContainerDescription";
	Try
		
		ContainerDescription = GetCMLObjectType(PathToDescription);
		
		DocumentManagement = GetCMLObjectType(PathToDescription + ".DocFlow");
		FillXDTOProperty(DocumentManagement, "ID", TreeAttributeValue(DataTree, "ID"), , ErrorText);
		
		SchemaDocuments  = GetCMLObjectType(PathToDescription + ".DocFlow.Documents");
		Document     = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document"); 
		
		FillXDTOProperty(Document, "TransactionCode",
			TreeAttributeValue(DataTree, "Document.TransactionCode"), , ErrorText);
		FillXDTOProperty(Document, "ReglamentCode",
			TreeAttributeValue(DataTree, "Document.RegulationsCode"), , ErrorText);
		
		Files = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files");
		If ValueIsFilled(TreeAttributeValue(DataTree, "Document.MainFile.Path")) Then
			DataFile = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files.MainImage");
			FileName = TreeAttributeValue(DataTree, "Document.MainFile.Name");
			If ValueIsFilled(FileName) Then
				FillXDTOProperty(DataFile, "Name", FileName, , ErrorText);
			EndIf;
			FillXDTOProperty(DataFile, "Path", TreeAttributeValue(DataTree, "Document.MainFile.Path"),
				True, ErrorText);
			FillXDTOProperty(Files, "MainImage", DataFile, , ErrorText);
		EndIf;
		
		TableRowSignaturesMainFile = DataTree.Rows.Find("Document.SignatureMainFile", "FullPath", True);
		If ValueIsFilled(TableRowSignaturesMainFile.Value) Then
			For Each StrSignature IN TableRowSignaturesMainFile.Rows Do
				Signature = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files.MainImageSignature");
				FileName = TreeAttributeValue(StrSignature, "Document.MainFileSignatures.LineNumber.Name");
				If ValueIsFilled(FileName) Then
					FillXDTOProperty(Signature, "Name", FileName, , ErrorText);
				EndIf;
				Path = TreeAttributeValue(StrSignature, "Document.MainFileSignatures.LineNumber.Path");
				FillXDTOProperty(Signature, "Path", Path, True, ErrorText);
				Files.MainImageSignature.Add(Signature);
			EndDo;
		EndIf;
		
		If ValueIsFilled(TreeAttributeValue(DataTree, "Document.AdditionalFile.Path")) Then
			DataFile = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files.DataImage");
			FileName = TreeAttributeValue(DataTree, "Document.AdditionalFile.Name");
			If ValueIsFilled(FileName) Then
				FillXDTOProperty(DataFile, "Name", FileName, , ErrorText);
			EndIf;
			FillXDTOProperty(DataFile, "Path", TreeAttributeValue(DataTree, "Document.AdditionalFile.Path"),
			True, ErrorText);
			FillXDTOProperty(Files, "DataImage", DataFile, , ErrorText);
			
			TableRowAdditionalFileSignatures = DataTree.Rows.Find("Document.SignatureAdditionalFile", "FullPath", True);
			If ValueIsFilled(TableRowAdditionalFileSignatures.Value) Then
				
				For Each StrSignature IN TableRowAdditionalFileSignatures.Rows Do
					Signature = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files.DataImageSignature");
					FileName = TreeAttributeValue(DataTree, "Document.AdditionalFileSignatures.LineNumber.Name");
					If ValueIsFilled(FileName) Then
						FillXDTOProperty(Signature, "Name", FileName, , ErrorText);
					EndIf;
					FillXDTOProperty(Signature, "Path", TreeAttributeValue(DataTree, "Document.AdditionalFileSignatures.LineNumber.Path"),
					True, ErrorText);
					Files.DataImageSignature.Add(Signature);
				EndDo;
			EndIf;
		EndIf;
		
		CardFile = GetCMLObjectType(PathToDescription + ".DocFlow.Documents.Document.Files.ExternalCard");
		FillXDTOProperty(CardFile, "Path", "Card.xml", , ErrorText);
		FillXDTOProperty(Files, "ExternalCard", CardFile, , ErrorText);
		
		FillXDTOProperty(Document, "Files", Files, , ErrorText);
		SchemaDocuments.Document.Add(Document);
		
		FillXDTOProperty(DocumentManagement, "Documents", SchemaDocuments, , ErrorText);
		ContainerDescription.DocFlow.Add(DocumentManagement);
		
		ContainerDescription.Validate();
		
		FileName = ElectronicDocumentsService.TemporaryFileCurrentName("xml");
		ExportEDtoFile(ContainerDescription, FileName, False);
		
		Return FileName;
		
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='Transport information generation';ru='Формирование транспортной информации'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
		Return "";
	EndTry;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ElectronicDocumentsEDFOperators: mechanism of electronic documents exchange.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// PROGRAMMING INTERFACE

////////////////////////////////////////////////////////////////////////////////
// Work with delivery notice

// Generates a package of electronic documents.
//
// Parameters:
//  CurRowPED  - values table - list of electronic documents for inclusion in the package
//
// Returns:
//  ContainerGenerated - Boolean (True - notification is generated, otherwise False)
//
Function GenerateEDAttachedFileEDFOperatorPackage(CurRowPED, AddressDataEncryptedAtClient = Undefined) Export
	
	Return GenerateEDTakskomPackageAttachedFile(CurRowPED, AddressDataEncryptedAtClient);
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED sending

// Function sends the files from the directory "SendingDirectoryAddress".
//
// Parameters:
//  Marker                - binary data, marker received on client;
//  SendingDirectoryAddress - String, full path to the directory with transferred files;
//  ResourceAddress          - String, web service address;
//  EDFProfileSettings    - CatalogRef.EDFProfileSettings - EDF profile settings on which the sending happens;
//  DebuggingFlag - Boolean.
//
// Returns:
//  SendingResult - Number (number of sent documents)
//
Function SendThroughEDFOperator(Marker, SendingDirectoryAddress, ResourceAddress, EDFProfileSettings) Export
	
	Return SendThroughTakskom(Marker, SendingDirectoryAddress, ResourceAddress, EDFProfileSettings);
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// ED receiving

// Get new electronic documents from Taxcom
//
// Parameters:
//  ReturnStructure - structure with fields: "UnpackingParameters,
//  ReturnArray, CallAlert" AgreementsAndCertificatesStructuresMatching - Map - suitability of agreements and structures of the authorization certificates;
//  GetAllList - get ED list without restriction of the
//  selection by date Readmission - Boolean - indication that receipt was recalled due to marker is invalid
//
Procedure GetEDFOperatorNewED(
			ReturnStructure,
			AccAgreementsAndStructuresOfCertificates,
			GetAllList = False,
			Readmission = False) Export
	
	GetNewEDTakskomOperator(
				ReturnStructure,
				AccAgreementsAndStructuresOfCertificates,
				GetAllList,
				Readmission);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Invitations to exchange

// Reads request for invitations from EDF operator.
//
// Parameters:
//  FileName  - String - file
//  name CounterpartiesTable  - values table - list of counterparties
//
Procedure ReadEDFOperatorInvitationRequest(FileName, CounterpartyTable, QueryDateTime, EDFProfileSettings)
	
	ReadInvitationRequestTakskom(FileName, CounterpartyTable, QueryDateTime, EDFProfileSettings);
	
EndProcedure

// Sends request for invitations of EDF operator.
//
// Parameters:
//  TableDataProcessors  - Values table - invitations
//                      table continuation of
//  parameter description AdditParametersStructure  - structure - list of additional parameters
//
// Returns:
//  FileName - String, attachment file name or empty
//
Function OutgoingEDFOperatorInvitationRequest(TableDataProcessors, AdditParametersStructure) Export
	
	Return OutgoingInvitationRequestTakskom(TableDataProcessors, AdditParametersStructure);
	
EndFunction

// Sends information about acceptance or rejection of an invitation to the special operator
// 
// Returns - Boolean (True - operation completed successfully, othewise False)
//
Function AcceptRejectContactThroughEDFOperator(ID, InvitationAccepted, Marker) Export
	
	Return AcceptRejectContactThroughTakskom(ID, InvitationAccepted, Marker);
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Unpacking electronic documents packages

// Returns an array of binary data of electronic documents package contents.
//
// Parameters:
// EDPackage             - DocumentRef.EDPackage - package of
// electronic documents under study, FolderForUnpacking,  - String - path
// to directory, EncryptionParameters - Structure, encryption settings applicable to the package of electronic documents.
//
// Returns:
//  ReturnStructure - array of binary data.
//
Function ReturnArrayBinaryDataPackageOperatorOfEDO(EDPackage) Export
	
	Return ReturnTakskomPackageBinaryDataArray(EDPackage);
	
EndFunction

// Returns - Number (number of processed documents)
Function HandleBinaryDataPackageOperatorOfEDO(
				EDPackage,
				UnpackingData,
				IsCryptofacilityOnClient,
				AccordanceOfEdAndSignatures,
				ReturnStructure) Export
	
	Return HandleBinaryDataPackageTakskom(
					EDPackage,
					UnpackingData,
					IsCryptofacilityOnClient,
					AccordanceOfEdAndSignatures,
					ReturnStructure);
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// EDF operator settings

// Generates the structure of settings for EDF operator
//
// Returns:
//  SettingsStructure   - structure of EDF operator settings.
//
Function EDFOperatorSettingsStructure() Export
	
	Return TakskomSettingsStructure();
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Exchange with EDF operator

Function ArrayOfOwners(EDKindsArray)
	
	Query = New Query;
	Query.Text = "SELECT DISTINCT
	               |	EDAttachedFiles.FileOwner
	               |FROM
	               |	Catalog.EDAttachedFiles AS EDAttachedFiles
	               |WHERE
	               |	EDAttachedFiles.Ref IN(&EDKindsArray)";
	Query.SetParameter("EDKindsArray", EDKindsArray);
	TabRez = Query.Execute().Unload();
	Return TabRez.UnloadColumn("FileOwner");
	
EndFunction

// Work with tree

Procedure InsertValueIntoTree(DataTree, AttributeName, AttributeValue)
	
	NewRow = DataTree.Rows.Find(AttributeName, "FullPath", True);
	If NewRow = Undefined Then
		NewRow = DataTree.Rows.Add();
		LevelNumber = StrOccurrenceCount(AttributeName, ".") + 1;
		NewRow.FullPath = AttributeName;
		NewRow["Level" + LevelNumber] = CommonUseED.ColumnName(AttributeName);
	EndIf;
	NewRow.Value = AttributeValue;

EndProcedure

Procedure AddValueToTree(DataTree, AttributeName, AttributeValue)
	
	NewRow = DataTree.Rows.Add();
	LevelNumber = StrOccurrenceCount(AttributeName, ".") + 1;
	NewRow.FullPath = AttributeName;
	NewRow["Level" + LevelNumber] = CommonUseED.ColumnName(AttributeName);
	NewRow.Value = AttributeValue;

EndProcedure

// For internal use only
Function TreeAttributeValue(DataTree, FullPath, ReportAboutError = True) Export
	
	FoundString = DataTree.Rows.Find(FullPath, "FullPath", True);
	If FoundString <> Undefined Then
		Return FoundString.Value;
	ElsIf ReportAboutError Then
		MessageText = NStr("en='Field in the data tree has not been found by the full path <%1>';ru='Не найдено поле в дереве данных по полному пути <%1>'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessageText, FullPath);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
EndFunction

Procedure AddFTSServiceFields(DataTree, EDStructure)
	
	InsertValueIntoTree(DataTree, "VersProg", "1C:Enterprise 8");
	InsertValueIntoTree(DataTree, "VersForm", "5.01");
	InsertValueIntoTree(DataTree, "IdSen",   EDStructure.Sender);
	InsertValueIntoTree(DataTree, "IdCust",    EDStructure.Recipient);
	
	If EDStructure.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom
		OR EDStructure.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		AddAttributesToEDO(DataTree);
	Else // fill in with the data of Company or zero values as fields must be filled out in the format of FTS
		AddAttributesToEmptyStatementOfEDO(DataTree, EDStructure.Company);
	EndIf;
	CurDateTime = CurrentSessionDate();
	InsertValueIntoTree(DataTree, "DocDate", Format(CurDateTime, "DF=dd.MM.yyyy"));
	InsertValueIntoTree(DataTree, "TempDoc", Format(CurDateTime, "DF=HH.mm.ss"));
	InsertValueIntoTree(DataTree, "EDKind",   EDStructure.EDKind);
	InsertValueIntoTree(DataTree, "CTD",     EDStructure.CTD);
	InsertValueIntoTree(DataTree, "UUID", EDStructure.UUID);
	
	If EDStructure.EDKind = Enums.EDKinds.TORG12Customer
		OR EDStructure.EDKind = Enums.EDKinds.TORG12Seller Then
		InsertValueIntoTree(DataTree, "DescFirstDock", "Goods sale");
		InsertValueIntoTree(DataTree, "RCMDFirstDoc", "0330212");
		InsertValueIntoTree(DataTree, "NumForm",     "TORG-12");
	ElsIf EDStructure.EDKind = Enums.EDKinds.ActCustomer
		OR EDStructure.EDKind = Enums.EDKinds.ActPerformer Then
		
		InsertValueIntoTree(DataTree, "DescFirstDock", "Act of work completion (services rendered)");
	ElsIf EDStructure.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
		
		InsertValueIntoTree(DataTree, "NumForm", "Correction document recipient");
	EndIf;
	YYYYMMDD = StrReplace(Format(CurDateTime, "DF=yyyy-MM-dd"), "-", "");
	FileStructure = New Structure("Prefix, RecipientID, SenderID, YYYYMMDD, UUID",
									 EDStructure.PrefixFileId,
									 EDStructure.Recipient,
									 EDStructure.Sender,
									 YYYYMMDD,
									 EDStructure.UUID);
	InsertValueIntoTree(DataTree, "IdFile", ElectronicDocumentsService.FTSFileName(FileStructure));
	
EndProcedure

// Checks filling of mandatory
// details of the tree Parameters:
//  DataTree - valuesTree - tree with data.
//  ErrorText - String - contains error text
//
Procedure CheckFillObligatoryAttributesRecursively(DataTree, ErrorText, IsTable = False, LineNumber = Undefined)
	
	// If in the tree there is the field ErrorText, then at the
	// stage of tree generation some errors occurred, for example, products and services are unmapped with supplier products and services.
	MappingErrorText = TreeAttributeValue(DataTree, "ErrorText", False);
	If ValueIsFilled(MappingErrorText) Then
		ErrorText = MappingErrorText;
		Return;
	EndIf;
	
	For Each String IN DataTree.Rows Do
		
		If String.Required = "Yes" AND Not ValueIsFilled(String.Value)
										AND Not TypeOf(String.Value) = Type("Number") Then
			ApplicationPresentation = ElectronicDocumentsReUse.ApplicationAttributePresentation(String.SubmissionCode);
			If Not ValueIsFilled(ApplicationPresentation) Then
				ApplicationPresentation = StrReplace(String.FullPath, ".", " - ");
			EndIf;
			If IsTable Then
				ErrorTemplate = NStr("en='Mandatory field is not filled in the table: ""%.1"" in the row %2';ru='Не заполнено обязательное поле таблицы: ""%1."" в строке %2'");
				ErrorText = ErrorText
							+ StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, ApplicationPresentation, LineNumber)
							+ Chars.LF;
			Else
				ErrorTemplate = NStr("en='Mandatory field is not filled: ""%1.""';ru='Не заполнено обязательное поле: ""%1.""'");
				ErrorText = ErrorText
							+ StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, ApplicationPresentation)
							+ Chars.LF;
			EndIf;
			Continue;
		EndIf;
		
		If String.SignOf = "Table" AND String.Required = "Yes" Then
			For Each TableRow IN String.Rows Do
				CheckFillObligatoryAttributesRecursively(TableRow, ErrorText, True, TableRow.Value);
			EndDo
		ElsIf String.SignOf = "Selection" AND String.Required = "Yes" Then
			CheckedString = String.Rows.Find(String.FullPath + "." + String.Value, "FullPath");
			If ValueIsFilled(CheckedString) Then
				CheckFillObligatoryAttributesRecursively(CheckedString, ErrorText);
			Else
				ApplicationPresentation = ElectronicDocumentsReUse.ApplicationAttributePresentation(String.SubmissionCode);
				If Not ValueIsFilled(ApplicationPresentation) Then
					ApplicationPresentation = StrReplace(String.FullPath, ".", " - ");
				EndIf;
				ErrorTemplate = NStr("en='Mandatory field is not filled: ""%1.""';ru='Не заполнено обязательное поле: ""%1.""'");
				ErrorText = ErrorText
							+ StringFunctionsClientServer.SubstituteParametersInString(ErrorTemplate, ApplicationPresentation)
							+ Chars.LF;
			EndIf;
		ElsIf String.SignOf = "Group" AND String.Value = True AND String.Rows.Count() > 0 Then
			CheckFillObligatoryAttributesRecursively(String, ErrorText);
		EndIf;
		
	EndDo;
	
EndProcedure

Function FillParticipantDataFTS(ParticipantXDTO, StringTreeData, ErrorText, TargetNamespaceSchema, ParticipantKind)
	
	DataFilled = False;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType")) Then
		
		IdPr = GetCMLObjectType("ParticipantType.IdPr", TargetNamespaceSchema);
		
		If TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType") = "Individual" Then
			
			PrPP = GetCMLObjectType("ParticipantType.IdPr.PrPP", TargetNamespaceSchema);
			TIN = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.TIN");
			FillXDTOProperty(PrPP, "TINInd", TIN, , ErrorText);
			Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			Surname = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Surname");
			FillXDTOProperty(Initials, "Surname", Surname, True, ErrorText);
			Name = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Name");
			FillXDTOProperty(Initials, "Name", Name, True, ErrorText);
			Patronymic = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Patronymic");
			FillXDTOProperty(Initials, "Patronymic", Patronymic, , ErrorText);
			
			FillXDTOProperty(PrPP, "NameAndSurnameIP", Initials,  , ErrorText);
			FillXDTOProperty(IdPr, "PrPP",  PrPP, , ErrorText);
			If TargetNamespaceSchema = "IAKTPRM2" Then
				PrLP = GetCMLObjectType("ParticipantType.IdPr.PrLP", TargetNamespaceSchema);
				FillXDTOProperty(PrLP, "DescEnt", "---", , ErrorText);
				FillXDTOProperty(IdPr, "PrLP",    PrLP,  , ErrorText);
			EndIf;
			Description = Surname + " " + Name + " " + Patronymic;
		Else
			PrLP = GetCMLObjectType("ParticipantType.IdPr.PrLP", TargetNamespaceSchema);
			Description = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.LegalEntity.CompanyDescription");
			FillXDTOProperty(PrLP, "DescEnt", Description, , ErrorText);
			TIN = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.LegalEntity.TIN");
			FillXDTOProperty(PrLP, "TINLP", TIN, , ErrorText);
			FillXDTOProperty(IdPr, "PrLP",  PrLP, , ErrorText);
			If TargetNamespaceSchema = "IAKTPRM2" Then
				PrPP = GetCMLObjectType("ParticipantType.IdPr.PrPP", TargetNamespaceSchema);
				Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
				FillXDTOProperty(Initials,  "Surname", "---", True, ErrorText);
				FillXDTOProperty(Initials,  "Name",     "---", True, ErrorText);
				FillXDTOProperty(PrPP, "NameAndSurnameIP",   Initials,         , ErrorText);
				FillXDTOProperty(IdPr, "PrPP",    PrPP,        , ErrorText);
			EndIf;
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "IdPr", IdPr, , ErrorText);
		DataFilled = True;
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".OKPO", False)) Then
		FillXDTOProperty(
				ParticipantXDTO,
				"OKPO",
				TreeAttributeValue(StringTreeData, ParticipantKind + ".OKPO"),
				,
				ErrorText);
		DataFilled = True;
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Address")) Then
		Address = StringTreeData.Rows.Find(ParticipantKind + ".Address", "FullPath", True);
		If ValueIsFilled(Address.Value) Then
			FillAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema, ParticipantKind);
		EndIf;
	EndIf;
	
	IsDataToBeFilled = False;
	Contact = GetCMLObjectType("ParticipantType.Contact", TargetNamespaceSchema);
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Contact.Phone")) Then
		Length = Number(GetXDTOschemaFieldProperty(TargetNamespaceSchema, "ParticipantType.Contact", "Phone", XDTOFacetType.MaxLength));
		Value = TrimAll(TreeAttributeValue(StringTreeData, ParticipantKind + ".Contact.Phone"));
		If Length < StrLen(Value) Then
			MessagePattern = NStr("en='Operation execution: Filling of XDTO.
		|Phone number exceeds the permissible length of %1 characters. (%2 %3).';ru='Выполнение операции: Заполнение XDTO.
		|Номер телефона превышает допустимую длину %1 симв. (%2 %3).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, Length, ParticipantKind, Description);
			ErrorText = ?(ValueIsFilled(ErrorText), ErrorText + Chars.LF + MessageText, MessageText);
			ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText, 2);
		Else
			FillXDTOProperty(Contact, "Phone", Value, , ErrorText);
			IsDataToBeFilled = True;
		EndIf;
	EndIf;
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Contact.Fax")) Then
		Length = Number(GetXDTOschemaFieldProperty(TargetNamespaceSchema, "ParticipantType.Contact", "Fax", XDTOFacetType.MaxLength));
		Value = TrimAll(Left(TreeAttributeValue(StringTreeData, ParticipantKind + ".Contact.Fax"), Length));
		If Length < StrLen(Value) Then
			MessagePattern = NStr("en='Operation execution: Filling of XDTO.
		|Fax number exceeds the permissible length of %1 characters. (%2 %3).';ru='Выполнение операции: Заполнение XDTO.
		|Номер факса превышает допустимую длину %1 симв. (%2 %3).'");
			MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern, Length, ParticipantKind, Description);
			ErrorText = ?(ValueIsFilled(ErrorText), ErrorText + Chars.LF + MessageText, MessageText);
			ElectronicDocumentsService.WriteEventOnEDToEventLogMonitor(MessageText, 2);
		Else
			FillXDTOProperty(Contact, "Fax", Value, , ErrorText);
			IsDataToBeFilled = True;
		EndIf;
	EndIf;
	If IsDataToBeFilled Then
		FillXDTOProperty(ParticipantXDTO, "Contact", Contact, , ErrorText);
		DataFilled = True;
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".BankAccount")) Then
		BankingDetails = "AccountNumber, BankName, BIC";
		BankAttributes = GetCMLObjectType("ParticipantType.BankAttr", TargetNamespaceSchema);
		PrBank = GetCMLObjectType("ParticipantType.BankAttr.PrBank", TargetNamespaceSchema);
		
		AccountNo = TreeAttributeValue(StringTreeData, ParticipantKind + ".BankAccount.AccountNo");
		If ValueIsFilled(AccountNo) Then
			FillXDTOProperty(BankAttributes, "AccountNo", AccountNo, ,ErrorText);
		EndIf;
		
		DescBank = TreeAttributeValue(StringTreeData, ParticipantKind + ".BankAccount.DescBank");
		BIN = TreeAttributeValue(StringTreeData, ParticipantKind + ".BankAccount.BIN");
		If ValueIsFilled(DescBank) OR ValueIsFilled(BIN) Then
			If ValueIsFilled(DescBank) Then
				FillXDTOProperty(PrBank, "DescBank", DescBank, ,ErrorText);
			EndIf;
			If ValueIsFilled(BIN) Then
				FillXDTOProperty(PrBank, "BIN", BIN, ,ErrorText);
			EndIf;
		EndIf;
		
		FillXDTOProperty(BankAttributes, "PrBank",   PrBank,              , ErrorText);
		FillXDTOProperty(ParticipantXDTO,        "BankAttr", BankAttributes, , ErrorText);
		DataFilled = True;
	EndIf;

	Return DataFilled;
	
EndFunction

Procedure FillAdditionalInformationFromTreeData(FillingXDTO,
											DataTree,
											Val Prefix,
											ParametersStructure,
											TargetNamespaceSchema,
											PathToInfField,
											AttributeNameInfoFields,
											OwnerItemName,
											LineNumber,
											ErrorText)
	
		AdditDataStructure = New Structure;
		Prefix = Prefix + ?(ValueIsFilled(Prefix), ".", "");
		RowOptionalData = DataTree.Rows.Find(Prefix + "AdditData.Unsigned", "FullPath", True);
		If RowOptionalData = Undefined Then
			RowOptionalData = DataTree.Rows.Find(Prefix + "AdditionalInformationIsNotDigitallySigned", "FullPath", True);
		EndIf;
		For Each Item in RowOptionalData.Rows Do
			AdditDataStructure.Insert(CommonUseED.ColumnName(Item.FullPath), Item.Value);
		EndDo;
		If AdditDataStructure.Count() > 0 Then
			ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, OwnerItemName,
				False, LineNumber);
		EndIf;
		
		AdditDataStructure = New Structure;
		RowOptionalData = DataTree.Rows.Find(Prefix + "AdditData.Signed", "FullPath", True);
		If RowOptionalData = Undefined Then
			RowOptionalData = DataTree.Rows.Find(Prefix + "AdditionalInformationDigitallySigned", "FullPath", True);
		EndIf;
		For Each Item in RowOptionalData.Rows Do
			AdditDataStructure.Insert(CommonUseED.ColumnName(Item.FullPath), Item.Value);
		EndDo;
		
		If AdditDataStructure.Count() > 0 Then
			MaxLength = GetXDTOschemaFieldProperty(
									TargetNamespaceSchema,
									PathToInfField,
									AttributeNameInfoFields,
									XDTOFacetType.MaxLength);
									
			ParametersStructure.Insert("AllowedLengthAddData" + ?(OwnerItemName = "Header", "header", "Rows"),
				MaxLength - 20); // 20 - service characters.
			ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure, AdditDataStructure, OwnerItemName,
				True, LineNumber);
		EndIf;
		
		RowInfoPaul = "";
		AdditFileGenerated = False;
		If TypeOf(ParametersStructure.AdditDataTree) = Type("ValueTree")
			AND ParametersStructure.AdditDataTree.Rows.Count() > 0 Then
			
			// Generate xml string (InfFull):
			If GenerateAdditFileCML(ParametersStructure,
				ErrorText, True, OwnerItemName, LineNumber) Then
				
				RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
				
			EndIf;
			
			// Generate additional file (for rows of tabular section is not generated):
			AdditFileGenerated = (OwnerItemName = "Header"
				AND GenerateAdditFileCML(ParametersStructure, ErrorText, False, OwnerItemName));
					
			If AdditFileGenerated Then
				
				InsertValueIntoTree(DataTree, "AdditFileFullName",     ParametersStructure.AdditFileFullName);
				InsertValueIntoTree(DataTree, "AdditFileIdentifier", ParametersStructure.AdditFileIdentifier);
				
			EndIf;
			
		EndIf;
		If ValueIsFilled(RowInfoPaul) OR AdditFileGenerated Then
			If OwnerItemName = "Header" Then
				InfFul = GetCMLObjectType(PathToInfField, TargetNamespaceSchema);
				If ValueIsFilled(RowInfoPaul) Then
					FillXDTOProperty(InfFul, AttributeNameInfoFields, RowInfoPaul, , ErrorText);
				EndIf;
				If AdditFileGenerated Then
					FillXDTOProperty(InfFul, "IdFileInfFul", String(ParametersStructure.AdditFileIdentifier), , ErrorText);
				EndIf;
				FillXDTOProperty(FillingXDTO, "InfFul", InfFul, , ErrorText);
			ElsIf ValueIsFilled(RowInfoPaul) Then
				FillXDTOProperty(FillingXDTO, AttributeNameInfoFields, RowInfoPaul, , ErrorText);
			EndIf;
		EndIf;
	
EndProcedure

Procedure FillAddress(Counterparty, LocationAddress, ErrorText, TargetNamespaceSchema, ParticipantKind)
		
	AddressType = GetCMLObjectType("AddressType", TargetNamespaceSchema);
	InvoiceSchema = (Find(TargetNamespaceSchema, "SFAKT") <> 0);
	AddressString = LocationAddress.Rows.Find(
												ParticipantKind + ".Address." + LocationAddress.Value,
												"FullPath");
	If LocationAddress.Value = "Structured" Then
		AdrRF = GetCMLObjectType("AddressType.AdrRF", TargetNamespaceSchema);
		FillXDTOProperty(AdrRF, "CodeState", AddressString.Rows[1].Value, InvoiceSchema, ErrorText);
		AddressAttributes = "ZipCode, Region, City, Settlement, Street, House, Block, Apartment";
		For Each String IN AddressString.Rows Do
			AttributeName = CommonUseED.ColumnName(String.FullPath);
			If Find(AddressAttributes, AttributeName) > 0 AND ValueIsFilled(String.Value) Then
				FillXDTOProperty(AdrRF, AttributeName, String.Value, , ErrorText);
			EndIf;
		EndDo;
		FillXDTOProperty(AddressType, "AdrRF", AdrRF, InvoiceSchema, ErrorText);
	ElsIf Not InvoiceSchema AND LocationAddress.Value = "Arbitrary" Then
		// IN the scheme of TORG-12 and the Act address in string form is sent in scheme item "AdrText".
		FillXDTOProperty(AddressType, "AdrText", AddressString.Value, , ErrorText);
	Else
		// IN the scheme of invoice, address is passed as a string in the element of the scheme "AdrFOR".
		AddressXDTO = GetCMLObjectType("AddressType.AdrFRN", TargetNamespaceSchema);
		AddressAttributes = "AdrText, CountryCode";
		For Each String IN AddressString.Rows Do
			AttributeName = CommonUseED.ColumnName(String.FullPath);
			If Find(AddressAttributes, AttributeName) > 0 AND ValueIsFilled(String.Value) Then
				FillXDTOProperty(AddressXDTO, AttributeName, String.Value, , ErrorText);
			EndIf;
		EndDo;
		FillXDTOProperty(AddressType, "AdrFRN", AddressXDTO, InvoiceSchema, ErrorText);
	EndIf;
	
	FillXDTOProperty(Counterparty, "Address", AddressType, InvoiceSchema, ErrorText);
	
EndProcedure

Procedure AddAttributesToEDO(DataTree)
	
	AttributesStructure = EDFOperatorSettingsStructure();
	Description = "";
	TIN = "";
	OperatorIdentifier = "";
	AttributesStructure.Property("Description", Description);
	AttributesStructure.Property("TIN", TIN);
	AttributesStructure.Property("OperatorIdentifier", OperatorIdentifier);
	StringOperatorAttributes = DataTree.Rows.Add();
	StringOperatorAttributes.FullPath = "AttributesOperatorOfEDO";
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.CompName", Description);
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.TINLP",   TIN);
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.EDFId",   OperatorIdentifier);
	
EndProcedure

Procedure AddAttributesToEmptyStatementOfEDO(DataTree, DataByCompany)
	
	Description = NStr("en='without EDO Operator';ru='Без оператора ЭДО'");
	TIN = "1111111117"; // First TIN which fulfills the format requirements
	
	DataLegalIndividual = ElectronicDocumentsOverridable.GetDataLegalIndividual(DataByCompany);
	If ValueIsFilled(DataLegalIndividual.FullDescr) Then
		Description = DataLegalIndividual.FullDescr;
	EndIf;
	If ValueIsFilled(DataLegalIndividual.TIN) Then
		TIN = DataLegalIndividual.TIN;
	EndIf;
	StringOperatorAttributes = DataTree.Rows.Add();
	StringOperatorAttributes.FullPath = "AttributesOperatorOfEDO";
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.CompName", Description);
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.TINLP",   Left(TIN, 10));
	InsertValueIntoTree(StringOperatorAttributes, "EDFOperatorAttributes.EDFId",   "---");
	
EndProcedure

Function InvoiceParametersStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("PackageCode");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("AmountWithoutVAT");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("DiscountAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("CodeCharacteristics");
	ProductsTable.Columns.Add("UsefulTime");
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("BaseUnitCode");
	ProductsTable.Columns.Add("BaseUnitDescription");
	ProductsTable.Columns.Add("BaseUnitDescriptionFull");
	ProductsTable.Columns.Add("BaseUnitInternationalAbbreviation");
	ProductsTable.Columns.Add("PackageDescription");
	ProductsTable.Columns.Add("Factor");
	ProductsTable.Columns.Add("ProductCode");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Barcode");
	ProductsTable.Columns.Add("Definition");
	ProductsTable.Columns.Add("AdditionalAttributes");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("SumWithVAT");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	ParametersStructure.Insert("Consignor");
	ParametersStructure.Insert("ShipperType");
	ParametersStructure.Insert("Consignee");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Id, Name, ProductsAndServices, BasicUnitCode, PackageCode");
	
	Return ParametersStructure;

EndFunction

Function InvoiceForPaymentParametersStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");

	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("VATAmount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	
	ParametersStructure.Insert("PaymentDueDate");
	ParametersStructure.Insert("CompanyBankAcc");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, CurrentAccount");
	
	Return ParametersStructure;

EndFunction

Function OrderParametersResellerStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");

	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("Role");
	ParametersStructure.Insert("NumberBySupplierData");
	ParametersStructure.Insert("DateBySupplierData");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("VATAmount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Id, Name, BasicUnitCode");
	
	Return ParametersStructure;

EndFunction

Function OrderClientParametersStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Role");
	ParametersStructure.Insert("NumberByCustomerData");
	ParametersStructure.Insert("DateByCustomerData");
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("VATAmount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Id, Name, BasicUnitCode");
	
	Return ParametersStructure;

EndFunction

Function PriceListParameterStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("PackageDescription");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");

	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	ParametersStructure.Insert("Definition");
	
	ParametersStructure.Insert("MandatoryFields", "Company, ID, Currency, GenerationDate,
	|Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Id, Name, ProductsAndServices, BasicUnitCode, PackageCode");
	
	Return ParametersStructure;

EndFunction

Function ReportsOfComplitionParametersStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("AmountWithoutVAT");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("DiscountAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("Content");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("DocumentAmount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	Parametersstructure.Insert("VATTaxation");
	ParametersStructure.Insert("NumberBySupplierData");
	ParametersStructure.Insert("DateBySupplierData");
	ParametersStructure.Insert("NumberByCustomerData");
	ParametersStructure.Insert("DateByCustomerData");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Id, Name, ProductsAndServices, BasicUnitCode, PackageCode");
	
	Return ParametersStructure;

EndFunction

Function ComissionGoodsWriteOffReportStructureParameters()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("SumWithVAT");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable",  ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Currency");
	ParametersStructure.Insert("ExchangeRate");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("PriceIncludesVAT");
	ParametersStructure.Insert("VATAmount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	ParametersStructure.Insert("BeginOfPeriod");
	ParametersStructure.Insert("EndOfPeriod");
	ParametersStructure.Insert("PaymentDate");
	ParametersStructure.Insert("VATTaxation");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection");

	Return ParametersStructure;
	
EndFunction

Function TransferOfGoodsBetweenCompaniesStructureParameters()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnitCode");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("PackageDescription");
	ProductsTable.Columns.Add("PackageCode");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");
	ProductsTable.Columns.Add("Factor");
	ProductsTable.Columns.Add("BaseUnitDescription");
	ProductsTable.Columns.Add("BaseUnitDescriptionFull");
	ProductsTable.Columns.Add("BaseUnitInternationalAbbreviation");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	ParametersStructure.Insert("Consignor");
	ParametersStructure.Insert("ShipperType");
	ParametersStructure.Insert("Consignee");
	ParametersStructure.Insert("PriceIncludesVAT");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields",
		"Id, Name, ProductsAndServices, BasicUnitCode, PackageCode");

	Return ParametersStructure;
	
EndFunction

Function ReturnOfGoodsBetweenCompaniesOfStructureParameters()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("Quantity");
	ProductsTable.Columns.Add("PackagingByOKEI");
	ProductsTable.Columns.Add("Package");
	ProductsTable.Columns.Add("Amount");
	ProductsTable.Columns.Add("VATRate");
	ProductsTable.Columns.Add("VATAmount");
	ProductsTable.Columns.Add("SumWithVAT");
	ProductsTable.Columns.Add("Price");
	ProductsTable.Columns.Add("DiscountAmount");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("Number");
	ParametersStructure.Insert("Date");
	ParametersStructure.Insert("Amount");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	ParametersStructure.Insert("Consignor");
	ParametersStructure.Insert("ShipperType");
	ParametersStructure.Insert("Consignee");
	ParametersStructure.Insert("PriceIncludesVAT");
	
	ParametersStructure.Insert("MandatoryFields", "Company, Counterparty,
	|ID, GenerationDate, Number, Date, EDKind, EDDirection, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields",
		"Id, Name, ProductsAndServices, BasicUnitCode, PackageCode");
		
	Return ParametersStructure;
		
EndFunction

// For internal use only
Procedure ReadInvitationRequestTakskom(FileName, CounterpartyTable, QueryDateTime, EDFProfileSettings) Export
	
	XMLObject = New XMLReader;
	MessageText = Undefined;
	QueryDateTime = Format(Date("20000101000000"), "DF='yyyy-MM-dd HH:mm:ss'");
	
	Try
		
		XMLObject.OpenFile(FileName);
		ED = XDTOFactory.ReadXML(XMLObject);
		XMLObject.Close();
		
		QueryDateTime = ED.Asof;
		
		If ED.Properties().Get("Contact") <> Undefined Then
			
			If TypeOf(ED.Contact) = Type("XDTOList") Then
				For Each Contact IN ED.Contact Do
					ReadContact(Contact, CounterpartyTable, EDFProfileSettings);
				EndDo;
			ElsIf TypeOf(ED.Contact) = Type("XDTODataObject") Then
				ReadContact(ED.Contact, CounterpartyTable, EDFProfileSettings);
			EndIf;
			
		EndIf;
		
	Except
		
		XMLObject.Close();
		MessagePattern = NStr("en='Data reading from the file %1 failed: %2 (see details in Events log monitor).';ru='Возникла ошибка при чтении данных из файла %1: %2 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			FileName, BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED reading';ru='Чтение ЭД.'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText);
	EndTry;
	
EndProcedure

// For internal use only
Function DataTableComponentExchangeParticipants(AccAgreementsAndStructuresOfCertificates) Export
	
	ResourceAddress = "GetContactListUpdates";
	InvitationsTable = InitExchangeParticipantsDataTable();
	
	For Each Item IN AccAgreementsAndStructuresOfCertificates Do
		
		EDFProfileSettings = Item.Key;
		CertificateStructure = Item.Value;
		
		Marker = "";
		If TypeOf(CertificateStructure) = Type("Structure") Then
			CertificateStructure.Property("MarkerTranscribed", Marker);
		EndIf;
		If Not ValueIsFilled(Marker) Then
			Continue;
		EndIf;
		
		AllEntriesReceived = False;
		
		LastQueryDate = Format(LastInvitationsDateReceived(EDFProfileSettings), "DF='yyyy-MM-dd HH:mm:ss'");
		While Not AllEntriesReceived Do
			AddressResourceFull = ResourceAddress + "?date=" + LastQueryDate + "&status=ContactStatus.Incoming";
			
			FileInvitation = GetThroughTakskom(AddressResourceFull, , Marker);
			If FileInvitation = Undefined Then
				Break;
			EndIf;
				
			LineNumbersOfTVToReading = InvitationsTable.Count();
			ReadEDFOperatorInvitationRequest(FileInvitation, InvitationsTable, LastQueryDate, EDFProfileSettings);
			DeleteFiles(FileInvitation);
				
			If LineNumbersOfTVToReading = InvitationsTable.Count() Then
				AllEntriesReceived = True;
			EndIf;
		EndDo;
	EndDo;
	
	Return InvitationsTable;
	
EndFunction

// For internal use only
Function InitExchangeParticipantsDataTable() Export
	
	KS12 = New StringQualifiers(12);
	CS255 = New StringQualifiers(255);
	KS1024 = New StringQualifiers(1024);
	CD = New DateQualifiers(DateFractions.DateTime);
	
	Array = New Array;
	Array.Add(Type("String"));
	
	TypeDescriptionC12 = New TypeDescription(Array, , KS12);
	TypeDescriptionWith255 = New TypeDescription("String", , CS255);
	TypeDescriptionS1024 = New TypeDescription("String", , KS1024);
	TypeDescriptionDate = New TypeDescription("Date", , , CD);
	TypeDescriptionEDFProfileSettings = New TypeDescription("CatalogRef.EDFProfileSettings");
	TypeDescriptionParticipantsStatuses = New TypeDescription("EnumRef.EDExchangeMemberStatuses");
	
	VT = New ValueTable;
	VT.Columns.Add("EDFProfileSettings", TypeDescriptionEDFProfileSettings);
	VT.Columns.Add("Description",  TypeDescriptionWith255);
	VT.Columns.Add("TIN",           TypeDescriptionC12);
	VT.Columns.Add("ID", TypeDescriptionWith255);
	VT.Columns.Add("InvitationText", TypeDescriptionS1024);
	VT.Columns.Add("State",     TypeDescriptionParticipantsStatuses);
	VT.Columns.Add("ErrorDescription",TypeDescriptionWith255);
	VT.Columns.Add("Changed",       TypeDescriptionDate);
	VT.Columns.Add("ExternalID",     TypeDescriptionWith255);
	
	Return VT;
	
EndFunction

Function LastInvitationsDateReceived(EDFProfileSettings)
	
	RequiredData = Date("20000101000000");
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	EDExchangeStatesThroughEDFOperators.LastInvitationsDateReceived
	|FROM
	|	InformationRegister.EDExchangeStatesThroughEDFOperators AS EDExchangeStatesThroughEDFOperators
	|WHERE
	|	EDExchangeStatesThroughEDFOperators.EDFProfileSettings = &EDFProfileSettings
	|	AND EDExchangeStatesThroughEDFOperators.DeleteAgreementAboutEDUsage = VALUE(Catalog.EDUsageAgreements.EmptyRef)";
	Query.SetParameter("EDFProfileSettings", EDFProfileSettings);
	Result = Query.Execute().Select();
	
	If Result.Next() Then
		RequiredData = ?(Result.LastInvitationsDateReceived = Date("00000000000000"),
			Date("20000101000000"), Result.LastInvitationsDateReceived);
	EndIf;
	
	Return RequiredData;
	
EndFunction

// Generates electonic document of products directory by reference to IB document.
//
// Parameters:
//  ObjectReference - Reference to IB object by which the electronic
//  document shall be generated, DirectoryProducts - values table that contains
//  the list of products and services, EDSign      - Boolean, a flag showing that the structure of electronic document attributes shall be returned.
//
Function DeleteGenerateProductsAndServicesCatalog(ObjectReference, ProductsDirectory, EDExchangeSettings, ASignOfED = True) Export
	
	ReturnValue = Undefined;
	ErrorText = "";
	
	EDStructure = New Structure;
	EDStructure.Insert("EDKind", Enums.EDKinds.ProductsDirectory);
	EDStructure.Insert("EDDirection", Enums.EDDirections.Outgoing);
	EDStructure.Insert("Sender", EDExchangeSettings.CompanyID);
	EDStructure.Insert("Recipient", EDExchangeSettings.CounterpartyID);
	EDStructure.Insert("EDVersionNumber", ElectronicDocumentsService.EDVersionNumberByOwner(ObjectReference));
	EDStructure.Insert("EDNumber", ReturnEDId(ObjectReference, EDStructure.Sender, EDStructure.EDVersionNumber));
	EDStructure.Insert("EDDate", CurrentSessionDate());
	EDStructure.Insert("EDOwner", ObjectReference);
	EDStructure.Insert("SenderDocumentDate", CurrentSessionDate());
	EDStructure.Insert("Company", ObjectReference.Company);
	EDStructure.Insert("Counterparty", ObjectReference.Counterparty);
	EDStructure.Insert("EDFProfileSettings", EDExchangeSettings.EDFProfileSettings);
	EDStructure.Insert("EDAgreement", EDExchangeSettings.EDAgreement);
	
	ParametersStructure = DeleteDirectoryProductsParametersStructure();
	ElectronicDocumentsOverridable.PrepareDataByProductsDirectory(ObjectReference,
																			ProductsDirectory,
																			EDStructure,
																			ParametersStructure);
	
	If CheckRequiredFieldsFilling(ObjectReference, ParametersStructure, ErrorText) Then
		
		DirectoryAddress = ElectronicDocumentsService.WorkingDirectory(, ObjectReference.UUID());
		ParametersStructure.Insert("FullFileName",
			DirectoryAddress + DetermineEDFileName(EDStructure.EDKind, ObjectReference, EDStructure.EDDate));
		
		If DeleteGenerateCMLCatalog(ParametersStructure) AND ASignOfED Then
			ParametersStructure.Insert("EDStructure", EDStructure);
			ReturnValue = ParametersStructure;
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorText) Then
		MessagePattern = NStr("en='During the generation %1 the
		|following  errors occurred: %2';ru='При формировании %1 возникли следующие ошибки: %2'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(MessagePattern,
			EDStructure.EDKind, ErrorText);
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return ReturnValue;
	
EndFunction

Procedure DeleteReadDirectoryXDTO(ED, ParseTree, NewED, Error)
	
	NewED.ID = ED.ID;
	NewED.EDKind = Enums.EDKinds.ProductsDirectory;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.ID);
	
	// Fill in the information about the owner of the directory.
	// Counterparty
	Item = ED.Owner;
	CounterpartyAttributes = New Structure;
	For Each CurProperty IN Item.Properties() Do
		
		DataVal = Item[CurProperty.Name];
		
		If TypeOf(DataVal) = Type("XDTODataValue") OR TypeOf(DataVal) = Type("XDTODataObject") Then
		ElsIf Not ValueIsFilled(DataVal) Then
			Continue;
		EndIf;
		
		If Upper(CurProperty.Name) = Upper("ID") Then 
			
			CounterpartyId = DataVal;
			// Parse ID for TIN
			SearchStructure = ParseCounterpartyID(CounterpartyId);
			If SearchStructure.Property("TIN") Then
				CounterpartyAttributes.Insert("TIN", SearchStructure.TIN);
			EndIf;
			
		ElsIf Upper(CurProperty.Name) = Upper("LegalEntity") OR Upper(CurProperty.Name) = Upper("Ind") Then
			ParticipantAttributes = DataVal;
			For Each ParticipantProperty IN ParticipantAttributes.Properties() Do
				ParticipantAttribute = ParticipantAttributes[ParticipantProperty.Name];
				If ParticipantAttribute <> Undefined Then
					If Upper(ParticipantProperty.Name) = Upper("LegalAddress")
						OR Upper(ParticipantProperty.Name) = Upper("RegistrationAddress") Then
						
						CounterpartyAttributes.Insert(ParticipantProperty.Name + "_Presentation", ParticipantAttribute.Presentation);
					ElsIf Upper(ParticipantProperty.Name) = Upper("OfficialName")
						OR Upper(ParticipantProperty.Name) = Upper("FullDescr") Then
						
						CounterpartyAttributes.Insert("FullDescr", ParticipantAttribute);
					Else
						CounterpartyAttributes.Insert(ParticipantProperty.Name, ParticipantAttribute);
					EndIf;
				EndIf;
			EndDo;
		Else
			CounterpartyAttributes.Insert(CurProperty.Name, DataVal);
		EndIf;
		
	EndDo;
	
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Counterparties");
	Counterparty = ElectronicDocumentsOverridable.FindRefToObject("Counterparties", CounterpartyId,
		CounterpartyAttributes, ED.ID);
	FoundString = FindCreateStringInParsedTree(FoundTypeInTree, CounterpartyId, "TIN: " + CounterpartyId,
		Counterparty, CounterpartyAttributes, ParseTree, Error);
	AddObjectHeaderAttribute(NewED, "Counterparty", FoundString.RowIndex);
	AddObjectHeaderAttribute(NewED, "GeneratingDate", ED.GeneratingDate);
	
	If ElectronicDocumentsReUse.UseAdditionalAnalyticsOfCompaniesCatalogPartners() Then
		AttributesOfPartner = New Structure();
		AttributesOfPartner.Insert("Counterparty", Counterparty);
		AppliedCatalogName = ElectronicDocumentsServiceCallServer.GetAppliedCatalogName("partners");
		
		ValAdditAnalytics = ElectronicDocumentsOverridable.FindRefToObject(AppliedCatalogName, , AttributesOfPartner);
		If ValueIsFilled(ValAdditAnalytics) Then
			FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "partners");
			FoundString = FindCreateStringInParsedTree(FoundTypeInTree, ValAdditAnalytics.Code, "Code: "
				+ ValAdditAnalytics.Code, ValAdditAnalytics, AttributesOfPartner, ParseTree, Error);
			AddObjectHeaderAttribute(NewED, "Partner", FoundString.RowIndex);
		EndIf;
	EndIf;
	
	// Fill in data about catalog products.
	DataSet = ED["Products"].Product;
	ReadDataByCatalogueProduct(DataSet, ED, ParseTree, NewED, Error);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Filling in xsd scheme branches of CML2 version

// Function fills in XDTO list with the values of values tree row, the
// names of which match the names of list items (attributes) of a simple type (string, number, ...).
//
// Parameters:
//  TreeRow - value tree row - String data source.
//  NameOfRootNode - String - name of XDTO root object, the item of which is populated XDTO list.
//  NodeName - String - name of XDTO list.
//  TargetNamespaceSchema - String - namespaces.
//  ErrorText - String - contains text of the error which occurred during filling of the object.
//
// Returns:
//  Undefined, XDTOObject - if the list is not filled in - then it is undefined.
//
Function FillXDTOListWithSameNameTreeParameters(TreeRow, NameOfRootNode, NodeName, TargetNamespaceSchema, ErrorText)
	
	NodeIsFull = False;
	DataLevel = "";
	For Each CurColumn IN TreeRow.Owner().Columns Do
		ColumnName = CurColumn.Name;
		If Find(ColumnName, "Level") > 0 AND ValueIsFilled(TreeRow[ColumnName]) Then
			CurLevel = Number(Mid(ColumnName, 8));
			If CurLevel > 0 Then
				CurLevel = CurLevel + 2; // T.k. next level "LineNumber".
				DataLevel = "Level" + CurLevel;
			EndIf;
		EndIf;
	EndDo;
	If ValueIsFilled(DataLevel) Then
		Attribute = GetCMLObjectType(NameOfRootNode, TargetNamespaceSchema);
		For Each CurRow IN TreeRow.Rows Do
			Node = GetCMLObjectType(NameOfRootNode + "." + NodeName, TargetNamespaceSchema);
			For Each CurProperty IN Node.Properties() Do
				ParameterValue = CurRow.Rows.Find(CurProperty.Name, DataLevel);
				If IsSimpleTypeItemXDTO(Node[CurProperty.Name])
					AND ParameterValue <> Undefined
					AND ValueIsFilled(ParameterValue.Value) Then
					Required = ValueIsFilled(CurProperty.LowerBound);
					FillXDTOProperty(Node, CurProperty.Name, ParameterValue.Value, Required, ErrorText);
					NodeIsFull = True;
				EndIf;
			EndDo;
			Attribute[NodeName].Add(Node);
		EndDo;
	EndIf;
	If Not NodeIsFull Then
		Attribute = Undefined;
	EndIf;
	
	Return Attribute;
	
EndFunction

Procedure GenerateDataByProductCML_206(Product, StringTreeData, TargetNamespaceSchema, ErrorText, FilesArray = Undefined)
	
	// Form product ID.
	ProductId = TreeAttributeValue(StringTreeData, "Products.LineNumber.ProductIdOfCounterparty", False);
	If Not ValueIsFilled(ProductId) Then
		ProductsAndServices = TreeAttributeValue(StringTreeData, "Products.LineNumber.ProductsAndServices");
		ProductsAndServicesID = ProductsAndServices.UUID();
		Characteristic = TreeAttributeValue(StringTreeData, "Products.LineNumber.Characteristic");
		CharacteristicID = ?(ValueIsFilled(Characteristic), Characteristic.UUID(), "");
		Package = TreeAttributeValue(StringTreeData, "Products.LineNumber.Package");
		IDPackage = ?(ValueIsFilled(Package), Package.UUID(), "");
		
		ProductID = String(ProductsAndServicesID) + "#" + String(CharacteristicID) + "#" + String(IDPackage);
	EndIf;
	FillXDTOProperty(Product, "ID", ProductID, , ErrorText);
	
	FillXDTOProperty(Product, "Description",
		TreeAttributeValue(StringTreeData, "Products.LineNumber.Description"), , ErrorText);
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Barcode") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Barcode");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Barcode", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.SKU") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.SKU");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "SKU", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Country") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Country");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Country", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.TradingMark") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.TradingMark");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "TradingMark", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Definition") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Definition");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Definition", Attribute, , ErrorText);
		EndIf;
	EndIf;

	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Picture") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Picture");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Picture", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	// Fill in tag BasicUnit.
	BaseUnit = GetCMLObjectType("Product.BaseUnit", TargetNamespaceSchema);
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.BaseUnitCode") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.BaseUnitCode");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(BaseUnit, "Code", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.BaseUnitDescription") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.BaseUnitDescription");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(BaseUnit, "ShortDescription", Attribute, , ErrorText);
		EndIf;
	EndIf;

	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.BaseUnitDescriptionFull") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.BaseUnitDescriptionFull");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(BaseUnit, "DescriptionFull", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.BaseUnitInternationalAbbreviation") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.BaseUnitInternationalAbbreviation");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(BaseUnit, "InternationalAbbreviation", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.MeasurementUnitCodeByOKEI") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.MeasurementUnitCodeByOKEI");
		If ValueIsFilled(Attribute) Then
			Recalculation = GetCMLObjectType("Product.BaseUnit.Recalculation", TargetNamespaceSchema);
			FillXDTOProperty(Recalculation, "Unit", Attribute, , ErrorText);
		
			If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.StorageUnitOfBalanceCoefficient") Then
				Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.StorageUnitOfBalanceCoefficient");
				If ValueIsFilled(Attribute) Then
					FillXDTOProperty(Recalculation, "Factor", Attribute, , ErrorText);
				EndIf;
			EndIf;
			BaseUnit.Recalculation.Add(Recalculation);
		EndIf;
	EndIf;
	FillXDTOProperty(Product, "BaseUnit", BaseUnit, True, ErrorText);
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.MeasurementUnitCodeByOKEI")
		AND Product.Properties().Get("Unit") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.MeasurementUnitCodeByOKEI");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Unit", Attribute, , ErrorText);
			
			Factor = TreeAttributeValue(StringTreeData, "Products.LineNumber.UnitDimensionsRate");
			If ValueIsFilled(Factor) Then
				FillXDTOProperty(Product, "Factor", Factor, , ErrorText);
			EndIf;
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.DirectoryId")
		AND Product.Properties().Get("DirectoryId") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.DirectoryId");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "DirectoryId", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.ClassifierIdentifier")
		AND Product.Properties().Get("ClassifierIdentifier") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.ClassifierIdentifier");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "ClassifierIdentifier", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Price")
		AND Product.Properties().Get("PriceForUnit") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Price");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "PriceForUnit", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Price")
		AND Product.Properties().Get("Price") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Price");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Price", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Quantity")
		AND Product.Properties().Get("Quantity") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Quantity");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Quantity", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Amount")
		AND Product.Properties().Get("Amount") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.Amount");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "Amount", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If Product.Properties().Get("Taxes") <> Undefined AND Product.Properties().Get("Taxes") <> Undefined Then
		If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.VATAmount") Then
			Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.VATAmount");
			If ValueIsFilled(Attribute) Then
				Taxes = GetCMLObjectType("Document.Products.Product.Taxes", TargetNamespaceSchema);
				Tax = GetCMLObjectType("Document.Products.Product.Taxes.Tax", TargetNamespaceSchema);
				FillXDTOProperty(Tax, "Description", "VAT", True, ErrorText);
				
				IncludedInAmount = TreeAttributeValue(StringTreeData, "Products.LineNumber.VATIncludedInAmount", False);
				If ValueIsFilled(IncludedInAmount) Then
					FillXDTOProperty(Tax, "IncludedInAmount", IncludedInAmount, , ErrorText);
				EndIf;
				FillXDTOProperty(Tax, "Amount", Attribute, True, ErrorText);
				
				VATRate = TreeAttributeValue(StringTreeData, "Products.LineNumber.VATRate");
				If ValueIsFilled(VATRate) Then
					RowVATRate = ElectronicDocumentsReUse.VATRateFromCorrespondence(, VATRate);
					FillXDTOProperty(Tax, "Rate", RowVATRate, , ErrorText);
				EndIf;
				Taxes.Tax.Add(Tax);
				FillXDTOProperty(Product, "Taxes", Taxes, , ErrorText);
			EndIf;
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.CountryOfOrigin")
		AND Product.Properties().Get("CountryOfOrigin") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.CountryOfOrigin");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "CountryOfOrigin", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.CCD")
		AND Product.Properties().Get("CCD") <> Undefined Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.CCD");
		If ValueIsFilled(Attribute) Then
			FillXDTOProperty(Product, "CCD", Attribute, , ErrorText);
		EndIf;
	EndIf;
	
	ThereAreProperties = False;
	PropertyValues = GetCMLObjectType("Document.Products.Product.PropertyValues", TargetNamespaceSchema);
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Barcodes")
			AND ValueIsFilled(TreeAttributeValue(StringTreeData, "Products.LineNumber.Barcodes")) Then
		ThereAreProperties = True;
		BarcodesTableRow = StringTreeData.Rows.Find("Products.LineNumber.Barcodes", "FullPath", True);
		For Each DataRow IN BarcodesTableRow.Rows Do
			PropertyValues = GetCMLObjectType("PropertyValues", TargetNamespaceSchema);
			FillXDTOProperty(PropertyValues, "ID", "Barcode", True, ErrorText);
			FillXDTOProperty(PropertyValues, "Description", DataRow.Rows[1].Value, , ErrorText);
			PropertyValues.Value.Add(DataRow.Rows[0].Value);
			PropertyValues.PropertyValues.Add(PropertyValues);
		EndDo;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.Properties")
			AND ValueIsFilled(TreeAttributeValue(StringTreeData, "Products.LineNumber.Properties")) Then
		ThereAreProperties = True;
		PropertiesTableRow = StringTreeData.Rows.Find("Products.LineNumber.Properties", "FullPath", True);
		IndexOf = 0;
		For Each DataRow IN PropertiesTableRow.Rows Do
			IndexOf = IndexOf + 1;
			PropertyValues = GetCMLObjectType("PropertyValues", TargetNamespaceSchema);
			FillXDTOProperty(PropertyValues, "ID", "Property" + IndexOf, True, ErrorText);
			FillXDTOProperty(PropertyValues, "Description", String(DataRow.Rows[0].Value), , ErrorText);
			PropertyValues.Value.Add(String(DataRow.Rows[1].Value));
			PropertyValues.PropertyValues.Add(PropertyValues);
		EndDo;
	EndIf;
	
	If ThereAreProperties Then
		FillXDTOProperty(Product, "PropertyValues", PropertyValues, , ErrorText);
	EndIf;
	
	// Fill in attribute values
	PutTableRowAdditData(StringTreeData, Product, ErrorText, StringTreeData.Value);

	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.AttributeValues") Then
		AttributeValues = GetCMLObjectType("Document.Products.Product.AttributeValues", TargetNamespaceSchema);
		If ValueIsFilled(TreeAttributeValue(StringTreeData, "Products.LineNumber.AttributeValues")) Then
			PropertiesTableRow = StringTreeData.Rows.Find("Products.LineNumber.AttributeValues", "FullPath", True);
			IndexOf = 0;
			For Each DataRow IN PropertiesTableRow.Rows Do
				IndexOf = IndexOf + 1;
				AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
				FillXDTOProperty(AttributeValue, "Description", String(DataRow.Rows[0].Value), True, ErrorText);
				AttributeValue.Value.Add(String(DataRow.Rows[1].Value));
				AttributeValues.AttributeValue.Add(AttributeValue);
			EndDo;
			FillXDTOProperty(Product, "AttributeValues", AttributeValues, , ErrorText);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.AttachedFiles")
			AND ValueIsFilled(TreeAttributeValue(StringTreeData, "Products.LineNumber.AttachedFiles")) Then
		
		FilesTablesRow = StringTreeData.Rows.Find(
														"Products.LineNumber.AttachedFiles",
														"FullPath",
														True);
		For Each DataRow IN FilesTablesRow.Rows Do
			Product.Picture.Add(DataRow.Rows[1].Value);
			If Not FilesArray = Undefined Then
				DataStructure = New Structure();
				DataStructure.Insert("TemporaryStorageAddress", DataRow.Rows[0].Value);
				DataStructure.Insert("FileName",                 DataRow.Rows[1].Value);
				DataStructure.Insert("ProductId",                 ProductId);
				FilesArray.Add(DataStructure);
			EndIf;
		EndDo;
		
	EndIf;
	
EndProcedure

Procedure GenerateDataOnTabularSectionCMLDocumentProducts_206(Product, StringTreeData, TargetNamespaceSchema, ErrorText)
	
	AdditionalInformation = GetCMLObjectType("Document.Products.Product.AdditionalInformation", TargetNamespaceSchema);
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.SalePrice") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.SalePrice");
		If ValueIsFilled(Attribute) Then
			
			AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
			AttributeValue.Description = "SalePrice";
			AttributeValue.Value.Add(Attribute);
			
			AdditionalInformation.AttributeValue.Add(AttributeValue);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.SalesAmount") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.SalesAmount");
		If ValueIsFilled(Attribute) Then
			
			AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
			AttributeValue.Description = "SalesAmount";
			AttributeValue.Value.Add(Attribute);
			
			AdditionalInformation.AttributeValue.Add(AttributeValue);
		EndIf;
	EndIf;
	
	If CommonUseED.AttributeExistsInTree(StringTreeData, "Products.LineNumber.BrokerageAmount") Then
		Attribute = TreeAttributeValue(StringTreeData, "Products.LineNumber.BrokerageAmount");
		If ValueIsFilled(Attribute) Then
			
			AttributeValue = GetCMLObjectType("AttributeValue", TargetNamespaceSchema);
			AttributeValue.Description = "BrokerageAmount";
			AttributeValue.Value.Add(Attribute);
			
			AdditionalInformation.AttributeValue.Add(AttributeValue);
		EndIf;
	EndIf;
	
	If AdditionalInformation.AttributeValue.Count() > 0 Then
		Product.AdditionalInformation = AdditionalInformation;
	EndIf;
	
EndProcedure

Procedure GenerateDataOnProductOffersCML_206(Product, StringTreeData, TargetNamespaceSchema, ErrorText)
	
	// fill in the attributes present in the Offer but absent in the product
	
	Prices = GetCMLObjectType("OffersPackage.Offers.Offer.Prices", TargetNamespaceSchema);
	Price = GetCMLObjectType("OffersPackage.Offers.Offer.Prices.Price", TargetNamespaceSchema);
	
	PriceValue = TreeAttributeValue(StringTreeData, "Products.LineNumber.Price");
	If ValueIsFilled(PriceValue) Then
		FillXDTOProperty(Price, "PriceForUnit", PriceValue, , ErrorText);
	EndIf;
	
	PriceType = TreeAttributeValue(StringTreeData, "Products.LineNumber.PriceType");
	If Not ValueIsFilled(PriceType) Then
		PriceTypeIDValue = "---";
	Else
		PriceTypeIDValue = String(PriceType.UUID());
	EndIf;
	FillXDTOProperty(Price, "PriceTypeIdentifier", PriceTypeIDValue, , ErrorText);
	
	ValueCurrencyPrices = TreeAttributeValue(StringTreeData, "Products.LineNumber.PriceCurrency");
	If ValueIsFilled(ValueCurrencyPrices) Then
		FillXDTOProperty(Price, "Currency", ValueCurrencyPrices, , ErrorText);
	EndIf;
	
	ValueQuantityPrices = TreeAttributeValue(StringTreeData, "Products.LineNumber.Quantity");
	If ValueIsFilled(ValueQuantityPrices) Then
		FillXDTOProperty(Price, "MinQuantity", ValueQuantityPrices, , ErrorText);
	EndIf;
	
	ValuePriceUnit = TreeAttributeValue(StringTreeData, "Products.LineNumber.MeasurementUnitCodeByOKEI");
	If ValueIsFilled(ValuePriceUnit) Then
		FillXDTOProperty(Price, "Unit", ValuePriceUnit, , ErrorText);
	EndIf;
	
	PriceUnitCoefficient = TreeAttributeValue(StringTreeData, "Products.LineNumber.UnitDimensionsRate");
	If ValueIsFilled(PriceUnitCoefficient) Then
		FillXDTOProperty(Price, "Factor", PriceUnitCoefficient, , ErrorText);
	EndIf;

	
	Prices.Price.Add(Price);
	Product.Prices = Prices;
	
EndProcedure

Procedure FillCMLParticipantData(Counterparty, StringTreeData, CounterpartyKind, TargetNamespaceSchema, ErrorText, AddData = "")
	
	If Counterparty.Properties().Get("Role") <> Undefined
		AND Find(CounterpartyKind, ".") = 0 Then
		FillXDTOProperty(Counterparty, "Role", CounterpartyKind, True, ErrorText);
	EndIf;
	
	// Attributes are used for the transfer of final buyer data from Commission agent report on sales:
	TIN = "";
	Description = "";
	AddData = New Structure;
	//
	If ValueIsFilled(TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType")) Then
		If TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType") = "Individual" Then
			Description = TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.Individual.FullDescr");
			FillXDTOProperty(Counterparty, "FullDescr", Description, True, ErrorText);
			TIN = TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.Individual.TIN");
			FillXDTOProperty(Counterparty, "TIN", TIN, True, ErrorText);
			FillXDTOProperty(Counterparty, "Surname",
				TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.Individual.Surname"), True, ErrorText);
			FillXDTOProperty(Counterparty, "Name",
				TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.Individual.Name"), True, ErrorText);
			FillXDTOProperty(Counterparty, "Patronymic", 
				TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.Individual.Patronymic"), , ErrorText);
		Else
			Description = TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.LegalEntity.CompanyDescription");
			FillXDTOProperty(Counterparty, "OfficialName", Description, True, ErrorText);
			TIN = TreeAttributeValue(StringTreeData, CounterpartyKind + ".ParticipantType.LegalEntity.TIN");
			FillXDTOProperty(Counterparty, "TIN", TIN, True, ErrorText);
		EndIf;
	EndIf;
	
	If ValueIsFilled(TIN) Then
		CounterpartyId = TIN;
		FillXDTOProperty(Counterparty, "ID", CounterpartyId, , ErrorText);
		AddData.Insert("Description", Description);
		AddData.Insert("TIN", TIN);
		AddData.Insert("ID", CounterpartyId);
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, CounterpartyKind + ".Address")) Then
		Address = StringTreeData.Rows.Find(CounterpartyKind + ".Address", "FullPath", True);
		If ValueIsFilled(Address.Value) Then
			AddressType = GetCMLObjectType("Address", TargetNamespaceSchema);
			// If the address is structured,
			// fill in the address field if no - only display.
			If Address.Value = "Structured" Then
				Presentation = "";
				For Each RowWithAddress IN Address.Rows[0].Rows Do
					
					If Not ValueIsFilled(RowWithAddress.Value) Then
						Continue;
					EndIf;
					
					AddressField = GetCMLObjectType("Address.AddressField", TargetNamespaceSchema);
					NormType = RowWithAddress.Level4;
					If NormType = "IndexOf" Then
						NormType = "Postal index";
					ElsIf NormType = "CodeState" Then
						NormType = "Region";
					ElsIf NormType = "Settlement" Then
						NormType = "Settlement";
					ElsIf NormType = "Qart" Then
						NormType = "Apartment";
					EndIf;
					AddressField.Type = NormType;
					AddressField.Value = RowWithAddress.Value;
					AddressType.AddressField.Add(AddressField);
					
					Presentation = Presentation + ?(Presentation = "","",", ") + RowWithAddress.Value;
					
				EndDo;
				
				FillXDTOProperty(AddressType, "Presentation", Presentation, True, ErrorText);
			Else
				If Address.Value = "Foreign" Then
					AddressString = TreeAttributeValue(StringTreeData, Address.FullPath + "." + Address.Value + ".AdrText");
				Else
					AddressString = TreeAttributeValue(StringTreeData, Address.FullPath + "." + Address.Value);
				EndIf;
				FillXDTOProperty(AddressType, "Presentation", AddressString, True, ErrorText);
			EndIf;
			
			FillXDTOProperty(Counterparty, "Address", AddressType, , ErrorText);
		EndIf;
	EndIf;
	
	IsDataToBeFilled = False;
	Contacts = GetCMLObjectType("ContactInformation", TargetNamespaceSchema);
	If ValueIsFilled(TreeAttributeValue(StringTreeData, CounterpartyKind + ".Contact.Phone")) Then
		Contact = GetCMLObjectType("ContactInformation.Contact", TargetNamespaceSchema);
		
		FillXDTOProperty(Contact, "Type", "Work phone", True, ErrorText);
		FillXDTOProperty(Contact, "Value",
			TreeAttributeValue(StringTreeData, CounterpartyKind + ".Contact.Phone"), True, ErrorText);
		IsDataToBeFilled = True;
		Contacts.Contact.Add(Contact);
	EndIf;
	If ValueIsFilled(TreeAttributeValue(StringTreeData, CounterpartyKind + ".Contact.Fax")) Then
		Contact = GetCMLObjectType("ContactInformation.Contact", TargetNamespaceSchema);
		
		FillXDTOProperty(Contact, "Type", "Fax", True, ErrorText);
		FillXDTOProperty(Contact, "Value",
			TreeAttributeValue(StringTreeData, CounterpartyKind + ".Contact.Fax"), True, ErrorText);
		IsDataToBeFilled = True;
		Contacts.Contact.Add(Contact);
	EndIf;
	If IsDataToBeFilled Then
		FillXDTOProperty(Counterparty, "Contacts", Contacts, , ErrorText);
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, CounterpartyKind + ".BankAccount")) Then
		BankingDetails = "AccountNumber, BankName, BIC";
		BankAttributes = GetCMLObjectType("BankAccount", TargetNamespaceSchema);
		PrBank = GetCMLObjectType("Bank", TargetNamespaceSchema);
		
		AccountNo = TreeAttributeValue(StringTreeData, CounterpartyKind + ".BankAccount.AccountNo");
		If ValueIsFilled(AccountNo) Then
			FillXDTOProperty(BankAttributes, "AccountNo", AccountNo, True,ErrorText);
		EndIf;
		
		DescBank = TreeAttributeValue(StringTreeData, CounterpartyKind + ".BankAccount.DescBank");
		BIN = TreeAttributeValue(StringTreeData, CounterpartyKind + ".BankAccount.BIN");
		If ValueIsFilled(DescBank) OR ValueIsFilled(BIN) Then
			If ValueIsFilled(DescBank) Then
				FillXDTOProperty(PrBank, "Description", DescBank, ,ErrorText);
			EndIf;
			If ValueIsFilled(BIN) Then
				FillXDTOProperty(PrBank, "BIN", BIN, ,ErrorText);
			EndIf;
		EndIf;
		
		FillXDTOProperty(BankAttributes, "Bank", PrBank, True, ErrorText);
		
		BankAccounts = GetCMLObjectType("Counterparty.CurrentAccounts", TargetNamespaceSchema);
		BankAccounts.BankAccount.Add(BankAttributes);
		
		If Counterparty.Properties().Get("BankAccount") <> Undefined Then
			FillXDTOProperty(Counterparty, "BankAccount", BankAttributes, , ErrorText);
		EndIf;
	EndIf;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Generation of container

// For internal use only
Procedure GenerateEDCardTakskom(ElectronicDocument, DirectoryAddress, ErrorText, Encrypted = False) Export

	TaxcomCardTree = CommonUseED.DocumentTree("TransferredDataCardTaxcom");
	
	// Prepare data tree for package card.
	PrepareDataByTakskomCard(ElectronicDocument, TaxcomCardTree, Encrypted);
	
	// Check if mandatory fields are filled.
	CheckFillObligatoryAttributesRecursively(TaxcomCardTree, ErrorText);
	If Not ValueIsFilled(ErrorText) Then
		Card = GenerateCardTakskomCML(TaxcomCardTree, ErrorText);
		FileCopy(Card, DirectoryAddress + "card.xml");
		DeleteFiles(Card);
	EndIf;
	
EndProcedure

// For internal use only
Procedure GenerateEDTransportInformationTakskom(ElectronicDocument, StructureFilesED, DirectoryAddress, ErrorText) Export
	
	TreeShippingInformationTakskom = CommonUseED.DocumentTree("TransportInformationTakskom");
	
	// Prepare the data tree with transport information.
	PrepareTakskomTransportInformationData(ElectronicDocument, StructureFilesED, TreeShippingInformationTakskom);
	
	// Check if mandatory fields are filled.
	CheckFillObligatoryAttributesRecursively(TreeShippingInformationTakskom, ErrorText);
	If Not ValueIsFilled(ErrorText) Then
		TransportInformationFileName = GenerateTransportInformationTakskomCML(TreeShippingInformationTakskom, ErrorText);
		FileCopy(TransportInformationFileName, DirectoryAddress + "meta.xml");
		DeleteFiles(TransportInformationFileName);
	EndIf;
	
EndProcedure

Procedure PrepareDataByTakskomCard(ElectronicDocument, TaxcomCardTree, Encrypted)
	
	EDKind          = ElectronicDocument.EDKind;
	SignatureSign = ElectronicDocument.EDDirection = Enums.EDDirections.Incoming;
	
	If EDKind = Enums.EDKinds.NotificationAboutReception
		OR EDKind = Enums.EDKinds.NotificationAboutClarification
		OR SignatureSign Then
		
		If SignatureSign  Then
			// Confirmation does not have a separate ED scheme, it is sent as DS of primary ED.
			ExternalIdentifier = ElectronicDocument.EDNumber;
		Else
			ExternalIdentifier = ElectronicDocument.ElectronicDocumentOwner.EDNumber;
		EndIf;
		
		If EDKind = Enums.EDKinds.NotificationAboutReception
			AND (ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDDEI
			OR ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDREI
			OR ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.NRCDDNREI) Then
			
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.Type", "SpecOperator");
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.Name", "tkc");
		EndIf;
		
	Else
		ExternalIdentifier = ElectronicDocument.EDNumber;
	EndIf;
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.ExternalIdentifier",
		ExternalIdentifier);
	
	DocumentKind = "Other";
	If ElectronicDocument.EDKind = Enums.EDKinds.AcceptanceCertificate Then
		
		DocumentKind = "Statement";
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.ActCustomer Then
		
		DocumentKind = "Statement";
		If CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
			
			DocumentKind = "FormalizedStatementCustomer";
		EndIf;
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.ActPerformer Then
		
		DocumentKind = "Statement";
		If TypeOf(ElectronicDocument) <> Type("Structure")
			AND CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
		
			DocumentKind = "FormalizedStatementVendor";
		EndIf;
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.TORG12
		OR ElectronicDocument.EDKind = Enums.EDKinds.GoodsTransferBetweenCompanies Then
		
		DocumentKind = "Consignment";
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.TORG12Customer
		OR ElectronicDocument.EDKind = Enums.EDKinds.AgreementAboutCostChangeRecipient Then
		
		DocumentKind = "Consignment";
		If CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
			
			DocumentKind = "FormalizedConsignmentCustomer";
		EndIf;
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.TORG12Seller
		OR ElectronicDocument.EDKind = Enums.EDKinds.AgreementAboutCostChangeSender Then
		
		DocumentKind = "Consignment";
		If TypeOf(ElectronicDocument) <> Type("Structure")
			AND CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
			
			DocumentKind = "FormalizedConsignmentVendor";
		EndIf;
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.InvoiceForPayment Then
		
		DocumentKind = "Account";
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.NotificationAboutReception
		AND CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
			
		DocumentKind = "ReceiveNotification";
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.NotificationAboutClarification
		AND CommonUse.ObjectAttributeValue(ElectronicDocument,
			"EDFScheduleVersion") = Enums.Exchange1CRegulationsVersion.Version20 Then
			
		DocumentKind = "SpecificationNotice";
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.CancellationOffer Then
		If SignatureSign Then
			DocumentKind = "SpecificationNotice";
		Else
			DocumentKind = "CancellationOffer";
		EndIf;
	ElsIf ElectronicDocument.EDKind = Enums.EDKinds.RandomED Then
		DocumentKind = DocumentTypeRowTakskomByEnumeration(ElectronicDocument.FileOwner.DocumentType);
	EndIf;
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.Name", DocumentKind);
	
	If Not ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		WantedSignatureAgain = True;
		If ElectronicDocument.EDKind = Enums.EDKinds.RandomED Then
			WantedSignatureAgain = ElectronicDocument.FileOwner.ConfirmationRequired;
		ElsIf ElectronicDocument.EDKind = Enums.EDKinds.InvoiceForPayment Then
			WantedSignatureAgain = False;
		ElsIf ElectronicDocument.EDKind = Enums.EDKinds.CancellationOffer Then
			WantedSignatureAgain = True;
		ElsIf SignatureSign OR ElectronicDocumentsServiceCallServer.ThisIsServiceDocument(ElectronicDocument) Then
			WantedSignatureAgain = False;
		EndIf;
		CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.ItIsRequiredToSignAgain",
			WantedSignatureAgain);
		
		If ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.PrimaryED
			OR ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.ESF
			// For ED of the kind "Notice of clarification" and "Notice of
			// receipt" it is required to generate additional data in order for file to be read on the receiving side
			OR ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.NAC
			OR ElectronicDocument.VersionPointTypeED = Enums.EDVersionElementTypes.RN Then

			AdditionalInformation = New ValueTable;
			AdditionalInformation.Columns.Add("Name");
			AdditionalInformation.Columns.Add("Value");
			
			NewRow = AdditionalInformation.Add();
			NewRow.Name = "Number";
			NewRow.Value = ?(ValueIsFilled(ElectronicDocument.SenderDocumentNumber),
				ElectronicDocument.SenderDocumentNumber, "Without number");
			
			NewRow = AdditionalInformation.Add();
			NewRow.Name = "Encrypted";
			NewRow.Value = Encrypted;

			NewRow = AdditionalInformation.Add();
			NewRow.Name = "VersionBED";
			NewRow.Value = InfobaseUpdateED.LibraryVersion();
			
			NewRow = AdditionalInformation.Add();
			NewRow.Name = "AppliedSolution";
			NewRow.Value = Metadata.Name;
			
			NewRow = AdditionalInformation.Add();
			NewRow.Name = "VersionOfAppliedSolutions";
			NewRow.Value = Metadata.Version;
			
			// For direct exchange add the attribute "PackageFormatVersion" to additional data.
			PackageFormatVersion = FormatVersionInLine(ElectronicDocumentsService.EDPackageVersion(ElectronicDocument));
			If ValueIsFilled(PackageFormatVersion) Then
				NewRow = AdditionalInformation.Add();
				NewRow.Name = "PackageFormatVersion";
				NewRow.Value = PackageFormatVersion;
			EndIf;
				
			CommonUseED.ImportingTableToTree(TaxcomCardTree, AdditionalInformation, "Description.AdditionalData");
		EndIf;
	EndIf;
	
	DataStructure = ElectronicDocumentsService.AttributesValuesStructure(ElectronicDocument.Company,
		"Name, TIN");
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.Name",
		DataStructure.Description);
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.TIN",
		DataStructure.TIN);
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.ContractNumber",
		"Contract by default");
		
	If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.ID",
			ElectronicDocument.Sender);
	Else
		If ElectronicDocument.EDDirection = Enums.EDDirections.Incoming Then
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.ID",
				ElectronicDocument.EDRecipient);
		Else
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Sender.ID",
				ElectronicDocument.EDFrom);
		EndIf;
	EndIf;
	
	If Not ValueIsFilled(TreeAttributeValue(TaxcomCardTree, "Recipient.Type")) Then
		If ElectronicDocument.EDFProfileSettings.EDExchangeMethod <> Enums.EDExchangeMethods.QuickExchange Then

			
			DataStructure = ElectronicDocumentsService.AttributesValuesStructure(ElectronicDocument.Counterparty,
				"Name, TIN");
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.Name",
				DataStructure.Description);
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.TIN",
				DataStructure.TIN);
			CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.ContractNumber",
				"Contract by default");
			
			If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
				CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.ID",
					ElectronicDocument.Recipient);
			Else
				If ElectronicDocument.EDDirection = Enums.EDDirections.Incoming Then
					CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.ID",
						ElectronicDocument.EDFrom);
				Else
					CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Recipient.ID",
						ElectronicDocument.EDRecipient);
				EndIf;
			EndIf;
			
			
		EndIf;
	EndIf;
	
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.Title", String(EDKind));
	
	Date = "";
	If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		Date = ElectronicDocument.EDDate;
	Else
		Date = ?(SignatureSign, CurrentSessionDate(), ElectronicDocument.CreationDate);
	EndIf;
	CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.Date", Date);
	
	If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		Return
	EndIf;
		
	VT = New ValueTable;
	VT.Columns.Add("Name");
	VT.Columns.Add("Value");
	If EDKind = Enums.EDKinds.RandomED Then
		CommonUseED.FillTreeAttributeValue(TaxcomCardTree, "Definition.Comment",
			ElectronicDocument.FileOwner.Text);
		Query = New Query;
		Query.Text =
			"SELECT
			|	EDAttachedFiles.UniqueId AS UniqueId
			|FROM
			|	Catalog.EDAttachedFiles AS EDAttachedFiles
			|		INNER JOIN Document.RandomED AS RandomED
			|		ON EDAttachedFiles.FileOwner = RandomED.Ref
			|WHERE
			|	RandomED.Ref = &BasisDocument";
		Query.SetParameter("BasisDocument", ElectronicDocument.FileOwner.BasisDocument);
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			VTRow = VT.Add();
			VTRow.Name = "UniqueGroundsID";
			VTRow.Value = TrimAll(Selection.UniqueId);
		EndIf;
	ElsIf EDKind <> Enums.EDKinds.PaymentOrder
		AND ValueIsFilled(ElectronicDocument.AdditionalInformation) Then
		VTRow = VT.Add();
		VTRow.Name = "Comment";
		VTRow.Value = TrimAll(ElectronicDocument.AdditionalInformation);
		CommonUseED.FillTreeAttributeValue(TaxcomCardTree,
			"Definition.Comment", TrimAll(ElectronicDocument.AdditionalInformation));
	EndIf;
	If VT.Count() > 0 Then
		CommonUseED.ImportingTableToTree(TaxcomCardTree, VT, "Description.AdditionalData");
	EndIf;
	
EndProcedure

Procedure PrepareTakskomTransportInformationData(ElectronicDocument, StructureFilesED, TreeTransportationInformationTakskom)
	
	EDKind          = ElectronicDocument.EDKind;
	SignatureSign = ElectronicDocument.EDDirection = Enums.EDDirections.Incoming;
	
	If EDKind = Enums.EDKinds.NotificationAboutReception
		OR EDKind = Enums.EDKinds.NotificationAboutClarification
		OR SignatureSign Then
		
		DocumentFlowID     = ElectronicDocument.UniqueId;
	Else
		If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
			DocumentFlowID = ElectronicDocument.EDNumber;
		Else
			// Change the filling of unique identifier for document circulation when using the version of the schedule No 20.
			If ElectronicDocument.EDFScheduleVersion = Enums.Exchange1CRegulationsVersion.Version20 Then
				DocumentFlowID = ElectronicDocument.UniqueId;
			Else
				DocumentFlowID = String(ElectronicDocument.UUID());
			EndIf;
		EndIf;
	EndIf;
	CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "ID", DocumentFlowID);
	
	If ElectronicDocument.EDFProfileSettings.EDExchangeMethod = Enums.EDExchangeMethods.QuickExchange Then
		RegulationsCode = "Nonformalized";
		TransactionCode = "MainDocument";
	Else
		RegulationsCode = GetRegulationCode(ElectronicDocument);
		TransactionCode = GetTransactionCode(ElectronicDocument, RegulationsCode, SignatureSign);
	EndIf;
	
	CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "ID", DocumentFlowID);
	CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "Document.RegulationsCode", RegulationsCode);
	CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "Document.TransactionCode", TransactionCode);
	
	// We will load the electronic document file.
	If StructureFilesED.Property("MainFile") AND ValueIsFilled(StructureFilesED.MainFile) Then
		CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "Document.MainFile.Path",
			StructureFilesED.MainFile);
	EndIf;
	
	// Import signatures of the electronic document to the tree of transport information.
	If StructureFilesED.Property("MainFileSignatures") AND StructureFilesED.MainFileSignatures.Count() > 0 Then
		CommonUseED.ImportingTableToTree(TreeTransportationInformationTakskom, StructureFilesED.MainFileSignatures,
			"Document.SignatureMainFile");
	EndIf;
	
	// Import the file with additional information.
	If StructureFilesED.Property("AdditionalFile") AND ValueIsFilled(StructureFilesED.AdditionalFile) Then
		CommonUseED.FillTreeAttributeValue(TreeTransportationInformationTakskom, "Document.AdditionalFile.Path",
			StructureFilesED.AdditionalFile);
	EndIf;
	
EndProcedure

Procedure AddCMLServiceFields(DataTree, EDStructure)
	
	InsertValueIntoTree(DataTree, "GeneratingDate", EDStructure.EDDate);
	InsertValueIntoTree(DataTree, "SchemaVersion", EDStructure.SchemaVersion);
	InsertValueIntoTree(DataTree, "ID", EDStructure.EDNumber);
	InsertValueIntoTree(DataTree, "EDKind", EDStructure.EDKind);
	InsertValueIntoTree(DataTree, "EDDirection", EDStructure.EDDirection);
	InsertValueIntoTree(DataTree, "UUID", New UUID);
	
	InsertValueIntoTree(DataTree, "Performer", EDStructure.Sender);
	
EndProcedure

Function DeleteDirectoryProductsParametersStructure()
	
	ProductsTable = New ValueTable;
	ProductsTable.Columns.Add("ID");
	ProductsTable.Columns.Add("SKU");
	ProductsTable.Columns.Add("Description");
	ProductsTable.Columns.Add("ProductsAndServices");
	ProductsTable.Columns.Add("Characteristic");
	ProductsTable.Columns.Add("BaseUnit");
	ProductsTable.Columns.Add("BaseUnitCode");
	ProductsTable.Columns.Add("BaseUnitDescription");
	ProductsTable.Columns.Add("BaseUnitDescriptionFull");
	ProductsTable.Columns.Add("BaseUnitInternationalAbbreviation");
	ProductsTable.Columns.Add("PackagingByOKEI");
	
	ParametersStructure = New Structure;
	ParametersStructure.Insert("Performer");
	ParametersStructure.Insert("SchemaVersion");
	ParametersStructure.Insert("ProductsTable", ProductsTable);
	ParametersStructure.Insert("Company");
	ParametersStructure.Insert("Counterparty");
	ParametersStructure.Insert("ID");
	ParametersStructure.Insert("GeneratingDate");
	ParametersStructure.Insert("EDKind");
	ParametersStructure.Insert("EDDirection");
	
	ParametersStructure.Insert("MandatoryFields", "Company, ID, GenerationDate, ProductsTable");
	ParametersStructure.Insert("ValueTableRequiredFields", "Name, ProductsAndServices, BasicUnit, PackageByOKEI");

	Return ParametersStructure;
	
EndFunction

Procedure SaveUnknownPackage(ItemBinaryData, EDFProfileSettings, ExternalUID)
	
	SetPrivilegedMode(True);
	
	Try
		EDPackage                    = Documents.EDPackage.CreateDocument();
		EDPackage.Date               = CurrentSessionDate();
		EDPackage.PackageStatus       = Enums.EDPackagesStatuses.Unknown;
		EDPackage.Direction        = Enums.EDDirections.Incoming;
		EDPackage.Company        = CommonUse.ObjectAttributeValue(EDFProfileSettings, "Company");
		EDPackage.EDFProfileSettings = EDFProfileSettings;
		EDPackage.EDExchangeMethod     = Enums.EDExchangeMethods.ThroughEDFOperatorTaxcom;
		EDPackage.ExternalUID         = ExternalUID;
		EDPackage.Write();
		
		UUID = String(New UUID());
		
		FileName = "EDI_" + UUID;
		AddressInStorage = PutToTempStorage(ItemBinaryData);
		AttachedFile = AttachedFiles.AddFile(
								EDPackage.Ref,
								FileName,
								"zip",
								CurrentSessionDate(),
								CurrentSessionDate(),
								AddressInStorage,
								,
								,
								Catalogs.EDAttachedFiles.GetRef());
	Except
		MessageText = BriefErrorDescription(ErrorInfo())
						+ NStr("en=' (see details in Event log monitor).';ru=' (подробности см. в Журнале регистрации).'");
		ErrorText = DetailErrorDescription(ErrorInfo());
		OperationKind = NStr("en='New EDPackage creation';ru='создание нового ПакетаЭД'");
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(OperationKind,
																					ErrorText,
																					MessageText);
	EndTry;
	
EndProcedure

Function GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing)
	
	Buffer = "";
	
	While IsBlankString(Buffer)
	 OR Left(Buffer, 2) = "//" Do
		
		If Import_CurrentRow > Import_LineCount Then
			Return "";
		EndIf;
			
		Buffer = TrimAll(StrGetLine(Import_TextForParsing, Import_CurrentRow));
		Import_CurrentRow = Import_CurrentRow + 1;
		
	EndDo;
	
	Return Buffer;
	
EndFunction

// Returns values tree for bank statement parsing
//
// Parameters:
//  TextForParsing - String, statement data in text format
//
// Returns:
//  ValueTree
//
Function ParsingTreeBankStatements(TextForParsing) Export
	
	SchemaVersion = "urn:1C.ru:ClientBankExchange";
	
	ClientBankExchange = GetCMLObjectType("ClientBankExchange",                SchemaVersion);
	SectionBankAcc     = GetCMLObjectType("ClientBankExchange.SectionBankAcc", SchemaVersion);
	FilterConditions      = GetCMLObjectType("ClientBankExchange.FilterConditions",  SchemaVersion);
	
	Import_TextForParsing = TextForParsing;
	Import_LineCount = StrLineCount(Import_TextForParsing);
	Import_CurrentRow   = 1;
	Import_ExchangeSign = False;
	Cancel = False;
	
	DocumentStructure = CreateStructureFromRow(
		  "Number,Date,Amount,"
		+ "PaymentType,PaymentMethod,"
		+ "StatementDate,StatementTime,StatementContent,"
		+ "DateCredited,"
		+ "Date_Received,"
		+ "PayerAccount,Payer,PayerTIN,Payer1,"
		+ "PayerBankAcc,PayerBank1,PayerBank2,PayerBIC,PayerBalancedAccount,"
		+ "Payer2,Payer3,Payer4,"
		+ "PayeeAccount,Recipient,PayeeTIN,Payee1,"
		+ "PayeeBankAcc,PayeeBank1,PayeeBank2,PayeeBIK,PayeeBalancedAccount,"
		+ "Payee2,Payee3,Payee4,"
		+ "AuthorStatus,KBKIndicator,OKATO,BasisIndicator,"
		+ "PeriodIndicator,NumberIndicator,DateIndicator,TypeIndicator,"
		+ "Code,"
		+ "PaymentDestination,"
		+ "PaymentDestination1,PaymentDestination2,PaymentDestination3,"
		+ "PaymentDestination4,PaymentDestination5,PaymentDestination6,"
		+ "PaymentDueDay,Sequence,"
		+ "PaymentCondition1,PaymentCondition2,PaymentCondition3,"
		+ "AcceptanceTerm,LetterOfCreditType,PaymentByRepr,AdditionalConditions,"
		+ "VendorAccountNumber,DocSendingDate");
		
	AccountTagsRow = "StartDate,EndDate,BankAcc,OpeningBalance,DebitedTotal,CreditedTotal,ClosingBalance";
	AccountStructure = CreateStructureFromRow(AccountTagsRow);
		
	DateFields = CreateStructureFromRow("CreationDate,Date,StatementDate,DateCredited,Date_Received,"
									+ "PaymentDueDate,DocSendingDate,StartDate,EndDate");
	NumbersFields = CreateStructureFromRow("OpeningBalance,DebitedTotal,CreditedTotal,"
									+ "ClosingBalance,Amount,AcceptanceTerm");
									
	HeaderTagsRow = "FormatVersion,Encoding,Sender,Recipient,CreationDate,"
							+ "CreationTime,StartDate,EndDate,BankAcc";
	HeaderFields = CreateStructureFromRow(HeaderTagsRow);
	
	While Import_CurrentRow <= Import_LineCount Do
		
		Str = GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing);
		
		If Left(Upper(TrimAll(Str)), 14) = "SectionDocument" Then
			
			Value = "";
			Tag = "";
			ParseTagString(Str, Tag, Value);
			
			If Tag = "SectionDocument" Then
				PaymentDocumentSection = GetCMLObjectType("ClientBankExchange.PaymentDocumentSection", SchemaVersion);
				FillXDTOProperty(PaymentDocumentSection, "SectionDocument", Value);
				SectionImported = ImportDocumentSection(
									PaymentDocumentSection,
									Import_CurrentRow,
									Import_LineCount,
									Import_TextForParsing,
									DocumentStructure,
									DateFields,
									NumbersFields);
				If Not SectionImported Then
					Return Undefined;
				Else
					ClientBankExchange.PaymentDocumentSection.Add(PaymentDocumentSection);
				EndIf;
				
			Else
				Message = New UserMessage;
				ErrorText = NStr("en='Import file structure is broken, string %1 : %2';ru='Нарушена структура файла импорта, строка %1 : %2'");
				Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																						ErrorText,
																						Import_CurrentRow - 1,
																						Str);
				Message.Message();
				Return Undefined;
			EndIf;
			
		ElsIf Left(Upper(TrimAll(Str)), 14) = "SECTIONBANKACC" Then
			
			AccountImported = ImportBankAccSection(SectionBankAcc,
													Import_CurrentRow,
													Import_LineCount,
													Import_TextForParsing,
													AccountStructure,
													DateFields,
													NumbersFields);
			
			If Not AccountImported Then
				Message = New UserMessage;
				MessageText = NStr("en='Import file structure is broken in the current account description section! String: %1';ru='Нарушена структура файла импорта в секции описания расчетного счета! Строка: %1'");
				Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																	MessageText,
																	Import_CurrentRow - 1);
				Message.Message();
				Return Undefined;
			EndIf;

		ElsIf Left(Upper(TrimAll(Str)), 10) = "EndFile" Then
			If Not Import_ExchangeSign Then
				Message = New UserMessage;
				Message.Text = NStr("en='""1CClientBankExchange"" is missing in the file of import!';ru='В файле импорта отсутствует признак обмена ""1CClientBankExchange""!'");
				Message.Message();
				Return Undefined;
			EndIf;
			IsFoundEndFile = True;
			LineNumber = 0;
		ElsIf Left(Upper(TrimAll(Str)), 20) = "1CCLIENTBANKEXCHANGE" Then
			Import_ExchangeSign = True;
		Else
			ImportHeaderString(
							ClientBankExchange,
							FilterConditions,
							Str,
							Import_CurrentRow,
							HeaderFields,
							DateFields,
							NumbersFields,
							Cancel);
		EndIf;
		
	EndDo;
	
	If Cancel Then
		Return Undefined;
	EndIf;
		
	If Not IsFoundEndFile Then
		Message = New UserMessage;
		Message.Text = NStr("en='Invalid file format (EndFile section not found)!';ru='Файл загрузки не соответствует стандарту (не найдена секция КонецФайла)!'");
		Message.Message();
		Return Undefined;
	EndIf;
	
	FillXDTOProperty(ClientBankExchange, "SectionBankAcc", SectionBankAcc);
	FillXDTOProperty(ClientBankExchange, "FilterConditions",  FilterConditions);
	
	If ClientBankExchange.Sender = Undefined Then
		FillXDTOProperty(ClientBankExchange, "Sender", "Client-bank");
	EndIf;
	
	If ClientBankExchange.Recipient = Undefined Then
		FillXDTOProperty(ClientBankExchange, "Recipient", "1C:Enterprise");
	EndIf;
	
	Try
		ClientBankExchange.Validate();
	Except
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(
								MessagePattern,
								BriefErrorDescription(ErrorInfo()));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(NStr("en='ED formation';ru='Формирование ЭД'"),
																					DetailErrorDescription(ErrorInfo()),
																					MessageText,
																					1);
		Return Undefined;
	EndTry;
	
	TempFile = GetTempFileName();
	ExportEDtoFile(ClientBankExchange, TempFile);
	
	DataStructure = GenerateParseTree(TempFile, Enums.EDDirections.Incoming);
		
	DeleteFiles(TempFile);
	If DataStructure = Undefined Then
		Return Undefined;
	EndIf;
	
	Return DataStructure.ParseTree;
	
EndFunction

Function FillInBuyerSellerDataFTSForIR(ParticipantXDTO, StringTreeData, ErrorText, TargetNamespaceSchema, ParticipantKind)
	
	DataFilled = False;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType")) Then
		
		IdPr = GetCMLObjectType("PrPurchSalesType.IdPr", TargetNamespaceSchema);
		
		If TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType") = "Individual" Then
			
			PrPP = GetCMLObjectType("PrPurchSalesType.IdPr.PrPP", TargetNamespaceSchema);
			TIN = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.TIN");
			FillXDTOProperty(PrPP, "TINInd", TIN, , ErrorText);
			Initials = GetCMLObjectType("NameAndSurnameOfType", TargetNamespaceSchema);
			Surname = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Surname");
			FillXDTOProperty(Initials, "Surname", Surname, True, ErrorText);
			Name = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Name");
			FillXDTOProperty(Initials, "Name", Name, True, ErrorText);
			Patronymic = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.Individual.Patronymic");
			FillXDTOProperty(Initials, "Patronymic", Patronymic, , ErrorText);
			
			FillXDTOProperty(PrPP, "NameAndSurnameIP", Initials,  , ErrorText);
			FillXDTOProperty(IdPr, "PrPP",  PrPP, , ErrorText);
			Description = Surname + " " + Name + " " + Patronymic;
		Else
			PrLP = GetCMLObjectType("PrPurchSalesType.IdPr.PrLP", TargetNamespaceSchema);
			Description = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.LegalEntity.CompanyDescription");
			FillXDTOProperty(PrLP, "DescEnt", Description, , ErrorText);
			TIN = TreeAttributeValue(StringTreeData, ParticipantKind + ".ParticipantType.LegalEntity.TIN");
			FillXDTOProperty(PrLP, "TINLP", TIN, , ErrorText);
			FillXDTOProperty(IdPr, "PrLP",  PrLP, , ErrorText);
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "IdPr", IdPr, , ErrorText);
		DataFilled = True;
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Address")) Then
		Address = StringTreeData.Rows.Find(ParticipantKind + ".Address", "FullPath", True);
		If ValueIsFilled(Address.Value) Then
			FillAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema, ParticipantKind);
		EndIf;
	EndIf;
	
	Return DataFilled;
	
EndFunction

Procedure PutComissionAgentDataToAdditionalData(DataTree, TargetNamespaceSchema, ErrorText)
	
	DataFilled = False;
	RowOptionalData = DataTree.Rows.Find("AdditData.Signed", "FullPath", True);
	IntermedInfo = GetCMLObjectType("PrPurchSalesType", TargetNamespaceSchema);
	If FillInBuyerSellerDataFTSForIR(IntermedInfo, DataTree, ErrorText, TargetNamespaceSchema, "Agent") Then
		XMLWriter = New XMLWriter;
		XMLWriter.SetString();
		XDTOFactory.WriteXML(XMLWriter, IntermedInfo);
		StrXML = XMLWriter.Close();
		BegPos = Find(StrXML, "<IdPr>");
		CouSymb = Find(StrXML, "</IdPr>") - BegPos + StrLen("</IdPr>");
		StrXML = Mid(StrXML, BegPos, CouSymb);
		AddValueToTree(RowOptionalData, "AddData.DigitallySigned.AgentData", StrXML);
		DataFilled = True;
	EndIf;
	
	// For compatibility with earlier versions of the EDB add 3 attributes about the agent:
	If TreeAttributeValue(DataTree, "Agent.ParticipantType") = "Individual" Then
		TIN = TreeAttributeValue(DataTree, "Agent.ParticipantType.Individual.TIN");
		Surname = TreeAttributeValue(DataTree, "Agent.ParticipantType.Individual.Surname");
		Name = TreeAttributeValue(DataTree, "Agent.ParticipantType.Individual.Name");
		Patronymic = TreeAttributeValue(DataTree, "Agent.ParticipantType.Individual.Patronymic");
		Description = TrimAll(Surname + " " + Name + " " + Patronymic);
	Else
		Description = TreeAttributeValue(DataTree, "Agent.ParticipantType.LegalEntity.CompanyDescription");
		TIN = TreeAttributeValue(DataTree, "Agent.ParticipantType.LegalEntity.TIN");
	EndIf;
	AddValueToTree(RowOptionalData, "AddData.DigitallySigned.AgentName", Description);
	AddValueToTree(RowOptionalData, "AddData.DigitallySigned.TINCommissionAgent", TIN);
	
EndProcedure

Function FillInConsignorConsigneeDataFTSForIR(ParticipantXDTO, StringTreeData, ErrorText, TargetNamespaceSchema, ParticipantKind)
	
	DataFilled = False;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Description")) Then
		
		IdPr = GetCMLObjectType("PrCargoSendRecType.NameGOP", TargetNamespaceSchema);
		
		If TreeAttributeValue(StringTreeData, ParticipantKind + ".Description") = "NameAndSurnameIP" Then
			
			Initials = GetCMLObjectType("PrCargoSendRecType.DescGOP.NameAndSurnameIP", TargetNamespaceSchema);
			Surname = TreeAttributeValue(StringTreeData, ParticipantKind + ".Description.NameAndSurnameIP.Surname");
			FillXDTOProperty(Initials, "Surname", Surname, True, ErrorText);
			Name = TreeAttributeValue(StringTreeData, ParticipantKind + ".Description.NameAndSurnameIP.Name");
			FillXDTOProperty(Initials, "Name", Name, True, ErrorText);
			Patronymic = TreeAttributeValue(StringTreeData, ParticipantKind + ".Description.NameAndSurnameIP.Patronymic");
			FillXDTOProperty(Initials, "Patronymic", Patronymic, , ErrorText);
			
			FillXDTOProperty(IdPr, "NameAndSurnameIP",  Initials, True, ErrorText);
		Else
			Description = TreeAttributeValue(StringTreeData, ParticipantKind + ".Description.CompanyDescription");
			FillXDTOProperty(IdPr, "DescEnt", Description, True, ErrorText);
		EndIf;
		FillXDTOProperty(ParticipantXDTO, "DescGOP", IdPr, , ErrorText);
		DataFilled = True;
	EndIf;
	
	If ValueIsFilled(TreeAttributeValue(StringTreeData, ParticipantKind + ".Address")) Then
		Address = StringTreeData.Rows.Find(ParticipantKind + ".Address", "FullPath", True);
		If ValueIsFilled(Address.Value) Then
			FillAddress(ParticipantXDTO, Address, ErrorText, TargetNamespaceSchema, ParticipantKind);
		EndIf;
	EndIf;
	
	Return DataFilled;
	
EndFunction

Function ParseTagString(ParsingString, Tag, Value)
	
	AssignmentPosition = Find(ParsingString, "=");
	
	If AssignmentPosition = 0 Then
		Return False;
	EndIf;
	
	Tag = UPPER(TrimAll(Left(ParsingString, AssignmentPosition - 1)));
	
	Value = TrimAll(Mid(ParsingString, AssignmentPosition + 1));
	
	Return Not IsBlankString(Tag);
	
EndFunction

Function ImportDocumentSection(PaymentDocumentSection, Import_CurrentRow, Import_LineCount, Import_TextForParsing, DocumentStructure, DateFields, NumbersFields)
	
	Var AttributeName;
	
	STATEMENT = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.STATEMENT",
						"urn:1C.ru:ClientBankExchange");
	PayerAttributes = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.PayerAttributes",
						"urn:1C.ru:ClientBankExchange");
	RecipientAttributes = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.RecipientAttributes",
						"urn:1C.ru:ClientBankExchange");
	PaymentAttributes = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.PaymentAttributes",
						"urn:1C.ru:ClientBankExchange");
	PaymentsToBudgetCML = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.PaymentsToBudget",
						"urn:1C.ru:ClientBankExchange");
	AdditionalAttributes = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.AdditionalAttributes",
						"urn:1C.ru:ClientBankExchange");
						
	ParsingString = GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing);
	IsPaymentsToBudget = False;
	PaymentDestinationInSingleLine = "";
	PaymentDestinationComposite = "";
	PaymentCondition = "";
	ErrorText = "";
	
	While Left(Upper(TrimAll(ParsingString)), 14) <> "EndDocument" Do
		
		Value = "";
		Tag = "";
		
		If ParseTagString(ParsingString, Tag, Value) Then
			
			If DocumentStructure.Property(Tag, AttributeName) Then
				If Tag = Upper("AuthorStatus") AND ValueIsFilled(Value) Then
					IsPaymentsToBudget = True;
				EndIf;
				If DateFields.Property(Tag) Then
					Value = GetDateFromString(Value, ErrorText);
				ElsIf NumbersFields.Property(Tag) Then
					Value = Number(Value);
				EndIf;
				If Tag = Upper("StatementDate") OR Tag = Upper("StatementTime") OR Tag = Upper("StatementContent") Then
					FillXDTOProperty(STATEMENT, DocumentStructure[Tag], Value);
				ElsIf Tag = Upper("DateCredited") Then
					DateCredited = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.PayerAttributes.DateCredited",
						"urn:1C.ru:ClientBankExchange");
					FillXDTOProperty(DateCredited, "__content", Value);
					FillXDTOProperty(PayerAttributes, "DateCredited", DateCredited);
				ElsIf Tag = Upper("Date_Received") Then
					Date_Received = GetCMLObjectType(
						"ClientBankExchange.PaymentDocumentSection.RecipientAttributes.Date_Received",
						"urn:1C.ru:ClientBankExchange");
					FillXDTOProperty(Date_Received, "__content", Value);
					FillXDTOProperty(RecipientAttributes, "Date_Received", Date_Received);
				ElsIf Tag = Upper("PayerAccount") OR Tag = Upper("Payer")
						OR Tag = Upper("PayerTIN") OR Tag = Upper("Payer1")
						OR Tag = Upper("Payer2") OR Tag = Upper("Payer3") OR Tag = Upper("Payer4")
						OR Tag = Upper("PayerBankAcc") OR Tag = Upper("PayerBank1") OR Tag = Upper("PayerBank2")
						OR Tag = Upper("PayerBIC") OR Tag = Upper("PayerBalancedAccount") Then
					FillXDTOProperty(PayerAttributes, DocumentStructure[Tag], Value);
				ElsIf Tag = Upper("PayeeAccount") OR Tag = Upper("Recipient")
						OR Tag = Upper("PayeeTIN") OR Tag = Upper("Payee1")
						OR Tag = Upper("Payee2") OR Tag = Upper("Payee3") OR Tag = Upper("Payee4")
						OR Tag = Upper("PayeeBankAcc") OR Tag = Upper("PayeeBank1") OR Tag = Upper("PayeeBank2")
						OR Tag = Upper("PayeeBIK") OR Tag = Upper("PayeeBalancedAccount") Then
					FillXDTOProperty(RecipientAttributes, DocumentStructure[Tag], Value);
				ElsIf Tag = Upper("PaymentKind") OR Tag = Upper("PayKind") OR Tag = Upper("OrderOfPriority")
						OR Tag = Upper("Code") Then
					FillXDTOProperty(PaymentAttributes, DocumentStructure[Tag], Value);
				ElsIf Tag = Upper("PaymentDestination") Then
					PaymentDestinationInSingleLine = Value;
				ElsIf ValueIsFilled(Value)
						AND (Tag = Upper("PaymentDestination1") OR Tag = Upper("PaymentDestination2") OR Tag = Upper("PaymentDestination3")
							OR Tag = Upper("PaymentDestination4") OR Tag = Upper("PaymentDestination5")
							OR Tag = Upper("PaymentDestination6")) Then
					PaymentDestinationComposite = PaymentDestinationComposite + Value + Chars.LF;
				ElsIf Tag = Upper("AuthorStatus") OR Tag = Upper("KBKIndicator") OR Tag = Upper("OKATO")
						OR Tag = Upper("BasisIndicator") OR Tag = Upper("PeriodIndicator") OR Tag = Upper("NumberIndicator")
						OR Tag = Upper("DateIndicator") OR Tag = Upper("TypeIndicator") Then
					If IsPaymentsToBudget Then
						FillXDTOProperty(PaymentsToBudgetCML, DocumentStructure[Tag], Value, True, ErrorText);
					EndIf
				ElsIf Tag = Upper("AcceptanceTerm") OR Tag = Upper("LetterOfCreditType") OR Tag = Upper("PaymentDueDate")
						OR Tag = Upper("PaymentCondition") OR Tag = Upper("PaymentByRepr") OR Tag = Upper("AdditionalConditions")
						OR Tag = Upper("NumberVendorAccount") OR Tag = Upper("DocSendingDate") Then
					FillXDTOProperty(AdditionalAttributes, DocumentStructure[Tag], Value);
				ElsIf ValueIsFilled(Value)
						AND (Tag = Upper("PaymentCondition1") OR Tag = Upper("PaymentCondition2") OR Tag = Upper("PaymentCondition3")) Then
					PaymentCondition = PaymentCondition + Value + Chars.LF;
				ElsIf Tag = Upper("Number") OR Tag = Upper("Date") OR Tag = Upper("Amount") Then
					FillXDTOProperty(PaymentDocumentSection, DocumentStructure[Tag], Value, True, ErrorText);
				Else
					FillXDTOProperty(PaymentDocumentSection, DocumentStructure[Tag], Value);
				EndIf;
			
			Else
				ErrorText = "Error occurred";
			EndIf;
			
			If Not IsBlankString(ErrorText) Then
				Message = New UserMessage;
				Pattern = NStr("en='Invalid details of the billing document, row %1 : %2';ru='Неверный реквизит платежного документа, строка %1 : %2'");
				Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																			Pattern,
																			Import_CurrentRow - 1,
																			ParsingString);
				Message.Message();
				Return False;
			EndIf;
			
		Else
			
			Message = New UserMessage;
			Pattern = NStr("en='Structure of billing document is broken, string %1 : %2';ru='Нарушена структура платежного документа, строка %1 : %2'");
			Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																			Pattern,
																			Import_CurrentRow - 1,
																			ParsingString);
			Message.Message();
			Return False;

		EndIf;
		
		ParsingString = GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing);
		
	EndDo;
	
	If ValueIsFilled(PaymentDestinationComposite) Then
		PaymentDestinationComposite = Mid(PaymentDestinationComposite, 1, StrLen(PaymentDestinationComposite) - 1);
		FillXDTOProperty(PaymentAttributes, "PaymentDestination", PaymentDestinationComposite);
	ElsIf ValueIsFilled(PaymentDestinationInSingleLine) Then
		FillXDTOProperty(PaymentAttributes, "PaymentDestination", PaymentDestinationInSingleLine);
	EndIf;
	
	If ValueIsFilled(PaymentCondition) Then
		PaymentCondition = Mid(PaymentCondition, 1, StrLen(PaymentCondition) - 1);
		FillXDTOProperty(AdditionalAttributes, "PaymentCondition", PaymentCondition);
	EndIf;
	
	FillXDTOProperty(PaymentDocumentSection, "STATEMENT",               STATEMENT);
	FillXDTOProperty(PaymentDocumentSection, "PayerAttributes",    PayerAttributes);
	FillXDTOProperty(PaymentDocumentSection, "RecipientAttributes",     RecipientAttributes);
	FillXDTOProperty(PaymentDocumentSection, "PaymentAttributes",        PaymentAttributes);
	If IsPaymentsToBudget Then
		FillXDTOProperty(PaymentDocumentSection, "PaymentsToBudget", PaymentsToBudgetCML);
	EndIf;
	FillXDTOProperty(PaymentDocumentSection, "AdditionalAttributes", AdditionalAttributes);
		
	Return True;
	
EndFunction


Function ImportBankAccSection(SectionBankAcc, Import_CurrentRow, Import_LineCount, Import_TextForParsing, AccountStructure, DateFields, NumbersFields)
	
	Var AttributeName;
	
	BankAccs = GetCMLObjectType("ClientBankExchange.SectionBankAcc.BankAccs", "urn:1C.ru:ClientBankExchange");
	
	ParsingString = GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing);
	
	ErrorText = "";
	Value = "";
	Tag = "";
	
	While ParseTagString(ParsingString, Tag, Value) Do
		If AccountStructure.Property(Tag, AttributeName) Then
			If DateFields.Property(Tag) Then
				Value = GetDateFromString(Value, ErrorText);
			ElsIf NumbersFields.Property(Tag) Then
				Value = ?(IsBlankString(Value), 0, Number(Value));
			EndIf;
			If Tag = Upper("DebitedTotal") OR Tag = Upper("CreditedTotal") OR Tag = Upper("ClosingBalance") Then

				FillXDTOProperty(BankAccs, AccountStructure[Tag], Value);
			ElsIf Tag = Upper("OpeningBalance") OR Tag = Upper("BankAcc") Then
				FillXDTOProperty(BankAccs, AccountStructure[Tag], Value, True, ErrorText);
			Else
				FillXDTOProperty(SectionBankAcc, AccountStructure[Tag], Value);
			EndIf;
		Else
			ErrorText = "Error occurred";
		EndIf;
		If Not IsBlankString(ErrorText) Then
			Message = New UserMessage;
			MessagePattern = NStr("en='Invalid attribute in current account description section, row %1 : %2';ru='Неверный реквизит в секции описания расчетного счета, строка %1 : %2'");
			Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																	MessagePattern,
																	Import_CurrentRow - 1,
																	ParsingString);
			Message.Message();
			Return False;
		EndIf;
		ParsingString = GetImportString(Import_CurrentRow, Import_LineCount, Import_TextForParsing);
		Value = "";
		Tag = "";
	EndDo;
	
	If UPPER(Left(TrimAll(ParsingString), 13)) = "ENDBANKACC" Then
		SectionBankAcc.BankAccs.Add(BankAccs);
		Return True;
	Else
		Return False;
	EndIf;
	
EndFunction


Function CreateStructureFromRow(Val StringThroughComma)
	
	NewStructure = New Structure;
	SeparatorPosition = Find(StringThroughComma, ",");
	While SeparatorPosition > 0 Do
		NameItema = Left(StringThroughComma, SeparatorPosition - 1);
		NewStructure.Insert(NameItema, NameItema);
		StringThroughComma = Mid(StringThroughComma, SeparatorPosition + 1);
		SeparatorPosition = Find(StringThroughComma, ",");
	EndDo;
	If StrLen(StringThroughComma) > 0 Then
		NewStructure.Insert(StringThroughComma, StringThroughComma);
	EndIf;
	Return NewStructure;
	
EndFunction

Function GetDateFromString(Val DateString, ErrorText)
	
	DotPosition = Find(DateString, ".");
	
	If DotPosition = 0 Then
		ErrorText = NStr("en='The incorrect format of the date row';ru='Неверный формат строки с датой'");
		Return Undefined;
	EndIf;
	
	NumberDate = Left(DateString, DotPosition - 1);
	DateString = Mid(DateString, DotPosition + 1);
	DotPosition = Find(DateString, ".");
	
	If DotPosition = 0 Then
		ErrorText = NStr("en='The incorrect format of the date row';ru='Неверный формат строки с датой'");
		Return Undefined;
	EndIf;
	
	DateMonth = Left(DateString, DotPosition - 1);
	DateYear = Mid(DateString, DotPosition + 1);
	
	If StrLen(DateYear) = 2 Then
		If Number(DateYear) < 50 Then
			DateYear = "20" + DateYear;
		Else
			DateYear = "19" + DateYear;
		EndIf;
	EndIf;
	
	Try
		Receiver = Date(Number(DateYear), Number(DateMonth), Number(NumberDate));
	Except
		ErrorText = NStr("en='The incorrect format of the date row';ru='Неверный формат строки с датой'");
		Return Undefined;
	EndTry;
	
	Return Receiver;
	
EndFunction

Procedure ImportHeaderString(XDTODataValue, FilterConditions, HeaderRowText, CurrentRow, FieldsStructure, DateFields, NumbersFields, Cancel)

	Value = "";
	Tag = "";
	ParseTagString(HeaderRowText, Tag, Value);
	IsError = False;
	
	If IsBlankString(Tag) Then
		Return;
	EndIf;
	
	If FieldsStructure.Property(Tag) = True Then
		
		If DateFields.Property(Tag) Then
			ErrorText = Undefined;
			Value = GetDateFromString(Value, ErrorText);
			IsError = ValueIsFilled(ErrorText);
		ElsIf NumbersFields.Property(Tag) Then
			Value = Number(Value);
		EndIf;
		Try
			If Tag = Upper("StartDate") OR Tag = Upper("EndDate") Then
				FillXDTOProperty(FilterConditions, FieldsStructure[Tag], Value);
			ElsIf Tag = Upper("BankAcc") Then
				FilterConditions.BankAcc.Add(Value);
			ElsIf Tag = Upper("Document") Then
				FilterConditions.Document.Add(Value);
			ElsIf Tag = Upper("FormatVersion") Then
				FillXDTOProperty(XDTODataValue, FieldsStructure[Tag], "1.05");
			ElsIf Tag = Upper("Encoding") Then
			Else
				FillXDTOProperty(XDTODataValue,  FieldsStructure[Tag], Value);
			EndIf
		Except
			IsError = True;
		EndTry;
		
	Else
		IsError = True;
	EndIf;
	
	If IsError Then
		Message = New UserMessage;
		MessageText = NStr("en='Invalid header attribute , row %1 : %2';ru='Неверный реквизит заголовка, строка %1 : %2'");
		Message.Text = StringFunctionsClientServer.SubstituteParametersInString(
																MessageText,
																CurrentRow - 1,
																HeaderRowText);
		Message.Message();
		Cancel = True;
	EndIf;

EndProcedure

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROCEDURES AND FUNCTIONS

////////////////////////////////////////////////////////////////////////////////
// Generation of ED from DB documents

Function VATRateType(VATRate)
	
	VATRateType = "";
	If ValueIsFilled(VATRate) Then
		If Find(Upper(VATRate), "VAT") > 0 Then
			VATRateType = "text";
		ElsIf Find(VATRate, "/") > 0 OR Find(VATRate, "\") > 0 Then
			VATRateType = "fraction";
		Else
			VATRateType = "percent";
		EndIf;
	EndIf;
	Return VATRateType;
	
EndFunction

Function ImagesTree(ImagesFileName)
	
	ImagesTree = New ValueTree();
	ImagesTree.Columns.Add("ProductIdentifier");
	ImagesTree.Columns.Add("FileName");
	ImagesTree.Columns.Add("TemporaryStorageAddress");
	TempDirectory = ElectronicDocumentsServiceCallServer.TemporaryFilesCurrentDirectory();
	TempDirectory = TempDirectory + "\" + String(New UUID);
	DeleteFiles(TempDirectory, "*");
	ZipFileReader = New ZipFileReader(ImagesFileName);
	ZipFileReader.ExtractAll(TempDirectory);
	Folders = FindFiles(TempDirectory, "*", False);
	For Each Folder IN Folders Do
		ProductString = ImagesTree.Rows.Add();
		ProductString.ProductIdentifier = Folder.Name;
		Files = FindFiles(TempDirectory + "\" + Folder.Name + "\", "*");
		For Each File IN Files Do
			ImageRow = ProductString.Rows.Add();
			ImageRow.FileName = File.Name;
			FileBinaryData = New BinaryData(File.FullName);
			ImageRow.TemporaryStorageAddress = PutToTempStorage(FileBinaryData,
			                                                                        New UUID);
		EndDo
	EndDo;
	
	DeleteFiles(TempDirectory);
	Return  ImagesTree;
	
EndFunction

Procedure PutStructureToAttributeValue(AttributeName, ValuesStructure, SalesDocument)
	
	// to the array we will put the string representation of the type "Key&Value#"
	AttributeValue = "";
	For Each KeyValue IN ValuesStructure Do
		
		AttributeValue = AttributeValue + KeyValue.Key + "&" + KeyValue.Value + "#";
		
	EndDo;
	
	AddToDocumentAttributeValues(AttributeName, AttributeValue, SalesDocument);
	
EndProcedure

Function CurrentAccountDetails(Val Item, ED, ParseTree, NewED, Error)
	
	AccountAttributes = New Structure;
	
	While StrLen(Item) > 0 Do
		
		SeparatorPosition = Find(Item, "#");
		AttributeValue = Left(Item, SeparatorPosition );
		Item = StrReplace(Item, AttributeValue, "");
		
		Position = Find(AttributeValue, "&");
		
		Attribute = Left(AttributeValue, Position - 1);
		
		AttributeValue = StrReplace(AttributeValue, Attribute, "");
		AttributeValue = StrReplace(AttributeValue,"&","");
		AttributeValue = StrReplace(AttributeValue,"#","");
		
		AccountAttributes.Insert(Attribute, AttributeValue);
		
	EndDo;
	
	Return AccountAttributes;
	
EndFunction

Procedure ReadReceiptSberbankXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.STATEMENT;
	NewED.EDDirection = Enums.EDDirections.Incoming;
	
	AddObjectHeaderAttribute(NewED, "TicketSBBOL", ED.docId);
	AddObjectHeaderAttribute(NewED, "CreationDateKvitka", ED.createTime);
	If Not ED.Properties().Get("Info") = Undefined Then
		AddObjectHeaderAttribute(NewED, "CodeDocumentStatus", ED.Info.statusStateCode);
		If Not ED.Info.Properties().Get("orgId") = Undefined Then
			AddObjectHeaderAttribute(NewED, "CompanyID", ED.Info.orgId);
		EndIf;
		If Not ED.Info.Properties().Get("docExtId") = Undefined Then
			AddObjectHeaderAttribute(NewED, "DocumentID", ED.Info.docExtId);
		EndIf;
		If Not ED.Info.BankDate = Undefined Then
			AddObjectHeaderAttribute(NewED, "DateWriteOffAccountOfPayer",  ED.Info.BankDate.chargeOffDate);
			AddObjectHeaderAttribute(NewED, "DateOfFiling",        ED.Info.BankDate.fileDate);
			AddObjectHeaderAttribute(NewED, "PayersBankStampDate",    ED.Info.BankDate.signDate);
			AddObjectHeaderAttribute(NewED, "ReceiptDateInPayersBank", ED.Info.BankDate.receiptDate);
			AddObjectHeaderAttribute(NewED, "DatePaymentEnums",         ED.Info.BankDate.dpp);
			AddObjectHeaderAttribute(NewED, "MarkByRecipientBankDate",     ED.Info.BankDate.recDate);
		EndIf;
		If Not ED.Info.MsgFromBank = Undefined Then
			AddObjectHeaderAttribute(NewED, "AuthorOfMessage",   ED.Info.MsgFromBank.author);
			AddObjectHeaderAttribute(NewED, "MessageFromBank", ED.Info.MsgFromBank.message);
		EndIf;
	EndIf;
	
EndProcedure

Function FormatVersionInLine(FormatVersion)
	
	If FormatVersion = Enums.EDPackageFormatVersions.Version20 Then
		Result = "2";
	ElsIf FormatVersion = Enums.EDPackageFormatVersions.Version30 Then
		Result = "3";
	EndIf;
	
	Return Result;
	
EndFunction

Procedure PlaceInAddData(AttributeName, AttributeValue, TreeRow, Prefix, DigitallySigned = True)
	
	Prefix = Prefix + ?(ValueIsFilled(Prefix), ".", "");
	
	If DigitallySigned Then
		RowOptionalData = TreeRow.Rows.Find(Prefix + "AdditData.Signed", "FullPath", True);
		If RowOptionalData = Undefined Then
			RowOptionalData = TreeRow.Rows.Find(Prefix + "AdditionalInformationDigitallySigned", "FullPath", True);
		EndIf;
	Else
		RowOptionalData = TreeRow.Rows.Find(Prefix + "AdditData.Unsigned", "FullPath", True);
		If RowOptionalData = Undefined Then
			RowOptionalData = TreeRow.Rows.Find(Prefix + "AdditionalInformationIsNotDigitallySigned", "FullPath", True);
		EndIf;
		
	EndIf;
	
	InsertValueIntoTree(RowOptionalData, AttributeName, AttributeValue);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Viewing offers on annulment

// Procedure populates the tabular document Notification of clarification.
//
Procedure FillInTabularDocumentCancellationOffer(SpreadsheetDocument, PrintInfo)
	
	SpreadsheetDocument.PrintParametersName = "PRINT_PARAMETERS_Annulment";
	
	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_Cancellation");
	
	TemplateArea = Template.GetArea("Title");
	SpreadsheetDocument.Put(TemplateArea);
	
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, PrintInfo.Header);
	SpreadsheetDocument.Put(TemplateArea);
	
	SpreadsheetDocument.FitToPage = True;
	
EndProcedure

Procedure ReadCancellationOfferXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.CancellationOffer;
	
	AddObjectHeaderAttribute(NewED, "FileName",          ED.Document.PrelimAnalysisInfo.InfoAnFile.AnFileName);
	AddObjectHeaderAttribute(NewED, "Recipient",        GetEDExchangeParticipantData(ED.Document.ParticEDO));
	AddObjectHeaderAttribute(NewED, "Sender",       GetEDExchangeParticipantData(ED.Document.AnOfferSent));
	AddObjectHeaderAttribute(NewED, "CorrectionText",    ED.Document.PrelimAnalysisInfo.TextAnnOffer);
	AddObjectHeaderAttribute(NewED, "TitleParameter", "");
	AddObjectHeaderAttribute(NewED, "RecipientIdentifier",  ED.Document.ParticEDO.IdParticEDF);
	AddObjectHeaderAttribute(NewED, "SenderID", ED.Document.AnOfferSent.IdParticEDF);
	
EndProcedure

Function GetCancellationOfferDataForPrinting(ObjectString, ParseTree, ID)
	
	FillingDataHeader = New Structure;
	
	FillingDataHeader.Insert("Sender", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Sender"));
	FillingDataHeader.Insert("SenderID", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "SenderID"));
	FillingDataHeader.Insert("Recipient",  GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"Recipient"));
	FillingDataHeader.Insert("RecipientIdentifier", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "RecipientIdentifier"));
	FillingDataHeader.Insert("CorrectionText", GetParsedTreeStringAttributeValue(ParseTree,
		ObjectString, "CorrectionText"));
	FillingDataHeader.Insert("FileName", GetParsedTreeStringAttributeValue(ParseTree, ObjectString,
		"FileName"));
	
	DataForObject = New Structure;
	DataForObject.Insert("Header", FillingDataHeader);
	
	Return DataForObject;
	
EndFunction

Procedure FillInTabularDocument_ED(SpreadsheetDocument, Attributes, TemplateName)

	Template = Catalogs.EDAttachedFiles.GetTemplate(TemplateName);
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, Attributes);
	SpreadsheetDocument.Put(TemplateArea);
	
EndProcedure

Procedure FillInTabularDocumentNumbertificationOnState_ED(SpreadsheetDocument, Attributes)

	Template = Catalogs.EDAttachedFiles.GetTemplate("ED_EDStatusNotification");
	TemplateArea = Template.GetArea("Header");
	FillPropertyValues(TemplateArea.Parameters, Attributes);
	SpreadsheetDocument.Put(TemplateArea);
	
	If Attributes.IsError Then
		TemplateArea = Template.GetArea("Error");
	Else
		TemplateArea = Template.GetArea("Status");
	EndIf;
		
	FillPropertyValues(TemplateArea.Parameters, Attributes);
	SpreadsheetDocument.Put(TemplateArea);
		
EndProcedure

Function DataForPrint(ObjectString)
	
	DataForObject = New Structure;
	
	For Each StringAttribute in ObjectString.Rows Do
		DataForObject.Insert(StringAttribute.Attribute,StringAttribute.AttributeValue);
	EndDo;
	
	Return DataForObject;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Asynchronous exchange with banks


// Returns marker
//
// Parameters:
//  EDAgreement - CatalogRef.EDUsageAgreements - agreement
// with bank MarkerQueryParameters - Structure - contains parameters
//  of the query on marker Decrypt - Boolean - indication whether to decrypt the marker.
//                   Used if decoding will be executed on the client
//
// Returns:
//  BinaryData - marker binary data
//
Function GetBankMarker(EDAgreement, MarkerRequestParameters, Decrypt = True) Export
	
	Address = "";
	SecureConnection = False;
	Protocol = "";
	
	AgreementAttributes = CommonUse.ObjectAttributesValues(
				EDAgreement, "ServerAddress, CompanyIdentifier");
	
	ElectronicDocumentsInternal.DetermineSiteParameters(
		AgreementAttributes.ServerAddress, SecureConnection, Address, Protocol);
	Proxy = ElectronicDocumentsService.GenerateProxy(Protocol);
	
	Join = New HTTPConnection(Address, , , , Proxy, SecureConnection);
	
	Marker = Undefined;
		
	If ValueIsFilled(MarkerRequestParameters.SignatureCertificate) Then
		
		CertificateBinaryData = MarkerRequestParameters.CertificateBinaryData.Get();
		CryptoCertificate = New CryptoCertificate(CertificateBinaryData);
		
		PasswordToCertificate = Undefined;
		MarkerRequestParameters.Property("UserPassword", PasswordToCertificate);
		If PasswordToCertificate <> Undefined OR Not Decrypt Then
			ResourceAddress = "LogonCert";
			
			ResultFileName = ElectronicDocumentsService.TemporaryFileCurrentName("txt");
			
			Headers = New Map;
			Headers.Insert("User-Agent", "1C:Enterprise/8");
			Headers.Insert("Content-Type", "application/xml; charset=utf-8");
			Headers.Insert("CustomerID", AgreementAttributes.CompanyID);
			Headers.Insert("x509SerialNumber", String(CryptoCertificate.SerialNumber));
			Headers.Insert("x509Issue",  CryptoCertificate.Issuer.CN);
				
			HTTPRequest = New HTTPRequest(ResourceAddress, Headers);
				
			Try
				Response = Join.Post(HTTPRequest, ResultFileName);
			Except
				MessageText = NStr("en='Authentication error on bank server!
		|(see details in Event log monitor).';ru='Ошибка аутентификации на сервере банка!
		|(подробности см. в Журнале регистрации).'");
				OperationKind = NStr("en='authentication on bank server';ru='аутентификация на сервере банка'");
				DetailErrorDescription = DetailErrorDescription(ErrorInfo());
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
					OperationKind, DetailErrorDescription, MessageText, 1);
				DeleteFiles(ResultFileName);
				Return Undefined;
			EndTry;
			
			If Response.StateCode <> 200 Then
				Pattern = NStr("en='Internet error (%1)';ru='Ошибка работы с Интернет (%1)'");
				ErrorMessage = StringFunctionsClientServer.SubstituteParametersInString(Pattern, Response.StateCode);
				CommonUseClientServer.MessageToUser(ErrorMessage);
				DeleteFiles(ResultFileName);
				Return Undefined;
			EndIf;
			
			Read = New XMLReader;
			URI = ElectronicDocumentsService.AsynchronousExchangeWithBanksNamespace();
			Try
				Read.OpenFile(ResultFileName);
				ResultBank = XDTOFactory.ReadXML(Read, XDTOFactory.Type(URI, "ResultBank"));
				ResultBank.Validate();
				If Not ResultBank.Success = Undefined Then
					If Not ResultBank.Success.LogonCertResponse = Undefined Then
						FileWithMarker = GetTempFileName();
						ResultBank.Success.LogonCertResponse.EncryptedSID.__content.Write(FileWithMarker);
					EndIf
				ElsIf Not ResultBank.Error = Undefined Then
					ErrorTemplate = NStr("en='An error occurred when receiving a bank marker.
		|Error code: %1. %2: %3';ru='Произошла ошибка при получении маркера банка.
		|Код ошибки: %1. %2: %3'");
					ErrorText = StringFunctionsClientServer.SubstituteParametersInString(
						ErrorTemplate, ResultBank.Error.Code, ResultBank.Error.Description, ResultBank.Error.MoreInfo);
					CommonUseClientServer.MessageToUser(ErrorText);
					Read.Close();
					DeleteFiles(ResultFileName);
					Return Undefined;
				EndIf;
			Except
				Read.Close();
				DeleteFiles(ResultFileName);
				MessageText = NStr("en='an error occurred when receiving a bank marker';ru='Произошла ошибка при получении маркера банка'");
				DetailErrorDescription = DetailErrorDescription(ErrorInfo());
				OperationKind = NStr("en='Receiving of bank marker';ru='Получение маркера банка'");
				ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
					OperationKind, DetailErrorDescription, MessageText, 1);
				Return Undefined;
			EndTry;
			
			If Decrypt Then
				ElectronicDocumentsServiceCallServer.ValidateCertificateValidityPeriod(
					MarkerRequestParameters.SignatureCertificate);
				Marker = DecryptMarker(FileWithMarker, PasswordToCertificate);
				DeleteFiles(FileWithMarker);
				MarkerRequestParameters.Insert("MarkerTranscribed", Marker);
			Else
				Marker = New BinaryData(ResultFileName);
				MarkerRequestParameters.Insert("MarkerEncrypted", Marker);
			EndIf;
			
			DeleteFiles(ResultFileName);
		EndIf;
	Else
		MessageText = NStr("en='Certificate of bank client is not specified.';ru='Не указан сертификат клиента банка.'");
		CommonUseClientServer.MessageToUser(MessageText);
	EndIf;
	
	Return Marker;
	
EndFunction

Function GenerateTransferOrderAsync(DataTree)
	
	TargetNamespace = ElectronicDocumentsService.AsynchronousExchangeWithBanksNamespace();
	
	ErrorText = "";
	Try 
		
		ED = GetCMLObjectType("PayDocRu", TargetNamespace);
		
		DocumentId = TreeAttributeValue(DataTree, "DocumentId");
		FillXDTOProperty(ED, "id", DocumentId, True, ErrorText);
		AsynchronousExchangeWithBanksSchemeVersion = ElectronicDocumentsService.AsynchronousExchangeWithBanksSchemeVersion();
		FillXDTOProperty(ED, "formatVersion", AsynchronousExchangeWithBanksSchemeVersion, True, ErrorText);
		FillXDTOProperty(ED, "creationDate", CurrentSessionDate(), True, ErrorText);
		FillXDTOProperty(ED, "userAgent", ElectronicDocumentsReUse.ClientApplicationVersionForBank(), , ErrorText);
		
		Sender = GetCMLObjectType("CustomerPartyType", TargetNamespace);
		ClientId = TreeAttributeValue(DataTree, "ClientId");
		FillXDTOProperty(Sender, "id", ClientId, True, ErrorText);
		PayerDescription = TreeAttributeValue(DataTree, "PayerDetails.Name");
		FillXDTOProperty(Sender, "name", PayerDescription, True, ErrorText);
		PayerTIN = TreeAttributeValue(DataTree, "PayerDetails.TIN");
		FillXDTOProperty(Sender, "tin", PayerTIN, True, ErrorText);
		FillXDTOProperty(ED, "Sender", Sender, True, ErrorText);
		
		Recipient = GetCMLObjectType("BankPartyType", TargetNamespace);
		PayerBankBIC = TreeAttributeValue(DataTree, "PayerAttributes.Bank.BIN");
		FillXDTOProperty(Recipient, "bic", PayerBankBIC, True, ErrorText);
		PayerBankName = TreeAttributeValue(DataTree, "PayerAttributes.Bank.Description");
		FillXDTOProperty(Recipient, "name", PayerBankName, True, ErrorText);
		FillXDTOProperty(ED, "Recipient", Recipient, True, ErrorText);
		
		PaymentData = GetCMLObjectType("PayDocRu.Data", TargetNamespace);
		
		Number = TreeAttributeValue(DataTree, "Number");
		FillXDTOProperty(PaymentData, "DocNo", Number, True, ErrorText);
		Date = TreeAttributeValue(DataTree, "Date");
		FillXDTOProperty(PaymentData, "DocDate", Date, True, ErrorText);
		Amount = TreeAttributeValue(DataTree, "Amount");
		FillXDTOProperty(PaymentData, "Sum", Amount, True, ErrorText);
		
		PayerAttributes = GetCMLObjectType("CustomerDetailsType", TargetNamespace);
		PayerBankAcc = TreeAttributeValue(DataTree, "PayerDetails.BankAcc");
		FillXDTOProperty(PayerAttributes, "Name", PayerDescription, True, ErrorText);
		FillXDTOProperty(PayerAttributes, "TIN", PayerTIN, , ErrorText);
		ThisIsTranferToBudget = TreeAttributeValue(DataTree, "PaymentsToBudget") = True;
		FillXDTOProperty(PayerAttributes, "Account", PayerBankAcc, True, ErrorText);
		
		PayersBank = GetCMLObjectType("BankType", TargetNamespace);
		FillXDTOProperty(PayersBank, "BIC", PayerBankBIC, True, ErrorText);
		FillXDTOProperty(PayersBank, "Name", PayerBankName, , ErrorText);
		PayerBankCity = TreeAttributeValue(DataTree, "PayerAttributes.Bank.City");
		FillXDTOProperty(PayersBank, "City", PayerBankCity, , ErrorText);
		PayerBankCorrAccount = TreeAttributeValue(DataTree, "PayerAttributes.Bank.CorrAccount");
		FillXDTOProperty(PayersBank, "CorrespAcc", PayerBankCorrAccount, , ErrorText);
		FillXDTOProperty(PayerAttributes, "Bank", PayersBank, True, ErrorText);
		FillXDTOProperty(PaymentData, "Payer", PayerAttributes, True, ErrorText);
		
		RecipientAttributes = GetCMLObjectType("CustomerDetailsType", TargetNamespace);
		RecipientDescription = TreeAttributeValue(DataTree, "RecipientDetails.Name");
		FillXDTOProperty(RecipientAttributes, "Name", RecipientDescription, True, ErrorText);
		PayeeTIN = TreeAttributeValue(DataTree, "RecipientAttributes.TIN");
		FillXDTOProperty(RecipientAttributes, "TIN", PayeeTIN, , ErrorText);
		PayeeBankAcc = TreeAttributeValue(DataTree, "RecipientDetails.BankAcc");
		FillXDTOProperty(RecipientAttributes, "Account", PayeeBankAcc, True, ErrorText);
		
		RecipientBank = GetCMLObjectType("BankType", TargetNamespace);
		PayeeBankBIC = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.BIN");
		FillXDTOProperty(RecipientBank, "BIC", PayeeBankBIC, True, ErrorText);
		RecipientBankName = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.Description");
		FillXDTOProperty(RecipientBank, "Name", RecipientBankName, , ErrorText);
		PayeeBankCity = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.City");
		FillXDTOProperty(RecipientBank, "City", PayeeBankCity, , ErrorText);
		PayeeBalancedAccount = TreeAttributeValue(DataTree, "RecipientAttributes.Bank.CorrAccount");
		FillXDTOProperty(RecipientBank, "CorrespAcc", PayeeBalancedAccount, , ErrorText);
		FillXDTOProperty(RecipientAttributes, "Bank", RecipientBank, True, ErrorText);
		FillXDTOProperty(PaymentData, "Payee", RecipientAttributes, True, ErrorText);
		
		PaymentKind = TreeAttributeValue(DataTree, "PaymentDetails.PaymentKind");
		FillXDTOProperty(PaymentData, "PaymentKind", PaymentKind, , ErrorText);
		PayKind = TreeAttributeValue(DataTree, "PaymentDetails.PaymentMethod");
		FillXDTOProperty(PaymentData, "TransitionKind", PayKind, , ErrorText);
		OrderOfPriority = TreeAttributeValue(DataTree, "PaymentDetails.Sequence");
		FillXDTOProperty(PaymentData, "Priority", OrderOfPriority, True, ErrorText);
		Code = TreeAttributeValue(DataTree, "PaymentAttributes.Code");
		FillXDTOProperty(PaymentData, "Code", Code, , ErrorText);
		PaymentDestination = TreeAttributeValue(DataTree, "PaymentDetails.PaymentDestination");
		FillXDTOProperty(PaymentData, "Purpose", PaymentDestination, True, ErrorText);
		
		If ThisIsTranferToBudget Then
			If Not ValueIsFilled(Code) Then
				FillXDTOProperty(PaymentData, "Code", "0", , ErrorText);
			EndIf;
			PaymentsToBudgetCML = GetCMLObjectType("PaymentDataType.BudgetPaymentInfo", TargetNamespace);
			AuthorStatus = TreeAttributeValue(DataTree, "PaymentsToBudget.ComposerStatus");
			FillXDTOProperty(PaymentsToBudgetCML, "DrawerStatus", AuthorStatus, True, ErrorText);
			KBKIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.KBKIndicator");
			FillXDTOProperty(PaymentsToBudgetCML, "CBC", KBKIndicator, True, ErrorText);
			OKTMO = TreeAttributeValue(DataTree, "PaymentsToBudget.OKTMO");
			If Not ValueIsFilled(OKTMO) OR IsBlankString(OKTMO) Then
				OKTMO = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "OKTMO", OKTMO, True, ErrorText);
			BasisIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.BasisIndicator");
			If Not ValueIsFilled(BasisIndicator) OR IsBlankString(BasisIndicator) Then
				BasisIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "Reason", BasisIndicator, True, ErrorText);
			
			PeriodIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.PeriodIndicator");
			If Not ValueIsFilled(PeriodIndicator) OR IsBlankString(PeriodIndicator)
				OR PeriodIndicator = "  . .    " Then
				PeriodIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "TaxPeriod", PeriodIndicator, True, ErrorText);
			
			NumberIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.NumberIndicator");
			If Not ValueIsFilled(NumberIndicator) OR IsBlankString(NumberIndicator) Then
				NumberIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "DocNo", NumberIndicator, True, ErrorText);
			
			DateIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.DateIndicator");
			If Not ValueIsFilled(DateIndicator) Then
				DateIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "DocDate", DateIndicator, True, ErrorText);
			
			TypeIndicator = TreeAttributeValue(DataTree, "PaymentsToBudget.TypeIndicator");
			If Not ValueIsFilled(TypeIndicator) OR IsBlankString(TypeIndicator) Then
				TypeIndicator = "0";
			EndIf;
			FillXDTOProperty(PaymentsToBudgetCML, "PayType", TypeIndicator, True, ErrorText);
			
			FillXDTOProperty(PaymentData, "BudgetPaymentInfo", PaymentsToBudgetCML, , ErrorText);
		EndIf;
	
		If TreeAttributeValue(DataTree, "PayerBankForIndirectPayments") = True Then
			PayersBankForSettlements = GetCMLObjectType("BankType", TargetNamespace);
			BIN = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments.BIC");
			FillXDTOProperty(PayersBankForSettlements, "BIC", BIN, True, ErrorText);
			Description = TreeAttributeValue(DataTree, "PayerBankForIndirectSettlements.Name");
			FillXDTOProperty(PayersBankForSettlements, "Name", Description, , ErrorText);
			City = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments.City");
			FillXDTOProperty(PayersBankForSettlements, "City", City, , ErrorText);
			CorrAccount = TreeAttributeValue(DataTree, "PayerBankForIndirectPayments.CorrAccount");
			FillXDTOProperty(PayersBankForSettlements, "CorrespAcc", CorrAccount, , ErrorText);
			FillXDTOProperty(PaymentData, "BankPayerIndirectAcc", PayersBankForSettlements, , ErrorText);
		EndIf;
		
		If TreeAttributeValue(DataTree, "RecipientBankForIndirectCalculations") = True Then
			RecipientBankForSettlements = GetCMLObjectType("BankType", TargetNamespace);
			BIN = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.BIC");
			FillXDTOProperty(RecipientBankForSettlements, "BIC", BIN, True, ErrorText);
			Description = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.Name");
			FillXDTOProperty(RecipientBankForSettlements, "Name", Description, , ErrorText);
			City = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.City");
			FillXDTOProperty(RecipientBankForSettlements, "City", City, , ErrorText);
			CorrAccount = TreeAttributeValue(DataTree, "RecipientBankForIndirectSettlements.CorrAccount");
			FillXDTOProperty(RecipientBankForSettlements, "CorrespAcc", CorrAccount, , ErrorText);
			FillXDTOProperty(PaymentData, "BankPayeeIndirectAcc", RecipientBankForSettlements, , ErrorText);
		EndIf;
		
		FillXDTOProperty(ED, "Data", PaymentData, True, ErrorText);
		
		ED.Validate();
		
		If ValueIsFilled(ErrorText) Then
			CommonUseClientServer.MessageToUser(ErrorText);
			FileIsFormed = False;
		Else
			ExportEDtoFile(ED, TreeAttributeValue(DataTree, "FullFileName"), False, "UTF-8");
			FileIsFormed = True;
		EndIf;

	Except
		
		MessagePattern = NStr("en='%1 (see details in event log monitor).';ru='%1 (подробности см. в Журнале регистрации).'");
		MessageText = StringFunctionsClientServer.SubstituteParametersInString(
								MessagePattern,
								?(ValueIsFilled(ErrorText), ErrorText, BriefErrorDescription(ErrorInfo())));
		ElectronicDocumentsServiceCallServer.ProcessExceptionByEDOnServer(
			NStr("en='ED formation';ru='Формирование ЭД'"), DetailErrorDescription(ErrorInfo()), MessageText, 1);
		FileIsFormed = False;
	EndTry;
	
	Return FileIsFormed;
	
EndFunction

Procedure ReadStatementAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.BankStatement;
	Stmt = ED;
	StmtData = Stmt.Data;
	
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	AddObjectHeaderAttribute(NewED, "Sender",      Stmt.Sender.Name);
	AddObjectHeaderAttribute(NewED, "Recipient",       Stmt.Recipient.Name);
	AddObjectHeaderAttribute(NewED, "GeneratingDate", Stmt.creationDate);
	AddObjectHeaderAttribute(NewED, "StartDate",       StmtData.DateFrom);
	AddObjectHeaderAttribute(NewED, "EndDate",        StmtData.DateTo);
	AddObjectHeaderAttribute(NewED, "StatementType",       StmtData.StatementType);
	
	ListTS = New ValueList;
	AccountParameters = New Structure;
	AccountParameters.Insert("BankAcc",         StmtData.Account);
	AccountParameters.Insert("OpeningBalance", StmtData.OpeningBalance);
	AccountParameters.Insert("DebitedTotal",   StmtData.TotalCredits);
	AccountParameters.Insert("CreditedTotal",     StmtData.TotalDebits);
	AccountParameters.Insert("ClosingBalance",  StmtData.ClosingBalance);
	FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "BankAccount");
	BankAccount = ElectronicDocumentsOverridable.FindRefToObject(
						"BankAccountsOfTheCompany", AccountParameters.BankAcc);
	FoundString = FindCreateStringInParsedTree(
		FoundTypeInTree, AccountParameters.BankAcc, , BankAccount, AccountParameters, ParseTree, Error);
	ListTS.Add(FoundString.RowIndex, "BankAccount");
	AddObjectTSAttributes(NewED, "BankAccountsOfTheCompany", ListTS);
	
	If Not StmtData.Stamp = Undefined Then
		StampParameters = New Structure;
		StampParameters.Insert("BIN", StmtData.Stamp.BIC);
		StampParameters.Insert("NameOfBank", StmtData.Stamp.Name);
		StampParameters.Insert("BankCity", StmtData.Stamp.City);
		StampParameters.Insert("BankCorrAccount", StmtData.Stamp.CorrespAcc);
		StampParameters.Insert("BankBranch",  StmtData.Stamp.Branch);
		FoundTypeInTree = FoundCreateObjectTypeInParseTree(ParseTree, "Stamp");
		FoundString = FindCreateStringInParsedTree(
			FoundTypeInTree, "Stamp", , , StampParameters, ParseTree, Error);
		AddObjectHeaderAttribute(NewED, "Stamp", FoundString.RowIndex);
	EndIf;
	
	For Each Operation in StmtData.OperationInfo Do
		
		PaymentAttributes = New ValueList;
		
		If Operation.DC = "1" Then // debiting from customer account
			PaymentAttributes.Add(Operation.ExtID, "PaymentId");
			PaymentAttributes.Add(Operation.Date, "DateCredited");
			PaymentAttributes.Add(True, "PaymentOutgoing");
		ElsIf Operation.DC = "2" Then // receipt to personal account
			PaymentAttributes.Add(Operation.Date, "Date_Received");
			PaymentAttributes.Add(False, "PaymentOutgoing");
		Else
			Continue;
		EndIf;
		
		PaymentAttributes.Add("Payment order", "SectionDocument");
		PayData = Operation.PayDoc.PayDocRu;
		
		PaymentAttributes.Add(PayData.DocNo,   "Number");
		PaymentAttributes.Add(PayData.DocDate, "Date");
		PaymentAttributes.Add(PayData.Sum,     "Amount");
		
		Payer = PayData.Payer;
		PaymentAttributes.Add(Payer.Name,            "PayerDescription");
		PaymentAttributes.Add(Payer.TIN,             "PayerTIN");
		PaymentAttributes.Add(Payer.Account,         "PayerAccount");
		PaymentAttributes.Add(Payer.Bank.BIC,        "PayerBankBIC");
		PaymentAttributes.Add(Payer.Bank.Name,       "PayerBankName");
		PaymentAttributes.Add(Payer.Bank.City,       "PayerBankCity");
		PaymentAttributes.Add(Payer.Bank.CorrespAcc, "PayerBankCorrAccount");
		
		Payee = PayData.Payee;
		PaymentAttributes.Add(Payee.Name,            "RecipientDescription");
		PaymentAttributes.Add(Payee.TIN,             "PayeeTIN");
		PaymentAttributes.Add(Payee.Account,         "PayeeAccount");
		PaymentAttributes.Add(Payee.Bank.BIC,        "PayeeBankBIC");
		PaymentAttributes.Add(Payee.Bank.Name,       "RecipientBankName");
		PaymentAttributes.Add(Payee.Bank.City,       "PayeeBankCity");
		PaymentAttributes.Add(Payee.Bank.CorrespAcc, "RecipientBankCorrAccount");
		
		PaymentAttributes.Add(PayData.PaymentKind,    "PaymentKind");
		PaymentAttributes.Add(PayData.TransitionKind, "PayKind");
		PaymentAttributes.Add(PayData.Priority,       "OrderOfPriority");
		PaymentAttributes.Add(PayData.Code,           "Code");
		PaymentAttributes.Add(PayData.Purpose,        "PaymentDestination");
		
		PaymentDestinationFormatted = PaymentDestinationFormatted(PayData.Purpose);
		
		RowsCountNP = min(StrLineCount(PaymentDestinationFormatted), 6);
		
		For Ct = 1 To RowsCountNP Do
			PaymentAttributes.Add(StrGetLine(PaymentDestinationFormatted, Ct), "PaymentDestination" + Ct);
		EndDo;
		
		If Not PayData.BudgetPaymentInfo = Undefined Then
			PayDataBudget = PayData.BudgetPaymentInfo;
			PaymentAttributes.Add(True, "IsPaymentsToBudget");
			PaymentAttributes.Add(PayDataBudget.DrawerStatus, "AuthorStatus");
			PaymentAttributes.Add(PayDataBudget.CBC,          "KBKIndicator");
			PaymentAttributes.Add(PayDataBudget.OKTMO,        "OKTMO");
			PaymentAttributes.Add(PayDataBudget.Reason,       "BasisIndicator");
			PaymentAttributes.Add(PayDataBudget.TaxPeriod,    "PeriodIndicator");
			PaymentAttributes.Add(PayDataBudget.DocNo,        "NumberIndicator");
			PaymentAttributes.Add(PayDataBudget.DocDate,      "DateIndicator");
			PaymentAttributes.Add(PayDataBudget.PayType,      "TypeIndicator");
		Else
			PaymentAttributes.Add(False, "IsPaymentsToBudget");
		EndIf;
		
		If Not PayData.BankPayerIndirectAcc = Undefined Then
			Bank = PayData.BankPayerIndirectAcc;
			PaymentAttributes.Add(Payer.Name, "PayerNameIndirectSettlements");
			PaymentAttributes.Add(Payer.Account, "PayerAccountIndirectSettlements");
			PaymentAttributes.Add(True, "PayerIndirectPayments");
			PaymentAttributes.Add(Bank.BIC, "PayerBankBICIndirectSettlements");
			PaymentAttributes.Add(Bank.Name, "PayerBankNameIndirectSettlements");
			PaymentAttributes.Add(Bank.City, "PayerBankCityIndirectSettlements");
			PaymentAttributes.Add(Bank.CorrespAcc, "PayerBankCorrAccountIndirectSettlements");
		Else
			PaymentAttributes.Add(False, "PayerIndirectPayments");
		EndIf;
		
		If Not PayData.BankPayeeIndirectAcc = Undefined Then
			Bank = PayData.BankPayeeIndirectAcc;
			PaymentAttributes.Add(Payee.Name, "RecipientNameIndirectSettlements");
			PaymentAttributes.Add(Payee.Account, "RecipientAccountIndirectSettlements");
			PaymentAttributes.Add(True, "RecipientIndirectSettlements");
			PaymentAttributes.Add(Bank.BIC, "RecipientBankBICIndirectSettlements");
			PaymentAttributes.Add(Bank.Name, "RecipientBankNameIndirectSettlements");
			PaymentAttributes.Add(Bank.City, "RecipientBankCityIndirectSettlements");
			PaymentAttributes.Add(Bank.CorrespAcc, "RecipientBankCorrAccountIndirectSettlements");
		Else
			PaymentAttributes.Add(False, "RecipientIndirectSettlements");
		EndIf;
		
		If Not Operation.Stamp = Undefined Then
			PaymentAttributes.Add(Operation.Stamp.BIC,         "BankStampBIC");
			PaymentAttributes.Add(Operation.Stamp.Name,        "BankStampName");
			PaymentAttributes.Add(Operation.Stamp.City,        "BankStampCity");
			PaymentAttributes.Add(Operation.Stamp.CorrespAcc,  "BankStampBankBalancedAccount");
			PaymentAttributes.Add(Operation.Stamp.Branch,      "BankStampBranch");
			PaymentAttributes.Add(Operation.Stamp.Status.Name, "BankStampStatus");
		EndIf;
				
		AddObjectTSAttributes(NewED, "TSRow", PaymentAttributes);
	EndDo;
	
EndProcedure

Procedure ReadStatementQueryAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.QueryStatement;
	
	DataRequest = ED.Data;
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	AddObjectHeaderAttribute(NewED, "StartDate", DataRequest.DateFrom);
	AddObjectHeaderAttribute(NewED, "EndDate",  DataRequest.DateTo);
	
	TextBank = NStr("en=' in the bank ';ru=' в банке '");
	If Not DataRequest.Bank.Name = Undefined Then
		TextBank = TextBank + DataRequest.Bank.Name + ", ";
	EndIf;
	TextBank = TextBank + NStr("en='BIC: ';ru='БИК: '") + DataRequest.Bank.BIC;
	
	AccountNo = DataRequest.Account + TextBank;
	AccountAttributes = New ValueList;
	AccountAttributes.Add(AccountNo, "AccountNo");
	AddObjectTSAttributes(NewED, "TSRow", AccountAttributes);
	
EndProcedure

Procedure ReadTransferOrderAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.PaymentOrder;
	PayData = ED.Data;
	
	AddObjectHeaderAttribute(NewED, "Number",          PayData.DocNo);
	AddObjectHeaderAttribute(NewED, "Date",           PayData.DocDate);
	AddObjectHeaderAttribute(NewED, "SectionDocument", "Payment order");
	AddObjectHeaderAttribute(NewED, "Amount",          PayData.Sum);
	AddObjectHeaderAttribute(NewED, "DocumentAmount", PayData.Sum);
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	
	Payer = PayData.Payer;
	AddObjectHeaderAttribute(NewED, "PayerDescription",      Payer.Name);
	AddObjectHeaderAttribute(NewED, "PayerTIN",               Payer.TIN);
	AddObjectHeaderAttribute(NewED, "PayerBankAcc",          Payer.Account);
	
	AddObjectHeaderAttribute(NewED, "PayerBankBIC",          Payer.Bank.BIC);
	AddObjectHeaderAttribute(NewED, "PayerBankName", Payer.Bank.Name);
	AddObjectHeaderAttribute(NewED, "PayerBankCity",        Payer.Bank.City);
	AddObjectHeaderAttribute(NewED, "PayerBankCorrAccount",     Payer.Bank.CorrespAcc);
	
	Payee = PayData.Payee;
	AddObjectHeaderAttribute(NewED, "RecipientDescription",      Payee.Name);
	AddObjectHeaderAttribute(NewED, "PayeeTIN",               Payee.TIN);
	AddObjectHeaderAttribute(NewED, "PayeeBankAcc",          Payee.Account);
	
	AddObjectHeaderAttribute(NewED, "PayeeBankBIC",          Payee.Bank.BIC);
	AddObjectHeaderAttribute(NewED, "RecipientBankName", Payee.Bank.Name);
	AddObjectHeaderAttribute(NewED, "PayeeBankCity",        Payee.Bank.City);
	AddObjectHeaderAttribute(NewED, "RecipientBankCorrAccount",     Payee.Bank.CorrespAcc);
	
	AddObjectHeaderAttribute(NewED, "PaymentKind",        PayData.PaymentKind);
	AddObjectHeaderAttribute(NewED, "PayKind",         PayData.TransitionKind);
	AddObjectHeaderAttribute(NewED, "OrderOfPriority",       PayData.Priority);
	AddObjectHeaderAttribute(NewED, "Code",               PayData.Code);
	AddObjectHeaderAttribute(NewED, "PaymentDestination", PayData.Purpose);
	
	If Not PayData.BudgetPaymentInfo = Undefined Then
		PayDataBudget = PayData.BudgetPaymentInfo;
		AddObjectHeaderAttribute(NewED, "IsTaxPayment",  True);
		AddObjectHeaderAttribute(NewED, "AuthorStatus",   PayDataBudget.DrawerStatus);
		AddObjectHeaderAttribute(NewED, "KBKIndicator",       PayDataBudget.CBC);
		AddObjectHeaderAttribute(NewED, "OKTMO",               PayDataBudget.OKTMO);
		AddObjectHeaderAttribute(NewED, "BasisIndicator", PayDataBudget.Reason);
		AddObjectHeaderAttribute(NewED, "PeriodIndicator",   PayDataBudget.TaxPeriod);
		AddObjectHeaderAttribute(NewED, "NumberIndicator",    PayDataBudget.DocNo);
		AddObjectHeaderAttribute(NewED, "DateIndicator",      PayDataBudget.DocDate);
		AddObjectHeaderAttribute(NewED, "TypeIndicator",      PayDataBudget.PayType);
	Else
		AddObjectHeaderAttribute(NewED, "IsTaxPayment",  False);
	EndIf;

	If Not PayData.BankPayerIndirectAcc = Undefined Then
		AddObjectHeaderAttribute(NewED, "PayerIndirectPayments", True);
		Bank = PayData.BankPayerIndirectAcc;
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsBIC",          Bank.BIC);
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsName", Bank.Name);
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsCity",        Bank.City);
		AddObjectHeaderAttribute(NewED, "PayerBankForSettlementsCorrAccount",     Bank.CorrespAcc);
	Else
		AddObjectHeaderAttribute(NewED, "PayerIndirectPayments", False);
	EndIf;
	
	If Not PayData.BankPayeeIndirectAcc = Undefined Then
		AddObjectHeaderAttribute(NewED, "RecipientIndirectSettlements", True);
		Bank = PayData.BankPayeeIndirectAcc;
		AddObjectHeaderAttribute(NewED, "RecipientBankForSettlementsBIC",          Bank.BIC);
		AddObjectHeaderAttribute(NewED, "RecipientBankNameForSettlements", Bank.Name);
		AddObjectHeaderAttribute(NewED, "RecipientBankForSettlementsCity",        Bank.City);
		AddObjectHeaderAttribute(NewED, "RecipientBankForSettlementsBalancedAccount",     Bank.CorrespAcc);
	Else
		AddObjectHeaderAttribute(NewED, "RecipientIndirectSettlements", False);
	EndIf;
	
EndProcedure

Procedure ReadQueryOnStateAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.EDStateQuery;
	
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	AddObjectHeaderAttribute(NewED, "FormatVersion", ED.formatVersion);
	AddObjectHeaderAttribute(NewED, "CreationDate", ED.creationDate);
	AddObjectHeaderAttribute(NewED, "Application", ED.userAgent);
	
	AddObjectHeaderAttribute(NewED, "ClientID", ED.Sender.id);
	AddObjectHeaderAttribute(NewED, "ClientDescription", ED.Sender.name);
	AddObjectHeaderAttribute(NewED, "TIN", ED.Sender.tin);
	AddObjectHeaderAttribute(NewED, "BIN", ED.Recipient.bic);
	AddObjectHeaderAttribute(NewED, "BankDescription", ED.Recipient.name);
	AddObjectHeaderAttribute(NewED, "SourceDocumentIdentifier", ED.ExtID);
	
EndProcedure

Procedure ReadQueryProbeAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.QueryProbe;
	
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	AddObjectHeaderAttribute(NewED, "FormatVersion", ED.formatVersion);
	AddObjectHeaderAttribute(NewED, "CreationDate", ED.creationDate);
	AddObjectHeaderAttribute(NewED, "Application", ED.userAgent);
	
	AddObjectHeaderAttribute(NewED, "ClientID", ED.Sender.id);
	AddObjectHeaderAttribute(NewED, "ClientDescription", ED.Sender.name);
	AddObjectHeaderAttribute(NewED, "TIN", ED.Sender.tin);
	AddObjectHeaderAttribute(NewED, "BIN", ED.Recipient.bic);
	AddObjectHeaderAttribute(NewED, "BankDescription", ED.Recipient.name);
	
EndProcedure

Procedure ReadNotificationOnStateAsyncXDTO(ED, ParseTree, NewED, Error)
	
	NewED.EDKind = Enums.EDKinds.NotificationOnStatusOfED;
	
	AddObjectHeaderAttribute(NewED, "DocumentID", ED.id);
	AddObjectHeaderAttribute(NewED, "FormatVersion", ED.formatVersion);
	AddObjectHeaderAttribute(NewED, "CreationDate", ED.creationDate);
	AddObjectHeaderAttribute(NewED, "Application", ED.userAgent);
	
	AddObjectHeaderAttribute(NewED, "ClientID", ED.Recipient.Customer.id);
	AddObjectHeaderAttribute(NewED, "ClientDescription", ED.Recipient.Customer.name);
	AddObjectHeaderAttribute(NewED, "TIN", ED.Recipient.Customer.tin);
	
	AddObjectHeaderAttribute(NewED, "BIN", ED.Sender.Bank.bic);
	AddObjectHeaderAttribute(NewED, "BankDescription", ED.Sender.Bank.name);
	
	AddObjectHeaderAttribute(NewED, "SourceDocumentIdentifier", ED.ExtID);
	AddObjectHeaderAttribute(NewED, "IDRequest", ED.ExtIDStatusRequest);
	
	If ED.Result.Error = Undefined Then
		AddObjectHeaderAttribute(NewED, "IsError", False);
		AddObjectHeaderAttribute(NewED, "StatusCode", ED.Result.Status.Code);
		AddObjectHeaderAttribute(NewED, "TextStatus", ED.Result.Status.Name);
		AddObjectHeaderAttribute(NewED, "AdditionalInformation", ED.Result.Status.MoreInfo);
	Else
		AddObjectHeaderAttribute(NewED, "IsError", True);
		AddObjectHeaderAttribute(NewED, "ErrorCode", ED.Result.Error.Code);
		AddObjectHeaderAttribute(NewED, "Definition", ED.Result.Error.Description);
		AddObjectHeaderAttribute(NewED, "AdditionalInformation", ED.Result.Error.MoreInfo);
	EndIf;
	
EndProcedure

Function PaymentDestinationFormatted(PaymentDestination)
	
	PaymentDestinationFormatted = "";
	For Counter = 1 To StrLineCount(PaymentDestination) Do
		CurRow = StrGetLine(PaymentDestination, Counter);
		While StrLen(CurRow) > 35 Do
			PaymentDestinationFormatted = PaymentDestinationFormatted + Mid(CurRow, 1, 35) + Chars.LF;
			CurRow = Mid(CurRow, 36);
		EndDo;
		PaymentDestinationFormatted = PaymentDestinationFormatted + CurRow + Chars.LF;
	EndDo;
	
	Return PaymentDestinationFormatted;
	
EndFunction

Function TableFromRowWithDelimiter(Val AttributeValues)
	
	ResultTable = New ValueTable;
	RowData = New Structure;
	
	For Each Item IN AttributeValues Do
		
		PositionLineNumber = Find(Item, "_");
		LineNumber = Left(Item, PositionLineNumber - 1);
		RowData.Insert("NumRow", LineNumber);

		Item = StrReplace(Item, LineNumber + "_", "");
		
		While StrLen(Item) > 0 Do
			
			Position = Find(Item, "#");
			
			AttributeAndValue = Left(Item, Position);
			Item = StrReplace(Item, AttributeAndValue, "");
			
			Delimiter = Find(AttributeAndValue, "&");
			
			DescriptionAttribute = Left(AttributeAndValue, Delimiter - 1);
			
			AttributeValue = StrReplace(AttributeAndValue, DescriptionAttribute, "");
			AttributeValue = StrReplace(AttributeValue, "&", "");
			AttributeValue = StrReplace(AttributeValue, "#", "");
			
			RowData.Insert(DescriptionAttribute, AttributeValue);
			
		EndDo;
		
		CreateTableColumns(RowData, ResultTable);
		
		NewRow = ResultTable.Add();
		FillPropertyValues(NewRow, RowData);
		
	EndDo;
	
	ResultTable.Sort("NumRow");

	Return ResultTable;
	
EndFunction

Procedure CreateTableColumns(StructureWithColumns, Table)
	
	For Each KeyValue IN StructureWithColumns Do
		If Not Table.Columns.Find(KeyValue.Key) = Undefined Then
			Continue;
		EndIf;
		
		Table.Columns.Add(KeyValue.Key);
		
	EndDo;
	
EndProcedure

Procedure PlaceHeaderAttributeToAdditData(DocumentTree, DataPath)
	
	AttributeValue = TreeAttributeValue(DocumentTree, DataPath);
	
	If Not ValueIsFilled(AttributeValue) Then
		Return;
	EndIf;
	
	AttributeName = StrReplace(DataPath, ".", "");
	
	If Upper(AttributeName) = Upper("OperationKind") Then
		AttributeValue = XMLString(AttributeValue);
	EndIf;
	
	If Upper(AttributeName) = Upper("DateOfCorrection") Then
		AttributeValue = Format(AttributeValue, "DLF=D");
	EndIf;
	
	AddData = New Structure(AttributeName, AttributeValue);
	CommonUseED.AddAddDataInTree(DocumentTree, AddData, True);
	
EndProcedure

Procedure PutTreeGroupToAdditData(DocumentTree, DataPath)
	
	GroupBranch = GroupValueInTree(DocumentTree, DataPath);
	If TypeOf(GroupBranch) = Type("ValueTreeRowCollection") Then
		
		GroupData = New Structure;
		For Each TreeRow IN GroupBranch Do
			
			AttributeValue = TreeRow.Value;
			If Not ValueIsFilled(AttributeValue) Then
				Continue;
			EndIf;
			
			AttributeName = StrReplace(TreeRow.FullPath, DataPath+".", "");
			
			GroupData.Insert(AttributeName, AttributeValue);
			
		EndDo;
		
		If GroupData.Count() > 0 Then
			CommonUseED.AddAddDataInTree(DocumentTree, GroupData, True);
		EndIf;
		
	EndIf;
	
EndProcedure

Procedure PutTreeTableToAdditData(DocumentTree, TableName)
	
	TableValue = CommonUseED.DataTree(DocumentTree, TableName);
	
	If Not ValueIsFilled(TableValue) Then
		Return;
	EndIf;
	
	AddData = New Structure(TableName, TableValue);
	CommonUseED.AddAddDataInTree(DocumentTree, AddData, True);
	
EndProcedure

Procedure PutSupportingDocumentsToAdditData(DataTree)
	
	BasisRef = TreeAttributeValue(DataTree, "BasisDocuments");
	If ValueIsFilled(BasisRef) Then
		
		BasisDocumentsParametersTable = GetBasisDocumentsParameters(BasisRef);
		If BasisDocumentsParametersTable.Count() > 0 Then
			
			BasisParameters = New Structure;
			BasisParameters.Insert("_VT_GroundsDocuments", BasisDocumentsParametersTable);
			
			CommonUseED.AddAddDataInTree(DataTree, BasisParameters, True);
			
		EndIf;
	EndIf;
	
	// Put signed attributes of basis document to additional data
	StringProductsTable = DataTree.Rows.Find("Products", "FullPath");

	For Each Product IN StringProductsTable.Rows Do
		RowOptionalData = Product.Rows.Find("Products.LineNumber.AdditionalInformationDigitallySigned", "FullPath", True);
		BasisDocument = TreeAttributeValue(Product, "Products.LineNumber.BasisDocument");
		If ValueIsFilled(BasisDocument) Then
			BasisDocumentsParametersTable = GetBasisDocumentsParameters(BasisDocument);
			For Each String IN BasisDocumentsParametersTable Do
				AddValueToTree(RowOptionalData, "BasisDocumentKind", String.EDKind);
				
				AddValueToTree(RowOptionalData,
					"BasisDocumentNumber", String.SenderDocumentNumber);
					
				AddValueToTree(RowOptionalData, "BasisDocumentDate",
					Format(String.SenderDocumentDate, "DLF=D"));
					
				AddValueToTree(RowOptionalData, "IDEDDocumentFoundation", String.Description);
				
			EndDo;
		EndIf;
	EndDo;

	
EndProcedure

Procedure PlaceTableRowAttributeToAdditData(DocumentTree, TableName, AttributeName)
	
	StringProductsTable = DocumentTree.Rows.Find("Products", "FullPath");
	For Each Product IN StringProductsTable.Rows Do
		
		AttributeValue = TreeAttributeValue(Product, "Products.LineNumber."+AttributeName);
		If Not ValueIsFilled(AttributeValue) Then
			Continue;
		EndIf;
		
		RowOptionalData = Product.Rows.Find("Products.LineNumber.AdditionalInformationDigitallySigned", "FullPath", True);
		AddValueToTree(RowOptionalData, AttributeName, AttributeValue);
		
	EndDo;
	
EndProcedure

Procedure PutHeaderAdditData(DataTree, DocumentXDTO, ErrorText);
	
	OwnerItemName = "Header";
	TargetNamespace = ElectronicDocumentsReUse.CMLNamespace();
	MaxLength = GetXDTOschemaFieldProperty(TargetNamespace, "AttributeValue", "Value", XDTOFacetType.MaxLength);
	NameMaxLength = "AllowedLengthOfExtraDataCaps";

	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", DocumentXDTO.ID);
	ParametersStructure.Insert(NameMaxLength, MaxLength - 20); // 20 - service characters.

	
	AdditDataStructure = New Structure;
	AdditDataUnsigned = DataTree.Rows.Find("AdditData.Unsigned", "FullPath",True);
	If Not AdditDataUnsigned = Undefined Then
		
		For Each TreeRow IN AdditDataUnsigned.Rows Do
			
			AttributeName = StrReplace(TreeRow.FullPath, "AddData.NotSigned.", "");
			AttributeValue = TreeRow.Value;
			AdditDataStructure.Insert(AttributeName, AttributeValue);
			
		EndDo;
	EndIf;
		
	If AdditDataStructure.Count() > 0 Then
		ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure,
			AdditDataStructure,
			OwnerItemName,
			False);
	EndIf;
	
	AdditDataStructure = New Structure;
	AdditionalInformationDigitallySigned = DataTree.Rows.Find("AdditData.Signed", "FullPath",True);
	If Not AdditionalInformationDigitallySigned = Undefined Then
		For Each TreeRow IN AdditionalInformationDigitallySigned.Rows Do
			
			AttributeName = StrReplace(TreeRow.FullPath, "AddData.Signed.", "");
			AttributeValue = TreeRow.Value;
			AdditDataStructure.Insert(AttributeName, AttributeValue);
			
		EndDo;
	EndIf;
	
	If AdditDataStructure.Count() > 0 Then
		
		ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure,
			AdditDataStructure,
			OwnerItemName,
			True);
		
	EndIf;
	
	RowInfoPaul = "";
	AddData = ParametersStructure.AdditDataTree;
	
	If TypeOf(AddData) = Type("ValueTree")
		AND AddData.Rows.Count() > 0 Then
		
		// Generate xml string (InfFull):
		FormedRow = GenerateAdditFileCML(ParametersStructure,
			ErrorText, True, OwnerItemName);
		
		If FormedRow Then
			
			RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			AttributeNameAdditData = "AddData" + OwnerItemName;
			AddToDocumentAttributeValues(AttributeNameAdditData, RowInfoPaul, DocumentXDTO)
		
		EndIf;
		
		//Generate additional file (for rows of tabular section is not generated):
		AdditFileGenerated = GenerateAdditFileCML(ParametersStructure,
			ErrorText, False, OwnerItemName);
		
		If AdditFileGenerated Then
			
			InsertValueIntoTree(DataTree, "AdditFileFullName",     ParametersStructure.AdditFileFullName);
			InsertValueIntoTree(DataTree, "AdditFileIdentifier",     ParametersStructure.AdditFileIdentifier);
			
		EndIf;
		
	EndIf;
		
EndProcedure

Procedure FillInUnSignedHeaderData(DataTree, DocumentXDTO, ErrorText)
	
	OwnerItemName = "Header";
	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", DocumentXDTO.ID);
	
	AdditDataUnsigned = DataTree.Rows.Find("AdditData.Unsigned", "FullPath",True);
	
	If Not AdditDataUnsigned = Undefined Then
		
		AdditDataStructure = New Structure;
		For Each TreeRow IN AdditDataUnsigned.Rows Do
			
			AttributeName = StrReplace(TreeRow.FullPath, "AddData.NotSigned.", "");
			AttributeValue = TreeRow.Value;
			AdditDataStructure.Insert(AttributeName, AttributeValue);
			
		EndDo;
		
		
		If AdditDataStructure.Count() > 0 Then
			ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure,
			AdditDataStructure,
			OwnerItemName,
			False);
		EndIf;
		
	EndIf;
	
	AddData = ParametersStructure.AdditDataTree;
	
	If TypeOf(AddData) = Type("ValueTree")
		AND AddData.Rows.Count() > 0 Then
		
		AdditFileGenerated = GenerateAdditFileCML(ParametersStructure,
			ErrorText, False, OwnerItemName);
		
		If AdditFileGenerated Then
			
			InsertValueIntoTree(DataTree, "AdditFileFullName",     ParametersStructure.AdditFileFullName);
			InsertValueIntoTree(DataTree, "AdditFileIdentifier",     ParametersStructure.AdditFileIdentifier);
			
		EndIf;
	EndIf;
	
EndProcedure

Procedure PutTableRowAdditData(DataTree, DocumentXDTO, ErrorText, LineNumber)
	
	OwnerItemName = "Rows";
	TargetNamespace = ElectronicDocumentsReUse.CMLNamespace();
	MaxLength = GetXDTOschemaFieldProperty(TargetNamespace, "AttributeValue", "Value", XDTOFacetType.MaxLength);
	NameMaxLength = "StringAdditDataAllowedLength";

	ParametersStructure = New Structure();
	ParametersStructure.Insert("AdditDataTree", AdditDataTree());
	ParametersStructure.Insert("IdFile", DocumentXDTO.ID);
	ParametersStructure.Insert(NameMaxLength, MaxLength - 20); // 20 - service characters.
	
	AdditionalInformationDigitallySigned = DataTree.Rows.Find("Products.LineNumber.AdditionalInformationDigitallySigned", "FullPath",True);
	If Not AdditionalInformationDigitallySigned = Undefined Then
		AdditDataStructure = New Structure;
		For Each TreeRow IN AdditionalInformationDigitallySigned.Rows Do
			
			AttributeName = StrReplace(TreeRow.FullPath, "Products.LineNumber.AdditionalInformationDigitallySigned.", "");
			AttributeValue = TreeRow.Value;
			AdditDataStructure.Insert(AttributeName, AttributeValue);
			
		EndDo;
		
		If AdditDataStructure.Count() > 0 Then
			
			ElectronicDocuments.AddDataToAdditDataTree(ParametersStructure,
				AdditDataStructure,
				OwnerItemName,
				True,
				LineNumber);
			
		EndIf;
	EndIf;
	
	RowInfoPaul = "";
	AddData = ParametersStructure.AdditDataTree;
	
	If TypeOf(AddData) = Type("ValueTree")
		AND AddData.Rows.Count() > 0 Then
		
		// Generate xml string (InfFull):
		FormedRow = GenerateAdditFileCML(ParametersStructure,
			ErrorText, True, OwnerItemName, String(LineNumber));
		
		If FormedRow Then
			
			RowInfoPaul = StrReplace(ParametersStructure.InfFul, "	", "");
			AttributeNameAdditData = "AddData" + OwnerItemName;
			AddToDocumentAttributeValues(AttributeNameAdditData, RowInfoPaul, DocumentXDTO)
		
		EndIf;
		
	EndIf;
	
EndProcedure

Procedure AddWithFieldsForAdditData(ParametersStructure, DataTree)
	
	ParametersStructure.Insert("UUID", TreeAttributeValue(DataTree, "UUID"));
	If CommonUseED.AttributeExistsInTree(DataTree, "AdditFileFullName") Then
		ParametersStructure.Insert("AdditFileFullName", TreeAttributeValue(DataTree, "AdditFileFullName"));
		ParametersStructure.Insert("AdditFileIdentifier", TreeAttributeValue(DataTree, "AdditFileIdentifier"));
	EndIf;
	
EndProcedure

Procedure CopyTreeRowsRecursively(RecipientRow, RowSource) Export
	
	For Each Attribute IN RowSource.Rows Do
		NewRow = RecipientRow.Rows.Add();
		FillPropertyValues(NewRow, Attribute);
		If Attribute.Rows.Count() > 0 Then
			CopyTreeRowsRecursively(NewRow, Attribute);
		EndIf;
	EndDo;

EndProcedure

Procedure ReadDocumentHeaderAdditData(DocumentXDTO, DocumentTree, Error, AdditionalAttributes = Undefined)
	
	TreeToHeader = False;
	AddTreeRow = DocumentTree.Rows.Find("AdditDataTree", "Attribute");
	If Not AddTreeRow = Undefined Then
		AddTree = AddTreeRow.AttributeValue;
	Else
		AddTree = AdditDataTree();
		TreeToHeader = True;
	EndIf;
	
	AddData = DocumentAdditAttributeValue("AddDataHeader", DocumentXDTO);
	If ValueIsFilled(AddData) Then
		
		ReadInfPol(AddData, AddTree, "Header");
	EndIf;
	
	AddAttributesAdditDataToHeader(AddTree, DocumentTree, Error, AdditionalAttributes);
	
	If TreeToHeader Then
		AddObjectHeaderAttribute(DocumentTree, "AdditDataTree", AddTree);
	EndIf;
	
EndProcedure

Procedure AddAttributesAdditDataToHeader(AddTree, DocumentTree, Error, AdditionalAttributes)
	
	HeaderString = AddTree.Rows.Find("Header", "AttributeValue");
	If Not ValueIsFilled(HeaderString) Then
		Return;
	EndIf;
	
	HeaderAttributes = New Structure;
	
	If AdditionalAttributes = Undefined Then
		AdditionalAttributes = New Structure;
	EndIf;
	
	For Each TreeBranch IN HeaderString.Rows Do
		
		AttributeName = TreeBranch.AttributeName;
		AttributeValue = TreeBranch.AttributeValue;
		
		If Find(AttributeValue, "_VT_") > 0 Then
			
			AttributeName = StrReplace(AttributeValue, "_VT_", "");
			
			AttributeValue = BranchTableBeforeData(TreeBranch);
			
			If Upper(AttributeName) = Upper("BasisDocuments")
				Or Upper(AttributeName) = Upper("BasisDocument") Then
				
				ArrayBEFORE = New Array;
				
				For Each CurRow IN AttributeValue Do
					
					BasisDocument = GetBasisDocument(CurRow.Description, AdditionalAttributes);
					ArrayBEFORE.Add(BasisDocument);
				EndDo;
				
				If ArrayBEFORE.Count() = 1 Then
					AttributeValue = ArrayBEFORE[0];
				Else
					AttributeValue = ArrayBEFORE;
				EndIf;
				
			EndIf;
			
		ElsIf Upper(AttributeName) = Upper("TransactionDocuments") Then
			
			AttributeValue = BranchTableBeforeData(TreeBranch);
			
		ElsIf Upper(AttributeName) = Upper("PriceIncludesVAT") Then
			
			PriceIncludesVAT = AttributeValue;
			
			If Upper(PriceIncludesVAT) = Upper("Yes") Then
				AttributeValue = True;
			ElsIf Upper(PriceIncludesVAT) = Upper("No") Then
				AttributeValue = False;
			EndIf;
			
		ElsIf Upper(AttributeName) = Upper("DateOfCorrection") Then
			
			CorrectionDateValue = AttributeValue;
			
			Try
				AttributeValue = DateFromString(CorrectionDateValue);
			Except
				AttributeValue = DateDD_MM_YYYY(CorrectionDateValue);
			EndTry;
		Else
			AttributeValue = AttributeValue;
			
		EndIf;
		
		HeaderAttributes.Insert(AttributeName, AttributeValue);

	EndDo;
	
	For Each KeyValue IN HeaderAttributes Do
		
		AddAttributeToReceiver(KeyValue.Key, KeyValue.Value, DocumentTree);
		
	EndDo;
	
EndProcedure

Function BranchTableBeforeData(TreeRow)
	
	Result = New ValueTable;
	GenerateValuesTableByAdditData(TreeRow, Result);
	
	Return Result;
	
EndFunction

Procedure ReadTSRowAdditData(XDTORow, DocumentTree, TableName, LineNumber, TSProperties, AdditParameters = Undefined)
	
	AddData = DocumentAdditAttributeValue("RowAddData", XDTORow);
	RowAddTree = DocumentTree.Rows.Find("AdditDataTree", "Attribute");
	
	NewTree = False;
	If RowAddTree = Undefined Then
		AddTree = AdditDataTree();
		NewTree = True;
		
	Else
		AddTree = RowAddTree.AttributeValue;
	EndIf;
		
	ReadInfPol(AddData, AddTree, TableName, String(LineNumber));
	
	If NewTree Then
		AddObjectHeaderAttribute(DocumentTree, "AdditDataTree", AddTree);
	EndIf;
	
	If AdditParameters = Undefined Then
		AdditParameters = New Structure;
	EndIf;
	
	AddAdditDataToRowProperties(AddTree, TableName,TSProperties, AdditParameters);
	
EndProcedure

Procedure AddAdditDataToRowProperties(AddTree, TableName, TSProperties, AdditParameters)
	
	TableProperties = AddTree.Rows.Find(TableName, "AttributeValue");
	If Not ValueIsFilled(TableProperties) Then
		Return;
	EndIf;
	
	
	For Each NumberStr IN TableProperties.Rows Do
		
		For Each CurProperty IN NumberStr.Rows Do
			
			PropertyName = CurProperty.AttributeName;
			PropertyValue = CurProperty.AttributeValue;
			
			If Upper(PropertyName) = Upper("BasisDocumentKind")
				Or Upper(PropertyName) = Upper("BasisDocumentNumber")
				Or Upper(PropertyName) = Upper("BasisDocumentDate") Then
				Continue;
			EndIf;
			
			If Upper(PropertyName) = Upper("IDEDDocumentFoundation") Then
				PropertyValue = GetBasisDocument(PropertyValue, AdditParameters);
				PropertyName = "BasisDocument";
			EndIf;
			
			
			TSProperties.Add(PropertyValue, PropertyName);
			
		EndDo;
		
	EndDo;
	
EndProcedure

Procedure PutUnsignedDataToHeader(DocumentTree)
	
	AddTree = Undefined;
	BranchAddTree = DocumentTree.Rows.Find("AdditDataTree","Attribute", True);
	If ValueIsFilled(BranchAddTree) Then
		AddTree = BranchAddTree.AttributeValue;
	EndIf;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Processing of ED additional data

// Generation of xml-file/string

Function GenerateAdditRow(RowArray, Attr, TargetNamespaceSchema, LegallyMeaningful, IsDataForAdditFile, ErrorText, Val NestingLevel)
	
	NestingLevel = NestingLevel + 1;
	For Each VTRow IN RowArray Do
		If Not LegallyMeaningful Then
			If VTRow.LegallyMeaningful Then 
				// If LegallySignificant = True, then incoming RowsArray contains only legally significant attributes.
				// Otherwise, RowsArray - mixed, i.e. legally significant attributes shall be skipped (due to they
				// will be transferred separately from the insignificant in different files).
				Continue;
			EndIf;
		EndIf;
		Attribute = GetCMLObjectType("Attribute.Attribute", TargetNamespaceSchema);
		FillXDTOProperty(Attribute, "Name", VTRow.AttributeName, , ErrorText);
		If ValueIsFilled(VTRow.AttributeValue) Then
			FillXDTOProperty(Attribute, "Value", VTRow.AttributeValue, , ErrorText);
		EndIf;
		DZRowsArray = VTRow.Rows;
		If DZRowsArray.Count() > 0 Then // add sets and arrays of data:
			GenerateAdditRow(DZRowsArray, Attribute, TargetNamespaceSchema, LegallyMeaningful,
				IsDataForAdditFile, ErrorText, NestingLevel);
			Attr.Attribute.Add(Attribute);
		Else // add final values of attributes:
			Attr.Attribute.Add(Attribute);
			IsDataForAdditFile = True;
		EndIf;
	EndDo;
	
EndFunction

Function GenerateAdditFileCML(ParametersStructure,
											ErrorText,
											Val LegallyMeaningful = False,
											TSName = Undefined,
											LineNumber = Undefined)
	
	// TSName and LineNumber are populated only for legally significant information (information - which will be
	// placed to the main file (InfFul, InfFulStr) and signed with EDS).
	If LineNumber <> Undefined Then //ValueIsFilledIn (TSName) OR
		LegallyMeaningful = True;
	EndIf;
	AdditFileGenerated = False;
	TargetNamespaceSchema = "AdditFileUniversal";
	Try
		AdditDataTree = ParametersStructure.AdditDataTree;
		If TypeOf(AdditDataTree) = Type("ValueTree") AND AdditDataTree.Rows.Count() > 0 Then
			
			IsDataForAdditFile = False;
			AdditFile = GetCMLObjectType("AdditFile", TargetNamespaceSchema);
			Data = GetCMLObjectType("AdditFile.Data", TargetNamespaceSchema);
			
			If LineNumber <> Undefined Then
				// If LineNumber - filled, then string InfFullStr is generated for legally significant information and specific TS row.
				FilterSt = New Structure;
				FilterSt.Insert("CWT", True);
				FilterSt.Insert("AttributeName", "List");
				FilterSt.Insert("AttributeValue", TSName);
				DZRowsArray = AdditDataTree.Rows.FindRows(FilterSt, True);
				If DZRowsArray.Count() > 0 Then
					// Find required string in necessary TS (LineNumber):
					FilterSt = New Structure("AttributeName, AttributeValue", "NPP", LineNumber);
					DZRowsArray = DZRowsArray[0].Rows.FindRows(FilterSt);
					If DZRowsArray.Count() > 0 Then
						// IN subordinate strings select legally relevant attributes:
						DZRowsArray = DZRowsArray[0].Rows;
					EndIf;
				EndIf;
			Else
				// If LegallySignificant=True, then the string InfFul(InfFulStr)is generated.

				If LegallyMeaningful Then
					FilterSt = New Structure("AttributeName, AttributeValue", "Set", TSName);
					DZRowsArray = AdditDataTree.Rows.FindRows(FilterSt);
					If DZRowsArray.Count() > 0 Then
						
						// IN subordinate strings select legally relevant attributes:
						DZRowsArray = DZRowsArray[0].Rows.FindRows(New Structure("LegallyMeaningful", True));
									
					EndIf;
					
				Else
					
					DZRowsArray = AdditDataTree.Rows;
					
				EndIf;
			EndIf;
			
			If DZRowsArray.Count() > 0 Then
				GenerateAdditRow(DZRowsArray, Data, TargetNamespaceSchema, LegallyMeaningful,
					IsDataForAdditFile, ErrorText, 0);
					
				FillXDTOProperty(AdditFile, "Data", Data, True, ErrorText);
			EndIf;
			
			AdditFileId = New UUID;
			FillXDTOProperty(AdditFile, "FileID", ParametersStructure.IdFile, True, ErrorText);
			FillXDTOProperty(AdditFile, "AdditFileId", String(AdditFileId), True, ErrorText);
			FillXDTOProperty(AdditFile, "FormatVersion", "1", True, ErrorText);
			FillXDTOProperty(AdditFile, "GeneratingDate", CurrentSessionDate(), True, ErrorText);
			AdditFile.Validate();
			
			If IsDataForAdditFile AND Not ValueIsFilled(ErrorText) Then
				If LegallyMeaningful Then
					XMLWriter = New XMLWriter;
					XMLWriter.SetString();
					XDTOFactory.WriteXML(XMLWriter, AdditFile);
					StrXML = XMLWriter.Close();
					BegPos = Find(StrXML, "<Data>");
					CouSymb = Find(StrXML, "</Data>") - BegPos + StrLen("</Data>");
					StrXML = Mid(StrXML, BegPos, CouSymb);
					
					StrXML = StrReplace(StrXML, Chars.Tab,"");
					StrXML = StrReplace(StrXML, Chars.LF,"");
					
					ParametersStructure.Insert("InfFul", StrXML);
				Else
					ParametersStructure.Insert("AdditFileIdentifier", AdditFileId);
					
					FullFileName = ElectronicDocumentsService.WorkingDirectory() + AdditFileId + ".xml";
					ParametersStructure.Insert("AdditFileFullName", FullFileName);
					ExportEDtoFile(AdditFile, FullFileName, False);
				EndIf;
				AdditFileGenerated = True;
			EndIf;
		EndIf;
	Except
		ErrorText = ErrorText + ErrorDescription();
	EndTry;
	
	Return AdditFileGenerated;
	
EndFunction

Procedure DisplayHeaderAdditDataForPrint(PrintInfo, Template, SpreadsheetDocument)
	
	AdditDataTree = Undefined;
	If PrintInfo.Property("AdditDataTree", AdditDataTree) AND TypeOf(AdditDataTree) = Type("ValueTree") Then
		FillHeaderAdditData(AdditDataTree, Template, SpreadsheetDocument);
	EndIf;
	
EndProcedure

Procedure DisplayRowAdditDataForPrinting(AdditDataTableRows, AdditDataStructure, LineNumber,SpreadsheetDocument, TemplateArea)
	
	If AdditDataTableRows.Count() > 0 Then
		ADTableString = AdditDataTableRows.Find(String(LineNumber), "NumberStr");
		If ADTableString <> Undefined Then
			If AdditDataStructure.AreDigitallySigned Then
				TemplateArea.Parameters.DigitallySigned = ADTableString.DigitallySignedData;
				SpreadsheetDocument.Join(TemplateArea);
			EndIf;
		EndIf;
	EndIf;
EndProcedure

Function AdditDataTable()
	
	AdditDataTableRows = New ValueTable;
	AdditDataTableRows.Columns.Add("NumberStr");
	AdditDataTableRows.Columns.Add("DigitallySignedData");
	AdditDataTableRows.Columns.Add("UnDigitallySignedData");
	
	Return AdditDataTableRows;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// SERVICE PROCEDURES AND FUNCTIONS

// Searches basis documents for ED
// invoice 1. Finds the document Torg-12, for example, on basis
// of which 2 was input. Searches all grounds for
// found Torg-12 3. Finds all invoices. for all torg-12 from
// p.2.4. Sets the state "Exchange is completed with correction" for found invoices in art. 3
//
// Parameters:
//* PrimaryED - reference or array of references - ED in
//invoice form * EDDirection - Enum - EDDirections  - parameter required for search of basis
//
Procedure ChangeGroundsIRState(PrimaryED, EDDirection) Export
	
	If Not TypeOf(PrimaryED) = Type("Array") Then
		EDKindsArray = New Array;
		EDKindsArray.Add(PrimaryED);
	Else
		EDKindsArray = PrimaryED;
	EndIf;
	
	EDCorrections = New Array;
	For Each ArrayElement IN EDKindsArray Do
		BasisED = ElectronicDocumentsServiceCallServer.BasisED(ArrayElement, EDDirection);
		If ValueIsFilled(BasisED) Then
			EDCorrections.Add(BasisED);
		EndIf;
	EndDo;
	
	If EDCorrections.Count() = 0 Then
		Return;
	EndIf;
	
	ElectronicDocumentsServiceCallServer.FillInGroundsED(EDCorrections, BasisED, EDDirection);
	
	// For array ED of primary documents we receive the array of IB documents.
	
	InvBasis = EDOwners(EDCorrections);
	
	InvForChanged = New Array;
	// From them an array of entered IR is received.
	FillInIRBySupportingDocuments(InvForChanged, InvBasis, EDDirection);
	
	// For IR list change ED state.
	SetStateExchangeFinishedWithCorrection(InvForChanged);
		
EndProcedure

// Returns the array of IB documents based on the transferred ED array
Function EDOwners(EDKindsArray) Export
	
	EDDocumentsAndOwners = CommonUse.ObjectsAttributeValue(EDKindsArray, "FileOwner");
	
	IBArray = New Array;
	For Each EDDocumentIB IN EDDocumentsAndOwners Do
		IBArray.Add(EDDocumentIB.Value);
	EndDo;
	
	Return IBArray;
	
EndFunction

Procedure FillInIRBySupportingDocuments(InvArray, GroundsArray, EDDirection)
	
	InvDocumentName = ElectronicDocumentsReUse.NameAttributeObjectExistanceInAppliedSolution("InvoiceReceivedInMetadata");
	
	If Not ValueIsFilled(InvDocumentName) Then
		Return;
	EndIf;
	
	InvMetadata = Metadata.Documents[InvDocumentName];
	
	If Not InvMetadata.TabularSections.Find("BasisDocuments") = Undefined Then
		
		QueryText = QueryTextToTabularSection(InvDocumentName);
		Query = New Query;
		Query.Text = QueryText;
		Query.SetParameter("BasisDocuments", GroundsArray);
		
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			InvArray.Add(Selection.IR)
		EndDo;

		
	ElsIf Not InvMetadata.Attributes.Find("BasisDocument") = Undefined Then
		
		InvArray = CommonUse.ObjectsAttributeValue(GroundsArray, "BasisDocument");
	
	EndIf;
	
EndProcedure

Function QueryTextToTabularSection(InvoiceName)
	
	QueryText =
	"SELECT
	|	T.Ref AS IR
	|FROM
	|	Document.%1.BasisDocuments AS T
	|WHERE
	|	T.BasisDocument IN(&BasisDocuments)";
	QueryText = StringFunctionsClientServer.SubstituteParametersInString(QueryText, InvoiceName);
	
	Return QueryText;
	
EndFunction

Procedure SetStateExchangeFinishedWithCorrection(ChangeableInv) Export
	
	State = Enums.EDVersionsStates.ExchangeCompletedWithCorrection;
	
	BeginTransaction();
	
	For Each IBDocument IN ChangeableInv Do
		
		Block = New DataLock;
		LockItem = Block.Add("InformationRegister.EDStates");
		LockItem.SetValue("ObjectReference", IBDocument);
		Block.Lock();
		
		EDStatus = InformationRegisters.EDStates.CreateRecordManager();
		EDStatus.ObjectReference = IBDocument;
		EDStatus.Read();
		
		If Not (EDStatus.EDVersionState = Enums.EDVersionsStates.CorrectionExpected
			Or EDStatus.EDVersionState = Enums.EDVersionsStates.DocumentClarificationNeeded) Then
			Continue;
		EndIf;
		
		EDStatus.ActionsFromOurSide = Enums.EDConsolidatedStates.AllExecuted;
		EDStatus.ActionsFromOtherPartySide = Enums.EDConsolidatedStates.AllExecuted;
		EDStatus.EDVersionState = State;
		EDStatus.Write();
		
	EndDo;
	
	CommitTransaction();
	
EndProcedure

Procedure AddAdditDataToDataForObject(DataForObject, ParseTree)
	
	RowTreaExtraData = ParseTree.Rows.Find("AdditDataTree", "Attribute", True);
	If RowTreaExtraData <> Undefined AND TypeOf(RowTreaExtraData.AttributeValue) = Type("ValueTree") Then
		AdditDataTree = RowTreaExtraData.AttributeValue;
		DataForObject.Insert("AdditDataTree", AdditDataTree);
	EndIf
	
EndProcedure
