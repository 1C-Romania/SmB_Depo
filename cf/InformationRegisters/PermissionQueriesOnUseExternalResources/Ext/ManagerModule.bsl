#If Server Or ThickClientOrdinaryApplication Or ExternalConnection Then

#Region ServiceProceduresAndFunctions

// Creates an administration request of security profiles.
//
// Parameters:
//  ApplicationModule - AnyRef, ref describing the application module.
//    To enable it,
//  you need the security profile, Operation - EnumRef.SecurityProfilesAdministrationOperations
//
// Returns - UUID - identifier of created request.
//
Function PermissionsAdministrationRequest(Val ApplicationModule, Val Operation) Export
	
	If Not RequiredPermissionsQueryToUseExternalResources() Then
		Return New UUID();
	EndIf;
	
	If Operation = Enums.OperationsAdministrationSecurityProfiles.Creating Then
		SecurityProfileName = SecurityProfileNewName(ApplicationModule);
	Else
		SecurityProfileName = SecurityProfileName(ApplicationModule);
	EndIf;
	
	Manager = CreateRecordManager();
	Manager.IDRequest = New UUID();
	
	If WorkInSafeMode.SafeModeIsSet() Then
		Manager.SafeMode = SafeMode();
	Else
		Manager.SafeMode = False;
	EndIf;
	
	Manager.Operation = Operation;
	Manager.AdministrationQuery = True;
	Manager.Name = SecurityProfileName;
	
	ProgramModuleProperties = WorkInSafeModeService.PropertiesForPermissionsRegister(ApplicationModule);
	Manager.SoftwareModuleType = ProgramModuleProperties.Type;
	Manager.SoftwareModuleID = ProgramModuleProperties.ID;
	
	Manager.Write();
	
	RecordKey = CreateRecordKey(New Structure("IDRequest", Manager.IDRequest));
	LockDataForEdit(RecordKey);
	
	Return Manager.IDRequest;
	
EndFunction

// Creates permissions request to use external resources.
//
// Parameters:
//  ApplicationModule - AnyRef, ref describing the application module.
//    To enable it,
//  you need the security profile, Owner - AnyRef - ref to an object of the infobase to
//    which requested permissions are logically connected. For example, all permissions for access to catalogs of
//    files storage volumes are logically connected to the corresponding items of
//    the FilesStorageVolumes catalog. All  permissions for access to catalogs of data
//    exchange (or to other resources depending on the used exchange transport) are logically connected to
//    the corresponding exchange plans nodes etc. If the permission is logically 
// isolated (for example, the grant of permission is regulated by the constant value with the Boolean type) -
//    it is recommended to use reference
//  to an item of the MetadataObjectsIDs catalog, ReplacementMode - Boolean - defines the substitution mode of all previously given permissions for this owner. If
//    the parameter value equals to True, the clearance of all permissions previously
//    requested for the same owner will be added to the request in addition to the requested permissions.
//  PermissionsToBeAdded - Array(XDTOObject) - array of XDTOObjects corresponding
//    to the internal descriptions of requested permissions for access to the external resources. It is assumed that
//    all XDTOObjects passed as a parameter are generated using the WorkInSafeMode.Permission*() functions call.
//  PermissionsToBeDeleted - Array(XDTOObject) - array of XDTOObjects corresponding
//    to the internal descriptions of canceled permissions for access to the external resources. It is assumed that
//    all XDTOObjects transferred as parameters are generated by calling the functions WorkInSafeMode.Permission*().
//
// Returns - UUID - identifier of created request.
//
Function PermissionsUseRequest(Val ApplicationModule, Val Owner, Val ReplacementMode, Val PermissionsToBeAdded, Val PermissionsToBeDeleted) Export
	
	If Not RequiredPermissionsQueryToUseExternalResources() Then
		Return New UUID();
	EndIf;
	
	If Owner = Undefined Then
		Owner = Catalogs.MetadataObjectIDs.EmptyRef();
	EndIf;
	
	If ApplicationModule = Undefined Then
		ApplicationModule = Catalogs.MetadataObjectIDs.EmptyRef();
	EndIf;
	
	If WorkInSafeMode.SafeModeIsSet() Then
		SafeMode = SafeMode();
	Else
		SafeMode = False;
	EndIf;
	
	Manager = CreateRecordManager();
	Manager.IDRequest = New UUID();
	Manager.AdministrationQuery = False;
	Manager.SafeMode = SafeMode;
	Manager.ReplacementMode = ReplacementMode;
	Manager.Operation = Enums.OperationsAdministrationSecurityProfiles.Update;
	
	PropertiesOfOwner = WorkInSafeModeService.PropertiesForPermissionsRegister(Owner);
	Manager.OwnerType = PropertiesOfOwner.Type;
	Manager.IDOwner = PropertiesOfOwner.ID;
	
	ProgramModuleProperties = WorkInSafeModeService.PropertiesForPermissionsRegister(ApplicationModule);
	Manager.SoftwareModuleType = ProgramModuleProperties.Type;
	Manager.SoftwareModuleID = ProgramModuleProperties.ID;
	
	If PermissionsToBeAdded <> Undefined Then
		
		PermissionsArray = New Array();
		For Each NewPermission IN PermissionsToBeAdded Do
			PermissionsArray.Add(CommonUse.ObjectXDTOInXMLString(NewPermission));
		EndDo;
		
		If PermissionsArray.Count() > 0 Then
			Manager.PermissionsToBeAdded = CommonUse.ValueToXMLString(PermissionsArray);
		EndIf;
		
	EndIf;
	
	If PermissionsToBeDeleted <> Undefined Then
		
		PermissionsArray = New Array();
		For Each CanceledPermission IN PermissionsToBeDeleted Do
			PermissionsArray.Add(CommonUse.ObjectXDTOInXMLString(CanceledPermission));
		EndDo;
		
		If PermissionsArray.Count() > 0 Then
			Manager.PermissionsToBeDeleted = CommonUse.ValueToXMLString(PermissionsArray);
		EndIf;
		
	EndIf;
	
	Manager.Write();
	
	RecordKey = CreateRecordKey(New Structure("IDRequest", Manager.IDRequest));
	LockDataForEdit(RecordKey);
	
	Return Manager.IDRequest;
	
EndFunction

// Creates and initializes the manager of requests application to use external resources.
//
// Parameters:
//  QueryIDs - Array(UUID) - request identifiers
//   for application of which a manager is created.
//
// Return value: ProcessingObject.PermissionSetupForExternalResourcesUse.
//
Function PermissionsApplicationManager(Val QueryIDs) Export
	
	Manager = DataProcessors.PermissionSettingsForExternalResourcesUse.Create();
	
	QueryText =
		"SELECT
		|	PermissionsQueries.SoftwareModuleType,
		|	PermissionsQueries.SoftwareModuleID,
		|	PermissionsQueries.OwnerType,
		|	PermissionsQueries.IDOwner,
		|	PermissionsQueries.Operation,
		|	PermissionsQueries.Name,
		|	PermissionsQueries.ReplacementMode,
		|	PermissionsQueries.PermissionsToBeAdded,
		|	PermissionsQueries.PermissionsToBeDeleted,
		|	PermissionsQueries.IDRequest
		|FROM
		|	InformationRegister.PermissionQueriesOnUseExternalResources AS PermissionsQueries
		|WHERE
		|	PermissionsQueries.IDRequest IN(&QueryIDs)
		|
		|ORDER BY
		|	PermissionsQueries.AdministrationQuery DESC";
	Query = New Query(QueryText);
	Query.SetParameter("QueryIDs", QueryIDs);
	
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		
		RecordKey = CreateRecordKey(New Structure("IDRequest", Selection.IDRequest));
		LockDataForEdit(RecordKey);
		
		If Selection.Operation = Enums.OperationsAdministrationSecurityProfiles.Creating OR 
				Selection.Operation = Enums.OperationsAdministrationSecurityProfiles.Delete Then
			
			Manager.AddQueryID(Selection.IDRequest);
			
			Manager.AddAdministrationOperation(
				Selection.SoftwareModuleType,
				Selection.SoftwareModuleID,
				Selection.Operation,
				Selection.Name);
			
		EndIf;
		
		PermissionsToBeAdded = New Array();
		If ValueIsFilled(Selection.PermissionsToBeAdded) Then
			
			Array = CommonUse.ValueFromXMLString(Selection.PermissionsToBeAdded);
			
			For Each ArrayElement IN Array Do
				PermissionsToBeAdded.Add(CommonUse.ObjectXDTOFromXMLRow(ArrayElement));
			EndDo;
			
		EndIf;
		
		PermissionsToBeDeleted = New Array();
		If ValueIsFilled(Selection.PermissionsToBeDeleted) Then
			
			Array = CommonUse.ValueFromXMLString(Selection.PermissionsToBeDeleted);
			
			For Each ArrayElement IN Array Do
				PermissionsToBeDeleted.Add(CommonUse.ObjectXDTOFromXMLRow(ArrayElement));
			EndDo;
			
		EndIf;
		
		Manager.AddQueryID(Selection.IDRequest);
		
		Manager.AddRequestForExternalResourcesUsePermissions(
			Selection.SoftwareModuleType,
			Selection.SoftwareModuleID,
			Selection.OwnerType,
			Selection.IDOwner,
			Selection.ReplacementMode,
			PermissionsToBeAdded,
			PermissionsToBeDeleted);
		
	EndDo;
	
	Manager.CalculateQueriesApplication();
	
	Return Manager;
	
EndFunction

// Checks if an online request of permissions to use external resources is needed.
//
// Return value: Boolean.
//
Function RequiredPermissionsQueryToUseExternalResources()
	
	If Not PossiblePermissionQueryToUseExternalResources() Then
		Return False;
	EndIf;
	
	Return Constants.SecurityProfilesAreUsed.Get() AND Constants.AutomaticallyConfigurePermissionsInSecurityProfiles.Get();
	
EndFunction

// Checks if an online request of permissions to use external resources is possible.
//
// Return value: Boolean.
//
Function PossiblePermissionQueryToUseExternalResources()
	
	If CommonUse.FileInfobase(InfobaseConnectionString()) OR Not GetFunctionalOption("SecurityProfilesAreUsed") Then
		
		// IN the file IB and when the security profiles are enabled,
		// the record of permissions requests is possible in the privileged mode or during using user personal account with administrative rights.
		Return PrivilegedMode() OR Users.InfobaseUserWithFullAccess();
		
	Else
		
		// IN the client-server IB, when the security profiles are enabled, record
		// of permissions requests is available only to administrators regardless of the setting of the privileged mode.
		If Not Users.InfobaseUserWithFullAccess() Then
			
			Raise NStr("en='Insufficient access rights to request permissions to use external resources.';ru='Недостаточно прав доступа для запроса разрешений на использование внешних ресурсов!'");
			
		EndIf;
		
		Return True;
		
	EndIf; 
	
EndFunction

// Generates the name of the security profile for the infobase or the external module.
//
// Parameters:
//   ExternalModule - AnyRef - ref to a catalog
//                                 item used as an external module.
//
// Returns: 
//   String - security proattachment file name.
//
Function SecurityProfileNewName(Val ApplicationModule)
	
	If ApplicationModule = Catalogs.MetadataObjectIDs.EmptyRef() Then
		
		Result = "Infobase_" + String(New UUID());
		
	Else
		
		ModuleManager = WorkInSafeModeService.ExternalModuleManager(ApplicationModule);
		Pattern = ModuleManager.SecurityProfileTemplateName(ApplicationModule);
		Return StrReplace(Pattern, "%1", String(New UUID()));
		
	EndIf;
	
	Return Result;
	
EndFunction

// Returns the name of the security profile for the infobase or the external module.
//
// Parameters:
//  ExternalModule - AnyRef - ref to a catalog
//    item used as an external module.
//
// Returns: 
//   String - security proattachment file name.
//
Function SecurityProfileName(Val ApplicationModule) Export
	
	If ApplicationModule = Catalogs.MetadataObjectIDs.EmptyRef() Then
		
		Return Constants.InfobaseSecurityProfile.Get();
		
	Else
		
		Return InformationRegisters.ExternalModulesConnectionModes.ExternalModuleConnectionMode(ApplicationModule);
		
	EndIf;
	
EndFunction

// Clears invalid requests for use of external resources.
//
Procedure ClearIrrelevantQueries() Export
	
	BeginTransaction();
	
	Try
		
		Selection = Select();
		
		While Selection.Next() Do
			
			Try
				
				Key = CreateRecordKey(New Structure("IDRequest", Selection.IDRequest));
				LockDataForEdit(Key);
				
			Except
				
				// Processing of the exception is not required.
				// Expected exception - attempt to delete the same register record from other session.
				Continue;
				
			EndTry;
			
			Manager = CreateRecordManager();
			Manager.IDRequest = Selection.IDRequest;
			Manager.Delete();
			
		EndDo;
		
		CommitTransaction();
		
	Except
		
		RollbackTransaction();
		Raise;
		
	EndTry;
	
EndProcedure

// Creates "empty" replacement requests for all previously granted permissions.
//
// Return value: Array (UUID) - request IDs to replace
// all previously granted permissions.
//
Function ReplacementRequestsForAllGrantedPermissions() Export
	
	Result = New Array();
	
	QueryText =
		"SELECT DISTINCT
		|	PermissionTable.SoftwareModuleType,
		|	PermissionTable.SoftwareModuleID,
		|	PermissionTable.OwnerType,
		|	PermissionTable.IDOwner
		|FROM
		|	InformationRegister.ExternalResourcesUsingPermissions AS PermissionTable";
	
	Query = New Query(QueryText);
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		
		ApplicationModule = WorkInSafeModeService.RefFromPermissionsRegister(
			Selection.SoftwareModuleType,
			Selection.SoftwareModuleID);
		
		Owner = WorkInSafeModeService.RefFromPermissionsRegister(
			Selection.OwnerType,
			Selection.IDOwner);
		
		SubstitutionQuery = WorkInSafeModeService.PermissionChangeRequest(
			Owner, True, New Array(), , ApplicationModule);
		
		Result.Add(SubstitutionQuery);
		
	EndDo;
	
	Return Result;
	
EndFunction

// Serializes requests to use external resources.
//
// Parameters:
//  IDs - Array(UUID) - identifiers
//   of serialized requests.
//
// Returns - String.
//
Function WriteRequestsToXMLString(Val IDs) Export
	
	Result = New Array();
	
	For Each ID IN IDs Do
		
		Set = CreateRecordSet();
		Set.Filter.IDRequest.Set(ID);
		Set.Read();
		
		Result.Add(Set);
		
	EndDo;
	
	Return CommonUse.ValueToXMLString(Result);
	
EndFunction

// Deserializes requests to use external resources.
//
// Parameters:
//  XMLString - String - result of the WriteQueriesToXMLRow() function.
//
Procedure ReadRequestsFromXMLString(Val XMLString) Export
	
	Queries = CommonUse.ValueFromXMLString(XMLString);
	
	BeginTransaction();
	
	Try
		
		For Each Query IN Queries Do
			Query.Write();
		EndDo;
		
		CommitTransaction();
		
	Except
		
		RollbackTransaction();
		Raise;
		
	EndTry;
	
EndProcedure

// Removes the requests for external resource usage.
//
// Parameters:
//  QueryIDs - Array(UUID) - identifiers of deleted queries.
//
Procedure DeleteQueries(Val QueryIDs) Export
	
	BeginTransaction();
	
	Try
		
		For Each IDRequest IN QueryIDs Do
			
			Manager = CreateRecordManager();
			Manager.IDRequest = IDRequest;
			Manager.Delete();
			
		EndDo;
		
		CommitTransaction();
		
	Except
		
		RollbackTransaction();
		Raise;
		
	EndTry;
	
EndProcedure

#EndRegion

#EndIf
