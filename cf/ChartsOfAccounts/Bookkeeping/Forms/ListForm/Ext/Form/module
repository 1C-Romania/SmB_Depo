

Procedure FormActionsLoadFromTemplate(Button)
	
	QuestionText = NStr("en='Are you sure you want to load full chart of account?';pl='Czy na pewno chcesz załadować pełny plan kont?'");
	Answer = DoQueryBox(QuestionText, QuestionDialogMode.YesNo);
		
	If Answer <> DialogReturnCode.Yes Then
		Return;
	EndIf;
	
	Template = ChartsOfAccounts.Bookkeeping.GetTemplate("ChartOfAccount");
	ChartOfAccountSheet = Template.GetArea();
	
	AccountsArray = New Array;
	AccountsWithChildsMap = New Map;
	
	For i = 3 to 1000 Do
		
		Code1 = ChartOfAccountSheet.Area(i, 1).Text;
		Code2 = ChartOfAccountSheet.Area(i, 2).Text;
		
		Code = Code1 + ?(IsBlankString(Code2), "", ".") + Code2;
		
		If IsBlankString(Code) Then
			Continue;
		EndIf;
		
		Account = ChartsOfAccounts.Bookkeeping.FindByCode(Code);
		If Account.IsEmpty() Then
			Account = ChartsOfAccounts.Bookkeeping.CreateAccount();
			Account.Code = Code;
		Else
			Account = Account.GetObject();
		EndIf;
		
		Description       = ChartOfAccountSheet.Area(i, 3).Text;
		OffBalance        = ChartOfAccountSheet.Area(i, 4).Text;
		Final             = ChartOfAccountSheet.Area(i, 5).Text;
		Type              = ChartOfAccountSheet.Area(i, 6).Text;
		Currency          = ChartOfAccountSheet.Area(i, 7).Text;
		Quantity          = ChartOfAccountSheet.Area(i, 8).Text;
		ExtDimensionName1 = ChartOfAccountSheet.Area(i, 9).Text;
		ExtDimensionName2 = ChartOfAccountSheet.Area(i, 11).Text;
		ExtDimensionName3 = ChartOfAccountSheet.Area(i, 13).Text;
		
		If Not IsBlankString(Code2) Then
			Account.Parent = ChartsOfAccounts.Bookkeeping.FindByCode(Code1);
			If Not Account.Parent.IsEmpty() Then
				AccountsWithChildsMap.Insert(Account.Parent);
			EndIf;
		EndIf;
		
		If Type = "A" Then
			Account.Type = AccountType.Active;
		ElsIf Type = "P" Then
			Account.Type = AccountType.Passive;
		Else
			Account.Type = AccountType.ActivePassive;
		EndIf;
		
		Account.Description = Description;
		
		Account.OffBalance = Not IsBlankString(OffBalance);
		Account.Final = Not IsBlankString(Final);
		Account.Currency = Not IsBlankString(Currency);
		Account.Quantity = Not IsBlankString(Quantity);
		Account.ForbidToUseWhenPosting = False;
		
		Account.ExtDimensionTypes.Clear();
		
		If Not IsBlankString(ExtDimensionName1) Then
			ExtDimensionTypesRow = Account.ExtDimensionTypes.Add();	
			ExtDimensionTypesRow.ExtDimensionType = ChartsOfCharacteristicTypes.BookkeepingExtDimensions[ExtDimensionName1];
			ExtDimensionTypesRow.Amount = True;
			ExtDimensionTypesRow.Currency = Account.Currency;
			ExtDimensionTypesRow.Quantity = Account.Quantity;
		EndIf;
		
		If Not IsBlankString(ExtDimensionName2) Then
			ExtDimensionTypesRow = Account.ExtDimensionTypes.Add();
			ExtDimensionTypesRow.ExtDimensionType = ChartsOfCharacteristicTypes.BookkeepingExtDimensions[ExtDimensionName2];
			ExtDimensionTypesRow.Amount = True;
			ExtDimensionTypesRow.Currency = Account.Currency;
			ExtDimensionTypesRow.Quantity = Account.Quantity;
		EndIf;
		
		If Not IsBlankString(ExtDimensionName3) Then
			ExtDimensionTypesRow = Account.ExtDimensionTypes.Add();
			ExtDimensionTypesRow.ExtDimensionType = ChartsOfCharacteristicTypes.BookkeepingExtDimensions[ExtDimensionName3];
			ExtDimensionTypesRow.Amount = True;
			ExtDimensionTypesRow.Currency = Account.Currency;
			ExtDimensionTypesRow.Quantity = Account.Quantity;
		EndIf;
		
		Account.Write();
		
		AccountsArray.Add(Account.Ref);
		
		Status(NStr("en='Written account: ';pl='Zapisane konto: '") + Account);
		
	EndDo;
	
	Status(NStr("en='Deleting accounts...';pl='Usuń konta...'"));
	
	AccountSelection = ChartsOfAccounts.Bookkeeping.Select();
	
	While AccountSelection.Next() Do
		
		If AccountsArray.Find(AccountSelection.Ref) = Undefined Then
			Account = AccountSelection.GetObject();
			Account.DeletionMark = True;
			Account.Write();
		EndIf;
		
	EndDo;
	
	Status(NStr("en='Marking accounts...';pl='Oznaczanie kont...'"));
	
	For each KeyAndValue in AccountsWithChildsMap Do
		
		Account = KeyAndValue.Key.GetObject();
		Account.ForbidToUseWhenPosting = True;
		Account.Write();
		
	EndDo;
	
EndProcedure

Procedure FormActionsPrintOut(Button)
	
	ChartsOfAccounts.Bookkeeping.GetForm("PrintOutForm", ThisForm).Open();
	
EndProcedure


Procedure ChartOfAccountsListOnRowOutput(Control, RowAppearance, RowData)
	
	CellAppearance = RowAppearance.Cells;
	
	If Not RowData.ExtDimension1Mandatory Then
		CellAppearance.ExtDimension1Type.TextColor = WebColors.MediumGray;
	EndIf;
	
	If Not RowData.ExtDimension2Mandatory Then
		CellAppearance.ExtDimension2Type.TextColor = WebColors.MediumGray;
	EndIf;
	
	If Not RowData.ExtDimension3Mandatory Then
		CellAppearance.ExtDimension3Type.TextColor = WebColors.MediumGray;
	EndIf;
	
	If RowData.BalanceType = Enums.AccountBalanceTypes.Result Then
		RowAppearance.BackColor = StyleColors.BlueColor;
	ElsIf RowData.BalanceType = Enums.AccountBalanceTypes.OffBalance Then
		RowAppearance.BackColor = StyleColors.YellowColor;
	EndIf; 
	
EndProcedure

Procedure ChartOfAccountsListBeforeAddRow(Control, Cancel, Clone, Parent, IsFolder)
	
	If Clone Then
		Return;
	EndIf;
	
	Cancel = True;
	
	NewAccountParentChoiceForm = ChartsOfAccounts.Bookkeeping.GetForm("NewAccountParentChoiceForm");
	NewAccountParentChoiceForm.Account = Control.CurrentRow;
	AccountParent = NewAccountParentChoiceForm.DoModal();
	
	If AccountParent = Undefined Then
		Return;
	EndIf;
	
	NewAccountForm = ChartsOfAccounts.Bookkeeping.GetNewAccountForm();
	NewAccountForm.Parent = AccountParent;
	NewAccountForm.Open();
	
EndProcedure

Procedure OnOpen()
	
	YearValidity = CommonAtServer.GetLastFinancialYear();
	YearValidityOnChange(Undefined);
	ChartOfAccountsList.Order.Clear();
	ChartOfAccountsList.Order.Set("AdditionalView");

	CurrentControl = Controls.ChartOfAccountsList;
	Controls.ChartOfAccountsList.CurrentColumn = Controls.ChartOfAccountsList.Columns.Code;

EndProcedure

Procedure YearValidityOnChange(Control)
	If ValueIsFilled(YearValidity) Then
		Query = New Query;
		Query.Text = "SELECT
		             |	Bookkeeping.Ref
		             |FROM
		             |	ChartOfAccounts.Bookkeeping AS Bookkeeping
		             |WHERE
		             |	CASE
		             |			WHEN Bookkeeping.FinancialYearsBegin = VALUE(Catalog.FinancialYears.EmptyRef)
		             |				THEN TRUE
		             |			ELSE Bookkeeping.FinancialYearsBegin.DateFrom <= &DateEndYearValidity
		             |		END
		             |	AND CASE
		             |			WHEN Bookkeeping.FinancialYearsEnd = VALUE(Catalog.FinancialYears.EmptyRef)
		             |				THEN TRUE
		             |			ELSE Bookkeeping.FinancialYearsEnd.DateTo >= &DateStartYearValidity
		             |		END";
		
		Query.SetParameter("DateStartYearValidity", YearValidity.DateFrom);
		Query.SetParameter("DateEndYearValidity", YearValidity.DateTo);
		
		Result = New ValueList;
		Result.LoadValues(Query.Execute().Unload().UnloadColumn("Ref"));
		
		ChartOfAccountsList.Filter.Ref.ComparisonType = ComparisonType.InList;
		ChartOfAccountsList.Filter.Ref.Use = True;
		ChartOfAccountsList.Filter.Ref.Value = Result;
	Else
		ChartOfAccountsList.Filter.Ref.Use = False;
	EndIf;
EndProcedure


ChartOfAccountsList.Columns.Add("BalanceType", False);
ChartOfAccountsList.Columns.Add("ExtDimension1Mandatory", False);
ChartOfAccountsList.Columns.Add("ExtDimension2Mandatory", False);
ChartOfAccountsList.Columns.Add("ExtDimension3Mandatory", False);
